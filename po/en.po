msgid ""
msgstr ""
"Project-Id-Version: Writing Hypervisor in Zig\n"
"POT-Creation-Date: 2025-05-28T22:52:10+09:00\n"
"PO-Revision-Date: 2025-05-28 22:53+0900\n"
"Last-Translator: smallkirby <ssmallkirby@gmail.com>\n"
"Language-Team: English\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.4.2\n"

#: src/SUMMARY.md:1
msgid "Summary"
msgstr "Summary"

#: src/SUMMARY.md:3
msgid "Writing Hypervisor in Zig 環境構築"
msgstr "Writing Hypervisor in Zig Setup"

#: src/SUMMARY.md:6
msgid "Bootloader"
msgstr "Bootloader"

#: src/SUMMARY.md:8 src/bootloader/hello_uefi.md:1
msgid "Hello UEFI"
msgstr "Hello UEFI"

#: src/SUMMARY.md:9
msgid "ログ出力"
msgstr "Logging"

#: src/SUMMARY.md:10
msgid "カーネルのパース"
msgstr "Parsing Kernel"

#: src/SUMMARY.md:11
msgid "簡易ページテーブル"
msgstr "Simple Page Table"

#: src/SUMMARY.md:12 src/bootloader/load_kernel.md:1 src/vmm/linux_boot.md:464
msgid "カーネルのロード"
msgstr "Loading Kernel"

#: src/SUMMARY.md:13
msgid "メモリマップとお片付け"
msgstr "Memory Map and Cleanup"

#: src/SUMMARY.md:14 src/bootloader/jump_to_ymir.md:1
msgid "カーネルの起動"
msgstr "Booting Kernel"

#: src/SUMMARY.md:16
msgid "Ymir Kernel"
msgstr "Ymir Kernel"

#: src/SUMMARY.md:18
msgid "シリアル出力"
msgstr "Serial Output"

#: src/SUMMARY.md:19
msgid "ビット演算とテスト"
msgstr "Bit Operations and Testing"

#: src/SUMMARY.md:20 src/kernel/serial_logsystem.md:1
msgid "シリアルログシステム"
msgstr "Serial Log System"

#: src/SUMMARY.md:21
msgid "GDT"
msgstr "GDT"

#: src/SUMMARY.md:22 src/kernel/interrupt.md:1
msgid "割り込みと例外"
msgstr "Interrupt and Exception"

#: src/SUMMARY.md:23
msgid "Page Allocator"
msgstr "Page Allocator"

#: src/SUMMARY.md:24 src/kernel/paging.md:1
msgid "ページング"
msgstr "Paging"

#: src/SUMMARY.md:25
msgid "パニック"
msgstr "Panic"

#: src/SUMMARY.md:26
msgid "General Allocator"
msgstr "General Allocator"

#: src/SUMMARY.md:27 src/kernel/pic.md:1 src/vmm/io.md:417
msgid "PIC"
msgstr "PIC"

#: src/SUMMARY.md:29
msgid "Ymir VMM"
msgstr "Ymir VMM"

#: src/SUMMARY.md:31
msgid "VMX Root Operation"
msgstr "VMX Root Operation"

#: src/SUMMARY.md:32
msgid "VMCSの基礎"
msgstr "Basics of VMCS"

#: src/SUMMARY.md:33 src/vmm/vmlaunch.md:968
msgid "VMLAUNCH"
msgstr "VMLAUNCH"

#: src/SUMMARY.md:34
msgid "VM-Entry / VM-Exit"
msgstr "VM-Entry / VM-Exit"

#: src/SUMMARY.md:35
msgid "EPT"
msgstr "EPT"

#: src/SUMMARY.md:36 src/vmm/linux_boot.md:1
msgid "Linux Boot Protocol"
msgstr "Linux Boot Protocol"

#: src/SUMMARY.md:37 src/vmm/vmx_root.md:99
msgid "CPUID"
msgstr "CPUID"

#: src/SUMMARY.md:38 src/vmm/vmx_root.md:217 src/vmm/vmx_root.md:438
#: src/vmm/vmx_root.md:469 src/vmm/vmlaunch.md:626 src/vmm/msr.md:70
#: src/vmm/msr.md:90 src/vmm/msr.md:109
msgid "MSR"
msgstr "MSR"

#: src/SUMMARY.md:39 src/vmm/vmcs.md:48 src/vmm/vmcs.md:66
#: src/vmm/vmlaunch.md:311 src/vmm/vmlaunch.md:653
msgid "Control Registers"
msgstr "Control Registers"

#: src/SUMMARY.md:40
msgid "I/O"
msgstr "I/O"

#: src/SUMMARY.md:41 src/vmm/intr_injection.md:1
msgid "割り込みの注入"
msgstr "Interrupt Injection"

#: src/SUMMARY.md:42 src/vmm/initramfs.md:1
msgid "initramfs"
msgstr "initramfs"

#: src/SUMMARY.md:43
msgid "VMCALL"
msgstr "VMCALL"

#: src/SUMMARY.md:45
msgid "謝辞 ライセンス"
msgstr "謝辞 ライセンス"

#: src/intro.md:12
msgid "[Japanese](/index.md)"
msgstr ""

#: src/intro.md:13
msgid "[English (WIP)](/en/index.md)"
msgstr ""

#: src/intro.md:15
msgid ""
"**You can switch the language by clicking the earth icon on the top right "
"corner of the page.**"
msgstr ""

#: src/intro.md:17
msgid ""
"Note that Japanese version is original and all other versions can be "
"outdated. When you see Japanese sentences in translated versions, it means "
"the translation is not yet available. Please request a translation at the "
"GitHub repository, or contribute to the translation if you can."
msgstr ""

#: src/intro.md:23
msgid ""
"**Writing Hypervisor in Zig** は [Zig](https://ziglang.org/) 言語を使いフルス"
"クラッチで Type-1 Hypervisor を実装しようというブログシリーズです。 OS よりも"
"低いレベルで動作するベアメタル Hypervisor を実装するにあたり、ブートローダ・"
"カーネル・VMM の各コンポーネントをイチから組み立てていきます。"
msgstr ""
"**Writing Hypervisor in Zig** is a blog series where we implement a Type-1 "
"hypervisor from scratch using the [Zig](https://ziglang.org/) language. In "
"order to implement a bare-metal Hypervisor that runs at a lower level than "
"an operating system, we will build the bootloader, kernel, and VMM "
"components from scratch."

#: src/intro.md:26
msgid ""
"本シリーズでは **Ymir** という名前の Hypervisor を実装します。 Ymir は Intel "
"64 (x86-64) CPU で動作し、Intel VT-x によるハードウェア仮想化支援機能を活用し"
"ます。 Ymir は以下の特徴を持ちます:"
msgstr ""
"This series implements a Hypervisor named **Ymir**. Ymir runs on Intel 64 "
"(x86-64) CPUs and takes advantage of hardware virtualization support "
"provided by Intel VT-x. Ymir has the following features:"

#: src/intro.md:30
msgid "**Type-1 Hypervisor**: OS に一切依存しません"
msgstr "**Type-1 Hypervisor**: No dependency on OS"

#: src/intro.md:31
msgid ""
"**Linux をブート可能**: Linux カーネルをブートするにに必要十分な機能を実装し"
"ます"
msgstr ""
"**Can boot Linux**: Ymir implements enough functionality to boot the Linux "
"kernel"

#: src/intro.md:32
msgid "**フルスクラッチ**: ライブラリなどの依存が一切ありません"
msgstr "**Written from Scratch**: No dependence on libraries, etc."

#: src/intro.md:33
msgid ""
"**Thin Hypervisor**: 必要な場合のみゲストに介入し、それ以外はパススルーします"
msgstr ""
"**Thin Hypervisor**: Ymir intervenes with a guest only when necessary, "
"otherwise pass-through everything"

#: src/intro.md:35
msgid "実装や説明を簡単にするため、Ymir は以下のような制約を持ちます:"
msgstr "For the simplicity, Ymir has the following constraints:"

#: src/intro.md:37
msgid "SMP (Symmetric Multi-Processing) はサポートしません"
msgstr "SMP (Symmetric Multi-Processing) is not supported"

#: src/intro.md:38
msgid "QEMU での開発を想定しており、実機での動作は確認していません"
msgstr ""
"Development on QEMU is expected, and Ymir has not been tested on actual "
"devices."

#: src/intro.md:39
msgid "実機で動かすには多少の修正が必要になるはずです"
msgstr "It should require some modification to run on a real machine."

#: src/intro.md:40
msgid "APIC はサポートしません"
msgstr "APIC is not supported"

#: src/intro.md:41
msgid "シングルゲストのみをサポートします"
msgstr "Multiple guest VM at a time is not supported"

#: src/intro.md:43
msgid ""
"本シリーズは全部で 30 程度のチャプターから構成されており、 各チャプターはとあ"
"るテーマの概念的な説明と実装の両方を含んでいます。 各チャプターを読みながら実"
"際にコードを書いていくことで、最終的に Linux をブートすることができる "
"Hypervisor が完成します:"
msgstr ""
"The series consists of about 30 chapters in total, each containing both "
"conceptual and implementation explanations of a topic. By reading the "
"chapters and writing the actual code, you will finally impuement a "
"hypervisor that can boot Linux:"

#: src/intro.md:49
msgid "対象読者"
msgstr "Intended Reader"

#: src/intro.md:51
msgid "本シリーズは以下のような読者を想定しています:"
msgstr "This series is intended for the following readers:."

#: src/intro.md:53
msgid "OS に対するある程度の理解がある、または自分で調べる意欲がある"
msgstr ""
"Some understanding of the OS or willingness to investigate on their own"

#: src/intro.md:54
msgid ""
"x86-64 アーキテクチャにある程度の理解がある、またはマニュアルを読んで調べるこ"
"とができる"
msgstr ""
"Some understanding of the x86-64 architecture or willingness to read and "
"examine manuals"

#: src/intro.md:55
msgid ""
"Zig 言語に興味がある、使ったことがある、またはリファレンスを読んで調べる意欲"
"がある"
msgstr ""
"Interest in, experience with, or willingness to study through references to "
"the Zig language"

#: src/intro.md:56
msgid "フルスクラッチで低レイヤなコードを書きたい"
msgstr "Willingness to write a low-level code from scratch"

#: src/intro.md:57
msgid "Intel VT-x をサポートする CPU を持っている"
msgstr "CPU that supports Intel VT-x"

#: src/intro.md:59
msgid "逆に、以下のような人には向いていません:"
msgstr "On the other hand, this blog is not suitable for those who:"

#: src/intro.md:61
msgid "マイナー言語なんて使いたくない"
msgstr "don't want to use a non-popular language"

#: src/intro.md:62
msgid "絶対に自分で言語や CPU のリファレンスを調べたくない"
msgstr "Never want to look up a language or CPU reference on your own"

#: src/intro.md:63
msgid "簡単のための機能削減や多少の厳密性の犠牲を許容できない"
msgstr ""
"Cannot tolerate feature reductions for simplicity or sacrifice of some rigor"

#: src/intro.md:64
msgid "Intel 64 の CPU を持っていない"
msgstr "don't have Intel 64 CPU"

#: src/intro.md:66
msgid "進め方"
msgstr "How to Read"

#: src/intro.md:68
msgid ""
"本シリーズはチャプター1から順に読み進めていくことを想定しています。 各チャプ"
"ターはそれまでのチャプターに対する依存を持っており、既に登場したコードは実装"
"されたものとして扱います。"
msgstr ""
"This series is intended to be read in order from Chapter 1. Each chapter has "
"dependencies on the previous chapters, and code that has already appeared is "
"treated as implemented."

#: src/intro.md:71
msgid ""
"本シリーズは実際に手を動かしてコードを書いていくことが強く推奨されます。 リ"
"ファレンス実装である Ymir は [Github で公開](https://github.com/smallkirby/"
"ymir) されています。 各チャプターにおける最終的なコードは上記リポジトリの "
"`whiz-*` というブランチに対応しています。 `whiz` は Writing Hypervisor in "
"Zig の略です。 チャプター内で省略された箇所やスニペットでは分かりにくかった箇"
"所は、対応するブランチを参照することで確認することができます。"
msgstr ""
"It is strongly recommended that you actually wr te the code in this series "
"by your own. The reference implementation, Ymir, is available [on Github]"
"(https://github.com/smallkirby/ymir). The final code for each chapter "
"corresponds to the `whiz-*` branch in the above repository. `whiz` stands "
"for Writing Hypervisor in Zig. You can refer to the corresponding branch to "
"see what was omitted in the chapter or what was not clear in the snippet."

#: src/intro.md:77
msgid ""
"なお、本シリーズで実装する `whiz-*` ブランチの Ymir は簡単のために `master` "
"ブランチの Ymir から一部機能が削減・簡略化されている可能性があります。 また、"
"修正は全てのブランチには反映されず最も新しい `whiz-*` および `master` ブラン"
"チにのみ反映されることに注意してください。"
msgstr ""
"Note that code in the `whiz-*` branch may have some features reduced or "
"simplified from the one in the `master` branch for simplicity. Also note "
"that the fixes will not be applied to all branches, but only to the most "
"recent `whiz-*` and `master` branches."

#: src/intro.md:81
msgid "記法について"
msgstr "Notations"

#: src/intro.md:83
msgid "コードのスニペットは以下のようなコードブロックで提示されます:"
msgstr "A snippet of code is presented in a code block like:"

#: src/intro.md:89
msgid ""
"ファイル名を持つコードブロックは、そのファイルに対して新たに追加されるコード"
"を意味します。 このような場合 `...` は既存のコードを省略するのに使われます:"
msgstr ""
"A code block with a file name means new code to be added for that file. In "
"such cases `... ` is used to omit existing code:"

#: src/intro.md:100
msgid ""
"ファイル名に `.tmp.` が含まれるコードは、実験等のために一時的に追加するコード"
"であることを意味します。 このようなコードはチャプターの終了時に削除されるべき"
"です:"
msgstr ""
"Codes with `.tmp.` in the filename mean that they are added temporarily for "
"experimentation. Such code should be removed at the end of the chapter:"

#: src/intro.md:107
msgid ""
"Zig の `struct` や `enum` のフィールドは、本文中で `.field` のように表記しま"
"す。 例として、以下のような構造体のフィールドは `.one` または `Some.one` のよ"
"うに表記します:"
msgstr ""
"Zig's `struct` and `enum` fields are denoted in the text as `.field`. As an "
"example, the following structure fields is denoted as `.one` or `Some.one`:"

#: src/intro.md:117
msgid ""
"レジスタ等において、Nビット目からMビット目を表す場合には `Register[M:N]` のよ"
"うに表記します。 この際、Mビット目を含むことに注意してください。"
msgstr ""
"For registers, the N-th through M-th bits are represented as `Register[M:"
"N]`. In this case, note that the M-th bit is included."

#: src/intro.md:120
msgid "改善・修正"
msgstr "Contributions"

#: src/intro.md:122
msgid "以下のような場合には、筆者に対して更新をリクエストしてください:"
msgstr "Please request an update from the author if you"

#: src/intro.md:124
msgid "説明に技術的な誤りがある"
msgstr "Found a technical error in the description"

#: src/intro.md:125
msgid "分かりにくい表現がある"
msgstr "Found an expression that is difficult to understand"

#: src/intro.md:126
msgid "誤字・脱字等を見つけた"
msgstr "Found typo or omissions"

#: src/intro.md:127
msgid "提示されたコードが動かない、または分かりにくい"
msgstr "Found that code presented does not work or is difficult to understand"

#: src/intro.md:128
msgid "本シリーズでは扱っていない内容を新たに扱ってほしい"
msgstr "Like to see new content that is still not covered in this series"

#: src/intro.md:130
msgid ""
"更新リクエストは [GitHub](https://github.com/smallkirby/writing-hypervisor-"
"in-zig) の Issue や Pull Request で受け付けています。 PR を作る前に Issue を"
"建てる必要はありません。 リクエストの大小や内容の正誤に関わらず修正依頼やリク"
"エスト等を歓迎します。"
msgstr ""
"You can request by creating Issue or Pull Request on [GitHub](https://github."
"com/smallkirby/writing-hypervisor-in-zig). It is not necessary to create an "
"Issue before creating a PR. We welcome any kind of requests and fixes."

#: src/intro.md:134 src/bootloader/hello_uefi.md:366
#: src/bootloader/uefi_log.md:410 src/kernel/pic.md:600
#: src/vmm/vmentry_vmexit.md:658 src/vmm/ept.md:779 src/vmm/linux_boot.md:740
#: src/vmm/io.md:742
msgid "References"
msgstr "References"

#: src/intro.md:136
msgid ""
"本シリーズにおける主な参考文献は [Intel® 64 and IA-32 Architectures Software "
"Developer Manuals](https://www.intel.com/content/www/us/en/developer/"
"articles/technical/intel-sdm.html) です。 以降は **SDM** と略して表記しま"
"す。 SDM から抜粋した画像については、キャプションに _\"SDM Vol.\\<Volume\\> "
"\\<Chapter\\>.\\<Section\\>.\\<Subsection\\>\"_ と表記します。 SDM から抜粋し"
"た画像は全て [© Intel Corporation](https://www.intel.com/) に帰属します。"
msgstr ""
"The primary reference in this series is [Intel® 64 and IA-32 Architectures "
"Software Developer Manuals](https://www.intel.com/content/www/us/en/"
"developer/articles/technical/intel-sdm.html), hereafter abbreviated as "
"**SDM**. For images taken from the SDM, the caption should read _\"SDM Vol."
"\\<Volume\\> \\<Chapter\\>. \\<Section\\>. \\<Subsection\\>\"_. All images "
"extracted from SDM are the property of [© Intel Corporation](https://www."
"intel.com/)."

#: src/intro.md:141
msgid "SDM 以外には、以下の情報を参考にしています:"
msgstr "Other than SDM, the following information is available for reference:"

#: src/intro.md:143 src/bootloader/hello_uefi.md:44
msgid "[BitVisor](https://www.bitvisor.org/)"
msgstr "[BitVisor](https://www.bitvisor.org/)"

#: src/intro.md:144
msgid ""
"[ZystemOS/pluto: An x86 kernel written in Zig](https://github.com/ZystemOS/"
"pluto)"
msgstr ""
"[ZystemOS/pluto: An x86 kernel written in Zig](https://github.com/ZystemOS/"
"pluto)"

#: src/intro.md:145
msgid ""
"[AndreaOrru/zen : Experimental operating system written in Zig](https://"
"github.com/AndreaOrru/zen)"
msgstr ""
"[AndreaOrru/zen : Experimental operating system written in Zig](https://"
"github.com/AndreaOrru/zen)"

#: src/intro.md:146
msgid ""
"[nuta/resea: A microkernel-based hackable operating system.](https://github."
"com/nuta/resea)"
msgstr ""
"[nuta/resea: A microkernel-based hackable operating system.](https://github."
"com/nuta/resea)"

#: src/intro.md:147
msgid ""
"[ハイパーバイザの作り方](https://syuu1228.github.io/"
"howto_implement_hypervisor/)"
msgstr ""
"[ハイパーバイザの作り方](https://syuu1228.github.io/"
"howto_implement_hypervisor/)"

#: src/intro.md:148
msgid "[ゼロからの OS 自作入門](https://zero.osdev.jp/)"
msgstr "[ゼロからの OS 自作入門](https://zero.osdev.jp/)"

#: src/intro.md:149
msgid ""
"[5 Days to Virtualization: A Series on Hypervisor Development - Reverse "
"Engineering](https://revers.engineering/7-days-to-virtualization-a-series-on-"
"hypervisor-development/)"
msgstr ""
"[5 Days to Virtualization: A Series on Hypervisor Development - Reverse "
"Engineering](https://revers.engineering/7-days-to-virtualization-a-series-on-"
"hypervisor-development/)"

#: src/intro.md:150
msgid ""
"[Hypervisor From Scratch - Rayanfam Blog](https://rayanfam.com/topics/"
"hypervisor-from-scratch-part-1/)"
msgstr ""
"[Hypervisor From Scratch - Rayanfam Blog](https://rayanfam.com/topics/"
"hypervisor-from-scratch-part-1/)"

#: src/intro.md:151
msgid "[Writing OS in Rust](https://os.phil-opp.com)"
msgstr "[Writing OS in Rust](https://os.phil-opp.com)"

#: src/intro.md:153
msgid "その他局所的に参考にした情報については各ページに記載します。"
msgstr "Other referenced information is provided on each page."

#: src/intro.md:155 src/license.md:1
msgid "ライセンス"
msgstr "License"

#: src/intro.md:157
msgid "[ライセンス](./license.md) を参照してください。"
msgstr "See [License](./license.md)."

#: src/intro.md:159
msgid "プライバシー"
msgstr "Privacy"

#: src/intro.md:161
msgid ""
"本ウェブサイトは Google Analytics を利用してアクセス解析をしています。 無効化"
"するには、ブラウザの設定から本サイトのクッキーを無効化してください。"
msgstr ""
"This website uses Google Analytics for access analysis. You can disable "
"cookies for this site in your browser settings."

#: src/intro.md:164
msgid "Changelog"
msgstr "Changelog"

#: src/intro.md:166
msgid "Date"
msgstr "Date"

#: src/intro.md:166
msgid "Log"
msgstr "Log"

#: src/intro.md:168
msgid "2024.11.17"
msgstr "2024.11.17"

#: src/intro.md:168
msgid "公開"
msgstr "Published"

#: src/setup.md:1
msgid "環境構築"
msgstr "Setup"

#: src/setup.md:3
msgid ""
"本チャプターでは、Ymir Hypervisor の開発に必要な環境の構築について説明しま"
"す。 これらは推奨される環境であり、以下の条件を満たさない場合でも開発ができる"
"可能性はあります。 お使いの環境に合わせて適宜読みかえてください。"
msgstr ""
"This chapter describes the environment required to develop Ymir hypervisor. "
"These are the recommended environments, but you can develop on other "
"environment as far as requirements are satisfied. Please read accordingly to "
"your own environment."

#: src/setup.md:7
msgid "想定する環境"
msgstr "Expected Environment"

#: src/setup.md:9
msgid "以下の環境における開発を想定しています:"
msgstr "Development on the below environment is expected:"

#: src/setup.md:11
msgid ""
"[Intel VT-x](https://en.wikipedia.org/wiki/X86_virtualization) がサポートされ"
"ている x64 (Intel64) アーキテクチャ"
msgstr ""
"x64 (Intel64) architecture with [Intel VT-x](https://en.wikipedia.org/wiki/"
"X86_virtualization) support"

#: src/setup.md:12
msgid "Nested Virtualization がサポートされているVMM"
msgstr "VMM that supports nested virtualization"

#: src/setup.md:13
msgid ""
"Linux であれば QEMU/KVM が Nested Virtualization をサポートしていて、CPUをパ"
"ススルーできる"
msgstr ""
"On Linux, QEMU/KVM supports nested virtualization and can pass-through CPU"

#: src/setup.md:14
msgid "Zig 0.13.0"
msgstr "Zig 0.13.0"

#: src/setup.md:16
msgid "筆者は以下の環境での動作を確認しています:"
msgstr "The author has tested in the following environment:."

#: src/setup.md:18
msgid "12th Gen Intel(R) Core(TM) i9-12900"
msgstr "12th Gen Intel(R) Core(TM) i9-12900"

#: src/setup.md:19
msgid "Ubuntu 24.04 LTS (Linux 6.8.0-45-generic)"
msgstr "Ubuntu 24.04 LTS (Linux 6.8.0-45-generic)"

#: src/setup.md:20
msgid "QEMU emulator version 8.2.2 (Debian 1:8.2.2+ds-0ubuntu1.2)"
msgstr "QEMU emulator version 8.2.2 (Debian 1:8.2.2+ds-0ubuntu1.2)"

#: src/setup.md:22
msgid ""
"CPU に関しては、最近の Intel Core シリーズであればほぼ確実に VT-x がサポート"
"されていると思われます。 実装は仮想環境上で行うため、必然的に Nested "
"Virtualization ができる環境が必要になります。 [VirtualBox](https://www."
"virtualbox.org/) でも [VMWare](https://www.vmware.com/) でも問題ない可能性は"
"ありますが、本シリーズでは QEMU/KVM の使用を想定します。"
msgstr ""
"As for CPUs, recent Intel Core series are almost certain to support VT-x. "
"Since we write and test Ymir in a VM, nestd virtualization is required. "
"Although [VirtualBox](https://www.virtualbox.org/) or [VMWare](https://www."
"vmware.com/) may work fine, we assume the use of QEMU/KVM in this series."

#: src/setup.md:26
msgid ""
"お使いの CPU が VT-x による仮想化支援をサポートしているかどうかは以下のコマン"
"ドで確認することができます。 なお、CPU 自体が VT-x をサポートしていても BIOS "
"で無効化されている場合があることに注意してください:"
msgstr ""
"You can check if your CPU supports virtualization by VT-x with the following "
"command. Note that even if the CPU itself supports VT-x, it may be disabled "
"in the BIOS:"

#: src/setup.md:33
msgid "Zig"
msgstr "Zig"

#: src/setup.md:35
msgid ""
"本シリーズでは、[Zig](https://ziglang.org/download/) 0.13.0 を使用します。 "
"Zig はまだ 1.0 に到達していない言語であるため後方互換性が保証されていませ"
"ん。 0.13.0 以降のバージョンがリリースされた場合も多少の修正で動くはずです"
"が、本シリーズでは執筆時点の最新バージョンである 0.13.0 を使用します。"
msgstr ""
"This series uses [Zig](https://ziglang.org/download/) 0.13.0. Zig is a "
"language that has not yet reached 1.0, so backward compatibility is not "
"guaranteed. Versions after 0.13.0 may work with some modifications, but this "
"series focuses only on 0.13.0, the latest version at the time of writing."

#: src/setup.md:39
msgid ""
"Zig には公式のバージョンマネージャが存在しません。 以下のどちらかの方法で "
"Zig 0.13.0 をインストールしてください。"
msgstr ""
"There is no official version manager for Zig. Please install Zig 0.13.0 in "
"either of the following ways."

#: src/setup.md:42
msgid ""
"1つ目がサードパーティ製のバージョンマネージャを使う方法です。 サードパーティ"
"製の Zig バージョンマネージャのひとつに [tristanisham/zvm](https://github."
"com/tristanisham/zvm) があります。 GitHub の README から環境に合った方法で "
"zvm をインストールした後、以下のコマンドで 0.13.0 をインストールします:"
msgstr ""
"First, you can use a third-party version manager. I prefer using "
"[tristanisham/zvm](https://github.com/tristanisham/zvm). After installing "
"zvm following the iREADME, install Zig 0.13.0 with the following command:"

#: src/setup.md:51
msgid ""
"zvm にこだわる必要はないため、お好みのバージョンマネージャ[^1] を使ってくださ"
"い。"
msgstr "No need to stick with zvm. Use the version manager[^1] of your choice."

#: src/setup.md:53
msgid ""
"2つ目が公式のリリースページを使う方法です。 Zig の[リリースページ](https://"
"ziglang.org/download/)から 0.13.0 のバイナリをダウンロードし、パスが通ってい"
"るディレクトリに配置してください。"
msgstr ""
"The second way is to use the official release page. Download the 0.13.0 "
"binary from Zig's [release page](https://ziglang.org/download/) and place it "
"in an arbitrary directory in PATH."

#: src/setup.md:56
msgid "Language Server"
msgstr "Language Server"

#: src/setup.md:58
msgid ""
"Zig の language server である [ZLS](https://github.com/zigtools/zls) を使用し"
"ます。 様々なエディタで利用可能な拡張が存在するため、[Zigのツールガイド]"
"(https://ziglang.org/learn/tools/)に従って環境をセットアップしてください。"
msgstr ""
"We use [ZLS](https://github.com/zigtools/zls), Zig's language server. There "
"are extensions available for various editors, so follow the [Zig's Tool "
"Guide](https://ziglang.org/learn/tools/) to set up for your environment."

#: src/setup.md:61 src/bootloader/load_kernel.md:120
#: src/bootloader/jump_to_ymir.md:201
msgid "\\[!WARNING\\]"
msgstr ""

#: src/setup.md:63
msgid "利用する Zig と ZLS のバージョンは必ず一致させてください[^2]。"
msgstr "You have to make sure that the version of Zig and ZLS is same[^2]。"

#: src/setup.md:65
msgid "OVMF"
msgstr "OVMF"

#: src/setup.md:67
msgid ""
"[OVMF](https://github.com/tianocore/tianocore.github.io/wiki/OVMF) は VM 上"
"で UEFI をサポートするプロジェクト[^3]です。 QEMU ではデフォルトで [SeaBIOS]"
"(https://www.seabios.org/SeaBIOS) と呼ばれるレガシーBIOSが使われますが、本シ"
"リーズでは OVMF を使って起動します。 使用する OVMF は、x64 アーキテクチャの "
"64bit モード起動をする `X64` ビルドを利用します。 これにより、ブートローダを "
"[Long Mode](https://en.wikipedia.org/wiki/Long_mode) で実行することが可能にな"
"ります。"
msgstr ""
"[OVMF](https://github.com/tianocore/tianocore.github.io/wiki/OVMF) is a "
"project[^3] that supports UEFI on VMs. QEMU uses a legacy BIOS called "
"[SeaBIOS](https://www.seabios.org/SeaBIOS) by default, but the bootloader in "
"this blog expects to run on UEFI. We use a `X64` build of OVMF, that boots "
"in 64-bit mode. This allows the bootloader to start running in [Long Mode]"
"(https://en.wikipedia.org/wiki/Long_mode)."

#: src/setup.md:72
msgid "Ubuntu を使っている場合には以下のコマンドでインストールできます:"
msgstr "Ubuntu users can install it with the following command:"

#: src/setup.md:78
msgid ""
"他の OS やパッケージマネージャを利用している場合には、それぞれの方法でインス"
"トールしてください。 また、ソースコードからのビルドも可能です。 その場合には "
"TianoCore の [GitHub Wiki](https://github.com/tianocore/tianocore.github.io/"
"wiki/How-to-build-OVMF) の手順に従ってください。"
msgstr ""
"If you are using another OS or package manager, please install using their "
"appropriate methods. You can also build from source code. In that case, "
"follow the instructions in TianoCore's [GitHub Wiki](https://github.com/"
"tianocore/tianocore.github.io/wiki/How-to-build-OVMF)."

#: src/setup.md:82
msgid ""
"例として、他には [zigup](https://github.com/marler8997/zigup) があります。"
msgstr "Another example is [zigup](https://github.com/marler8997/zigup)."

#: src/setup.md:83
msgid ""
"バージョンを一致させないと ZLS が正常に動作しません (e.g. [\"ZLS not pulling "
"in information from dependencies\"](https://ziggit.dev/t/zls-not-pulling-in-"
"information-from-dependencies/4179))"
msgstr ""
"ZLS will not work properly when used with inconsistent version of Zig (e.g. "
"[“ZLS not pulling in information from dependencies”](https://ziggit.dev/t/"
"zls-not-pulling-in-information- from-dependencies/4179))"

#: src/setup.md:84
msgid ""
"[Open Virtual Machine Firmware (OVMF) Status Report](https://access.redhat."
"com/articles/1434903)"
msgstr ""
"[Open Virtual Machine Firmware (OVMF) Status Report](https://access.redhat."
"com/articles/1434903)"

#: src/bootloader/hello_uefi.md:3
msgid ""
"本チャプターからは Ymir のブートローダにあたる **Surtr** の実装を始めていきま"
"す。 Surtr は UEFI アプリケーションとして 64bit モードで動作します。 本チャプ"
"ターでは最初に hypervisor の分類と Ymir の全体構成について確認します。 その"
"後、QEMU 上で動作する UEFI アプリケーションの雛形を作成し、実際に QEMU 上で動"
"作させます。 まだ起動するだけで何もしないアプリケーションですが、次チャプター"
"以降で実装する Surtr の基礎となる部分です。"
msgstr ""
"In this chapter, we will start implementing **Surtr**, the bootloader of "
"Ymir. Surtr runs as a UEFI application in 64-bit mode. We will first review "
"the classification of hypervisors and the overall structure of Ymir. After "
"that, we will create a template for a UEFI application to run on QEMU. "
"Although it is still an application that *just runs*, we can learn the basis "
"for Surtr, which we will implement in the next chapters and beyond."

#: src/bootloader/hello_uefi.md:9 src/bootloader/uefi_log.md:7
#: src/bootloader/parse_kernel.md:9 src/bootloader/simple_pg.md:9
#: src/bootloader/load_kernel.md:7 src/bootloader/cleanup_memmap.md:9
#: src/kernel/serial_output.md:12 src/kernel/bit_and_test.md:8
#: src/kernel/serial_logsystem.md:8 src/kernel/gdt.md:8
#: src/kernel/interrupt.md:12 src/kernel/page_allocator.md:14
#: src/kernel/paging.md:9 src/kernel/panic.md:11
#: src/kernel/general_allocator.md:10 src/kernel/pic.md:8 src/vmm/vmx_root.md:6
#: src/vmm/vmcs.md:7 src/vmm/vmlaunch.md:7 src/vmm/vmentry_vmexit.md:8
#: src/vmm/ept.md:6 src/vmm/linux_boot.md:8 src/vmm/cpuid.md:6 src/vmm/msr.md:7
#: src/vmm/cr.md:7 src/vmm/io.md:9 src/vmm/intr_injection.md:7
#: src/vmm/initramfs.md:9 src/vmm/vmcall.md:10
msgid "\\[!IMPORTANT\\]"
msgstr ""

#: src/bootloader/hello_uefi.md:11
msgid ""
"本チャプターの最終コードは [`whiz-surtr-hello_uefi`](https://github.com/"
"smallkirby/ymir/tree/whiz-surtr-hello_uefi) ブランチにあります。"
msgstr ""
"Source code for this chapter is in [`whiz-surtr-hello_uefi`](https://github."
"com/smallkirby/ymir/tree/whiz-surtr-hello_uefi) branch."

#: src/bootloader/hello_uefi.md:13 src/bootloader/uefi_log.md:11
#: src/bootloader/parse_kernel.md:13 src/bootloader/simple_pg.md:13
#: src/bootloader/load_kernel.md:11 src/bootloader/cleanup_memmap.md:13
#: src/bootloader/jump_to_ymir.md:7 src/kernel/serial_output.md:16
#: src/kernel/bit_and_test.md:12 src/kernel/serial_logsystem.md:12
#: src/kernel/gdt.md:12 src/kernel/interrupt.md:16
#: src/kernel/page_allocator.md:18 src/kernel/paging.md:13
#: src/kernel/panic.md:15 src/kernel/general_allocator.md:14
#: src/kernel/pic.md:12 src/vmm/vmx_root.md:10 src/vmm/vmcs.md:11
#: src/vmm/vmlaunch.md:11 src/vmm/vmentry_vmexit.md:12 src/vmm/ept.md:10
#: src/vmm/linux_boot.md:12 src/vmm/cpuid.md:10 src/vmm/msr.md:11
#: src/vmm/cr.md:11 src/vmm/io.md:13 src/vmm/intr_injection.md:11
#: src/vmm/initramfs.md:13 src/vmm/vmcall.md:14
msgid "Table of Contents"
msgstr "Table of Contents"

#: src/bootloader/hello_uefi.md:15
msgid "[Hypervisor の種類](#hypervisor-の種類)"
msgstr ""

#: src/bootloader/hello_uefi.md:16
msgid "[Type-1 Hypervisor](#type-1-hypervisor)"
msgstr ""

#: src/bootloader/hello_uefi.md:17
msgid "[Type-2 Hypervisor](#type-2-hypervisor)"
msgstr ""

#: src/bootloader/hello_uefi.md:18
msgid "[Surtr Bootloader](#surtr-bootloader)"
msgstr ""

#: src/bootloader/hello_uefi.md:19
msgid "[UEFI アプリの作成](#uefi-アプリの作成)"
msgstr ""

#: src/bootloader/hello_uefi.md:20
msgid "[ビルドスクリプトの設定](#ビルドスクリプトの設定)"
msgstr ""

#: src/bootloader/hello_uefi.md:21
msgid "[エントリポイントの作成](#エントリポイントの作成)"
msgstr ""

#: src/bootloader/hello_uefi.md:22
msgid "[QEMU で実行するための設定](#qemu-で実行するための設定)"
msgstr ""

#: src/bootloader/hello_uefi.md:23
msgid "[実行](#実行)"
msgstr ""

#: src/bootloader/hello_uefi.md:24 src/bootloader/uefi_log.md:19
#: src/bootloader/parse_kernel.md:20 src/bootloader/simple_pg.md:19
#: src/bootloader/load_kernel.md:19 src/bootloader/jump_to_ymir.md:16
#: src/kernel/serial_output.md:25 src/kernel/bit_and_test.md:21
#: src/kernel/serial_logsystem.md:16 src/kernel/gdt.md:26
#: src/kernel/interrupt.md:27 src/kernel/page_allocator.md:32
#: src/kernel/paging.md:23 src/kernel/panic.md:21
#: src/kernel/general_allocator.md:24 src/kernel/pic.md:33
#: src/vmm/vmx_root.md:24 src/vmm/vmcs.md:25 src/vmm/vmlaunch.md:29
#: src/vmm/vmentry_vmexit.md:23 src/vmm/ept.md:22 src/vmm/linux_boot.md:26
#: src/vmm/cpuid.md:22 src/vmm/msr.md:19 src/vmm/cr.md:26 src/vmm/io.md:21
#: src/vmm/intr_injection.md:20 src/vmm/initramfs.md:18 src/vmm/vmcall.md:19
msgid "[まとめ](#まとめ)"
msgstr ""

#: src/bootloader/hello_uefi.md:25 src/bootloader/uefi_log.md:20
#: src/kernel/pic.md:34 src/vmm/vmentry_vmexit.md:24 src/vmm/ept.md:23
#: src/vmm/linux_boot.md:27 src/vmm/io.md:22
msgid "[References](#references)"
msgstr ""

#: src/bootloader/hello_uefi.md:27
msgid "Hypervisor の種類"
msgstr "Type of Hypervisor"

#: src/bootloader/hello_uefi.md:29
msgid "Hypervisor には大きく分けて Type-1 と Type-2 の2種類があります。"
msgstr ""
"Hypervisors can be broadly classified into two types: Type-1 and Type-2."

#: src/bootloader/hello_uefi.md:31
msgid "Type-1 Hypervisor"
msgstr "Type-1 Hypervisor"

#: src/bootloader/hello_uefi.md:33
msgid ""
"Type-1 Hypervisor はベアメタルで動作する hypervisor です。 ハードウェアに直接"
"アクセスできる一方、裏を返すと低レベルなリソース管理をする必要があります。 "
"Type-2 と比較すると、より VM に特化したリソース管理ができたり、 Context "
"Switch を挟まない分リソースアクセスの速度が早いという利点があります。 Ymir "
"も Type-1 に分類され、ハードウェア上で直接動作します (本シリーズでは QEMU 上"
"で動かすんですけどね...)。 Type-1 に分類される主な hypervisor には以下のもの"
"があります:"
msgstr ""
"Type-1 Hypervisor is a hypervisor that runs on bare metal. While it provides "
"direct access to hardware, it requires low-level resource management. "
"Compared to Type-2, Type-1 hypervisors have the advantage of more VM-"
"specific resource management and faster resource access speeds since it has "
"no need to do a context switch. Ymir is also classified as Type-1 and runs "
"directly on hardware (though in this series, it runs on QEMU...). "
"Hypervisors classified as Type-1 are as follows:"

#: src/bootloader/hello_uefi.md:41
msgid "VMWare ESXi"
msgstr "VMWare ESXi"

#: src/bootloader/hello_uefi.md:42
msgid "Microsoft Hyper-V"
msgstr "Microsoft Hyper-V"

#: src/bootloader/hello_uefi.md:43
msgid "Linux KVM[^1]"
msgstr "Linux KVM[^1]"

#: src/bootloader/hello_uefi.md:46
msgid "Type-2 Hypervisor"
msgstr "Type-2 Hypervisor"

#: src/bootloader/hello_uefi.md:48
msgid ""
"Type-2 Hypervisor はホストOS上で動作する hypervisor です。 ハードウェアリソー"
"スにアクセスする場合にはホストOSを経由する必要があるため、Type-1 に比べてオー"
"バーヘッドが発生します。低レベルなリソース管理はOSに任せられるという観点で"
"は、Type-1 と比較して実装が容易であるとも言えます。 Type-2 に分類される主な "
"hypervisor には以下のものがあります:"
msgstr ""
"Type-2 Hypervisor is a hypervisor that runs on the host OS. It requires "
"access to hardware resources via the host OS, which incurs more overhead "
"than Type-1. It can be said to be easier to implement than Type-1 in that "
"low-level resource management can be left to the OS. Hypervisors classified "
"as Type-2 include the following:"

#: src/bootloader/hello_uefi.md:52
msgid "Oracle VirtualBox"
msgstr "Oracle VirtualBox"

#: src/bootloader/hello_uefi.md:53
msgid "VMWare Workstation"
msgstr "VMWare Workstation"

#: src/bootloader/hello_uefi.md:54
msgid "QEMU"
msgstr "QEMU"

#: src/bootloader/hello_uefi.md:56
msgid "Surtr Bootloader"
msgstr "Surtr Bootloader"

#: src/bootloader/hello_uefi.md:58
msgid ""
"本シリーズで実装する hypervisor は Type-1 です。ベアメタルで動きます。 動作す"
"る上で OS に依存することができません。 そのため、必然的に**OSが提供する機能を"
"実装する必要があります**。 本シリーズではゲストOSとして Linux を動かすことが"
"最終的な目的であるため、 一般的なOSが提供する機能を全て実装することはしません"
"が、以下のような基本的な機能は実装します:"
msgstr ""
"The hypervisor implemented in this series is Type-1. It runs on bare metal. "
"It cannot depend on the OS for its operations. Therefore, it must "
"necessarily **implement the functions provided by the OS**. Since the "
"ultimate goal of this series is to run Linux as a guest OS, we will not "
"implement all the functions provided by common OS, but will implement the "
"following basic functions:"

#: src/bootloader/hello_uefi.md:64
msgid "ブートローダ"
msgstr "Bootloader"

#: src/bootloader/hello_uefi.md:65
msgid "メモリ管理"
msgstr "Memory management"

#: src/bootloader/hello_uefi.md:66
msgid "シリアル通信"
msgstr "Serial communication"

#: src/bootloader/hello_uefi.md:67
msgid "割り込み"
msgstr "Interrupts and exceptions"

#: src/bootloader/hello_uefi.md:69
msgid ""
"このうち、ブートローダの部分を **Surtr**[^2] と呼ぶことにします。 また、それ"
"以外のカーネル部分を **Ymir**[^3] と呼びます。 Ymir の中でも、一般的な OS が"
"提供する機能の部分を **Ymir Kernel**、仮想化機能を提供する部分を **Ymir "
"VMM** と呼び分けます。 本チャプターからは Surtr を実装して Ymir Kernel がブー"
"トするところまでをひとつの目標とします。"
msgstr ""
"We will call the bootloader part **Surtr**[^2]. The rest of the kernel part "
"is called **Ymir**[^3]. Within Ymir, the part that provides general OS "
"functions is called **Ymir Kernel**, and the part that provides "
"virtualization functions is called **Ymir VMM**. The goal of several chaptes "
"is to implement Surtr and boot Ymir Kernel."

#: src/bootloader/hello_uefi.md:74
msgid "UEFI アプリの作成"
msgstr "Creating UEFI application"

#: src/bootloader/hello_uefi.md:76
msgid ""
"それでは早速 Surtr の実装を始めていきましょう。 本シリーズではファームウェア"
"として [UEFI](https://ja.wikipedia.org/wiki/"
"Unified_Extensible_Firmware_Interface) を採用します。 [レガシー BIOS]"
"(https://en.wikipedia.org/wiki/BIOS) は使いませんが、本文中では UEFI のことを"
"指して BIOS と呼称することもあります。"
msgstr ""
"Let's get started with mplemening Surtr. In this series, we will use [UEFI]"
"(https://ja.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface) as the "
"firmware. [Legacy BIOS](https://en.wikipedia.org/wiki/BIOS) will not be used "
"in this blog."

#: src/bootloader/hello_uefi.md:80
msgid ""
"Zig は x64 UEFI プラットフォームを [Tier-2 サポート](https://ziglang.org/"
"download/0.13.0/release-notes.html)しています。 一般的な CPU の Linux / "
"macOS / Windows などは Tier-1 サポートです。 Tier-1 と Tier-2 には、自動テス"
"トが実行されていなかったり、 一部テストが無効化されていたりするなどの違いがあ"
"りますが、一般的な機能は問題なく使えるという印象です。 そのため、**普通のネイ"
"ティブアプリをビルドするのと同様にして UEFI アプリを作成できます**。 UEFI ア"
"プリが必要とする構造体や定数なども Zig の標準ライブラリ内に含まれているため、"
"非常に楽に開発することができます。"
msgstr ""
"Zig has [Tier-2 support](https://ziglang.org/download/0.13.0/release-notes."
"html) for x64 UEFI platforms. Linux / macOS / Windows on common CPUs are "
"Tier-1 supported. There are some differences between Tier-1 and Tier-2, such "
"as automated tests not being run and some tests being disabled, but my "
"impression is that general functionality can be used without problems. Thus, "
"you can create a UEFI app just as you would build a \"normal\" native app. "
"The structures and constants required by UEFI apps are included in Zig's "
"standard libraries, making development very easy."

#: src/bootloader/hello_uefi.md:87
msgid "ビルドスクリプトの設定"
msgstr "Configure Build Script"

#: src/bootloader/hello_uefi.md:89
msgid ""
"まずは Zig プロジェクトを作成します。 [開発構築のチャプター](../setup.md) を"
"参考に Zig をインストールした後、以下のコマンドでプロジェクトを作成してくださ"
"い:"
msgstr ""
"First, create a Zig project. After installing Zig referring to [setup "
"chapters](../setup.md), and then create a project with the following "
"commands:"

#: src/bootloader/hello_uefi.md:98
msgid "以下のようなプロジェクト構成になります:"
msgstr "The project structure will be as follows:"

#: src/bootloader/hello_uefi.md:109
msgid ""
"`build.zig`[^4]: ビルドスクリプト。Zig ではプロジェクトのビルド設定自体を "
"Zig で記述します。"
msgstr ""
"`build.zig`[^4]: Build script. Zig describes the project build configuration "
"itself in Zig."

#: src/bootloader/hello_uefi.md:110
msgid ""
"`build.zig.zon`: 依存関係を [ZON](https://zig.news/edyu/zig-package-manager-"
"wtf-is-zon-558e) という形式で記述します。Surtr/Ymir は依存を全く持たないた"
"め、必要ありません。"
msgstr ""
"`build.zig.zon`: Describe dependencies in the form of [ZON format](https://"
"zig.news/edyu/zig-package-manager-wtf-is-zon-558e). Surtr and Ymir has no "
"dependencies at all and the file is therefore not required."

#: src/bootloader/hello_uefi.md:111
msgid "`src`: ソースディレクトリ。"
msgstr "`src`: Source directory."

#: src/bootloader/hello_uefi.md:113
msgid ""
"本シリーズでは、デフォルトのプロジェクト構成から少し変更して以下のような構成"
"にします:"
msgstr ""
"In this blog, we will make a slight change from the default project "
"structure to the following:"

#: src/bootloader/hello_uefi.md:123
msgid ""
"`src`の代わりに Surtr と Ymir 用のソースディレクトリをそれぞれ用意していま"
"す。 まずは`build.zig`に Surtr 用の設定を記述します:"
msgstr ""
"Instead of `src`, we created source directories for Surtr and Ymir, "
"respectively. First, write the configuration for Surtr in `build.zig`:"

#: src/bootloader/hello_uefi.md:148
msgid ""
"`b.standardOptimizeOption` はデフォルトの最適化オプションを取得する関数で"
"す。 最適化レベルはコマンドラインから指定でき、デフォルトでは `Debug` が設定"
"されます。 利用可能な最適化レベルは以下の4つです:"
msgstr ""
"`b.standardOptimizeOption` is a function to get the default optimization "
"option. The optimization level can be specified from the command line and "
"defaults to `Debug`. There are four optimization levels available:"

#: src/bootloader/hello_uefi.md:152
msgid "最適化レベル"
msgstr "Optimization Level"

#: src/bootloader/hello_uefi.md:152 src/bootloader/load_kernel.md:30
#: src/bootloader/load_kernel.md:40
msgid "説明"
msgstr "Description"

#: src/bootloader/hello_uefi.md:154
msgid "`Debug`"
msgstr "`Debug`"

#: src/bootloader/hello_uefi.md:154
msgid "デフォルト。未定義動作(UD)に対するチェックが付与されます。"
msgstr "Default level. A check for undefined behavior (UD) is inserted."

#: src/bootloader/hello_uefi.md:155
msgid "`ReleaseFast`"
msgstr "`ReleaseFast`"

#: src/bootloader/hello_uefi.md:155
msgid ""
"最もアグレッシブに最適化します。未定義動作(UD)に対するチェックが行われませ"
"ん。"
msgstr ""
"Most aggressive optimization. No checks are made for undefined behavior (UD)."

#: src/bootloader/hello_uefi.md:156
msgid "`ReleaseSafe`"
msgstr "`ReleaseSafe`"

#: src/bootloader/hello_uefi.md:156
msgid "最適化を行いますが、未定義動作(UD)に対するチェックが付与されます。"
msgstr ""
"Optimization is performed, but a check for undefined behavior (UD) is "
"performed."

#: src/bootloader/hello_uefi.md:157
msgid "`ReleaseSmall`"
msgstr "`ReleaseSmall`"

#: src/bootloader/hello_uefi.md:157
msgid "生成されるバイナリサイズが小さくなるように最適化します。"
msgstr "Optimize for smaller binary size."

#: src/bootloader/hello_uefi.md:159
msgid ""
"`b.addExecutable` で実行可能ファイルを追加します。 `.name`で出力名を指定しま"
"す。 `.root_source_file`でエントリポイントとなるソースファイルを指定します。 "
"**Zig では、Cのようにコンパイルするファイルやインクルードするファイルを全て指"
"定する必要はありません**。 `.root_source_file`で指定したファイルから参照され"
"るファイルを自動的にビルドツリーの中に含めてくれます。 `.target`にはコンパイ"
"ルターゲットを指定します。 今回は x64 アーキテクチャの UEFI プラットフォーム"
"をターゲットとします。 ベアメタルで動くブートローダでありライブラリの動的ロー"
"ドの仕組みは持っていないため、`.linkage`には`.static`を指定します。"
msgstr ""
"Add an executable with `b.addExecutable()`. Specify the output name with `."
"name`. Specify the source file to be the entry point with `."
"root_source_file`. **Zig does not require you to specify all the files to "
"compile or include as you do in C**. It will automatically include in the "
"build tree the files referenced by the file specified in `."
"root_source_file`. Specify the compile target in `.target`. In this case, "
"out target is x64 architecture & UEFI platform. Since this is a bare-metal "
"bootloader and does not have a dynamic loading mechanism for libraries, `."
"linkage` should be `.static`."

#: src/bootloader/hello_uefi.md:168
msgid ""
"最後に、`b.installArtifact()` で Surtr を `install` ターゲットに追加します。 "
"Zig のビルドは `zig build <target>` コマンドで実行します。 この際、`<target>`"
"を省略するとデフォルトのターゲットである `install` ターゲットが実行されま"
"す。 `installArtifact()`は、この `install` ターゲットに artifact を追加するも"
"のです。"
msgstr ""
"Finally, add Surtr to the `install` target with `b.installArtifact()`. You "
"can build it with `zig build <target>` command. If you omit `<target>`, the "
"default target `install` is executed. The `installArtifact()` adds an "
"artifact to this `install` target."

#: src/bootloader/hello_uefi.md:173 src/kernel/serial_output.md:129
#: src/kernel/bit_and_test.md:79 src/vmm/vmx_root.md:167
#: src/vmm/linux_boot.md:76 src/vmm/io.md:325 src/vmm/initramfs.md:22
msgid "\\[!TIP\\]"
msgstr ""

#: src/bootloader/hello_uefi.md:175
msgid ""
"`.static` は冗長に書くと `std.builtin.LinkMode.static` という `enum` の値で"
"す。 Zig では、関数の引数など値の型が確定している場合に `enum` の型を省略でき"
"ます。 そのため、本シリーズでは多くのコードでFQDNを省略して記述しています。 "
"VSCode + ZLS でも、ピリオドをタイプした時点で可能な`enum`値が補完されます。"
msgstr ""
"`.static` is an abbreviation for  `std.builtin.LinkMode.static`. Zig allows "
"you to omit the type name of `enum` if the type of the value is known, such "
"as function arguments. For this reason, many codes in this blog are written "
"without FQDN. VSCode + ZLS also completes possible `enum` values when you "
"just type a period."

#: src/bootloader/hello_uefi.md:180
msgid ""
"また、`addExecutable()` の引数である `.{...}` は構造体を意味します。 Zig で"
"は `Struct {}` のようにして構造体のインスタンスを生成しますが、ここでも型が確"
"定している場合には構造体名を省略することができます。"
msgstr ""
"Also, `. {...} `, the argument of `addExecutable()`, is a structure. You "
"instantiates the structure like `Struct {}`, but again, the structure name "
"can be omitted if the type is known."

#: src/bootloader/hello_uefi.md:183
msgid "エントリポイントの作成"
msgstr "Defining an Entry Point"

#: src/bootloader/hello_uefi.md:185
msgid "次に、`surtr/boot.zig` にエントリポイントを作成します:"
msgstr "Next, create an entry point in `surtr/boot.zig`:"

#: src/bootloader/hello_uefi.md:200
msgid ""
"返り値の型は `std.os.uefi.Status` にします。`return`では、前述したようにFQDN"
"を省略しています。 単純に`hlt`ループするだけの何もしないUEFIアプリです。"
msgstr ""
"The return type should be `std.os.uefi.Status`. In the `return`, the FQDN is "
"omitted as described above. This is a UEFI app that does nothing but simply "
"loop `hlt`."

#: src/bootloader/hello_uefi.md:203
msgid "QEMU で実行するための設定"
msgstr "Configuration to Run on QEMU"

#: src/bootloader/hello_uefi.md:205
msgid ""
"この UEFI アプリを QEMU 上で実行します。 `build.zig`に以下の設定を追記します:"
msgstr ""
"Let's run this UEFI app on QEMU. Add the following settings to the `build."
"zig`:"

#: src/bootloader/hello_uefi.md:220
msgid ""
"Zig ではビルド生成物はデフォルトで `zig-out` というディレクトリに出力されます"
"[^5]。 `addInstallFile()`によって、生成した `BOOTX64.EFI.efi` を `zig-out/"
"img/efi/boot/BOOTX64.EFI` にコピーします。 `install_surtr.step.dependOn()`で"
"は、このコピー処理を行う前に Surtr のビルドを行うように依存関係を宣言していま"
"す。 また、続く `dependOn()` ではデフォルトの `install` ターゲットの依存とし"
"てこのコピー処理を実行するように宣言しています。 これにより、`zig build` した"
"ときに Surtr のビルドと生成物のコピー処理が行われるようになります。"
msgstr ""
"Zig outputs the build product to the directory `zig-out` by default[^5]. "
"`addInstallFile()` copies the generated `BOOTX64.EFI.efi` to `zig-out/img/"
"efi/boot/BOOTX64.EFI`. In `install_surtr.step.dependOn()`, a dependency is "
"declared to build Surtr before this copy. The following `dependOn()` "
"declares the copy operation to be performed as a dependency of the default "
"`install` target. This ensures that when you `zig build`, the build of Surtr "
"and copying of the product will be performed."

#: src/bootloader/hello_uefi.md:226
msgid "続いて、QEMUを実行するための設定を追記します:"
msgstr "Then, add following settings to run QEMU:"

#: src/bootloader/hello_uefi.md:254
msgid ""
"QEMUに渡すオプションを指定しています。 オプションの意味は以下のとおりです:"
msgstr ""
"It defines options to be passed to QEMU. The meanings of the options are as "
"follows:"

#: src/bootloader/hello_uefi.md:257
msgid ""
"`-m 512M`: メモリを512MBに設定します。これより少なくても多くてもおそらく動き"
"ます。"
msgstr ""
"`-m 512M`: Set the memory to 512 MB. It will probably work with less or more "
"than this."

#: src/bootloader/hello_uefi.md:258
msgid ""
"`-bios /usr/share/ovmf/OVMF.fd`: OVMFをFWとして指定します。 `apt`でインストー"
"ルした場合にはこのパスになります。 自前でビルドした場合には、生成されたバイナ"
"リのパスを指定してください。"
msgstr ""
"`-bios /usr/share/ovmf/OVMF.fd`: Specify OVMF as FW. If you installed it "
"with `apt`, the path becomes like this. If you built it by yourself, specify "
"the path to the generated binary."

#: src/bootloader/hello_uefi.md:261
msgid ""
"`-drive file=...`: ハードドライブの設定をします。 QEMU では [VVFAT (Virtual "
"FAT filesystem)](https://en.wikibooks.org/wiki/QEMU/Devices/Storage) という仮"
"想ドライブによってホストのディレクトリをそのままゲストにドライブとして渡すこ"
"とができるため、それを利用しています。"
msgstr ""
"`-drive file=...`: Configure hard drive settings. QEMU uses a virtual drive "
"called [VVFAT (Virtual FAT filesystem)](https://en.wikibooks.org/wiki/QEMU/"
"Devices/Storage) to pass the host directory to the guest."

#: src/bootloader/hello_uefi.md:263
msgid "`-nographic`: グラフィカルモードを無効にします。"
msgstr "`-nographic`: Disable graphical mode."

#: src/bootloader/hello_uefi.md:264
msgid ""
"`-serial mon:stdio`: シリアル通信を標準入出力に設定します。 ターミナルからの"
"入力はシリアル入力としてゲストに渡され、逆にシリアル出力はターミナルに出力さ"
"れます。"
msgstr ""
"`-serial mon:stdio`: Sets serial communication as standard input/output. "
"Input from the terminal is passed to the guest as serial input, and "
"conversely, serial output is written to the terminal."

#: src/bootloader/hello_uefi.md:266
msgid "`-enable-kvm`: バックエンドに KVM を使用します。"
msgstr "`-enable-kvm`: Use KVM as the backend."

#: src/bootloader/hello_uefi.md:267
msgid "`-cpu host`: ホストのCPUをパススルーします。"
msgstr "`-cpu host`: Pass-through host CPU."

#: src/bootloader/hello_uefi.md:268
msgid "`-s`: GDB サーバを起動してポート`1234`でリッスンさせます。"
msgstr "`-s`: Start the GDB server and make it listen on port `1234`."

#: src/bootloader/hello_uefi.md:270
msgid ""
"`b.step()`によって、新しいビルドターゲットを追加しています。 これにより `zig "
"build run` とすることで、その依存として設定した上記のQEMUコマンドが実行されま"
"す。"
msgstr ""
"A new build target is added by `b.step()`. This will cause `zig build run` "
"to execute the above QEMU command that you set as its dependency."

#: src/bootloader/hello_uefi.md:273
msgid "実行"
msgstr "Run on QEMU"

#: src/bootloader/hello_uefi.md:275
msgid "それでは、実際にビルドして QEMU で実行してみましょう:"
msgstr "Now, let's actually build the app and run it on QEMU:"

#: src/bootloader/hello_uefi.md:282
msgid "以下のように、QEMU が起動し先に進まなければOKです:"
msgstr "It's okay if QEMU starts and does not proceed as shown below:"

#: src/bootloader/hello_uefi.md:290
msgid ""
"[HLT](https://www.felixcloutier.com/x86/hlt) 命令によってCPUが停止しているこ"
"とを確認してみましょう。 生成された UEFI アプリをディスアセンブルしてみると、"
"`.text`セクションは以下のようになっています。とても小さいです:"
msgstr ""
"[HLT](https://www.felixcloutier.com/x86/hlt) 命令によってCPUが停止しているこ"
"とを確認してみましょう。 生成された UEFI アプリをディスアセンブルしてみると、"
"`.text`セクションは以下のようになっています。とても小さいです:"

#: src/bootloader/hello_uefi.md:317
msgid ""
"`+1036`の位置に`hlt`命令が、`+1037`の位置に`hlt`にジャンプするコードがありま"
"す。 続いて、QEMU の起動中に `Ctrl+A C` をタイプして [QEMU monitor](https://"
"qemu-project.gitlab.io/qemu/system/monitor.html) を起動し、レジスタの値を見て"
"みます:"
msgstr ""
"There is a `hlt` instruction at `+1036` and code to jump to `hlt` at the "
"`+1037`. Then, while QEMU is running, type `Ctrl+A C` to open [QEMU monitor]"
"(https://qemu-project.gitlab.io/qemu/system/monitor.html) and look at the "
"register values:"

#: src/bootloader/hello_uefi.md:347
msgid ""
"RIP が `000000001e235037` になっていることがわかります。 下 3nibble[^nibble] "
"が先程見たアセンブリの `jmp` 命令のアドレスと一致しているため、意図したとおり"
"にループされていることがわかりますね (このアプリがロードされたベースアドレス"
"がどうやら `0x1E235000` だったようです)。"
msgstr ""
"You can see that the RIP is `000000001e235037`. You can see that the bottom "
"3nibble[^nibble] matches the address of the `jmp` instruction in the "
"assembly we just looked at. So it is looping as intended (the base address "
"this app was loaded was apparently `0x1E235000`)."

#: src/bootloader/hello_uefi.md:351
msgid "\\[!Note\\]"
msgstr ""

#: src/bootloader/hello_uefi.md:353
msgid ""
"`info registers`の結果からだけでも、いくつかのことが分かります。 例えば、"
"UEFI が [GDT](../kernel/gdt.md) や [IDT](../kernel/interrupt.md) の設定を既に"
"済ませてくれているようです。 また、CR3 が設定されていることからも UEFI が "
"[ページング](./simple_pg.md) を有効化してくれているようです。 現在のページ"
"テーブルは仮想アドレスと物理アドレスがダイレクトマップされているであろうこと"
"が推測できます。 気になる人は CR3 を辿ってページテーブルを探索してみるのも良"
"いかもしれません。 自力でやらずとも、GDB拡張である [gef](https://github.com/"
"bata24/gef) の `vmmap` コマンドを使うと簡単にメモリマップを一覧できます。"
msgstr ""
"The results of `info registers` alone can tell us several things. For "
"example, if UEFI is not using [GDT](./kernel/gdt.md) and [IDT](./kernel/"
"interrupt.md) have already been set. The fact that CR3 is set also indicates "
"that UEFI has already enabled [paging](./simple_pg.md). We can assume that "
"the current page table would be a direct map of virtual and physical "
"addresses. If you are curious, you may want to explore the page table by "
"following CR3. Even if you don't do it by yourself, you can easily list the "
"memory map by using the `vmmap` command of [gef](https://github.com/bata24/"
"gef) GDB extension."

#: src/bootloader/hello_uefi.md:360 src/bootloader/uefi_log.md:403
#: src/bootloader/parse_kernel.md:339 src/bootloader/simple_pg.md:630
#: src/bootloader/load_kernel.md:338 src/bootloader/jump_to_ymir.md:423
#: src/kernel/serial_output.md:404 src/kernel/bit_and_test.md:274
#: src/kernel/serial_logsystem.md:125 src/kernel/gdt.md:531
#: src/kernel/interrupt.md:584 src/kernel/page_allocator.md:495
#: src/kernel/paging.md:573 src/kernel/panic.md:156
#: src/kernel/general_allocator.md:271 src/kernel/pic.md:587
#: src/vmm/vmx_root.md:725 src/vmm/vmcs.md:682 src/vmm/vmlaunch.md:1104
#: src/vmm/vmentry_vmexit.md:624 src/vmm/ept.md:770 src/vmm/linux_boot.md:728
#: src/vmm/cpuid.md:545 src/vmm/msr.md:444 src/vmm/cr.md:639 src/vmm/io.md:652
#: src/vmm/intr_injection.md:481 src/vmm/initramfs.md:212 src/vmm/vmcall.md:135
msgid "まとめ"
msgstr "Summary"

#: src/bootloader/hello_uefi.md:362
msgid ""
"本チャプターでは Surtr ブートローダを実装する準備として UEFI アプリの雛形を作"
"成しました。 実装したアプリは HLT ループをするだけのものでしたが、QEMU "
"monitor の結果から意図したとおりに HLT と JMP を繰り返していることが確認でき"
"ました。 ずっと無言でループされても面白くないため、次のチャプターでは Surtr "
"に出力機能を追加し何か喋らせてみます。"
msgstr ""
"In this chapter, we created a UEFI app skeleton in preparation for "
"implementing the Surtr bootloader. The app just repeats HLT loop. QEMU "
"monitor confirmed that the HLT and JMP were repeating as intended. Since it "
"is not interesting to loop silently all the time, in the next chapter, we "
"will add an output function to Surtr to make it speak something."

#: src/bootloader/hello_uefi.md:368
msgid "[ssstoyama/bootloader_zig](https://github.com/ssstoyama/bootloader_zig)"
msgstr ""
"[ssstoyama/bootloader_zig](https://github.com/ssstoyama/bootloader_zig)"

#: src/bootloader/hello_uefi.md:369 src/bootloader/uefi_log.md:412
msgid ""
"[フルスクラッチで作る!UEFIベアメタルプログラミング](http://yuma.ohgami.jp/"
"UEFI-Bare-Metal-Programming/index.html)"
msgstr ""
"[フルスクラッチで作る!UEFIベアメタルプログラミング](http://yuma.ohgami.jp/"
"UEFI-Bare-Metal-Programming/index.html)"

#: src/bootloader/hello_uefi.md:370
msgid "[bata24/gef](https://github.com/bata24/gef)"
msgstr "[bata24/gef](https://github.com/bata24/gef)"

#: src/bootloader/hello_uefi.md:372
msgid ""
"KVM はホストOSである Linux とやり取りするため一見すると Type-2 のようにも思え"
"ますが、 Linuxと同じ最低レイヤで動作するということを考えれば、Type-1 に分類さ"
"れることが多いのも納得ですね。"
msgstr ""
"At first glance, KVM may seem to be Type-2 since it interacts with Linux "
"(the host OS), but considering that it operates at the same lowest layer as "
"Linux, it makes sense that it is often classified as Type-1."

#: src/bootloader/hello_uefi.md:374
msgid ""
"Surtr は北欧神話における火の巨人です。 神話中でも多くは語られず、最終戦争であ"
"るラグナロクの際に暴れまわって世界を滅ぼすくらいしか登場しません。 原初の巨人"
"である Ymir よりも先に存在していたという不思議な存在です。 Ymir よりも先に存"
"在していたという理由でブートローダの名前に採用しています。"
msgstr ""
"Surtr is a fire giant in Norse mythology. Not much is said about them in the "
"mythology, and they appear only in the final war, Ragnarok, when they "
"rampage and destroy the world. It is a mysterious being that existed before "
"Ymir, the primordial Titan. It has been adopted as the name of the "
"bootloader for the reason that it existed before Ymir."

#: src/bootloader/hello_uefi.md:378
msgid ""
"Ymir は北欧神話における原初の巨人です。 世界が生まれる前に溶けた霜から生ま"
"れ、一緒に生まれたアウズンブラという牛の乳を飲んで育ちます。 全能神であるオー"
"ディンは Ymir の子孫にあたりますが、Ymir はオーディンによって殺されてその死骸"
"から世界が作られました。 原初の存在であり Ymir から世界が生まれたという言い伝"
"えから、ゲストOSをホストする hypervisor (のカーネル部分)の名前に採用していま"
"す。"
msgstr ""
"Ymir is the primordial giant in Norse mythology. He was born from the frost "
"that melted before the world was born, and grew up drinking the milk of a "
"cow named Ausumbra, with whom he was born. Odin, the Almighty God, is a "
"descendant of Ymir, who was killed by Odin and the world was created from "
"his corpse. The name of the hypervisor (the kernel part of the hypervisor) "
"that hosts a guest OS is taken from the legend that the world was born from "
"Ymir."

#: src/bootloader/hello_uefi.md:382
msgid "[Zig Build System](https://ziglang.org/learn/build-system/)"
msgstr "[Zig Build System](https://ziglang.org/learn/build-system/)"

#: src/bootloader/hello_uefi.md:383
msgid "コマンドラインオプションから出力ディレクトリはオーバーライドできます。"
msgstr "The output directory can be overridden from command line options."

#: src/bootloader/hello_uefi.md:384
msgid ""
"8bit ごとの単位を byte と呼ぶように、4bit ごとの単位を nibble と呼びます。"
msgstr ""
"As each 8-bit unit is called a byte, each 4-bit unit is called a nibble."

#: src/bootloader/uefi_log.md:1
msgid "UEFI でログ出力"
msgstr "Logging in UEFI Application"

#: src/bootloader/uefi_log.md:3
msgid ""
"Surtr の雛形ができたので、次にやりたいことはログ出力です。 ログ出力はデバッグ"
"をする上でも非常に重要なので先にやってしまいましょう。 今回は UEFI の "
"[Simple Text Output](https://uefi.org/specs/"
"UEFI/2.9_A/12_Protocols_Console_Support.html) というプロトコルを利用してログ"
"を出力していきます。"
msgstr ""
"Now that we have a template for Surtr, the next thing we want to do is to "
"output logs. Log output is very important for debugging, so let's do it "
"first. This time, we will use the UEFI [Simple Text Output](https://uefi.org/"
"specs/UEFI/2.9_A/12_Protocols_Console_Support.html) protocol to output logs."

#: src/bootloader/uefi_log.md:9
msgid ""
"本チャプターの最終コードは [`whiz-surtr-uefi_log`](https://github.com/"
"smallkirby/ymir/tree/whiz-surtr-uefi_log) ブランチにあります。"
msgstr ""
"Source code for this chapter is in [`whiz-surtr-hello_uefi`](https://github."
"com/smallkirby/ymir/tree/whiz-surtr-uefi_log) branch."

#: src/bootloader/uefi_log.md:13
msgid ""
"[System Table と Simple Text Output Protocol](#system-table-と-simple-text-"
"output-protocol)"
msgstr ""
"[System Table と Simple Text Output Protocol](#system-table-と-simple-text-"
"output-protocol)"

#: src/bootloader/uefi_log.md:14
msgid "[ログ実装のオーバーライド](#ログ実装のオーバーライド)"
msgstr "[ログ実装のオーバーライド](#ログ実装のオーバーライド)"

#: src/bootloader/uefi_log.md:15
msgid "[ログの初期化](#ログの初期化)"
msgstr "[ログの初期化](#ログの初期化)"

#: src/bootloader/uefi_log.md:16
msgid "[ログのスコープ](#ログのスコープ)"
msgstr "[ログのスコープ](#ログのスコープ)"

#: src/bootloader/uefi_log.md:17
msgid "[ログレベル](#ログレベル)"
msgstr "[ログレベル](#ログレベル)"

#: src/bootloader/uefi_log.md:18
msgid "[ログレベルの変更](#ログレベルの変更)"
msgstr "[ログレベルの変更](#ログレベルの変更)"

#: src/bootloader/uefi_log.md:22
msgid "System Table と Simple Text Output Protocol"
msgstr "System Table and Simple Text Output Protocol"

#: src/bootloader/uefi_log.md:24
msgid ""
"UEFI では [EFI System Table](https://uefi.org/specs/"
"UEFI/2.9_A/04_EFI_System_Table.html#efi-system-table-1) というテーブルに各種 "
"[ブートサービス](https://uefi.org/specs/UEFI/2.9_A/07_Services_Boot_Services."
"html)・[ランタイムサービス](https://uefi.org/specs/"
"UEFI/2.10/08_Services_Runtime_Services.html) へのポインタが格納されていま"
"す。 その中でも、`ConOut` というフィールドには "
"[EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL](https://uefi.org/specs/"
"UEFI/2.9_A/12_Protocols_Console_Support.html#efi-simple-text-output-"
"protocol) インタフェースへのポインタが格納されています。 このプロトコルを利用"
"することで、テキスト出力を容易に行えます。"
msgstr ""
"In UEFI, [EFI System Table](https://uefi.org/specs/"
"UEFI/2.9_A/04_EFI_System_Table.html#efi-system-table-1) contains various "
"[Boot Services](https://uefi.org/specs/UEFI/2.9_A/07_Services_Boot_Services."
"html) and [Runtime Services](https://uefi.org/specs/"
"UEFI/2.10/08_Services_Runtime_Services.html). Among them, the field `ConOut` "
"contains a pointer to [EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL](https://uefi.org/"
"specs/UEFI/2.9_A/12_Protocols_Console_Support.html#efi-simple-text-output-"
"protocol) interface. This protocol allows for easy text output in UEFI "
"application."

#: src/bootloader/uefi_log.md:29
msgid ""
"System Table へのポインタは `std.os.uefi.system_table` に入っています。 ここ"
"から Simple Output Protocol へのポインタを取得します:"
msgstr ""
"A pointer to the System Table is contained in `std.os.uefi.system_table`. "
"You can get the pointer to the Simpl Output Protocl by:"

#: src/bootloader/uefi_log.md:40
msgid ""
"Simple Output Protocol を取得後、[`clearScreen()`](https://uefi.org/specs/"
"UEFI/2.9_A/12_Protocols_Console_Support.html#efi-simple-text-output-protocol-"
"clearscreen)を呼んで画面をクリアします。 これによって、前チャプターで表示され"
"ていた `BdsDxe: loading Boot0001...` のような出力が消えてまっさらな画面が表示"
"されるはずです。"
msgstr ""
"After retrieving the Simple Output Protocol, call [`clearScreen()`](https://"
"uefi.org/specs/UEFI/2.9_A/12_Protocols_Console_Support.html#efi-simple-text-"
"output-protocol-clearscreen) to clear the screen. By doing this, the output "
"like `BdsDxe: loading Boot0001.... ` that was displayed in the previous "
"chapter should disappear and you should see a blank screen."

#: src/bootloader/uefi_log.md:43
msgid ""
"画面への文字列出力には [outputString()](https://uefi.org/specs/"
"UEFI/2.9_A/12_Protocols_Console_Support.html#efi-simple-text-output-protocol-"
"outputstring) を使います。 ただし、ここで渡す文字列は [UCS-2](https://e-"
"words.jp/w/UCS-2.html) という文字列集合を使います。 UCS-2 は1文字を2バイトで"
"表現します。 詳しいことは他の文献に譲るとして、ASCII文字の範囲内であれば "
"`<8bit ASCII code> <0x00>` という2バイトで1文字が表されるという事実だけをここ"
"では利用します。 よって、`\"Hello, world!\"`という文字列は以下のようにして出"
"力できます:"
msgstr ""
"To output a string to the screen, use [outputString()](https://uefi.org/"
"specs/UEFI/2.9_A/12_Protocols_Console_Support.html#efi-simple-text-output-"
"protocol-outputstring). Note that the string here uses the [UCS-2](https://e-"
"words.jp/w/UCS-2.html) character set. UCS-2 represents a character as two "
"bytes. I'll leave the details to other literature, but here we only use the "
"fact that a character is represented by two bytes, `<8bit ASCII code> "
"<0x00>`, if it is within the range of ASCII characters. Thus, the string "
"`\"Hello, world!\"` can be output as follows:"

#: src/bootloader/uefi_log.md:56
msgid ""
"Zig において、文字列リテラルは `[N:0]const u8` という [Sentinel-Terminated "
"Arrays](https://ziglang.org/documentation/master/#Sentinel-Terminated-"
"Arrays) 型になります。 言い換えれば NULL 終端された配列です。 よって、`for`"
"ループで使う変数の `b` は `const u8` 型になります。 `outputString()`の引数の"
"型は `[*:0]const u16` であるため、`u8`型を`u16`型に変換する必要があります。 "
"`for`ループの中身の `&[_:0]u16{ b }` では `u8` 型の `b` を `u16` 型に変換して"
"います。 `[_:0]` と指定することで、最後に勝手に `0x00` が追加され、UCS-2 文字"
"列として扱えるようになります。"
msgstr ""
"In Zig, string literals are of type `[N:0]const u8`, [Sentinel-Terminated "
"Arrays](https://ziglang.org/documentation/master/#Sentinel-Terminated-"
"Arrays). In other words, it is a null-terminated array. Thus, the variable "
"`b` used in the `for` loop is of type `const u8`. The type of the argument "
"to `outputString()` is `[*:0]const u16`, so the `u8` type must be converted "
"to a `u16` type. The `&[_:0]u16{ b }` inside the `for` loop converts `b` of "
"type `u8` to type `u16`. By specifying `[_:0]`, `0x00` is added at the end "
"automatically and can be treated as a UCS-2 string."

#: src/bootloader/uefi_log.md:63 src/bootloader/uefi_log.md:115
#: src/bootloader/uefi_log.md:208 src/bootloader/parse_kernel.md:174
#: src/bootloader/simple_pg.md:59 src/bootloader/jump_to_ymir.md:375
#: src/kernel/bit_and_test.md:152 src/kernel/paging.md:364
msgid "\\[!INFO\\]"
msgstr ""

#: src/bootloader/uefi_log.md:65
msgid "Zig において、配列の初期化は以下のように行います:"
msgstr "In Zig, arrays are initialized as follows:"

#: src/bootloader/uefi_log.md:71
msgid "ただし、配列のサイズが明らかである場合にはサイズを `_` で省略できます:"
msgstr ""
"However, if the size of the array is known, the size can be omitted by "
"writing `_`:"

#: src/bootloader/uefi_log.md:77
msgid "また、NULL終端された配列は以下のように初期化できます:"
msgstr "Also, a null-terminated array can be initialized as follows:"

#: src/bootloader/uefi_log.md:83
msgid ""
"この場合、`array.len == 4` ではありますが `array[4]` (5番目の要素)にアクセス"
"でき、その値は `0` になります。"
msgstr ""
"In this case, `array.len == 4` but `array[4]` (the fifth element) is "
"accessible and its value is `0`."

#: src/bootloader/uefi_log.md:85
msgid "ログ実装のオーバーライド"
msgstr "Overriding Implementation"

#: src/bootloader/uefi_log.md:87
msgid ""
"Zig では `std.log.info()` のような関数でログを出力できます。 これらの関数の実"
"体である [std.log.log()](https://github.com/ziglang/zig/blob/"
"bdd3bc056ee998770ea48a93b4ec99521f069aed/lib/std/log.zig#L117) は "
"`std_options.logFn` を呼び出します。 これはデフォルトでは [defaultLog()]"
"(https://github.com/ziglang/zig/blob/"
"bdd3bc056ee998770ea48a93b4ec99521f069aed/lib/std/log.zig#L143) になっていま"
"す。 この関数は内部で OS ごとの分岐をするのですが、`os.uefi` においてはコンパ"
"イルできないような分岐になっています。 よって `std_options.logFn` をオーバー"
"ライド[^override]し、**Simple Text Output を利用するような独自のログ関数を実"
"装してあげる必要があります**。"
msgstr ""
"Zig can output logs with functions such as `std.log.info()`. The entity of "
"these functions, [std.log.log()](https://github.com/ziglang/zig/blob/"
"bdd3bc056ee998770ea48a93b4ec99521f069aed/lib/std/log.zig#L117), call ` "
"std_options.logFn`. This defaults to [defaultLog()](https://github.com/"
"ziglang/zig/blob/bdd3bc056ee998770ea48a93b4ec99521f069aed/lib/std/log."
"zig#L143). The implementation of this function is OS-specific, but there're "
"no impl for UEFI platform. Therefore, you need to override `std_options."
"logFn` and implement your own logging function that uses **Simple Text "
"Output**."

#: src/bootloader/uefi_log.md:93
msgid ""
"`surtr/log.zig` を作成し、ログ関数を実装します。 `logFn` のシグネチャのとおり"
"に関数を定義してあげます:"
msgstr ""
"Create `surtr/log.zig` and implement the logging functions. Define the "
"function as per the signature of `logFn`:"

#: src/bootloader/uefi_log.md:117
msgid ""
"Zig では使われない変数がある状態ではコンパイルエラーになります。 関数の引数な"
"どで使わない変数がある場合には `_` で明示的に使わないことを宣言する必要があり"
"ます。 VSCode + ZLS を使っている場合、利用しない変数がある状態でセーブをする"
"と自動的に `_` に変換してくれるので便利です。 また、最初から引数の名前を `_` "
"にすることでも同様の効果が得られます。"
msgstr ""
"Zig will emits a compile error for iunused variables. If there are unused "
"function arguments, you must explicitly declare that they are intentionally "
"not used by using `_`. If you are using VSCode + ZLS, it's convenient that "
"it automatically converts unused variables to `_` when you save a file. The "
"same effect can also be achieved by mansally etting the argument names to "
"`_`."

#: src/bootloader/uefi_log.md:122
msgid ""
"`std.fmt.format()` はフォーマット文字列と引数から文字列を生成し、それを第1引"
"数の`Writer`に書き込む関数です。 `Writer`型は、以下のように定義します:"
msgstr ""
"`std.fmt.format()` is a function that generates a string from a format "
"string and arguments and writes it to the first argument `Writer`. The "
"`Writer` type is defined as follows:"

#: src/bootloader/uefi_log.md:135
msgid ""
"[`std.io.Writer()`](https://github.com/ziglang/zig/blob/"
"bfcf18c5a7d13d990c6bbda04d6a2cd37038a9ea/lib/std/io.zig#L304) は与えた情報を"
"もとに Writer 型を返してくれる関数です。 Zig では関数が型を返すことができま"
"す。 第1引数は`Writer`が呼び出された時に利用できるコンテキストです。今回はコ"
"ンテキストが必要ないため`void`を指定します。 第2引数はこの`Writer`が返すエ"
"ラー型です。エラーは返さないため、空のエラー型`LogError`を定義し、それを指定"
"しておきます。 最も重要な第3引数では実際に出力をする関数を指定します:"
msgstr ""
"[`std.io.Writer()`](https://github.com/ziglang/zig/blob/"
"bfcf18c5a7d13d990c6bbda04d6a2cd37038a9ea/lib/std/io.zig#L304) is a function "
"that returns a Writer type based on the information you give. Zig allows "
"functions to return types. The first argument is the context that will be "
"available when `Writer` is called. In this case, `void` is specified since "
"no context is needed. The second argument is the error type returned by this "
"`Writer`. Since no errors are returned, an empty error type `LogError` "
"should be defined and specified. The third argument, the most important one, "
"specifies the function that actually outputs the data:"

#: src/bootloader/uefi_log.md:151
msgid ""
"第1引数のコンテキストは`Writer`型の定義時に指定した型です。今回は`void`型を指"
"定しており使わないため、最初から`_`で無視しています。 `bytes`は出力する文字列"
"です。 先程 `\"Hello, world!\"` を出力したときと同様に、UCS-2 に変換して "
"`outputString()` に渡してあげます。"
msgstr ""
"The first argumect is the type specified when defining the `Writer` type. "
"Since the `void` type is specified and we will not use it, it's explicitly "
"ignored with `_`. The `bytes` is the string to output. As in the case of "
"outputting `“Hello, world!”`, it's converted to UCS-2 and passed to "
"`outputString()`."

#: src/bootloader/uefi_log.md:155
msgid ""
"これで独自のログ関数を実装できました。 あとは `std_options.logFn` にこの関数"
"をセットしてオーバーライドしてあげるだけです:"
msgstr ""
"Now you have implemented your own logging function. All that remains is to "
"set this function in `std_options.logFn` and override it:"

#: src/bootloader/uefi_log.md:165
msgid ""
"ドキュメントされていませんが、`std_options` 変数は `build.zig` の "
"`root_source_file` で指定したファイル以外オーバーライドできないようです。 そ"
"のため、`default_log_options` 変数を `pub` 指定して `boot.zig` から触れるよう"
"にしています。 `boot.zig` においてこの変数を参照し、 `std_options` 変数をオー"
"バーライドします:"
msgstr ""
"It is not documented, but it seems that the `std_options` variable can be "
"overridden only in `root_source_file` defined n `build.zig`. Therefore, the "
"`default_log_options` variable is `pub` so that `boot.zig` can read it. In "
"`boot.zig`, we reference this variable and override the `std_options` "
"variable:"

#: src/bootloader/uefi_log.md:175
msgid ""
"これで `std.log.info()` を呼び出すと、独自に実装したログ関数が呼び出されるよ"
"うになりました。"
msgstr ""
"Now, your own logging implementation will be called by `std.log.info()`."

#: src/bootloader/uefi_log.md:177
msgid "ログの初期化"
msgstr "Initialization of Log System"

#: src/bootloader/uefi_log.md:179
msgid ""
"ログ関数をオーバーライドしただけでは、ログが出力されるようにはなりません。 "
"`writerFunction()` で利用している `con_out` 変数を `log.zig` に渡してグローバ"
"ル変数としてセットしてあげる必要があります。 ログを出力する関数を用意します:"
msgstr ""
"Overriding the log function alone will not cause the log to be output to the "
"screen. You must pass the `con_out` variable used in `writerFunction()` to "
"`log.zig`, and set it as a global variable. Prepare a function to output the "
"log:"

#: src/bootloader/uefi_log.md:195
msgid ""
"あとは先程取得した Simple Text Output Protocol のポインタを渡してあげればログ"
"が出力されるようになります。 試しに以下のようなログ出力をしてみましょう:"
msgstr ""
"Then, the log will be output by passing a pointer to the Simple Text Output "
"Protocol that was obtained earlier. Let's try the following:"

#: src/bootloader/uefi_log.md:206
msgid "QEMU を動かしてログが出力されるかどうかを確認してください。"
msgstr "Run QEMU to see if logs are printed:"

#: src/bootloader/uefi_log.md:210
msgid ""
"Zig において関数は [Error Union Type](https://ziglang.org/documentation/"
"master/#Error-Union-Type) を返します。 この型は、エラー型と成功時の型の両方を"
"合わせた `LogError!u32` のようなかたちをしています。 エラーとして任意の型を許"
"容する場合には `!u32` のように書くこともできます。 逆にエラーを一切返さない場"
"合には `u32` と書けます。"
msgstr ""
"In Zig, the function returns [Error Union Type](https://ziglang.org/"
"documentation/master/#Error-Union-Type). This type has the form like "
"`LogError!u32`, which combines both the error type and the success type. It "
"can also be written as `!u32` if anyerror is acceptable. Conversely, if you "
"do not want to return any errors, you can write `u32`."

#: src/bootloader/uefi_log.md:215
msgid ""
"関数を呼び出したとき、その関数がエラーを返す可能性がある場合は `catch` で受け"
"ることでエラーを処理できます:"
msgstr ""
"If you call a function that may return an error, you can catch it with "
"`catch` to handle the error:"

#: src/bootloader/uefi_log.md:217
msgid ""
"```zig\n"
"const value = SomeFunction() catch |err| {\n"
"    log.error(\"SomeFunction failed: {?}\", .{err});\n"
"    @panic();\n"
"}\n"
"```"
msgstr ""
"```zig\n"
"const value = SomeFunction() catch |err| {\n"
"    log.error(\"SomeFunction failed: {?}\", .{err});\n"
"    @panic();\n"
"}\n"
"```"

#: src/bootloader/uefi_log.md:224
msgid ""
"エラーが返されなかった場合、`catch` ブロックは実行されず、`value` には関数の"
"返り値が代入されます。 先程の `writerFunction()` では `outputString()` がエ"
"ラーを返す可能性があるため、`catch unreachable` でエラーを処理しています。"
msgstr ""
"If no error is returned, the `catch` block is not executed and `value` is "
"assigned the return value. In the previous `writerFunction()`, "
"`outputString()` may return an error, so `catch unreachable` is used to "
"handle the error."

#: src/bootloader/uefi_log.md:227
msgid ""
"ここで、`unreachable`の意味は **ビルドの最適化レベルによって変化します**。 "
"`Debug` と `ReleaseSafe` レベルの場合、`unreachable` は [`@panic()`](https://"
"ziglang.org/documentation/master/#panic) を引き起こします。 それ以外の場合に"
"は、`unreachable`は「到達することがない」というアノテーションとして働くた"
"め、 実際にその箇所に到達してしまった場合の挙動は未定義です。 実行される可能"
"性がある箇所に `unreachable` を置かないように気をつけましょう。"
msgstr ""
"The meaning of `unreachable` **depends on the optimization level of the "
"build**. For the `Debug` and `ReleaseSafe` levels, `unreachable` causes "
"[`@panic()`](https://ziglang.org/documentation/master/#panic). Otherwise, "
"`unreachable` acts just as a “never reachable” annotation. The behavior when "
"the execution reached there is undefined. Be careful not to put "
"`unreachable` where it could be executed."

#: src/bootloader/uefi_log.md:233
msgid "ログのスコープ"
msgstr "Scope"

#: src/bootloader/uefi_log.md:235
msgid ""
"ここまででログの出力ができるようになりました。 これで終わっても十分なのです"
"が、せっかくなのでもう少し Zig のログシステムの良さを活かしてみましょう。"
msgstr ""
"Now we are ready to output logs. This would be enough, but since we are "
"here, let's take advantage of Zig's logging system a little more."

#: src/bootloader/uefi_log.md:238
msgid "Zig では**ログにスコープをもたせることができます**:"
msgstr "Zig allows for **scoping of logs**:"

#: src/bootloader/uefi_log.md:246
msgid ""
"`scoped(.hoge)` は、`hoge` というスコープが与えられた新しいログ関数たちを生成"
"してくれます。 先程実装した `log()` 関数の第2引数ではこのスコープを受け取るこ"
"とができます。 スコープも一緒に出力してあげるように修正しましょう:"
msgstr ""
"`scoped(.hoge)` generates a new set of log functions given a scope of "
"`hoge`. The second argument of the `log()` function we just implemented "
"accepts this scope. Let's modify it so that it outputs the scope as well:"

#: src/bootloader/uefi_log.md:269
msgid ""
"受け取った`scope`が`.default`以外の場合には、`(<SCOPE>)` という文字列を作成"
"し、それを出力するようにしています。 Zig では配列を `++` 演算子で結合できるた"
"め、これを利用しています。 引数に `comptime` を含む関数はコンパイル時に評価さ"
"れるため、スコープ用の文字列生成部分には実行時のオーバーヘッドはありません。"
msgstr ""
"If the received `scope` is not `.default`, a string `(<SCOPE>)` is included "
"in the output. Zig allows array concatnation using the `++` operator. "
"Functions with `comptime` arguments are evaluated at compile time, so the "
"string generation for scope has no runtime overhead."

#: src/bootloader/uefi_log.md:273
msgid ""
"`boot.zig` では、スコープを `.surtr` として Surtr からの出力であることがわか"
"りやすいようにします:"
msgstr ""
"In `boot.zig`, we use the scope `.surtr` to make it easy to see that the "
"output is from Surtr:"

#: src/bootloader/uefi_log.md:281
msgid "以下のような出力になるはずです:"
msgstr "The output should look something like this:"

#: src/bootloader/uefi_log.md:288
msgid "ログレベル"
msgstr "Log Level"

#: src/bootloader/uefi_log.md:290
msgid ""
"ログの最後の要素は **ログレベル** です。 Zig のログレベルは `std.log.Level` "
"enum として定義されており、`err`/`warn`/`info`/`debug` の4つがあります。 デ"
"フォルトのログレベルは [最適化レベルによって決まります](https://github.com/"
"ziglang/zig/blob/bdd3bc056ee998770ea48a93b4ec99521f069aed/lib/std/log."
"zig#L101-L106)。 プログラムのログレベルより低いログは出力されず、コンパイル時"
"に削除されます。"
msgstr ""
"The last element of the log is the **log level**. Zig's log levels are "
"defined as `std.log.Level` enum, with four levels: `err`/`warn`/`info`/"
"`debug`. The default log level is [determined by the optimization level]"
"(https://github.com/ziglang/zig/blob/"
"bdd3bc056ee998770ea48a93b4ec99521f069aed/lib/std/log.zig#L101-L106). Logs "
"lower than the program's log level are not output and are removed at compile "
"time."

#: src/bootloader/uefi_log.md:295
msgid "ここでは、分かりやすいようにログレベルも出力してみましょう:"
msgstr "For clarity, let's also output the log level:"

#: src/bootloader/uefi_log.md:321
msgid ""
"`comptime switch` はコンパイル時に評価される `switch` 文です。 `level` に対応"
"する文字列を生成し、スコープ文字列のように `fmt` と結合して出力しています。 "
"この状態でログを出力すると以下のようになるはずです:"
msgstr ""
"`comptime switch` is a `switch` statement that is evaluated at compile time. "
"It generates a string corresponding to `level`, concatenates it with `fmt` "
"like a scope string, and outputs it. The log output in this state should "
"look like this:"

#: src/bootloader/uefi_log.md:330
msgid "ログレベルの変更"
msgstr "Change Log Level"

#: src/bootloader/uefi_log.md:332
msgid ""
"ログレベルはコード中で `std_options.log_level` にセットすることで変更できま"
"す。 しかし、わざわざログレベルを変更するためにコードを書き換えるのはめんどう"
"ですね。 ビルドスクリプトを変更し、ビルド時にログレベルを変更できるようにしま"
"しょう:"
msgstr ""
"The log level can be changed by setting `std_options.log_level` in the code. "
"However, it is not convenient to rewrite the code just to change the log "
"level. Let's modify the build script to change the log level at build time:"

#: src/bootloader/uefi_log.md:366
msgid ""
"`b.option` によって、新たなコマンドライン引数を定義しています。 引数で受け"
"取った文字列を4つの enum 値に変換し、`addOption()` で新たに `log_level` とい"
"う名前のオプションとして追加します。"
msgstr ""
"A new command line argument is defined by `b.option`. The string received as "
"an argument is converted to four enum values and added as a new option named "
"`log_level` with `addOption()`."

#: src/bootloader/uefi_log.md:369
msgid "ここで追加したオプションは、コード中で以下のように参照できます:"
msgstr "The options added here can be referenced in the code as follows:"

#: src/bootloader/uefi_log.md:377
msgid ""
"`log_level` はコンパイル時に決定する値として利用できます。 この値を "
"`std_options.log_level` にセットしてあげましょう:"
msgstr ""
"The `log_level` can be used as a value that's determined at compile time. "
"Set this value to `std_options.log_level`:"

#: src/bootloader/uefi_log.md:393
msgid ""
"あとはビルド時にこのオプションを指定してあげれば、ログレベルが変更されます。 "
"試しに `log.info()` でログ出力するように指定してあげた上で、コンパイル時にロ"
"グレベルとして `.warn` を指定してみましょう:"
msgstr ""
"Then, specify this option at build time to change the log level. For "
"example, you can use `log.info()` to specify log output, and then specify `."
"warn` as the log level at compile time:"

#: src/bootloader/uefi_log.md:401
msgid "QEMUの出力からログ出力が消えるはずです。"
msgstr "The log output should disappear from the QEMU output."

#: src/bootloader/uefi_log.md:405
msgid ""
"本チャプターでは UEFI の Simple Text Output Protocol を利用した出力を実装しま"
"した。 この出力を Zig のログシステムに組み込むことで、ログのスコープやレベル"
"を自由に変更できるようになりました。 ログカンスは、もちろんフォーマット文字列"
"も利用できます。 今後の開発が捗ること間違いなしですね。"
msgstr ""
"In this chapter, we implemented logging using UEFI's Simple Text Output "
"Protocol. By incorporating this output into Zig's logging system, the scope "
"and level of logging can be changed as you like. Of course, you can also use "
"format strings. I'm sure that further development gets easy!"

#: src/bootloader/uefi_log.md:413
msgid ""
"[UEFI Specification 2.9 Errata A](https://uefi.org/specs/UEFI/2.9_A/index."
"html)"
msgstr ""
"[UEFI Specification 2.9 Errata A](https://uefi.org/specs/UEFI/2.9_A/index."
"html)"

#: src/bootloader/uefi_log.md:415
msgid ""
"厳密には Zig にはオーバーライドという概念はありません。 標準ライブラリの中で "
"`@hasDecl()` によってアプリが対象の変数を定義していない場合にのみライブラリ側"
"で定義した値を使うような[実装](https://github.com/ziglang/zig/blob/"
"bfcf18c5a7d13d990c6bbda04d6a2cd37038a9ea/lib/std/std.zig#L101)になっていま"
"す。"
msgstr ""
"Strictly speaking, Zig does not have the concept of override. It is "
"[implemented](https://github.com/ziglang/zig/blob/"
"bfcf18c5a7d13d990c6bbda04d6a2cd37038a9ea/lib/std/std.zig#L101) in the "
"standard library such that it uses the functin defined by std only if the "
"app hasn't provided the target variable by `@hasDecl()` ."

#: src/bootloader/parse_kernel.md:1
msgid "カーネルのELFをパースする"
msgstr "Parsing Kernel ELF"

#: src/bootloader/parse_kernel.md:3
msgid ""
"本チャプターでは、ホストOSである Ymir を UEFI のファイルシステムから読み込み"
"ます。 その ELF ファイルをパースし、Ymir が要求するメモリレイアウトを取得しま"
"す。 本来であればそのままメモリに Ymir をロードして処理を移したいところです"
"が、 そのためには ELF が要求する仮想アドレスに物理ページをマップするための"
"ページテーブルを作成する必要があります。 ページテーブルの操作は次チャプターで"
"実装することにして、今回は Ymir Kernel の ELF のパースまでを行います。"
msgstr ""
"In this chapter, we read the host OS, Ymir, from the UEFI file system. The "
"ELF file is parsed to obtain the memory layout required by Ymir. Normally, "
"we would like to load Ymir directly into memory and transfer the execution "
"to her. But to do so, we need to organize a page table to map the virtual "
"pages required by ELF to the physical addresses. The page table operation "
"will be implemented in the next chapter. In this chapter we will do up to "
"the parsing of ELF of Ymir kernel."

#: src/bootloader/parse_kernel.md:11
msgid ""
"本チャプターの最終コードは [`whiz-surtr-parse_kernel`](https://github.com/"
"smallkirby/ymir/tree/whiz-surtr-parse_kernel) ブランチにあります。"
msgstr ""
"Source code for this chapter is in [`whiz-surtr-parse_kernel`](https://"
"github.com/smallkirby/ymir/tree/whiz-surtr-parse_kernel) branch."

#: src/bootloader/parse_kernel.md:15
msgid "[Ymir の雛形のビルド](#ymir-の雛形のビルド)"
msgstr "[Ymir の雛形のビルド](#ymir-の雛形のビルド)"

#: src/bootloader/parse_kernel.md:16
msgid "[カーネルヘッダの読み込み](#カーネルヘッダの読み込み)"
msgstr "[カーネルヘッダの読み込み](#カーネルヘッダの読み込み)"

#: src/bootloader/parse_kernel.md:17
msgid "[ファイルのオープン](#ファイルのオープン)"
msgstr "[ファイルのオープン](#ファイルのオープン)"

#: src/bootloader/parse_kernel.md:18
msgid "[ファイルの読み込み](#ファイルの読み込み)"
msgstr "[ファイルの読み込み](#ファイルの読み込み)"

#: src/bootloader/parse_kernel.md:19
msgid "[ELF ヘッダのパース](#elf-ヘッダのパース)"
msgstr "[ELF ヘッダのパース](#elf-ヘッダのパース)"

#: src/bootloader/parse_kernel.md:22
msgid "Ymir の雛形のビルド"
msgstr "Building a Skeleton for Ymir"

#: src/bootloader/parse_kernel.md:24
msgid ""
"カーネルである Ymir をロードするためには、当然 Ymir の ELF ファイルをビルドす"
"る必要があります。 まずは何もしない Ymir の雛形を作成し、その ELF ファイルを"
"ビルドできるようにします。"
msgstr ""
"To load the Ymir kernel, we obviously need to build its ELF file. As a first "
"step, we'll create a minimal skeleton of Ymir that does nothing, just to "
"make sure we can successfully build the ELF file."

#: src/bootloader/parse_kernel.md:27
msgid "`ymir` ディレクトリを作成し、`ymir/main.zig` を以下のようにします:"
msgstr "Create a `ymir` directory and add the following to `ymir/main.zig`:"

#: src/bootloader/parse_kernel.md:37
msgid ""
"`kernelEntry()` は Surtr から制御が移される Ymir のエントリポイントとしま"
"す。 この関数からは抜け出すことがないため、返り値の型は [`noreturn`](https://"
"ziglang.org/documentation/master/#noreturn) とします。"
msgstr ""
"The `kernelEntry()` function serves as the entry point for Ymir, where "
"control is transferred from Surtr. Since this function never returns, its "
"return type is set to [`noreturn`](https://ziglang.org/documentation/master/"
"#noreturn)."

#: src/bootloader/parse_kernel.md:40
msgid ""
"Zig では `callconv()` によって関数の [Calling Convention](https://en."
"wikipedia.org/wiki/Calling_convention) を指定できます。 [UEFI の calling "
"convention](https://uefi.org/specs/UEFI/2.9_A/02_Overview.html#calling-"
"conventions) は Windows と同じであるため本来は `.Win64` を指定するべきです。 "
"しかし、後々この関数はスタックをカーネル用に切り替えて実際のメイン関数を呼び"
"出すためのトランポリン関数にする予定のため、 ここでは一旦 `.Naked` を指定して"
"おきます。 この calling convention は関数のプロローグやエピローグを生成せずレ"
"ジスタ状態の変更も伴わないため、 トランポリンコードには最適です。"
msgstr ""
"In Zig, you can specify a function's [calling convention](https://en."
"wikipedia.org/wiki/Calling_convention) using `callconv()`.Since the [UEFI "
"calling convention](https://uefi.org/specs/UEFI/2.9_A/02_Overview."
"html#calling-conventions) is the same as Windows, we would normally use `."
"Win64`. However, this function is intended to be a trampoline that switches "
"to the kernel's stack and then calls the actual main function. For that "
"reason, we temporarily use `.Naked` here.\n"
"The `.Naked` calling convention is ideal for trampoline code because it "
"avoids generating function prologues, epilogues, or any register management."

#: src/bootloader/parse_kernel.md:47
msgid "これで Ymir の雛形ができたので、ビルドの設定をします:"
msgstr ""
"Now that we've created the basic skeleton of Ymir, let's set up the build "
"configuration:"

#: src/bootloader/parse_kernel.md:68
msgid ""
"`.target` ではOSタグとして `.freestanding` を指定します。 また、`.code_model`"
"でコードモデル[^1]として `.kernel` を指定します。 コードモデルはリロケーショ"
"ンに必要な情報を生成するために参照され、他には `.small` や `.medium` などがあ"
"ります。 のちのチャプターで出てきますが Ymir のアドレスレイアウトは Linux に"
"似せて `0xFFFF888000000000` らへんに配置するようにします。 そのため、 `."
"kernel` を指定しないとリロケーションに必要な情報が入り切らずエラーになってし"
"まいます。 アドレスレイアウトを指定するにはリンカスクリプトを書く必要がありま"
"すが、今のところはこのままで問題ありません。 最後に、エントリポイントとして先"
"程定義した `kernelEntry()` を指定してあげれば完成です。"
msgstr ""
"In the `.target` field, we specify `.freestanding` as the OS tag. We also "
"set the `.code_model` to `.kernel` to define the [code model](https://lld."
"llvm.org/NewLLDFrontend.html#code-models) to use. Code models affect how "
"relocation information is generated. Other options include `.small` and `."
"medium`.\n"
"As we’ll cover in a later chapter, Ymir’s address layout is modeled after "
"Linux. Ymir is placed around `0xFFFF888000000000`. If `.kernel` is not "
"specified, the relocation information may exceed what fits in the default "
"code model, resulting in errors. Although defining an address layout "
"requires a linker script, we won’t write one just yet.\n"
"Finally, we complete the setup by specifying `kernelEntry()` as the entry "
"point."

#: src/bootloader/parse_kernel.md:76
msgid ""
"この時点で `zig build` を実行すると `zig-out/bin/ymir.elf` が生成されます。 "
"`readelf`でヘッダを見てみましょう:"
msgstr ""
"At this point, running `zig build` will generate `zig-out/bin/ymir.elf`. "
"Let's take a look at the headers using `readelf`:"

#: src/bootloader/parse_kernel.md:105
msgid ""
"当然ですがちゃんと 64bit ELF が生成されています。 エントリポイントは "
"`0x1001120` であり、`objdump` で周辺を見てみると先程定義した `kernelEntry()` "
"が存在していることがわかります:"
msgstr ""
"As expected, a proper 64-bit ELF file is generated. The entry point is at "
"`0x1001120`, and if you examine the surrounding area with `objdump`, you can "
"confirm that the previously defined `kernelEntry()` function is present:"

#: src/bootloader/parse_kernel.md:117
msgid ""
"以上で Surtr から読み込むための Ymir の ELF ファイルが生成できました。 生成し"
"た Ymir を EFI ファイルシステムに配置する設定も書いてしまいましょう:"
msgstr ""
"With this, the ELF file for Ymir, which will be loaded by Surtr, has been "
"successfully generated. Let's also set up the configuration to place the "
"generated Ymir onto the EFI file system:"

#: src/bootloader/parse_kernel.md:130
msgid ""
"[Surtr をインストールする設定](hello_uefi.md)とほとんど同じです。 これによ"
"り、Ymir は `zig-out/img/ymir.elf` にコピーされることになります。"
msgstr ""
"This setup is almost the same as the [configuration for installing Surtr]"
"(hello_uefi.md). As a result, Ymir will be copied to `zig-out/img/ymir.elf`."

#: src/bootloader/parse_kernel.md:133
msgid "カーネルヘッダの読み込み"
msgstr "Loading Kernel Headers"

#: src/bootloader/parse_kernel.md:135
msgid ""
"Surtr からファイルシステム上のファイルにアクセスするためには [Simple File "
"System Protocol](https://uefi.org/specs/UEFI/2.10/13_Protocols_Media_Access."
"html#simple-file-system-protocol) を使います。 UEFI アプリである Surtr が実行"
"されてから明示的に exit するまでは、 [Boot Services](https://uefi.org/specs/"
"UEFI/2.9_A/07_Services_Boot_Services.html) という UEFI が提供する関数群にアク"
"セスできます。 Boot Services へのポインタは、前回ログ出力に利用した Simple "
"Text Output Protocol と同様に [EFI System Table](https://uefi.org/specs/"
"UEFI/2.9_A/04_EFI_System_Table.html#efi-system-table-1) から取得できます:"
msgstr ""
"To access files on the filesystem from Surtr, we use the [Simple File System "
"Protocol](https://uefi.org/specs/UEFI/2.10/13_Protocols_Media_Access."
"html#simple-file-system-protocol).\n"
"Until Surtr, UEFI application, explicitly calls exit, it has access to a set "
"of functions provided by UEFI called [Boot Services](https://uefi.org/specs/"
"UEFI/2.9_A/07_Services_Boot_Services.html). \n"
"A pointer to Boot Services can be obtained from the [EFI System Table]"
"(https://uefi.org/specs/UEFI/2.9_A/04_EFI_System_Table.html#efi-system-"
"table-1), just like we did previously to get the Simple Text Output Protocol "
"for logging:"

#: src/bootloader/parse_kernel.md:148
msgid "取得した Boot Services から、Simple File System Protocol を取得します:"
msgstr ""
"From the obtained Boot Services, we retrieve the Simple File System Protocol:"

#: src/bootloader/parse_kernel.md:161
msgid ""
"続いて、Simple File System Protocol を利用して FS のルートディレクトリを開き"
"ます:"
msgstr ""
"Next, using the Simple File System Protocol, we open the root directory of "
"the filesystem:"

#: src/bootloader/parse_kernel.md:176
msgid ""
"Zig では C のように変数の宣言だけをすることができません。 必ず宣言と同時に値"
"を初期化する必要があります。 未初期化な値を代入するためには [`undefined`]"
"(https://ziglang.org/documentation/master/#undefined) を利用できます。 "
"`undefined` で初期化された変数の値は、Debug モードでは `0xAA` で埋められ、そ"
"れ以外のモードでは未定義です。 また、`undefined` で初期化されたかどうかを判断"
"する方法はありません。"
msgstr ""
"In Zig, unlike in C, you cannot declare a variable without also initializing "
"it. Every variable must be assigned a value at the time of declaration. If "
"you want to assign an uninitialized value, you can use [`undefined`](https://"
"ziglang.org/documentation/master/#undefined). When a variable is initialized "
"with `undefined`, its actual contents are filled with `0xAA` in Debug mode, "
"while in other build modes, the value is truly undefined. There is no way to "
"check whether a variable was initialized with `undefined` or not."

#: src/bootloader/parse_kernel.md:182
msgid "ファイルのオープン"
msgstr "Opening a File"

#: src/bootloader/parse_kernel.md:184
msgid ""
"続いて、Ymir の ELF ファイルを開きます。 ファイルを開くのには [open()]"
"(https://uefi.org/specs/UEFI/2.10/13_Protocols_Media_Access.html#id25) 関数を"
"使います。 ここで指定するファイル名は、前回のログ出力と同様に [UCS-2]"
"(https://e-words.jp/w/UCS-2.html) を使う必要があります。 Simple File System "
"Protocol を利用してファイルを開く機会は他にもいくつかあるため、UCS-2 への変換"
"をするヘルパー関数を用意してあげましょう:"
msgstr ""
"Next, we open the Ymir ELF file. To open a file, we use the [open()](https://"
"uefi.org/specs/UEFI/2.10/13_Protocols_Media_Access.html#id25) function. The "
"filename must be specified using [UCS-2](https://e-words.jp/w/UCS-2.html), "
"just like with the previous logging output.\n"
"Since we'll open files using the Simple File System Protocol multiple times, "
"it's helpful to create a utility function to convert strings to UCS-2:"

#: src/bootloader/parse_kernel.md:201
msgid ""
"開くファイル名はコンパイル時に決まっているため、引数は `comptime s` としてい"
"ます。 このようにすると、返り値の型として `s.len` のような情報が使えるように"
"なります。 今回は UCS-2 に変換するとバイト長が2倍になるため、返り値の型は "
"`[s.len * 2:0]u16` です。 関数内でやっていることは前回と同様に ASCII 文字列の"
"各バイトの後に `\\0` を加えているだけです。"
msgstr ""
"Since the filename to open is fixed at compile time, the argument is "
"declared as `comptime s`. This allows us to use `s.len` in the return "
"type. \n"
"Because converting to UCS-2 doubles the byte length, the return type here is "
"`[s.len * 2:0]u16`. Inside the function, the conversion is straightforward - "
"just like before, it inserts a `\\0` after each ASCII byte."

#: src/bootloader/parse_kernel.md:206
msgid "この関数を利用して、ファイルを開く関数を作ります:"
msgstr "Using this function, let's create a function to open a file:"

#: src/bootloader/parse_kernel.md:230
msgid ""
"`root.open()` で実際にファイルをオープンします。 第3引数にはファイルのモード"
"を選択します。書き込む必要がないため Read-Only で十分です。 第4引数はファイル"
"作成時に作成するファイルの attribute を指定しますが、今回はオープンしかしない"
"ため使いません。 適当に `0` を指定しておきます。"
msgstr ""
"We open the file using `root.open()`. The third argument specifies the file "
"mode; since writing is not needed, read-only mode is sufficient. The fourth "
"argument sets the file attributes when creating a new file, but since we're "
"only opening an existing file here, it is unused and can be set to `0`."

#: src/bootloader/parse_kernel.md:235
msgid "この関数を使うと、カーネルを以下のようにオープンできます:"
msgstr "Using this function, you can open the kernel as follows:"

#: src/bootloader/parse_kernel.md:243
msgid "ファイルの読み込み"
msgstr "Reading a File"

#: src/bootloader/parse_kernel.md:245
msgid ""
"Ymir の ELF がオープンできたため実際にファイルを FS からメモリに読み込みま"
"す。 ELF ファイルは必ず [ELF Header](https://refspecs.linuxfoundation.org/"
"elf/gabi4+/ch4.eheader.html) というヘッダから始まります。 まずはこのヘッダだ"
"けを読み込んでパースしていきましょう。"
msgstr ""
"Now that the Ymir ELF file is opened, we proceed to read it from the "
"filesystem into memory. An ELF file always begins with an [ELF Header]"
"(https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html). First, "
"let's read just this header and parse it."

#: src/bootloader/parse_kernel.md:249
msgid ""
"ファイルを読み込むための領域の確保には Boot Services が提供する [Memory "
"Allocation Services](https://uefi.org/specs/"
"UEFI/2.9_A/07_Services_Boot_Services.html#memory-allocation-services) の "
"[AllocatePool()](https://uefi.org/specs/UEFI/2.9_A/07_Services_Boot_Services."
"html#id16) 関数を利用します:"
msgstr ""
"To allocate memory for reading the file, we use the [AllocatePool()](https://"
"uefi.org/specs/UEFI/2.9_A/07_Services_Boot_Services.html#id16) function "
"provided by [Memory Allocation Services](https://uefi.org/specs/"
"UEFI/2.9_A/07_Services_Boot_Services.html#memory-allocation-services) in "
"Boot Services:"

#: src/bootloader/parse_kernel.md:262
msgid ""
"`allocatePool()`の第1引数には確保するメモリタイプ[^2]を指定します。 今回は "
"`LoaderData` という UEFI アプリのデータ用のメモリ[^3]を取得します。 ELF ヘッ"
"ダのサイズは固定であり、`std.elf.Elf64_Ehdr` 構造体のサイズと同一です。 この"
"サイズ分だけメモリを確保しています。 ただし、`header_size` は後ほど読み込みを"
"する際に実際に読み込まれた値を格納するのにも使うため、`var` として定義してい"
"ます。"
msgstr ""
"The first argument of `allocatePool()` specifies the memory type[^2] to "
"allocate. In this case, we request memory of type `LoaderData`, which is "
"intended for UEFI application data[^3].\n"
"The size of the ELF header is fixed and matches the size of the `std.elf."
"Elf64_Ehdr` structure. We allocate memory of this size.\n"
"Note that `header_size` is defined as a `var` because it will also be used "
"later to store the actual number of bytes read during the file read "
"operation."

#: src/bootloader/parse_kernel.md:268
msgid "読み込み用メモリを確保したので、実際にファイルを読み込みます:"
msgstr ""
"With the memory allocated for reading, let's proceed to actually read the "
"file:"

#: src/bootloader/parse_kernel.md:279
msgid ""
"ここまでで Ymir カーネルの ELF ヘッダを読み込むことができました。 読み込まれ"
"たファイルのサイズは `header_size` に格納されています。 実際にQEMU上で実行し"
"て正常に動作していることを確認してみてください。"
msgstr ""
"At this point, we have successfully read the ELF header of the Ymir kernel. "
"The size of the data read is stored in `header_size`. Please try running "
"this on QEMU to verify that it works correctly."

#: src/bootloader/parse_kernel.md:283
msgid "ELF ヘッダのパース"
msgstr "Parsing ELF Header"

#: src/bootloader/parse_kernel.md:285
msgid ""
"最後に、読み込んだ ELF ヘッダのパースをします。 ELF ヘッダの構造はとてもシン"
"プルなためパーサを自分で書いてもいいですが、 Zig は先程見たように ELF ヘッダ"
"を表現する構造体 `std.elf.Elf64_Ehdr` を提供してます。 今回はこれを使うことに"
"します[^4]:"
msgstr ""
"Finally, we parse the loaded ELF header. The structure of the ELF header is "
"quite simple, so you could write your own parser. However, as we saw "
"earlier, Zig provides the `std.elf.Elf64_Ehdr` struct to represent the ELF "
"header. We will use this struct here[^4]:"

#: src/bootloader/parse_kernel.md:299
msgid ""
"たったこれだけです。簡単ですね。 本当に正しくパースできているのかどうかを確認"
"するため、一部のフィールドを出力してみましょう:"
msgstr ""
"That's all it takes. Simple, isn't it? To verify that the parsing was done "
"correctly, let's output some of the fields:"

#: src/bootloader/parse_kernel.md:320
msgid "出力結果は以下のようになります:"
msgstr "The output will look like this:"

#: src/bootloader/parse_kernel.md:337
msgid ""
"これらの値が正しいかどうかは、 `zig-out/bin/ymir.elf` のヘッダを `readelf -h`"
"で見た結果と比較することで確認できます。"
msgstr ""
"You can verify the correctness of these values by comparing them with the "
"output of `readelf -h` on `zig-out/bin/ymir.elf`."

#: src/bootloader/parse_kernel.md:341
msgid ""
"本チャプターでは Ymir Kernel の雛形を作成し、生成された ELF ファイルを UEFI "
"のファイルシステムからメモリ上に読み込みました。 また、Zig が提供する機能を"
"使って Ymir の ELF ヘッダをパースしました。 このあとは ELF のプログラムヘッダ"
"をパースし、各セグメントを ELF が要求する仮想アドレスにロードしてあげる必要が"
"あります。 しかし、要求された仮想アドレスを物理アドレスにマップするにはページ"
"テーブルを設定する必要があります。 次チャプターでは、ページテーブルの操作を実"
"装していきましょう。"
msgstr ""
"In this chapter, we created a skeleton of the Ymir kernel and loaded the "
"generated ELF file from the UEFI filesystem into memory. We also parsed the "
"Ymir ELF header using Zig std library.\n"
"Next, we need to parse the ELF program headers and load each segment into "
"the virtual addresses specified by the ELF file. However, to map these "
"requested virtual addresses to physical addresses, we must set up page "
"tables.\n"
"In the next chapter, we will implement page table management."

#: src/bootloader/parse_kernel.md:347
msgid ""
"[Understanding the x64 code models - Eli Bendersky's website](https://eli."
"thegreenplace.net/2012/01/03/understanding-the-x64-code-models)"
msgstr ""
"[Understanding the x64 code models - Eli Bendersky's website](https://eli."
"thegreenplace.net/2012/01/03/understanding-the-x64-code-models)"

#: src/bootloader/parse_kernel.md:348 src/bootloader/simple_pg.md:647
msgid ""
"[Memory Type Usage before ExitBootServices() - UEFI Specification 2.9A]"
"(https://uefi.org/specs/UEFI/2.9_A/07_Services_Boot_Services.html#memory-"
"type-usage-before-exitbootservices)"
msgstr ""
"[Memory Type Usage before ExitBootServices() - UEFI Specification 2.9A]"
"(https://uefi.org/specs/UEFI/2.9_A/07_Services_Boot_Services.html#memory-"
"type-usage-before-exitbootservices)"

#: src/bootloader/parse_kernel.md:349
msgid "`LoaderData` は UEFI アプリのデフォルトのメモリタイプでもあります。"
msgstr "`LoaderData` is also the default memory type for UEFI applications."

#: src/bootloader/parse_kernel.md:350
msgid ""
"Surtr/Ymir は外部依存パッケージを一切持ちません。しかし、Zig が提供するものは"
"躊躇せず使っています。 それすらも使いたくない場合には、ぜひ自分で ELF パーサ"
"も書いてみてください。結構勉強になると思います。"
msgstr ""
"Surtr/Ymir has no external dependencies whatsoever. However, we use what Zig "
"provides without hesitation. If you prefer not to use even those, try "
"writing your own ELF parser. It can be quite educational."

#: src/bootloader/simple_pg.md:1
msgid "簡易版ページテーブル"
msgstr "Simple Page Table"

#: src/bootloader/simple_pg.md:3
msgid ""
"前チャプターでは Ymir の ELF イメージをファイルシステムからメモリ上に読み込め"
"るようになりました。 本当はそのままカーネルをロードしたいところでしたが、 そ"
"のためにはページテーブルを操作して ELF が要求する仮想アドレスをマップする必要"
"があります。 ブートローダである Surtr がページテーブルを操作する必要があるの"
"はカーネルのロード時だけであるため、 本チャプターでは必要最低限なページテーブ"
"ルの操作を実装していきます。"
msgstr ""
"In the previous chapter, we enabled loading the Ymir ELF image from the "
"filesystem into memory. Ideally, we would like to load the kernel right "
"after that, but to do so, we need to manipulate the page table to map the "
"virtual addresses requested by the ELF file.\n"
"Since the Surtr bootloader only needs to manipulate page tables to load "
"kernel image, this chapter focuses on implementing the minimal necessary "
"page table operations."

#: src/bootloader/simple_pg.md:11
msgid ""
"本チャプターの最終コードは [`whiz-surtr-simple_pg`](https://github.com/"
"smallkirby/ymir/tree/whiz-surtr-simple_pg) ブランチにあります。"
msgstr ""
"Source code for this chapter is in [`whiz-surtr-simple_pg`](https://github."
"com/smallkirby/ymir/tree/whiz-surtr-simple_pg) branch."

#: src/bootloader/simple_pg.md:15 src/kernel/serial_output.md:18
msgid "[arch ディレクトリの作成](#arch-ディレクトリの作成)"
msgstr "[arch ディレクトリの作成](#arch-ディレクトリの作成)"

#: src/bootloader/simple_pg.md:16
msgid "[ページテーブルエントリ](#ページテーブルエントリ)"
msgstr "[ページテーブルエントリ](#ページテーブルエントリ)"

#: src/bootloader/simple_pg.md:17
msgid "[4KiB ページのマップ](#4kib-ページのマップ)"
msgstr "[4KiB ページのマップ](#4kib-ページのマップ)"

#: src/bootloader/simple_pg.md:18
msgid "[Lv4 テーブルを writable にする](#lv4-テーブルを-writable-にする)"
msgstr "[Lv4 テーブルを writable にする](#lv4-テーブルを-writable-にする)"

#: src/bootloader/simple_pg.md:21 src/kernel/serial_output.md:27
msgid "arch ディレクトリの作成"
msgstr "Creating the `arch` Directory"

#: src/bootloader/simple_pg.md:23
msgid ""
"ページテーブルの構造を始めとして、ページテーブルの構造や操作は CPU アーキテク"
"チャに大きく依存します。 本シリーズでは x86-64 以外をサポートしませんが、それ"
"でもアーキテクチャ依存のコードは階層を分けて書いていくことにします。"
msgstr ""
"Page table structures and operations heavily depend on the CPU architecture. "
"In this series, we only support x86-64, but even so, architecture-specific "
"code should be organized into separate layers."

#: src/bootloader/simple_pg.md:26
msgid ""
"`arch` ディレクトリの中に `x86` ディレクトリを作成し、以下のような構造にしま"
"す:"
msgstr ""
"Create an `x86` directory inside the `arch` directory, resulting in the "
"following structure:"

#: src/bootloader/simple_pg.md:40
msgid ""
"`arch.zig`: `boot.zig`から直接利用するファイル。 できる限りアーキ依存の概念を"
"隠蔽できるような API を提供し、`arch/`以下のファイルが提供する API を直接参照"
"できないようにします。"
msgstr ""
"`arch.zig`: This file is used directly from `boot.zig`. It provides an API "
"that abstracts architecture-dependent concepts as much as possible, "
"preventing direct access to the APIs provided by files under `arch/`."

#: src/bootloader/simple_pg.md:42
msgid ""
"`arch/x86/arch.zig`: x86-64 固有の API などを export するルートファイル。"
msgstr ""
"`arch/x86/arch.zig`: The root file that exports x86-64 specific APIs and "
"related functionality."

#: src/bootloader/simple_pg.md:44
msgid ""
"`/arch.zig` では以下のようにターゲットとなるアーキテクチャに応じて `arch` 以"
"下のコードを export します:"
msgstr ""
"In `/arch.zig`, the code under `arch/` is exported according to the target "
"architecture as follows:"

#: src/bootloader/simple_pg.md:55
msgid ""
"`builtin.target.cpu.arch` は `build.zig` の `.cpu_arch` で指定したターゲット"
"アーキテクチャです。 今回は `x86_64` で固定ですが、他のアーキにも対応するよう"
"にした場合ターゲットに応じて変化します。 コンパイル時に決定する値であるため、"
"この`switch`文もコンパイル時に評価され、対応するアーキのルートファイルが "
"export されます。"
msgstr ""
"`builtin.target.cpu.arch` corresponds to the target CPU architecture "
"specified by `.cpu_arch` in `build.zig`. Although we only have `x86_64`, "
"this can vary depending on the target if we support other architectures. "
"Since this value is determined at compile time, the `switch` statement is "
"also evaluated at compile time, and the root file for the corresponding "
"architecture is exported."

#: src/bootloader/simple_pg.md:61
msgid ""
"[usingnamespace](https://ziglang.org/documentation/master/#usingnamespace) "
"は、指定した構造体のフィールド全てを現在のスコープに持ってきてくれる機能で"
"す。 今回の場合、単純に `@import(\"arch/x86/arch.zig\")` すると以下のように利"
"用側で一段余計なフィールドを指定する必要があります:"
msgstr ""
"[usingnamespace](https://ziglang.org/documentation/master/#usingnamespace) "
"is a feature that brings all the fields of a specified struct into the "
"current scope. In this case, if you simply use `@import(\"arch/x86/arch."
"zig\")`, the caller would need to specify an extra field domain as follows:"

#: src/bootloader/simple_pg.md:64
msgid ""
"```zig\n"
"// -- surtr/arch.zig --\n"
"pub const impl = @import(\"arch/x86/arch.zig\");\n"
"// -- surtr/boot.zig --\n"
"const arch = @import(\"arch.zig\");\n"
"arch.impl.someFunction();\n"
"```"
msgstr ""
"```zig\n"
"// -- surtr/arch.zig --\n"
"pub const impl = @import(\"arch/x86/arch.zig\");\n"
"// -- surtr/boot.zig --\n"
"const arch = @import(\"arch.zig\");\n"
"arch.impl.someFunction();\n"
"```"

#: src/bootloader/simple_pg.md:72
msgid ""
"`usingnamespace` を使うことで、この余計な一段階を省くことができるようになりま"
"す:"
msgstr ""
"By using `usingnamespace`, you can eliminate this extra level, making the "
"code cleaner:"

#: src/bootloader/simple_pg.md:74
msgid ""
"```zig\n"
"// -- surtr/arch.zig --\n"
"pub usingnamespace @import(\"arch/x86/arch.zig\");\n"
"// -- surtr/boot.zig --\n"
"const arch = @import(\"arch.zig\");\n"
"arch.someFunction();\n"
"```"
msgstr ""
"```zig\n"
"// -- surtr/arch.zig --\n"
"pub usingnamespace @import(\"arch/x86/arch.zig\");\n"
"// -- surtr/boot.zig --\n"
"const arch = @import(\"arch.zig\");\n"
"arch.someFunction();\n"
"```"

#: src/bootloader/simple_pg.md:82
msgid ""
"やや黒魔術的な見た目な機能ですが、`usingnamespace` を使って構造体内のフィール"
"ドを現在のファイルのトップレベルスコープに import するようなことはできないた"
"め安心してください:"
msgstr ""
"Although it might look somewhat like black magic, rest assured that "
"`usingnamespace` cannot import struct fields directly into the top-level "
"scope of the current file:"

#: src/bootloader/simple_pg.md:84
msgid ""
"```zig\n"
"usingnamespace @import(\"some.zig\"); // someFunction() が定義されているファ"
"イル\n"
"someFunction(); // このようなことはできない\n"
"```"
msgstr ""
"```zig\n"
"usingnamespace @import(\"some.zig\"); // someFunction() が定義されているファ"
"イル\n"
"someFunction(); // このようなことはできない\n"
"```"

#: src/bootloader/simple_pg.md:89
msgid ""
"`arch/x86/arch.zig` はアーキ依存のコードの内 `/arch` 以上の階層から利用したい"
"ファイルを定義します。 今回はページテーブルを実装したいため、 `arch/x86/page."
"zig` を作成したあと、 `arch/x86/arch.zig` から `page.zig` を export します。"
msgstr ""
"`arch/x86/arch.zig` defines files containing architecture-dependent code "
"that should be accessible from `/arch` or higher levels. Since we want to "
"implement page tables, we will create `arch/x86/page.zig` and then export it "
"from `arch/x86/arch.zig`."

#: src/bootloader/simple_pg.md:98
msgid ""
"これで `boot.zig` から x64 のページングに関する機能を参照できるようになりまし"
"た。"
msgstr ""
"With this setup, you can now access x64 paging-related functionality "
"directly from `boot.zig`."

#: src/bootloader/simple_pg.md:100
msgid "ページテーブルエントリ"
msgstr "Page Table Entry"

#: src/bootloader/simple_pg.md:102
msgid ""
"ここから、ページテーブルの操作をできるようにしていきます。 そもそも、UEFI か"
"ら Surtr に制御が移った時点で既に UEFI が 64bit モードに移行してくれており、 "
"初期用のページテーブルを構築してくれています。 [gef](https://github.com/"
"bata24/gef) の `vmmap` コマンドを使ってメモリマップを確認してみましょう。 "
"`build.zig` で QEMU の起動コマンドとして `-s` を指定しているため、 ポート "
"`1234` で GDB サーバにアタッチできます。 現在 Surtr は `main()` の最後に無限"
"ループをするようになっているため、その間にGDBでアタッチします:"
msgstr ""
"From here, we will enable page table manipulation. When control is "
"transferred from UEFI FW to Surtr, UEFI has already switched to 64-bit mode "
"and constructed the initial page tables. Let's check the memory map using "
"the `vmmap` command of [gef](https://github.com/bata24/gef). Since `-s` is "
"specified as the QEMU startup command in `build.zig`, you can attach to the "
"GDB server on port `1234`. Currently, Surtr enters an infinite loop at the "
"end of `main()`, so you can attach with GDB during this time:"

#: src/bootloader/simple_pg.md:157
msgid ""
"UEFI が用意してくれたページテーブルは仮想アドレスと物理アドレスをストレートに"
"マップしています。 本格的なページテーブルの設定は Ymir でやるとして、Surtr で"
"は簡易的なページング設定だけをします。 本シリーズでは、4-level paging を採用"
"します。 4-level paging における各レベルのページテーブルエントリは以下の構造"
"をしています:"
msgstr ""
"The page tables prepared by UEFI map virtual addresses directly to same "
"physical addresses. While the full-fledged page table setup will be handled "
"by Ymir, Surtr will only perform a simple paging configuration. In this "
"series, we adopt 4-level paging. The page table entries at each level of 4-"
"level paging have the following structure:"

#: src/bootloader/simple_pg.md:162 src/kernel/paging.md:112
msgid ""
"![Formats of CR3 and Paging-Structure Entries with 4-Level Paging](../assets/"
"sdm/paging-structure-entries.png) _Formats of CR3 and Paging-Structure "
"Entries with 4-Level Paging. SDM Vol.3A 4.5.5_"
msgstr ""
"![Formats of CR3 and Paging-Structure Entries with 4-Level Paging](../assets/"
"sdm/paging-structure-entries.png) _Formats of CR3 and Paging-Structure "
"Entries with 4-Level Paging. SDM Vol.3A 4.5.5_"

#: src/bootloader/simple_pg.md:165
msgid ""
"4種類のエントリがあり、Intel ではそれぞれ **PML4E**, **PDPTE**, **PDE**, "
"**PTE** と呼ばれています。 この呼び方はソフトウェアによって異なり、Linux で"
"は PGD, PUD, PMD, PTE と呼ばれています。 あまり名前が直感的でないため、本シ"
"リーズでは **Lv4**, **Lv3**, **Lv2**, **Lv1** と呼ぶことにします。"
msgstr ""
"There are four types of entries, which Intel refers to as **PML4E**, "
"**PDPTE**, **PDE**, and **PTE**. The naming varies depending on the "
"software; for example, Linux calls them PGD, PUD, PMD, and PTE. Since these "
"names can be unintuitive, in this series we will refer to them as **Lv4**, "
"**Lv3**, **Lv2**, and **Lv1** respectively."

#: src/bootloader/simple_pg.md:169
msgid ""
"まずは4つのエントリそれぞれを表す構造体を定義していきます。 上の画像から分か"
"るとおり、4つのエントリはどれも同じような構造を持っています[^1]。 そこで、以"
"下のように `EntryBase()` という、型を返す関数を定義し、それを使って4つのエン"
"トリを定義します:"
msgstr ""
"First, let's define structures representing each of the four entries. As you "
"can see from the diagram above, all four entries share a very similar "
"structure[^1]. Therefore, we define a function called `EntryBase()` that "
"returns a type, and then use it to define the four entries as follows:"

#: src/bootloader/simple_pg.md:229
msgid ""
"Zig では関数が型を返すことができ、C++ でいうところのテンプレートに近いような"
"ものを実現できます。 `EntryBase()` は `TableLevel` というエントリのレベルに相"
"当する `enum` をとり、 そのレベルに応じたテーブルエントリの構造体を返す関数で"
"す。 引数にとった値は、返される構造体において定数として利用できます。 また、"
"`packed struct(u64)` と指定することで、フィールドの合計サイズが 64bit になる"
"ことを保証しています[^2]。"
msgstr ""
"In Zig, functions can return types, enabling a feature somewhat similar to "
"templates in C++. The `EntryBase()` function takes an `enum` called "
"`TableLevel`, which corresponds to the entry's level, and returns a struct "
"representing the page table entry for that level. The passed argument can be "
"used as a constant within the returned struct. Additionally, by declaring it "
"as a `packed struct(u64)`, we ensure the total size of the fields is exactly "
"64 bits[^2]."

#: src/bootloader/simple_pg.md:235
msgid ""
"最後に、この `EntryBase()` を各 `LvXEntry` に対して呼び出すことで4つのテーブ"
"ルエントリ型を定義しています。 C++ でいうところのテンプレートのインスタンス化"
"のようなものです。 もちろんコンパイル時に決定されるため、ランタイムオーバー"
"ヘッドはありません。"
msgstr ""
"Finally, by calling `EntryBase()` for each `LvXEntry`, we define the four "
"types of page table entries. This is similar to template instantiation in C+"
"+. Since these are resolved at compile time, there is no runtime overhead."

#: src/bootloader/simple_pg.md:239
msgid ""
"この構造体に、エントリが指し示す1レベル下のページテーブルの物理アドレス、また"
"はページの物理アドレスを取得するための関数を追加します:"
msgstr ""
"We add a method to this struct to retrieve the physical address pointed to "
"by the entry, which can be either the next-level page table or the physical "
"page itself:"

#: src/bootloader/simple_pg.md:251
msgid ""
"`Phys` と `Virt` は物理アドレスと仮想アドレスを表す型です。 ページング操作を"
"する関数では物理アドレスと仮想アドレスを取り違えてしまうミスをしてしまいがち"
"[^3]なため、 それを防ぐために要求するアドレスが物理アドレスと仮想アドレスかの"
"どちらなのかを明示します[^4]。 `address()` 関数は、自身の `phys` をシフトして"
"物理アドレスに変換するだけのヘルパー関数です。 返される物理アドレスは、エント"
"リがページをマップする場合 (`.ps == true`) はマップするページの物理アドレスで"
"す。 ページテーブルを参照する場合 (`.ps == false`) は参照するページテーブルの"
"物理アドレスになります。"
msgstr ""
"`Phys` and `Virt` represent physical and virtual address types, "
"respectively. We often risk mixing up physical and virtual addresses[^3] "
"when implementing paging functions, so these types clearly indicate whether "
"an address is physical or virtual to prevent such mistakes[^4]. The "
"`address()` function is a helper that converts its internal `phys` field to "
"by shifting it to produce the physical address. The returned physical "
"address corresponds to either the physical address of the mapped page if the "
"entry maps a page (`.ps == true`), or the physical address of the referenced "
"page table if the entry points to another page table (`.ps == false`)."

#: src/bootloader/simple_pg.md:258
msgid ""
"続いて、ページテーブルエントリを作成する関数を定義します。 ページをマップする"
"エントリを作成する場合には簡単です:"
msgstr ""
"Next, define a function to create a page table entry. It is straightforward "
"when creating an entry that maps a page:"

#: src/bootloader/simple_pg.md:275
msgid ""
"ページをマップするため `.ps` を `true` に設定し、マップするページの物理アドレ"
"スを設定します。 なお、Surtr/Ymir では 512GiB ページはサポートしないため、 も"
"しも `Lv4Entry` (つまり `level == .lv4`) に対してこの関数を呼び出そうとした場"
"合にはコンパイルエラーとします。"
msgstr ""
"To map a page, set `.ps` to `true` and specify the physical address of the "
"page to be mapped. Note that Surtr/Ymir does not support 512 GiB pages, so "
"if this function is called for a `Lv4Entry` (i.e., `level == .lv4`), it will "
"result in a compile-time error."

#: src/bootloader/simple_pg.md:279
msgid ""
"同様に、ページテーブルを参照するエントリを作成する関数も定義します。 この場合"
"の引数は物理ページのアドレスではなく、自分よりも1レベルだけ低いエントリへのポ"
"インタにします。 そのためには、「自分よりも1レベル低いエントリの型」を定義し"
"てあげる必要があります。 `BaseType()`が返す構造体に以下の定数を持たせましょ"
"う:"
msgstr ""
"Similarly, we define a function to create an entry that references a page "
"table. In this case, the argument is not the physical address of a page, but "
"a pointer to an entry one level lower than itself. To do this, we need to "
"define the \"type of the entry one level below.\" Add the following constant "
"to the struct:"

#: src/bootloader/simple_pg.md:294
msgid ""
"自身が`Lv4Entry`ならば `LowerType` は `Lv3Entry` になります。 `Lv1Entry` より"
"も下のエントリは存在しないため、`Lv1Entry` の場合は空の構造体を返します。 こ"
"れを用いると、ページテーブルを参照するエントリを作成する関数は以下のようにな"
"ります:"
msgstr ""
"If the entry is `Lv4Entry`, then `LowerType` is `Lv3Entry`. Since there is "
"no entry below `Lv1Entry`, in that case `LowerType` returns an empty struct. "
"Using this, the function to create an entry that references a page table "
"looks like this:"

#: src/bootloader/simple_pg.md:312
msgid ""
"`table` はこのエントリが指すページテーブルへのポインタです。 先ほどとは対象的"
"に、自身が `Lv1Entry` である場合にはコンパイルエラーとします。"
msgstr ""
"`table` is a pointer to the page table that this entry points to. In "
"contrast to the previous case, if the entry itself is an `Lv1Entry`, this "
"will result in a compile-time error."

#: src/bootloader/simple_pg.md:315
msgid "4KiB ページのマップ"
msgstr "Mapping a 4KiB page"

#: src/bootloader/simple_pg.md:317
msgid ""
"テーブルエントリの定義ができたので、実際にページをマップする関数を実装しま"
"す。 Surtr では、4KiB ページのみをサポートすることにします。"
msgstr ""
"With the table entries defined, let's implement the function to actually map "
"pages. Surtr will support only 4KiB pages."

#: src/bootloader/simple_pg.md:320
msgid ""
"ページウォークは以下の図[^5]のように CR3 に入っている Lv4 テーブルから始まり"
"ます。 仮想アドレスの `[47:39]` ビット目が Lv4 テーブルにおけるインデックスで"
"す。 このインデックスから Lv4 エントリを取得すると、その中に Lv3 テーブルへの"
"ポインタが入っています。 これを繰り返すことで、4KiB ページをマップする Lv1 エ"
"ントリにたどり着きます。"
msgstr ""
"Page walking starts from the Lv4 table stored in the CR3 register, as shown "
"in the diagram[^5]. The bits `[47:39]` of the virtual address serve as the "
"index into the Lv4 table. By using this index, you obtain the Lv4 entry, "
"which contains a pointer to the Lv3 table. Repeating this process leads you "
"down to the Lv1 entry, which maps the 4KiB page."

#: src/bootloader/simple_pg.md:325
msgid ""
"![Linear-Address Translation to a 4-KByte Page Using 4-Level Paging](../"
"assets/sdm/address-translation-4level.png) _Linear-Address Translation to a "
"4-KByte Page Using 4-Level Paging. SDM Vol.3A 4.5.4_"
msgstr ""
"![Linear-Address Translation to a 4-KByte Page Using 4-Level Paging](../"
"assets/sdm/address-translation-4level.png) _Linear-Address Translation to a "
"4-KByte Page Using 4-Level Paging. SDM Vol.3A 4.5.4_"

#: src/bootloader/simple_pg.md:328
msgid "まずは各レベルのページテーブルを取得する関数です:"
msgstr ""
"First, here are the functions to retrieve the page tables at each level:"

#: src/bootloader/simple_pg.md:353
msgid ""
"`getTable()` が内部実装であり、取得したいページテーブルエントリの型と物理アド"
"レスを受け取ります。 ページテーブルは必ず 4KiB アラインメントされているため、"
"下位12ビットをマスクしてページテーブルの先頭アドレスを取得します。 そうして計"
"算したアドレスから 512 個のエントリを持つスライスとしてテーブルを返します。 "
"残りの4つの関数は、それぞれのレベルのページテーブルを取得するためのヘルパー関"
"数です。"
msgstr ""
"`getTable()` is the internal implementation that takes the type of the page "
"table entry you want to retrieve and the physical address. Since page tables "
"are always 4KiB-aligned, it masks out the lower 12 bits to get the base "
"address of the page table. Then, it returns the table as a slice containing "
"512 entries starting from that address. \n"
"The other four functions are helper functions to get the page tables of each "
"respective level."

#: src/bootloader/simple_pg.md:358
msgid ""
"続いて、指定された仮想アドレスに対応するページテーブルエントリを取得する関数"
"を実装します。 この関数は仮想アドレスとページテーブルの物理アドレスを受取りま"
"す:"
msgstr ""
"Next, we implement a function to get the page table entry corresponding to a "
"given virtual address. This function takes the virtual address and the "
"physical address of the page table as inputs:"

#: src/bootloader/simple_pg.md:389
msgid ""
"`getEntry()` が内部実装で、最初に先程の `getTable()` を呼んでページテーブルを"
"スライスとして取得します。 その後、先程の図に従って仮想アドレスからエントリの"
"インデックスを計算し、テーブルから該当するエントリを取得して返します。 "
"`getTable()` と同様に、残りの4つの関数は引数 `T` を具体化したヘルパー関数に"
"なっています。"
msgstr ""
"The internal implementation, `getEntry()`, first calls the previously "
"defined `getTable()` to obtain the page table as a slice. Then, following "
"the earlier diagram, it calculates the index of the entry from the virtual "
"address and retrieves the corresponding entry from the table.\n"
"Similar to `getTable()`, the remaining four functions are helper functions "
"that instantiate the generic parameter `T` with specific types."

#: src/bootloader/simple_pg.md:393
msgid ""
"これで、仮想アドレスからページテーブルエントリを取得する準備がほぼ整いまし"
"た。 ヘルパー関数として CR3 レジスタを取得する取得するラッパーを `asm.zig` に"
"追加します:"
msgstr ""
"With this, we are almost ready to retrieve page table entries from virtual "
"addresses. As a helper function, add a wrapper to read the CR3 register in "
"`asm.zig`:"

#: src/bootloader/simple_pg.md:408
msgid "最後に、4KiB ページをマップする関数を次に示します。"
msgstr "Finally, the function to map a 4KiB page is shown below:"

#: src/bootloader/simple_pg.md:450 src/kernel/page_allocator.md:336
msgid "Argument"
msgstr "Argument"

#: src/bootloader/simple_pg.md:450 src/kernel/serial_output.md:224
#: src/kernel/gdt.md:234 src/kernel/interrupt.md:40
#: src/kernel/page_allocator.md:336 src/kernel/paging.md:29
#: src/vmm/vmx_root.md:469 src/vmm/vmcs.md:33 src/vmm/linux_boot.md:500
#: src/vmm/io.md:207 src/vmm/io.md:423 src/vmm/io.md:600
msgid "Description"
msgstr "Description"

#: src/bootloader/simple_pg.md:452
msgid "`virt`"
msgstr "`virt`"

#: src/bootloader/simple_pg.md:452
msgid "マップする仮想アドレス。"
msgstr "Virtual address"

#: src/bootloader/simple_pg.md:453
msgid "`phys`"
msgstr "`phys`"

#: src/bootloader/simple_pg.md:453
msgid "マップする物理アドレス。"
msgstr "Physical address"

#: src/bootloader/simple_pg.md:454
msgid "`attr`"
msgstr "`attr`"

#: src/bootloader/simple_pg.md:454
msgid "マップするページの属性。"
msgstr "Attribute of the mapped page"

#: src/bootloader/simple_pg.md:455
msgid "`bs`"
msgstr "`bs`"

#: src/bootloader/simple_pg.md:455
msgid ""
"UEFI Boot Services。新たに作成するページテーブル用のメモリ確保のために使いま"
"す。"
msgstr ""
"UEFI Boot Services. This is used to allocate memory for page table data."

#: src/bootloader/simple_pg.md:457
msgid ""
"先程の図で見たように、CR3 からスタートして Lv1 エントリまでページウォークをし"
"ます。 その過程でページテーブルが存在しない、つまり `lvNent.present == "
"false` である場合には `allocateNewTable()` で新しいページテーブルを作成しま"
"す。 なお、この関数では対象の<u>仮想アドレスが既にマップされている場合は想定"
"していません</u>。 言い換えると、この関数は必ず新しいマッピングを作成すること"
"しか想定していません。 よって、既に既存のマッピングが存在する場合には以下のよ"
"うな挙動をします:"
msgstr ""
"As seen in the previous figure, it starts from CR3 and pagewalks to the Lv1 "
"entry. If the page table does not exists, that is, `lvNent.present == "
"false`, a new page table is created with `allocateNewTable()`. Note that "
"this function does not assume the target <u>virtual address</u> is already "
"mapped. In other words, this function only assumes that a new mapping will "
"always be created. Thus, if there is already an existing mapping, it behaves "
"as follows:"

#: src/bootloader/simple_pg.md:463
msgid ""
"仮想アドレスが既に 4KiB ページにマップされている場合: `AlreadyMapped` エラー"
"を返す。"
msgstr ""
"If the virtual address is already mapped to a 4KiB page: return "
"`AlreadyMapped` error."

#: src/bootloader/simple_pg.md:464
msgid ""
"仮想アドレスが既に 2MiB 以上のページにマップされている場合: 既存のマップを上"
"書きする。"
msgstr ""
"If a virtual address is already mapped to a page of 2MiB or more: overwrite "
"the existing map."

#: src/bootloader/simple_pg.md:466
msgid ""
"Lv1 にまでたどり着いたら、事前に定義した `newMapPage()` を使って指定された物"
"理ページにマップします。 その際、ページの属性に応じて `rw` フラグを設定しま"
"す。 `rw == true` の場合は read/write になり、それ以外の場合は read-only にな"
"ります。"
msgstr ""
"Once it reaches Lv1, it maps the page to the specified physical address "
"using `newMapPage()`. When it does so, it sets the `rw` flag according to "
"the attributes of the page. If `rw == true`, it will be read/write, "
"otherwise it will be read-only."

#: src/bootloader/simple_pg.md:470
msgid ""
"なお、この関数は新たなマッピングを作成することしか想定していないため、最後に "
"TLB をフラッシュする必要がありません。 仮に既存のマップを変更するような場合に"
"は、CR3 をリロードするか `invlpg` 等の命令を使って TLB をフラッシュする必要が"
"あります。"
msgstr ""
"Note that this function does not need to flush the TLB at the end, since it "
"is only intended to create a new mapping. If you want to modify an existing "
"map, you need to reload CR3 or flush TLB using `invlpg` or other "
"instructions."

#: src/bootloader/simple_pg.md:473
msgid ""
"新たにページテーブルを確保する関数 `allocateNewTable()` は以下のように実装さ"
"れています:"
msgstr ""
"`allocateNewTable()`, which allocates a new page table, is implemented as "
"follows:"

#: src/bootloader/simple_pg.md:495
msgid ""
"Boot Services の [AllocatePages()](https://uefi.org/specs/"
"UEFI/2.9_A/07_Services_Boot_Services.html#efi-boot-services-allocatepages) を"
"使って1ページだけ確保します。 この際、メモリタイプは `BootServicesData`[^6] "
"を指定します。 このページテーブルは Ymir が新たにマッピングを作成するまでは、"
"Surtr から Ymir に処理が移っても使われ続けます。 つまり、この領域は Ymir が解"
"放して自由に使って良い領域ではありません。 [のちのチャプター](../kernel/"
"page_allocator.md) で説明しますが、メモリタイプを `BootServicesData` にするこ"
"とで Ymir は自身の新しいページテーブルを作成するまではこの領域を利用不可能で"
"あるということを Ymir に伝えています。"
msgstr ""
"We use Boot Services' [AllocatePages()](https://uefi.org/specs/"
"UEFI/2.9_A/07_Services_Boot_Services.html#efi-boot-services-allocatepages) "
"to allocate only one page. In this case, specify `BootServicesData`[^6] as "
"the memory type. This page table will continue to be used even after the "
"execution is transferred from Surtr to Ymir, until she creates a new "
"mapping. In other words, this is not an area that Ymir can free and use as "
"she likes. As described in [the later chapter](../kernel/page_allocator.md), "
"by setting the memory type to `BootServicesData`, Surtur is telling Ymir "
"that this area is unavailable until she creates its own new page table."

#: src/bootloader/simple_pg.md:502
msgid ""
"確保したページは `clearPage()` でゼロクリアしています。 最後に、エントリに新"
"たに作成したページテーブルの物理アドレスをセットしています。"
msgstr ""
"The allocated page is zero-cleared with `clearPage()`. Finally, the physical "
"address of the newly created page table is set to the entry."

#: src/bootloader/simple_pg.md:505
msgid "Lv4 テーブルを writable にする"
msgstr "Making Lv4 Table Writable"

#: src/bootloader/simple_pg.md:507
msgid ""
"以上で 4KiB のページをマップできるようになりました。 実際に適当な仮想アドレス"
"をマップできることを確認してみましょう。 `boot.zig` で以下のように適当なアド"
"レスをマップします:"
msgstr ""
"We can now map a 4KiB page. Let's check that we can actually map an "
"appropriate virtual address. In `boot.zig`, map an appropriate address as "
"follows:"

#: src/bootloader/simple_pg.md:526
msgid "実行すると以下のようになります:"
msgstr "The result looks like:"

#: src/bootloader/simple_pg.md:549
msgid ""
"ページフォルトが発生してしまいました[^7]。 ページフォルトが発生したアドレス"
"は **CR2** に入っており、今回は `0x1FC01FF8` です。 このアドレスは、CR3 が指"
"すページ、すなわち Lv4 テーブルが入っているページと一致しています。 オフセッ"
"トの `0xFF8` は指定した仮想アドレス `0xFFFF_FFFF_DEAD_0000` に対応するテーブ"
"ル内のエントリのオフセットです。 [gef](https://github.com/bata24/gef) の "
"`vmmap` コマンドで Lv4 テーブルの様子を見てみます:"
msgstr ""
"A page fault has occurred [^7]. The address where the page fault occurred is "
"contained in **CR2**, this time `0x1FC01FF8`. This address matches the page "
"pointed to by CR3, i.e., the page containing the Lv4 table. The offset "
"`0xFF8` is the offset of the entry in the table corresponding to the "
"specified virtual address `0xFFFFFF_FFFFFF_DEAD_0000`. Let's take a look at "
"the Lv4 table with the `vmmap` command of [gef](https://github.com/bata24/"
"gef):"

#: src/bootloader/simple_pg.md:563
msgid ""
"`Flags` から分かるとおり、どうやら **UEFI が提供する Lv4 テーブルは read-"
"only になっている** ようです。 このままでは Lv4 テーブル内のエントリを書き換"
"えることができないため、 Lv4 テーブルを書き込み可能にする必要があります。"
msgstr ""
"As you can see from the `Flags`, it seems that **UEFI-provided Lv4 tables "
"are read-only**. Since it is not possible to rewrite entries in the Lv4 "
"table, we need to make the Lv4 table writable."

#: src/bootloader/simple_pg.md:567
msgid ""
"Lv4 テーブルが存在するページの属性を変更するためには、ページテーブルエントリ"
"を修正する必要があります。 しかし、そのエントリ自体が現在は read-only になっ"
"ているため、変更を加えることができません。 鶏が先か卵が先かみたいな問題になっ"
"てしまいました。デッドロックです。 Lv4 テーブル自体を書き込み可能にするために"
"は、Lv4 テーブル自体をコピーするしかありません。 以下のような関数を定義し、"
"Lv4 テーブルを書き込み可能にします:"
msgstr ""
"In order to change the attributes of the page on which the Lv4 table "
"resides, the page table entry must be modified. However, that entry itself "
"is now read-only and cannot be modified. It has become a chicken first or "
"egg first kind of problem. It is a deadlock. The only way to make the Lv4 "
"table writable is to copy the Lv4 table itself. Define a function like the "
"following to make the Lv4 table writable:"

#: src/bootloader/simple_pg.md:588
msgid "また、ヘルパー関数 `loadCr3()` を追加します:"
msgstr "Also, add a helper function `loadCr3()`:"

#: src/bootloader/simple_pg.md:601
msgid ""
"`setLv4Writable()` は Boot Services を利用して新たにページテーブルを確保し、"
"現在の Lv4 テーブルを全てコピーします。 最後に `loadCr3()` で CR3 を新しく確"
"保した Lv4 テーブルの物理アドレスにセットします。 CR3 のリロードは全ての TLB "
"をフラッシュするため、以降は新しい Lv4 テーブルが使われるようになります。 新"
"しく作成したページテーブルには read-only の設定がされていないため、これで "
"Lv4 テーブルが書き込み可能になります。"
msgstr ""
"`setLv4Writable()` allocates a new page table using Boot Services and copies "
"all entries in the Lv4 table. Finally, `loadCr3()` sets CR3 to the physical "
"address of the newly allocated Lv4 table. Since reloading CR3 flushes all "
"TLBs, the new Lv4 table will be used from now on. The newly created page "
"table is not set to read-only. The Lv4 table is now writable."

#: src/bootloader/simple_pg.md:606
msgid ""
"`boot.zig` で 4KiB ページをマップする前に Lv4 テーブルを書き込み可能にしてみ"
"ましょう:"
msgstr ""
"Let's make the Lv4 table writable before we map 4KiB page in `boot.zig`:"

#: src/bootloader/simple_pg.md:617
msgid ""
"実行すると今度はページフォルトが起きずに正常に hlt ループまで実行されるはずで"
"す。 この時点でのページテーブルを見ると以下のようになっています:"
msgstr ""
"The hlt loop should now performed normally without a page fault. The page "
"table at this point looks like this:"

#: src/bootloader/simple_pg.md:628
msgid ""
"ちゃんと指定した仮想アドレス `0xFFFFFFFFDEAD0000` が 物理アドレス `0x100000` "
"にマップされていることがわかります。"
msgstr ""
"You can see that the specified virtual address `0xFFFFFFFFFFDEAD0000` is "
"mapped to the physical address `0x100000`."

#: src/bootloader/simple_pg.md:632
msgid ""
"本チャプターでは、4-level paging におけるページテーブルエントリの構造体を定義"
"し、4KiB ページをマップする関数を実装しました。 実際に 4KiB ページをマップす"
"る際には、Lv4 テーブルが read-only になっているためページフォルトが発生してし"
"まいます。 そのため、Lv4 テーブルを書き込み可能にするための関数を実装しまし"
"た。"
msgstr ""
"In this chapter, we defined a structure for page table entries in 4-level "
"paging and implemented a function to map 4KiB pages. When actually mapping "
"4KiB pages, a page fault occured because the Lv4 table was read-only. "
"Therefore, we implemented a function to make the Lv4 table writable."

#: src/bootloader/simple_pg.md:636
msgid ""
"これで Ymir カーネルを要求されたアドレスにマップするための準備が整いました。 "
"次チャプターでは、Ymir Kernel を実際にロードする処理を実装していきましょう。"
msgstr ""
"We are now ready to load the Ymir kernel to the requested virtual address. "
"In the next chapter, we will implement functions to actually load the Ymir "
"Kernel."

#: src/bootloader/simple_pg.md:639
msgid ""
"厳密には各エントリのフィールドには異なるものもありますが、本シリーズでは問題"
"がなく簡単のために同じ構造体を使うことにします。"
msgstr ""
"Strictly speaking, some of the fields in each entry are different, but for "
"this series we will use the same structure for simplicity."

#: src/bootloader/simple_pg.md:640
msgid ""
"このような構造体を _integer-backed packed struct_ と呼びます。 フィールドの合"
"計サイズが指定したサイズと異なる場合にはコンパイルエラーになります。"
msgstr ""
"Such a structure is called an _integer-backed packed struct_. If the total "
"size of the fields is different from the specified size, a compile error "
"will happen."

#: src/bootloader/simple_pg.md:642
msgid ""
"UEFI が用意するページテーブルでは仮想アドレスと物理アドレスが同じになるように"
"設定されているため、この2つを混同しても動いてしまいます。"
msgstr ""
"The page table provided by UEFI is set up so that virtual and physical "
"addresses are the same. So confusing the two will still work."

#: src/bootloader/simple_pg.md:643
msgid ""
"結局の所どちらも `u64` であり、Zig では `Phys` を要求する場所で `u64` を渡し"
"てもエラーになってくれません。 `Phys` を要求する場所で `Virt` を渡しても同様"
"にエラーになりません。 あくまでもコードを見る際のアノテーション的な意味合いで"
"使っています。"
msgstr ""
"After all, both are `u64` in Zig, and passing `u64` where `Phys` is required "
"will not cause an error. Passing `Virt` in a place that requires `Phys` will "
"not give you an error as well. It is used only as an annotation to read the "
"code."

#: src/bootloader/simple_pg.md:646
msgid ""
"x64 では segmentation はほとんど使われないため、図中の _Linear-Address_ は仮"
"想アドレスとほぼ同義です。"
msgstr ""
"Since segmentation is rarely used in x64, _Linear-Address_ in the figure is "
"almost synonymous with virtual address."

#: src/bootloader/simple_pg.md:648
msgid "この例外ハンドラは UEFI が用意してくれたものです。"
msgstr "This exception handler is provided by UEFI."

#: src/bootloader/load_kernel.md:3
msgid ""
"前チャプターでは 4KiB ページのマップができるようになりました。 ページ操作をで"
"きるようにしたもともとの理由は、Ymir Kernel をロードする際に Ymir が要求する"
"レイアウトに合わせて仮想アドレスをマップするためです。 本チャプターでは Ymir "
"Kernel のELF ファイルをパースし、要求する仮想アドレスにカーネルをロードしてい"
"きます。"
msgstr ""
"In the previous chapter, we implemented support for mapping 4KiB pages. The "
"original motivation for enabling page operations was to map virtual "
"addresses according to the layout required by the Ymir Kernel during its "
"loading process. In this chapter, we'll parse the Ymir Kernel's ELF file and "
"load it into memory at the virtual addresses it expects."

#: src/bootloader/load_kernel.md:9
msgid ""
"本チャプターの最終コードは [`whiz-surtr-load_kernel`](https://github.com/"
"smallkirby/ymir/tree/whiz-surtr-load_kernel) ブランチにあります。"
msgstr ""
"Source code for this chapter is in [`whiz-surtr-parse_kernel`](https://"
"github.com/smallkirby/ymir/tree/whiz-surtr-load_kernel) branch."

#: src/bootloader/load_kernel.md:13
msgid "[Ymir のリンカスクリプト](#ymir-のリンカスクリプト)"
msgstr "[Ymir のリンカスクリプト](#ymir-のリンカスクリプト)"

#: src/bootloader/load_kernel.md:14
msgid "[カーネル用のメモリの確保](#カーネル用のメモリの確保)"
msgstr "[カーネル用のメモリの確保](#カーネル用のメモリの確保)"

#: src/bootloader/load_kernel.md:15
msgid "[仮想アドレスのマップ](#仮想アドレスのマップ)"
msgstr "[仮想アドレスのマップ](#仮想アドレスのマップ)"

#: src/bootloader/load_kernel.md:16
msgid "[カーネルの読み込みとロード](#カーネルの読み込みとロード)"
msgstr "[カーネルの読み込みとロード](#カーネルの読み込みとロード)"

#: src/bootloader/load_kernel.md:17
msgid "[セグメントの読み込み](#セグメントの読み込み)"
msgstr "[セグメントの読み込み](#セグメントの読み込み)"

#: src/bootloader/load_kernel.md:18
msgid "[BSS セグメントの初期化](#bss-セグメントの初期化)"
msgstr "[BSS セグメントの初期化](#bss-セグメントの初期化)"

#: src/bootloader/load_kernel.md:21
msgid "Ymir のリンカスクリプト"
msgstr "Linker Script of Ymir"

#: src/bootloader/load_kernel.md:23
msgid ""
"まず最初に Ymir の仮想アドレスレイアウトを決めます。 アドレスレイアウトをどの"
"ようにするかには特に決まりがありません。 例えば、Linux ではユーザランドとカー"
"ネルごとに利用する仮想アドレス空間を分けています。 カーネルの中でも、ある部分"
"は `.text` がマップ、ある部分は物理アドレスに direct map されていたりします"
"[^1]。"
msgstr ""
"First, we'll define the virtual address layout for Ymir. There's no strict "
"rule for how to organize the address layout. For example, Linux separates "
"the virtual address space used by userland and the kernel. Even within the "
"kernel, certain regions are mapped for `.text`, while others are direct-"
"mapped to physical addresses[^1]."

#: src/bootloader/load_kernel.md:28
msgid ""
"また、[BitVisor](https://www.bitvisor.org/) は以下のような仮想アドレスのレイ"
"アウトになっているようです[^2]:"
msgstr ""
"BitVisor, on the other hand, appears to use the following virtual address "
"layout[^2]:"

#: src/bootloader/load_kernel.md:30 src/bootloader/load_kernel.md:40
msgid "仮想アドレス"
msgstr "Virtual Address"

#: src/bootloader/load_kernel.md:32
msgid "`0x0000000000` - `0x003FFFFFFF`"
msgstr "`0x0000000000` - `0x003FFFFFFF`"

#: src/bootloader/load_kernel.md:32
msgid "プロセス"
msgstr "Userland Process"

#: src/bootloader/load_kernel.md:33
msgid "`0x0040000000` - `0x007FFFFFFF`"
msgstr "`0x0040000000` - `0x007FFFFFFF`"

#: src/bootloader/load_kernel.md:33
msgid "カーネル"
msgstr "Kernel"

#: src/bootloader/load_kernel.md:34
msgid "`0x00F0000000` - `0x00FEFFFFFF`"
msgstr "`0x00F0000000` - `0x00FEFFFFFF`"

#: src/bootloader/load_kernel.md:34
msgid "物理アドレスの動的割当て"
msgstr "Dynamically allocated physical memory"

#: src/bootloader/load_kernel.md:35
msgid "`0x8000000000` - `0x8FFFFFFFFF`"
msgstr "`0x8000000000` - `0x8FFFFFFFFF`"

#: src/bootloader/load_kernel.md:35
msgid "物理アドレスの静的割当て"
msgstr "Statically allocated physical memory"

#: src/bootloader/load_kernel.md:37
msgid ""
"Ymir では特に理由はなく Linux のレイアウトに近いものを採用します。 Ymir の仮"
"想アドレスレイアウトは以下のようになります:"
msgstr ""
"Ymir adopts a layout similar to Linux’s, though there's no particular reason "
"for this choice. The virtual address layout for Ymir is as follows:"

#: src/bootloader/load_kernel.md:42
msgid "`0xFFFF888000000000` - `0xFFFF88FFFFFFFFFF`"
msgstr "`0xFFFF888000000000` - `0xFFFF88FFFFFFFFFF`"

#: src/bootloader/load_kernel.md:42
msgid "Direct Map. 物理アドレスの `0` にマップされる。ヒープもここ。"
msgstr ""
"Direct Map. This region is mapped to physical address 0. Heap also locates "
"here."

#: src/bootloader/load_kernel.md:43 src/kernel/paging.md:32
msgid "`0xFFFFFFFF80000000` -"
msgstr "`0xFFFFFFFF80000000` -"

#: src/bootloader/load_kernel.md:43
msgid "Kernel Base."
msgstr "Kernel Base."

#: src/bootloader/load_kernel.md:44 src/kernel/paging.md:33
msgid "`0xFFFFFFFF80100000` -"
msgstr "`0xFFFFFFFF80100000` -"

#: src/bootloader/load_kernel.md:44
msgid "Kernel Text."
msgstr "Kernel Text."

#: src/bootloader/load_kernel.md:46
msgid "これらのレイアウトを実現するため、以下のリンカスクリプトを用意します:"
msgstr "To achieve this layout, let's prepare the below linker script:"

#: src/bootloader/load_kernel.md:78
msgid ""
"このリンカスクリプトによって、全てのセクションは仮想アドレスの "
"`0xFFFFFFFF80100000` 以降に配置されるようになります。 また、それらのセクショ"
"ンは仮想アドレスから `0xFFFFFFFF80000000` を引いた物理アドレスにマップされま"
"す。"
msgstr ""
"With this linker script, all sections are placed starting from the virtual "
"address `0xFFFFFFFF80100000`. Additionally, each section is mapped to a "
"physical address by subtracting `0xFFFFFFFF80000000` from its virtual "
"address."

#: src/bootloader/load_kernel.md:81 src/bootloader/load_kernel.md:305
#: src/bootloader/jump_to_ymir.md:311 src/kernel/gdt.md:81
#: src/kernel/gdt.md:116 src/kernel/gdt.md:414 src/kernel/interrupt.md:261
#: src/kernel/interrupt.md:338 src/kernel/interrupt.md:442
#: src/kernel/page_allocator.md:111 src/kernel/page_allocator.md:352
#: src/kernel/paging.md:150 src/kernel/panic.md:7 src/vmm/vmcall.md:31
msgid "\\[!NOTE\\]"
msgstr ""

#: src/bootloader/load_kernel.md:83
msgid ""
"Ymir のリンカスクリプトとセグメント構成について、詳しくは [カーネルの起動]"
"(jump_to_ymir.md) のセクションで説明します。"
msgstr ""
"For more details on Ymir's linker script and segment layout, see the "
"[Booting Kernel](jump_to_ymir.md) chapter."

#: src/bootloader/load_kernel.md:85
msgid ""
"リンカスクリプトをビルドに含めるには、`build.zig` で以下のように指定します:"
msgstr ""
"To include the linker script in the build, write `build.zig` as follows:"

#: src/bootloader/load_kernel.md:92
msgid "ビルドをして生成された ELF ファイルのセグメントを確認してみましょう:"
msgstr "Let's see the segments of generated ELF file:"

#: src/bootloader/load_kernel.md:116
msgid ""
"まだ Ymir カーネル自体がほとんど何もしない関数であるため、`.text`セクションで"
"すら 3byte しかありません。 しかし、エントリポイントが `0xFFFFFFFF80100000` "
"であることや、そのセグメントが物理アドレスの `0x100000` にマップされているこ"
"とがわかります。 意図したとおりに配置されているようですね。"
msgstr ""
"Since the Ymir kernel currently does almost nothing, even the `.text` "
"section is only 3 bytes long. However, we can confirm that the entry point "
"is at `0xFFFFFFFF80100000`, and that the segment is mapped to the physical "
"address `0x100000`. It seems everything is placed as intended."

#: src/bootloader/load_kernel.md:122
msgid ""
"Ymir では Linux に近いレイアウトを採用しました。 特に理由はないですが、Linux "
"をある程度触ったことがある人にとってはなんとなく直感的であるような気がしたか"
"らです。 しかし、**Linux に近いレイアウトを採用することは寧ろ良くない選択** "
"かもしれません。"
msgstr ""
"Ymir adopts a layout similar to Linux. There’s no particular reason for this "
"choice - it just felt more intuitive for those who have some experience with "
"Linux. However, **adopting a layout similar to Linux might actually be a "
"poor choice**."

#: src/bootloader/load_kernel.md:126
msgid ""
"というのも、Linux に近いレイアウトを採用した場合、「あるアドレスが Ymir のア"
"ドレスなのかゲスト Linux のアドレスなのか」が分かりにくくなります。 "
"`0xFFFFFFFF80100000` というアドレスに breakpoint を設定した場合、Ymir が実行"
"した場合もゲストが実行した場合もどちらもヒットしてしまいます。 Breakpoint に"
"ヒットしたあとで、それが Ymir かゲストかを判断するのは少し面倒です。 そうであ"
"るならば、最初から Linux と絶対に被らないような領域を使う方が、デバッグする上"
"では好ましいのかもしれません。"
msgstr ""
"That's because if we adopt a layout similar to Linux, it becomes difficult "
"to tell whether a given address belongs to Ymir or to the guest Linux. For "
"example, if you set a breakpoint at the address `0xFFFFFFFF80100000`, it "
"will be hit regardless of whether Ymir or the guest is running. After "
"hitting the breakpoint, figuring out which was actually running can be a bit "
"of a hassle. \n"
"Given that, it might actually be better to use a memory region that is "
"guaranteed not to overlap with Linux from the start for debugging purposes ."

#: src/bootloader/load_kernel.md:131
msgid "カーネル用のメモリの確保"
msgstr "Allocating Memory for Kernel"

#: src/bootloader/load_kernel.md:133
msgid ""
"Ymir カーネルのレイアウトが決まったので、今度はカーネルをメモリにロードする準"
"備をします。 具体的には、カーネルをロードするメモリとして必要なサイズを計算"
"し、その分だけメモリを確保します。"
msgstr ""
"Now that the layout of the Ymir kernel has been decided, the next step is to "
"prepare for loading the kernel into memory. Specifically, we need to "
"calculate how much memory is required to load the kernel and allocate that "
"amount of memory accordingly."

#: src/bootloader/load_kernel.md:136
msgid ""
"カーネルのサイズは ELF ファイルをパースして得られるカーネルのメモリマップから"
"計算します。 まずは ELF の **セグメントヘッダ (プログラムヘッダ)** のイテレー"
"タを作成します。 Zig の標準ライブラリにはセグメントヘッダのイテレータが既に実"
"装されているため、それを使います:"
msgstr ""
"The kernel size is calculated from the kernel's memory map obtained by "
"parsing the ELF file. First, we create an iterator for the ELF **segment "
"headers (program headers)**. Since Zig's standard library already provides "
"an iterator for segment headers, we will use that:"

#: src/bootloader/load_kernel.md:150
msgid ""
"カーネルを配置する物理アドレスの最小と最大のを記録する変数、及び仮想アドレス"
"の最小を記録する変数を用意します。 セグメントヘッダのイテレータは、`std.elf."
"Header.program_header_iterator()` で作成できます。 このイテレータを使ってセグ"
"メントヘッダを辿り、カーネルが要求する最小・最大アドレスを計算します:"
msgstr ""
"Prepare variables to record the minimum and maximum physical addresses where "
"the kernel will be placed, as well as the minimum virtual address. The "
"segment header iterator can be created using `std.elf.Header."
"program_header_iterator()`. Using this iterator, iterate through the segment "
"headers and calculate the minimum and maximum addresses required by the "
"kernel:"

#: src/bootloader/load_kernel.md:168
msgid ""
"セグメントのタイプが `PT_LOAD`[^3] であるセグメントが現在分かっている最小・最"
"大のセグメントのアドレスを更新する場合には、そのアドレスを記録します。"
msgstr ""
"When the segment type is `PT_LOAD`[^3], update the currently known minimum "
"and maximum segment addresses accordingly."

#: src/bootloader/load_kernel.md:170
msgid "続いて、必要なメモリサイズを計算します:"
msgstr "Then we calculate the memory size required:"

#: src/bootloader/load_kernel.md:178
msgid ""
"セグメントの最小アドレスと最大アドレスの差分から、必要な 4KiB ページの数を計"
"算します。 `(A - B + (C - 1)) / C` は `(A + B) / C` の余りが 0 でない場合に切"
"り上げて1を足す式です。"
msgstr ""
"Calculate the number of required 4KiB pages from the difference between the "
"minimum and maximum segment addresses. The expression `(A - B + (C - 1)) / "
"C` rounds up `(A - B) / C` when the remainder is not zero."

#: src/bootloader/load_kernel.md:181 src/vmm/vmlaunch.md:1090
msgid "実行すると以下の出力になります:"
msgstr "You'll see the below output:"

#: src/bootloader/load_kernel.md:194
msgid ""
"現在 Ymir のセグメントサイズは `kernelEntry()` の 3byte のみであるため、一見"
"すると変な出力になっていますね。 しかし、`readelf` でセグメントヘッダを読んだ"
"時の結果と一致しており、 必要なページサイズが 1 ページであることも正しく計算"
"できているようです。"
msgstr ""
"Currently, Ymir's segment size is only 3 bytes (for `kernelEntry()`), so the "
"output might look odd at first glance. However, it matches the results "
"obtained by reading the segment headers with `readelf`, confirming that the "
"required page size is correctly calculated as one page."

#: src/bootloader/load_kernel.md:198
msgid "最後に、計算したページ分だけメモリを確保してあげます。"
msgstr "Finally, allocate memory for the number of pages calculated."

#: src/bootloader/load_kernel.md:210
msgid ""
"前チャプターと同様に、 Boot Services の [AllocatePages()](https://uefi.org/"
"specs/UEFI/2.9_A/07_Services_Boot_Services.html#efi-boot-services-"
"allocatepages) を使ってページを確保します。 ただし、ここでは **第1引数の "
"`alloca_type` として `.AllocateAddress` を指定することで、第4引数で指定したア"
"ドレス丁度にメモリを確保** させます。 このアドレスは先ほど計算したセグメント"
"の開始アドレスです。 もしも指定された物理アドレスからメモリを確保できなかった"
"場合にはエラーを返すことにします。"
msgstr ""
"As in the previous chapter, we use Boot Services' [AllocatePages()](https://"
"uefi.org/specs/UEFI/2.9_A/07_Services_Boot_Services.html#efi-boot-services-"
"allocatepages) to allocate pages. However, here we specify `."
"AllocateAddress` for the first argument `alloc_type` to **allocate memory "
"exactly at the address given in the fourth argument**. This address is the "
"start address of the segment we calculated earlier. If allocation at the "
"specified physical address fails, an error is returned."

#: src/bootloader/load_kernel.md:215
msgid "仮想アドレスのマップ"
msgstr "Mapping Virtual Address"

#: src/bootloader/load_kernel.md:217
msgid ""
"カーネルが要求する\"物理アドレス\"にメモリを確保できたため、次は要求する\"仮"
"想アドレス\"を確保した物理アドレスにマップします。 [簡易ページテーブルのチャ"
"プター](simple_pg.md) で 4KiB ページをマップする関数を実装したため、それを"
"使ってページをマップします:"
msgstr ""
"Since memory has been successfully allocated at the \"physical address\" "
"requested by the kernel, the next step is to map the requested \"virtual "
"address\" to the allocated physical address. We previously implemented a "
"function to map 4KiB pages in the [Simple Page Table chapter](simple_pg.md), "
"so we will use that function to map the pages:"

#: src/bootloader/load_kernel.md:236
msgid ""
"確保した 4KiB ページの枚数分 (`pages_4kib`) だけページのマップを繰り返しま"
"す。 本当であれば、セグメントヘッダが要求する属性 (読み込み専用等) でマップす"
"るべきですが、ここでは簡単のために全て `.read_write` でマップします。"
msgstr ""
"Repeat the page mapping for the number of allocated 4KiB pages "
"(`pages_4kib`). Ideally, the pages should be mapped with the attributes "
"specified by the segment header (such as read-only), but for simplicity, "
"here we map all pages with `.read_write`."

#: src/bootloader/load_kernel.md:239
msgid "実行してメモリマップを確認すると以下のようになります:"
msgstr "When you run it and check the memory map, it looks like the following:"

#: src/bootloader/load_kernel.md:250
msgid ""
"仮想アドレスの `0xFFFFFFFF80100000` から1ページ分だけ物理アドレスの "
"`0x0000000000100000` にマップされていることがわかります。 うまくマップできて"
"いるようですね。"
msgstr ""
"You can see that one page starting at virtual address `0xFFFFFFFF80100000` "
"is mapped to the physical address `0x0000000000100000`. It's as expected. "
"Nice."

#: src/bootloader/load_kernel.md:253
msgid "カーネルの読み込みとロード"
msgstr "Reading and Loading Kernel Image"

#: src/bootloader/load_kernel.md:255
msgid ""
"[カーネルのパースのチャプター](./parse_kernel.md) では、Ymir の ELF ヘッダ部"
"分しかメモリに読み込んでいませんでした。 最後に、用意したメモリにカーネルのセ"
"グメント全体をロードしていきます。"
msgstr ""
"In the [Parsing Kernel chapter](./parse_kernel.md), only the ELF header of "
"Ymir was loaded into memory. Now, we will load the entire kernel segments "
"into the prepared memory."

#: src/bootloader/load_kernel.md:258
msgid "セグメントの読み込み"
msgstr "Loading Segments"

#: src/bootloader/load_kernel.md:260
msgid ""
"まずは、先ほど必要なメモリサイズを計算したときと同様にセグメントヘッダのイテ"
"レータを作成するところから始めます:"
msgstr ""
"First, just like when we calculated the required memory size earlier, we "
"start by creating an iterator for the segment headers:"

#: src/bootloader/load_kernel.md:277
msgid ""
"ロードする必要があるのは、やはり `PT_LOAD` セグメントだけです。それ以外の場合"
"にはスキップします。 続いて、セグメントを FS からメモリに読み出します:"
msgstr ""
"Only the `PT_LOAD` segments need to be loaded; all others are skipped. Next, "
"the segments are read from the file system into memory:"

#: src/bootloader/load_kernel.md:300
msgid ""
"ここで、`kernel` は [カーネルのパース](parse_kernel.md) で作った `*uefi."
"protocol.File` です。 `setPosition()` でセグメントの開始オフセットまでシーク"
"したあと、 セグメントヘッダが要求する仮想アドレスに対して、セグメントをファイ"
"ルから読み出します。 とてもシンプルです。"
msgstr ""
"Here, `kernel` is a `*uefi.protocol.File` created in the [Parsing Kernel]"
"(parse_kernel.md) chapter. After seeking to the segment's start offset using "
"`setPosition()`, we read the segment from the file directly into the virtual "
"address requested by the segment header. It's very straightforward."

#: src/bootloader/load_kernel.md:307
msgid ""
"ページング周りのコードを書く際は、仮想アドレスと物理アドレスを取り違えるミス"
"をしやすいです。 しかし、**Surtr においては実はそこまで両者を意識する必要はあ"
"りません**。 というのも、UEFI が提供するマッピングは仮想アドレスをストレート"
"に物理アドレスへとマップするため、 仮想アドレスと物理アドレスが等しくなるから"
"です。"
msgstr ""
"When working on paging-related code, it's very likely to confuse virtual "
"addresses with physical addresses. However, **in Surtr, you actually don't "
"need to be overly concerned about distinguishing between the two**. This is "
"because the mappings provided by UEFI direct map virtual addresses to the "
"same physical addresses, making virtual and physical addresses effectively "
"identical."

#: src/bootloader/load_kernel.md:312
msgid ""
"なお、カーネルをロードしようとしているメモリは先ほど新たに仮想アドレスをマッ"
"プしました。 しかし依然としてストレートマップも有効のままです。 そのため、こ"
"の物理アドレスに対しては2通りの仮想アドレスを介してアクセスできます。 試しに"
"上のコードの `phdr.p_vaddr` (新しく作成したマップ) を `phdr.p_paddr` (スト"
"レートマップ) に変更してみてください。 問題なく動くはずです。"
msgstr ""
"Note that the memory where the kernel is being loaded has just been newly "
"mapped. However, the direct mapping is still enabled. Therefore, the "
"physical address can be accessed via two different virtual addresses. \n"
"Try changing `phdr.p_vaddr` (the newly created mapping) in the code above to "
"`phdr.p_paddr` (the old direct mapping). It should work without any issues."

#: src/bootloader/load_kernel.md:318
msgid "BSS セグメントの初期化"
msgstr "Initialization of BSS Segment"

#: src/bootloader/load_kernel.md:320
msgid ""
"[`.bss` セクション](https://en.wikipedia.org/wiki/.bss) は、ロード時にゼロ初"
"期化されるセクションです。 ゼロ初期化されることが分かっているため、ELF ファイ"
"ル中には `.bss` セクションのデータは含まれていません。 セグメントをロードする"
"際に、`.bss` セクションのサイズだけメモリを確保し、ゼロで初期化する必要があり"
"ます。 既にメモリは確保してあるため、ここではゼロ初期化だけを行いましょう:"
msgstr ""
"The `.bss` section is a segment that is zero-initialized when loaded. Since "
"the segment is known to be zero-initialized, the `.bss` section's data is "
"not included in the ELF file. When loading segments, you need to allocate "
"memory for the `.bss` section and initialize it to zero.\n"
"Since the memory is already allocated, here we only need to perform zero "
"initialization:"

#: src/bootloader/load_kernel.md:333
msgid ""
"ゼロ埋めには Zig の `@memset()` 関数も利用できますが、 せっかくなので UEFI が"
"提供してくれる [SetMem()](https://uefi.org/specs/"
"UEFI/2.10/07_Services_Boot_Services.html#miscellaneous-boot-services) を使っ"
"てみました。 これで `.bss` セクションの初期化は完了です[^4]。 まぁ、今の "
"Ymir には `.bss` セクションは存在しないので実際には何も起こらないんです"
"が...。"
msgstr ""
"For zero-filling, you could use Zig's `@memset()` function. But now I chose "
"to use UEFI's [SetMem()](https://uefi.org/specs/"
"UEFI/2.10/07_Services_Boot_Services.html#miscellaneous-boot-services). Yes, "
"no reason. We've completed the initialization of the `.bss` section[^4]. \n"
"Well, technically, the current Ymir kernel doesn’t have a `.bss` section "
"yet, so nothing actually happens here..."

#: src/bootloader/load_kernel.md:340
msgid ""
"本チャプターでは Ymir Kernel をロードするのに必要なメモリサイズを計算し、その"
"分だけ物理メモリを確保しました。 その後、カーネルが要求する通りに仮想アドレス"
"をマップし、そこにカーネルをロードしました。"
msgstr ""
"In this chapter, we calculated the amount of memory needed to load the Ymir "
"Kernel and allocated that much physical memory. Then, we mapped the virtual "
"addresses as required by the kernel and loaded the kernel into that mapped "
"memory."

#: src/bootloader/load_kernel.md:343
msgid ""
"これでいよいよ Ymir を実行する準備ができました。 すぐに Ymir にジャンプしても"
"いいですが、次チャプターは少しお片付けをして、それからカーネルに飛び込むこと"
"にしましょう。"
msgstr ""
"With this, we are finally ready to run Ymir. We could jump straight into "
"Ymir now, but in the next chapter, we'll do some cleanup before diving into "
"the kernel."

#: src/bootloader/load_kernel.md:346
msgid ""
"[Complete virtual memory map with 4-level page tables - kernel.org](https://"
"www.kernel.org/doc/Documentation/x86/x86_64/mm.txt)"
msgstr ""
"[Complete virtual memory map with 4-level page tables - kernel.org](https://"
"www.kernel.org/doc/Documentation/x86/x86_64/mm.txt)"

#: src/bootloader/load_kernel.md:347
msgid ""
"[BitVisorの仮想メモリーマップ](https://qiita.com/hdk_2/"
"items/6c7aaa72f5dcfcfda342)"
msgstr ""
"[Memory map of BitVisor](https://qiita.com/hdk_2/items/6c7aaa72f5dcfcfda342)"

#: src/bootloader/load_kernel.md:348
msgid ""
"[Executable and Linking Format (ELF) Specification Version 1.2](https://"
"refspecs.linuxfoundation.org/elf/elf.pdf)"
msgstr ""
"[Executable and Linking Format (ELF) Specification Version 1.2](https://"
"refspecs.linuxfoundation.org/elf/elf.pdf)"

#: src/bootloader/load_kernel.md:349
msgid ""
"厳密には、この方法は `.bss` セクション以外のセクション/セグメントもゼロクリア"
"します。 例えば `.text` セグメントのサイズが `0x800` であった場合、セグメント"
"のサイズは 4KiB アラインされるため `.text` セクションの後に `0x800` byte の空"
"白ができることになります。 今回の方法では、この空白部分もついでにゼロクリアし"
"ています(悪いことではありません)。"
msgstr ""
"Strictly speaking, this method zeroes out not only the `.bss` section but "
"also other segments. For example, if the `.text` segment size is `0x800` "
"bytes, the segment size is aligned to 4KiB, leaving a `0x800` byte gap after "
"the `.text` section. With the current approach, this gap is also zeroed out "
"(which isn't necessarily a bad thing)."

#: src/bootloader/cleanup_memmap.md:1
msgid "UEFI のメモリマップとお片付け"
msgstr "Memory Map of UEFI and Cleanup"

#: src/bootloader/cleanup_memmap.md:3
msgid ""
"前チャプターで Ymir Kernel をメモリにロードできたため、早速 Ymir に制御を渡し"
"て... といきたいところですが、本チャプターでは Ymir の実行まではいきません。 "
"その前に UEFI にいる間しかできないお片付けをします。 また、UEFI が提供するメ"
"モリマップを取得して観察してみます。 このメモリマップはのちほど Ymir で使うこ"
"とになるのに加え、Boot Services を終了させるためにも必要となります。"
msgstr ""
"In the previous chapter, we successfully loaded the Ymir Kernel into memory, "
"so naturally, we want to transfer control to Ymir right away... However, in "
"this chapter, we won't run Ymir yet. Before that, we'll perform some cleanup "
"tasks that can only be done while still in the UEFI environment. "
"Additionally, we'll get and inspect the memory map provided by UEFI. This "
"memory map will later be used by Ymir and is also necessary for properly "
"exiting Boot Services."

#: src/bootloader/cleanup_memmap.md:11
msgid ""
"本チャプターの最終コードは [`whiz-surtr-cleanup_memmap`](https://github.com/"
"smallkirby/ymir/tree/whiz-surtr-cleanup_memmap) ブランチにあります。"
msgstr ""
"Source code for this chapter is in [`whiz-surtr-cleanup_memmap`](https://"
"github.com/smallkirby/ymir/tree/whiz-surtr-cleanup_memmap) branch."

#: src/bootloader/cleanup_memmap.md:15
msgid "[ファイルのお片付け](#ファイルのお片付け)"
msgstr "[ファイルのお片付け](#ファイルのお片付け)"

#: src/bootloader/cleanup_memmap.md:16
msgid "[メモリマップの取得](#メモリマップの取得)"
msgstr "[メモリマップの取得](#メモリマップの取得)"

#: src/bootloader/cleanup_memmap.md:17
msgid "[メモリマップの定義](#メモリマップの定義)"
msgstr "[メモリマップの定義](#メモリマップの定義)"

#: src/bootloader/cleanup_memmap.md:18
msgid "[`MemoryDescriptor` のイテレータ](#memorydescriptor-のイテレータ)"
msgstr "[`MemoryDescriptor` のイテレータ](#memorydescriptor-のイテレータ)"

#: src/bootloader/cleanup_memmap.md:19
msgid "[メモリマップの取得と表示](#メモリマップの取得と表示)"
msgstr "[メモリマップの取得と表示](#メモリマップの取得と表示)"

#: src/bootloader/cleanup_memmap.md:20
msgid "[Exit Boot Services](#exit-boot-services)"
msgstr "[Exit Boot Services](#exit-boot-services)"

#: src/bootloader/cleanup_memmap.md:22
msgid "ファイルのお片付け"
msgstr "Cleanup of Open Files"

#: src/bootloader/cleanup_memmap.md:24
msgid ""
"Ymir をロードするために UEFI の Simple File System Protocol を使いました。 "
"ルートファイルを開き、Ymir の ELF ファイルを開き、ヘッダをメモリに読み込んだ"
"ことを覚えているでしょうか。 使ったものは片付けるのが世の常です。お片付けをし"
"ましょう。"
msgstr ""
"We used UEFI's Simple File System Protocol to read and load Ymir image. You "
"might recall that we opened the root directory, then the Ymir ELF file, and "
"read its header into memory. It's good practice to clean up what we've used. "
"Let's do cleanup now."

#: src/bootloader/cleanup_memmap.md:28
msgid "ELF ファイルを読み込んだのは:"
msgstr "We've read ELF file twice:"

#: src/bootloader/cleanup_memmap.md:30
msgid "ELF ヘッダのパースのため"
msgstr "To parse the ELF header"

#: src/bootloader/cleanup_memmap.md:31
msgid "カーネルのセグメントのロードのため"
msgstr "To load kernel segments"

#: src/bootloader/cleanup_memmap.md:33
msgid ""
"の2回です。 この内、2については Ymir の実行に必要なため残しておいて、1のみを"
"片付けます。 ヘッダ用の領域は [AllocatePool()](https://uefi.org/specs/"
"UEFI/2.9_A/07_Services_Boot_Services.html#id16) で確保したため、対応する "
"[FreePool()](https://uefi.org/specs/UEFI/2.9_A/07_Services_Boot_Services."
"html#efi-boot-services-freepool) で解放します:"
msgstr ""
"Among these, we need to keep the 2 that's required to run Ymir. So we only "
"clean up the buffer for the ELF header. Since the buffer was allocated with "
"[AllocatePool()](https://uefi.org/specs/UEFI/2.9_A/07_Services_Boot_Services."
"html#id16), we release it using the corresponding [FreePool()](https://uefi."
"org/specs/UEFI/2.9_A/07_Services_Boot_Services.html#efi-boot-services-"
"freepool) API:"

#: src/bootloader/cleanup_memmap.md:46
msgid "続いて、開いていた Ymir の ELF ファイルを閉じます:"
msgstr "Next, close the Ymir ELF file:"

#: src/bootloader/cleanup_memmap.md:57
msgid ""
"これで開いているファイルが存在しなくなったため、ルートディレクトリを閉じてあ"
"げます:"
msgstr "Now that there're no open files, let's close the root directory:"

#: src/bootloader/cleanup_memmap.md:68
msgid "メモリマップの取得"
msgstr "Obtaining Memory Map"

#: src/bootloader/cleanup_memmap.md:70
msgid ""
"お片付けとは少し違いますが、UEFI が提供する [メモリマップ](https://uefi.org/"
"htmlspecs/ACPI_Spec_6_4_html/15_System_Address_Map_Interfaces/uefi-"
"getmemorymap-boot-services-function.html) を取得します。 このメモリマップは、"
"現在利用されている全てのメモリに関する情報を提供します。 Surtr においてカーネ"
"ル用の領域として `AllocatePages()` や `AllocatePool()` で確保した領域も含まれ"
"ます。 取得したマップは、のちほど Ymir に渡し、Ymir は [アロケータを構築](../"
"kernel/page_allocator.md) するために利用します。"
msgstr ""
"Although this isn't the part of cleanup, let's retrieve the [memory map]"
"(https://uefi.org/htmlspecs/"
"ACPI_Spec_6_4_html/15_System_Address_Map_Interfaces/uefi-getmemorymap-boot-"
"services-function.html) provided by UEFI. This memory map gives detailed "
"information about all the memory currently in use, including the areas that "
"Surtr allocated for the kernel by `AllocatePages()` and `AllocatePool()`.\n"
"We'll pass this memory map to Ymir later, where it will be used to build its "
"[memory allocator](../kernel/page_allocator.md)."

#: src/bootloader/cleanup_memmap.md:75
msgid "メモリマップの定義"
msgstr "Definition of Memory Map"

#: src/bootloader/cleanup_memmap.md:77
msgid ""
"UEFI が提供するメモリマップ自体はただのバイナリデータであり、パースにはその他"
"諸々の情報が必要です。 これらの情報をまとめた構造体を定義します。"
msgstr ""
"The memory map provided by UEFI is just raw binary data, and parsing it "
"requires several additional pieces of information. To handle this, we define "
"a struct that consolidates all the necessary data for parsing."

#: src/bootloader/cleanup_memmap.md:80
msgid ""
"`surtr/defs.zig` を新しく作成します。 このファイルは、Ymir と Surtr で共通し"
"て利用するデータ構造を定義するのに使います。 以下のようにメモリマップを定義し"
"ます:"
msgstr ""
"Create a new file named `surtr/defs.zig`. This file will be used to define "
"data structures shared between Ymir and Surtr. Define the memory map struct "
"as follows:"

#: src/bootloader/cleanup_memmap.md:102
msgid ""
"メモリマップの主要な要素は `MemoryDescriptor` の配列です。 **1つのディスクリ"
"プタは、1つの連続するメモリ領域を表現します**。 配列のサイズは `map_size / "
"descriptor_size` です。"
msgstr ""
"The core component of the memory map is an array of `MemoryDescriptor` "
"structs. **Each descriptor represents a single contiguous block of memory.** "
"The size of this array is `map_size / descriptor_size`."

#: src/bootloader/cleanup_memmap.md:106
msgid "`MemoryDescriptor` のイテレータ"
msgstr "Iterator for `MemoryDescriptor`"

#: src/bootloader/cleanup_memmap.md:108
msgid ""
"ELF のセグメントヘッダをイテレートしたように、`MemoryDescriptor` も簡単にイテ"
"レートできると便利そうです。 `MemoryMap` の情報をもとに `MemoryDescriptor` を"
"イテレートする構造体を定義します:"
msgstr ""
"Just like iterating over ELF program headers, it would be convenient to "
"easily iterate over `MemoryDescriptor` entries as well. Based on the "
"information in `MemoryMap`, we define a struct to iterate through the "
"`MemoryDescriptor` entries:"

#: src/bootloader/cleanup_memmap.md:142
msgid ""
"`new()`では、イテレートに必要な3つの要素 `descriptors`, `descriptor_size`, "
"`total_size` を記憶します。 また、現在の `MemoryDescriptor` を指すポインタ "
"`current` を先頭にセットします。"
msgstr ""
"In `new()`, we store the three elements necessary for iteration: "
"`descriptors`, `descriptor_size`, and `total_size`. We also set the pointer "
"`current`, which points to the current `MemoryDescriptor`, to the start of "
"the array."

#: src/bootloader/cleanup_memmap.md:145
msgid ""
"`next()` は、現在指している `MemoryDescriptor` を返し、イテレータを次の "
"`MemoryDescriptor` に進めます。 先述したように、`MemoryDescriptor`は連続した"
"配列であり、1つの要素のサイズは `descriptor_size` であるため、 `current` に "
"`descriptor_size` を加算することで次の要素に進めます。 もしも次の要素が存在し"
"ない場合は `null` を返します。"
msgstr ""
"The `next()` method returns the current `MemoryDescriptor` and advances the "
"iterator to the next element. As mentioned earlier, `MemoryDescriptor`s are "
"stored in a contiguous array, with each element sized `descriptor_size`. "
"Therefore, adding `descriptor_size` to `current` moves the pointer to the "
"next element. If there is no next element, it returns `null`."

#: src/bootloader/cleanup_memmap.md:150
msgid "メモリマップの取得と表示"
msgstr "Obtaining and Printing Memory Map"

#: src/bootloader/cleanup_memmap.md:152
msgid "`surtr/boot.zig` にメモリマップを取得するヘルパー関数を追加します:"
msgstr "Add the helper function to obtain the memory map in `surtr/boot.zig`:"

#: src/bootloader/cleanup_memmap.md:169
msgid ""
"実際にメモリマップを取得する関数 `getMemoryMap()` はこのあとすぐに実装しま"
"す。 ここで取得するメモリマップは、あくまでもメモリマップの\"コピー\"です。 "
"よって、もとのマップをコピーするためのバッファが必要となります。 バッファがど"
"れだけ必要かは利用されているメモリブロックの個数に依存しますが、今回は固定で4"
"ページ分のバッファを用意します[^1]。 これだけあればおそらく十分でしょう。 "
"`getMemomryMap()` は、`MemoryMap` を引数にとった上で、その中身を埋めて返しま"
"す。 引数として渡すマップには、用意したバッファのアドレスとサイズだけを指定す"
"ればOKです。"
msgstr ""
"We'll implement the function `getMemoryMap()` shortly. The memory map "
"obtained here is essentially a *copy* of the actual memory map. Therefore, a "
"buffer is required to hold this copied map. The required buffer size depends "
"on the number of memory blocks in use, but for simplicity, we'll allocate a "
"fixed buffer size equivalent to 4 pages[^1]. This should be sufficient in "
"most cases.\n"
"The `getMemoryMap()` function takes a `MemoryMap` struct as an argument and "
"fills it with the retrieved information. When passing the map as an "
"argument, you only need to specify the address and size of the pre-allocated "
"buffer."

#: src/bootloader/cleanup_memmap.md:177
msgid "続いて、実際にメモリマップを取得する関数を実装します:"
msgstr "Next , let's implement a function that obtains the memory map:"

#: src/bootloader/cleanup_memmap.md:192
msgid ""
"UEFI の Runtime Services が提供する、メモリマップを取得するための "
"[`GetMemoryMap()`](https://uefi.org/specs/"
"UEFI/2.9_A/07_Services_Boot_Services.html#efi-boot-services-getmemorymap) の"
"単なるラッパーです。"
msgstr ""
"This is a simple wrapper around UEFI Runtime Services' [`GetMemoryMap()`]"
"(https://uefi.org/specs/UEFI/2.9_A/07_Services_Boot_Services.html#efi-boot-"
"services-getmemorymap), which retrieves the memory map."

#: src/bootloader/cleanup_memmap.md:194
msgid "最後に、取得したメモリマップを表示します:"
msgstr "Finally, print the obtained memory map:"

#: src/bootloader/cleanup_memmap.md:210
msgid ""
"実行すると、以下のようにメモリマップが表示されます。各メモリタイプの意味は[こ"
"ちらのテーブル](https://uefi.org/specs/UEFI/2.9_A/07_Services_Boot_Services."
"html#memory-type-usage-before-exitbootservices)を参照してください:"
msgstr ""
"When executed, the memory map is displayed as shown below. For the meaning "
"of each memory type, please refer to [this table](https://uefi.org/specs/"
"UEFI/2.9_A/07_Services_Boot_Services.html#memory-type-usage-before-"
"exitbootservices):"

#: src/bootloader/cleanup_memmap.md:347
msgid ""
"以上でメモリマップの取得は完了です。 しばしお茶でもしばきながら、表示されたメ"
"モリマップを眺めて、`AllocatePages()`で確保した領域はなんというメモリタイプに"
"なっているかなどを確認してみてください。 あとはこれまでの人生を振り返ってみる"
"のとかも良いかもしれませんね。"
msgstr ""
"This completes the process of obtaining the memory map. Take a break with a "
"cup of tea and take a look at the displayed memory map. Try checking what "
"memory type the area allocated by `AllocatePages()` has. Reflecting on your "
"life so far might also be a good idea."

#: src/bootloader/cleanup_memmap.md:351
msgid "Exit Boot Services"
msgstr "Exit Boot Services"

#: src/bootloader/cleanup_memmap.md:353
msgid ""
"カーネルにジャンプする前の最後のお片付けとして、UEFI Boot Services を終了しま"
"す。 これは Boot Services の [ExitBootServices()](https://uefi.org/specs/"
"UEFI/2.9_A/07_Services_Boot_Services.html#efi-boot-services-"
"exitbootservices) を呼ぶことで実現できます。 この関数を呼んだあとは Boot "
"Services が使えなくなる代わりに [Runtime Services](https://uefi.org/specs/"
"UEFI/2.9_A/08_Services_Runtime_Services.html#services-runtime-services) が利"
"用可能になります。"
msgstr ""
"As the final cleanup step before jumping to the kernel, we will exit the "
"UEFI Boot Services. This is done by calling the Boot Services function "
"[`ExitBootServices()`](https://uefi.org/specs/"
"UEFI/2.9_A/07_Services_Boot_Services.html#efi-boot-services-"
"exitbootservices). After calling this function, Boot Services will no longer "
"be available, but the [Runtime Services](https://uefi.org/specs/"
"UEFI/2.9_A/08_Services_Runtime_Services.html#services-runtime-services) will "
"become accessible."

#: src/bootloader/cleanup_memmap.md:357
msgid ""
"`ExitBootServices()` を呼ぶためには、**UEFI OS loader** (本シリーズでいうとこ"
"ろの Surtr) が現在のメモリマップを掌握していることを保証する必要があります。 "
"UEFI に「おれは全部知ってるぞ」と教える必要があるということですね。 そのため"
"に、この関数には先ほど取得したメモリマップのキーを渡します:"
msgstr ""
"To call `ExitBootServices()`, the UEFI OS loader (Surtr in this series) must "
"guarantee that it has an up-to-date view of the current memory map. In other "
"words, you need to tell UEFI, \"I know everything.\" To do this, the "
"function requires the key of the memory map that was obtained earlier:"

#: src/bootloader/cleanup_memmap.md:367
msgid ""
"しかしながら、メモリマップは `AllocatePages()` や `AllocatePool()` などによっ"
"て変更される可能性があります。 取得したメモリマップ(のキー)が最新ではないと "
"UEFI が判断すると、この関数はエラーを返します。 その場合には、再度メモリマッ"
"プを取得して自分は最新のメモリマップを知っているんだということを主張してあげ"
"る必要があります[^2]:"
msgstr ""
"However, the memory map can change due to calls like `AllocatePages()` or "
"`AllocatePool()`. If UEFI determines that the memory map (or its key) you "
"provided is outdated, `ExitBootServices()` will return an error. In that "
"case, you need to retrieve the memory map again and assert that you have the "
"latest memory map[^2]:"

#: src/bootloader/cleanup_memmap.md:389
msgid ""
"以上で UEFI Boot Services から脱出することに成功しました。 あなたはもう大人と"
"してこの薄寒い社会を一人で生きていかなければいけません。"
msgstr ""
"With this, you have successfully exited UEFI Boot Services. From now on, you "
"must face this cold world on your own, like a true adult."

#: src/bootloader/cleanup_memmap.md:392
msgid ""
"なお、これ以降 Boot Services は利用できません。 ずっと利用してきたログシステ"
"ムは、Boot Services の Simple Text Output Protocol を利用していました。 よっ"
"て、**ログ出力はもうできなくなります**。 試しに `log.warn()` かなにかで出力し"
"ようとしてみてください。 きっとエラーが起こるはずです。 もう喋ることすらもで"
"きません。 言いたいことも言えないこんな世の中じゃ、POISON...[^3]"
msgstr ""
"From this point onward, Boot Services are no longer available. The logging "
"system we've been using relies on the Simple Text Output Protocol provided "
"by Boot Services. Therefore, **log output will no longer work**. \n"
"Try calling something like `log.warn()` to output a message - you will most "
"likely encounter an error. You won’t even be able to print anything "
"anymore. \n"
"Sometimes the system goes on the blink, and the whole thing it turns out "
"wrong...[^3]"

#: src/bootloader/cleanup_memmap.md:400
msgid ""
"ちゃんと実装したい場合には、少なめのサイズのバッファを用意して "
"`getMemoryMap()` を呼び出し、 エラーが返ってきた場合にはバッファを拡張して再"
"度呼び出すという方法が考えられます。"
msgstr ""
"If you want to implement this properly, one approach is to start with a "
"reasonably small buffer, call `getMemoryMap()` with it, and then allocate a "
"larger buffer and retry if it returns an error."

#: src/bootloader/cleanup_memmap.md:402
msgid ""
"実際には、Surtr においてはメモリマップを取得してからメモリマップが変わるよう"
"な処理はしていないため、 この `if` 文に到達することはありません。"
msgstr ""
"In practice, Surtr doesn't perform any operations that would modify the "
"memory map after retrieving it, so this `if` block should never be reached."

#: src/bootloader/cleanup_memmap.md:404
msgid ""
"[POISON ～言いたい事も言えないこんな世の中は～ - 反町隆史](https://www.uta-"
"net.com/song/10442/)"
msgstr "[Bad Day - Daniel Powter](https://youtu.be/gH476CxJxfg)"

#: src/bootloader/jump_to_ymir.md:3
msgid ""
"UEFI にいる状態でする必要のあるお片付けも終わったため、いよいよカーネルを起動"
"する準備ができました。 本チャプターでは、カーネルに渡す引数を準備して Ymir "
"カーネルへジャンプします。 ジャンプした先でスタックのピボットをしてカーネル用"
"スタックに切り替えたあと、カーネルのメイン関数に制御を移します。"
msgstr ""
"UEFI にいる状態でする必要のあるお片付けも終わったため、いよいよカーネルを起動"
"する準備ができました。 本チャプターでは、カーネルに渡す引数を準備して Ymir "
"カーネルへジャンプします。 ジャンプした先でスタックのピボットをしてカーネル用"
"スタックに切り替えたあと、カーネルのメイン関数に制御を移します。"

#: src/bootloader/jump_to_ymir.md:9
msgid "[カーネルに渡す引数の準備](#カーネルに渡す引数の準備)"
msgstr "[カーネルに渡す引数の準備](#カーネルに渡す引数の準備)"

#: src/bootloader/jump_to_ymir.md:10
msgid "[カーネルへのジャンプ](#カーネルへのジャンプ)"
msgstr "[カーネルへのジャンプ](#カーネルへのジャンプ)"

#: src/bootloader/jump_to_ymir.md:11
msgid "[リンカスクリプトとスタック](#リンカスクリプトとスタック)"
msgstr "[リンカスクリプトとスタック](#リンカスクリプトとスタック)"

#: src/bootloader/jump_to_ymir.md:12
msgid "[レイアウトの設定](#レイアウトの設定)"
msgstr "[レイアウトの設定](#レイアウトの設定)"

#: src/bootloader/jump_to_ymir.md:13
msgid "[セクションとセグメントの確認](#セクションとセグメントの確認)"
msgstr "[セクションとセグメントの確認](#セクションとセグメントの確認)"

#: src/bootloader/jump_to_ymir.md:14
msgid "[Stack Trampoline](#stack-trampoline)"
msgstr "[Stack Trampoline](#stack-trampoline)"

#: src/bootloader/jump_to_ymir.md:15
msgid "[`BootInfo` の検証](#bootinfo-の検証)"
msgstr "[`BootInfo` の検証](#bootinfo-の検証)"

#: src/bootloader/jump_to_ymir.md:18
msgid "カーネルに渡す引数の準備"
msgstr "カーネルに渡す引数の準備"

#: src/bootloader/jump_to_ymir.md:20
msgid ""
"Surtr から Ymir にはいくつかの情報を渡す必要があります。 その代表的なものは、"
"UEFI から取得したメモリマップです。 Boot Services を exit したあとではこのメ"
"モリマップを取得する方法がなくなるため、 Surtr が事前に取得しておいたメモリ"
"マップを Ymir に渡します。"
msgstr ""
"Surtr から Ymir にはいくつかの情報を渡す必要があります。 その代表的なものは、"
"UEFI から取得したメモリマップです。 Boot Services を exit したあとではこのメ"
"モリマップを取得する方法がなくなるため、 Surtr が事前に取得しておいたメモリ"
"マップを Ymir に渡します。"

#: src/bootloader/jump_to_ymir.md:25
msgid "`surtr/defs.zig`  に Surtr/Ymir 間で受け渡しする情報を定義します:"
msgstr "`surtr/defs.zig`  に Surtr/Ymir 間で受け渡しする情報を定義します:"

#: src/bootloader/jump_to_ymir.md:39
msgid ""
"`magic` は、正しく引数を Ymir に渡せたことを確認するためのマジックナンバーで"
"す。 `memory_map` は Boot Services から取得した現在のメモリマップです。 Ymir "
"はこのマップをもとにして不要な UEFI の領域を解放し、[独自のメモリアロケータ]"
"(../kernel/page_allocator.md) を構築します。"
msgstr ""
"`magic` は、正しく引数を Ymir に渡せたことを確認するためのマジックナンバーで"
"す。 `memory_map` は Boot Services から取得した現在のメモリマップです。 Ymir "
"はこのマップをもとにして不要な UEFI の領域を解放し、[独自のメモリアロケータ]"
"(../kernel/page_allocator.md) を構築します。"

#: src/bootloader/jump_to_ymir.md:43
msgid "`boot.zig` において全てのお片付けを終えた後、 `BootInfo` を作成します:"
msgstr "`boot.zig` において全てのお片付けを終えた後、 `BootInfo` を作成します:"

#: src/bootloader/jump_to_ymir.md:53
msgid ""
"なお、既に Boot Services を exit してしまっているため、デバッグのためにログ出"
"力は使えないことに注意してください。"
msgstr ""
"なお、既に Boot Services を exit してしまっているため、デバッグのためにログ出"
"力は使えないことに注意してください。"

#: src/bootloader/jump_to_ymir.md:55
msgid "カーネルへのジャンプ"
msgstr "カーネルへのジャンプ"

#: src/bootloader/jump_to_ymir.md:57
msgid ""
"いよいよカーネルへとジャンプします。 このジャンプは、通常の関数呼び出しと同じ"
"方法で実現できます。 カーネルのエントリポイントは、先程の `BootInfo` を受け取"
"る関数です。 UEFI の calling convention は Windows と同じ[^1]であるため、"
"`callconv(.Win64)` を指定します:"
msgstr ""
"いよいよカーネルへとジャンプします。 このジャンプは、通常の関数呼び出しと同じ"
"方法で実現できます。 カーネルのエントリポイントは、先程の `BootInfo` を受け取"
"る関数です。 UEFI の calling convention は Windows と同じ[^1]であるため、"
"`callconv(.Win64)` を指定します:"

#: src/bootloader/jump_to_ymir.md:68
msgid ""
"エントリポイントのアドレスは、ELF ヘッダにある `entry` フィールドに書いてあり"
"ます。 この値を `@ptrFromInt()` を使って `*KernelEntryType` という関数ポイン"
"タにキャストしています。"
msgstr ""
"エントリポイントのアドレスは、ELF ヘッダにある `entry` フィールドに書いてあり"
"ます。 この値を `@ptrFromInt()` を使って `*KernelEntryType` という関数ポイン"
"タにキャストしています。"

#: src/bootloader/jump_to_ymir.md:71
msgid "残るは、この関数ポインタを呼び出すだけです:"
msgstr "残るは、この関数ポインタを呼び出すだけです:"

#: src/bootloader/jump_to_ymir.md:79
msgid ""
"Ymir に処理が移ったあとは Surtr に戻ることはありません。 そのため、"
"`unreachable` を指定してコンパイラにここまで到達しないことを伝えています。"
msgstr ""
"Ymir に処理が移ったあとは Surtr に戻ることはありません。 そのため、"
"`unreachable` を指定してコンパイラにここまで到達しないことを伝えています。"

#: src/bootloader/jump_to_ymir.md:82
msgid ""
"さて、実際に動かして Ymir が実行されていることを確認しましょう。 現在 Ymir の"
"エントリポイントである `kernelEntry()` は無限 halt するだけの関数です。 QEMU "
"を動かして無限ループで止まることを確認してください。 その状態で QEMU monitor "
"を起動し、`info registers` でレジスタの値を確認してみましょう:"
msgstr ""
"さて、実際に動かして Ymir が実行されていることを確認しましょう。 現在 Ymir の"
"エントリポイントである `kernelEntry()` は無限 halt するだけの関数です。 QEMU "
"を動かして無限ループで止まることを確認してください。 その状態で QEMU monitor "
"を起動し、`info registers` でレジスタの値を確認してみましょう:"

#: src/bootloader/jump_to_ymir.md:110
msgid ""
"`RIP` は `0xFFFFFFFF80100001` となっており、これは Ymir のリンカスクリプトで"
"指定した `.text` セクションの値です。 正しく Ymir に実行が移ったようですね！"
msgstr ""
"`RIP` は `0xFFFFFFFF80100001` となっており、これは Ymir のリンカスクリプトで"
"指定した `.text` セクションの値です。 正しく Ymir に実行が移ったようですね！"

#: src/bootloader/jump_to_ymir.md:113
msgid ""
"Windows における calling convention では、引数は RCX, RDX, R8, R9 に順に入れ"
"られます。 今回は引数は `BootInfo` の1つだけなので、RCX に `BootInfo` のアド"
"レスが入っているはずです:"
msgstr ""
"Windows における calling convention では、引数は RCX, RDX, R8, R9 に順に入れ"
"られます。 今回は引数は `BootInfo` の1つだけなので、RCX に `BootInfo` のアド"
"レスが入っているはずです:"

#: src/bootloader/jump_to_ymir.md:123
msgid ""
"RCX が指す先には、`BootInfo` の先頭フィールドである `magic` の値 "
"`0xDEADBEEFCAFEBABE` が入っていることが確認できます。 引数の受け渡しもしっか"
"りできているようです。"
msgstr ""
"RCX が指す先には、`BootInfo` の先頭フィールドである `magic` の値 "
"`0xDEADBEEFCAFEBABE` が入っていることが確認できます。 引数の受け渡しもしっか"
"りできているようです。"

#: src/bootloader/jump_to_ymir.md:126
msgid "リンカスクリプトとスタック"
msgstr "リンカスクリプトとスタック"

#: src/bootloader/jump_to_ymir.md:128
msgid ""
"カーネルが起動したものの、**依然としていろいろなものを UEFI が用意してくれた"
"まま使っています**。 ページテーブル・IDT・GDT などもそうですが、最初に重要な"
"のがスタックです。"
msgstr ""
"カーネルが起動したものの、**依然としていろいろなものを UEFI が用意してくれた"
"まま使っています**。 ページテーブル・IDT・GDT などもそうですが、最初に重要な"
"のがスタックです。"

#: src/bootloader/jump_to_ymir.md:131
msgid ""
"UEFI が Surtr を実行する際にはスタックを用意してくれるのですが、このスタック"
"領域は `BootServiceData` と呼ばれるブート用の領域に確保されています。 この領"
"域はのちほど Ymir が自身のメモリアロケータを初期化する際に解放することになり"
"ます。 よって、まずは**スタックをカーネル用の領域へと切り替える必要があります"
"**。 今回は、Ymir にスタック用のセグメントを用意してあげることでスタック領域"
"を用意することにします[^2]。"
msgstr ""
"UEFI が Surtr を実行する際にはスタックを用意してくれるのですが、このスタック"
"領域は `BootServiceData` と呼ばれるブート用の領域に確保されています。 この領"
"域はのちほど Ymir が自身のメモリアロケータを初期化する際に解放することになり"
"ます。 よって、まずは**スタックをカーネル用の領域へと切り替える必要があります"
"**。 今回は、Ymir にスタック用のセグメントを用意してあげることでスタック領域"
"を用意することにします[^2]。"

#: src/bootloader/jump_to_ymir.md:136
msgid "レイアウトの設定"
msgstr "レイアウトの設定"

#: src/bootloader/jump_to_ymir.md:138
msgid ""
"[カーネルのロードのチャプター](load_kernel.md) で Ymir のレイアウトをリンカス"
"クリプトで簡単に設定しました。 ここではもう少しだけ真面目に設定します。 "
"`ymir/linker.ld` を以下のように書き換えます[^3]:"
msgstr ""
"[カーネルのロードのチャプター](load_kernel.md) で Ymir のレイアウトをリンカス"
"クリプトで簡単に設定しました。 ここではもう少しだけ真面目に設定します。 "
"`ymir/linker.ld` を以下のように書き換えます[^3]:"

#: src/bootloader/jump_to_ymir.md:184
msgid ""
"`.text` / `.rodata` / `.data` / `.bss` についてはそのままです。 各オブジェク"
"トファイルに存在するセクションを集めて最終的な実行ファイルのセクションを構成"
"しています。 `AT` は物理アドレスを指定しています。 `ADDR(.text)`は `.text` セ"
"クションの仮想アドレスになるため、そこから `KERNEL_VADDR_BASE` を引いた値をセ"
"クションの物理アドレスとします。 つまり、ベースの仮想アドレスからのオフセット"
"をそのまま物理アドレスにしているということです。"
msgstr ""
"`.text` / `.rodata` / `.data` / `.bss` についてはそのままです。 各オブジェク"
"トファイルに存在するセクションを集めて最終的な実行ファイルのセクションを構成"
"しています。 `AT` は物理アドレスを指定しています。 `ADDR(.text)`は `.text` セ"
"クションの仮想アドレスになるため、そこから `KERNEL_VADDR_BASE` を引いた値をセ"
"クションの物理アドレスとします。 つまり、ベースの仮想アドレスからのオフセット"
"をそのまま物理アドレスにしているということです。"

#: src/bootloader/jump_to_ymir.md:190
msgid ""
"新たに `__stack` セクションを追加しています。 スタックのサイズはとりあえず5"
"ページです。足りなくなったら足せばいいだけです、今回は十分ですが。 他のセク"
"ションとの違いとして、`NOLOAD` を指定しています。 `NOLOAD` を指定すると、その"
"領域はメモリにロードされないという意味になります。 スタック領域は初期値が不要"
"なため、ELF ファイルには含める必要がありません。 セクションのサイズには "
"`STACK_SIZE` を指定しますが、これによって **ELF 自体のサイズが変わるというこ"
"とはありません**。"
msgstr ""
"新たに `__stack` セクションを追加しています。 スタックのサイズはとりあえず5"
"ページです。足りなくなったら足せばいいだけです、今回は十分ですが。 他のセク"
"ションとの違いとして、`NOLOAD` を指定しています。 `NOLOAD` を指定すると、その"
"領域はメモリにロードされないという意味になります。 スタック領域は初期値が不要"
"なため、ELF ファイルには含める必要がありません。 セクションのサイズには "
"`STACK_SIZE` を指定しますが、これによって **ELF 自体のサイズが変わるというこ"
"とはありません**。"

#: src/bootloader/jump_to_ymir.md:197
msgid ""
"スタックの両側に配置してある `__stackguard_upper` / `__stackguard_lower` は**"
"スタックガードページ**です。 このページを read-only にすることで、スタック"
"オーバーフローやスタックアンダーフローが発生した場合にページフォルトを発生さ"
"せます[^4]。 気づかないうちにスタックが溢れて隣接する領域を破壊してしまうこと"
"を防ぐ目的です。"
msgstr ""
"スタックの両側に配置してある `__stackguard_upper` / `__stackguard_lower` は**"
"スタックガードページ**です。 このページを read-only にすることで、スタック"
"オーバーフローやスタックアンダーフローが発生した場合にページフォルトを発生さ"
"せます[^4]。 気づかないうちにスタックが溢れて隣接する領域を破壊してしまうこと"
"を防ぐ目的です。"

#: src/bootloader/jump_to_ymir.md:203
msgid ""
"スタックがオーバーフローしてガードページへの書き込みが発生すると、ページフォ"
"ルトが発生します。 フォルトハンドラがガードページをスタックとして利用しようと"
"することで再度フォルトが発生してしまいます。 これは double fault を引き起こ"
"し、その中で同様にしてフォルトが起こります。 最終的には **Triple Fault を引き"
"起こし、CPU がリセットされてこの世の終わりが訪れます...**。"
msgstr ""
"スタックがオーバーフローしてガードページへの書き込みが発生すると、ページフォ"
"ルトが発生します。 フォルトハンドラがガードページをスタックとして利用しようと"
"することで再度フォルトが発生してしまいます。 これは double fault を引き起こ"
"し、その中で同様にしてフォルトが起こります。 最終的には **Triple Fault を引き"
"起こし、CPU がリセットされてこの世の終わりが訪れます...**。"

#: src/bootloader/jump_to_ymir.md:208
msgid ""
"これを防ぐためには、ページフォルトハンドラでスタックを独自のものに切り替える"
"必要があります。 割り込みハンドラ用のスタックは [TSS](https://wiki.osdev.org/"
"Task_State_Segment) という領域を使って指定することができます。 TSS と GDT と "
"IDT を適切に設定することでページフォルトのときのみ独自のスタックに切り替える"
"ことができます[^5]。 本シリーズでは TSS は使わず、割り込みが発生した瞬間のス"
"タックをそのまま使います。 スタックオーバーフローはすぐに Triple Fault になっ"
"てしまうので、嫌な人は TSS を使って独自スタックを実装してみてください。"
msgstr ""
"これを防ぐためには、ページフォルトハンドラでスタックを独自のものに切り替える"
"必要があります。 割り込みハンドラ用のスタックは [TSS](https://wiki.osdev.org/"
"Task_State_Segment) という領域を使って指定することができます。 TSS と GDT と "
"IDT を適切に設定することでページフォルトのときのみ独自のスタックに切り替える"
"ことができます[^5]。 本シリーズでは TSS は使わず、割り込みが発生した瞬間のス"
"タックをそのまま使います。 スタックオーバーフローはすぐに Triple Fault になっ"
"てしまうので、嫌な人は TSS を使って独自スタックを実装してみてください。"

#: src/bootloader/jump_to_ymir.md:214
msgid ""
"各セクションの最後に書いてある `:segment` は、そのセクションを `segment` セグ"
"メントに配置します。 セグメントの定義は以下です:"
msgstr ""
"各セクションの最後に書いてある `:segment` は、そのセクションを `segment` セグ"
"メントに配置します。 セグメントの定義は以下です:"

#: src/bootloader/jump_to_ymir.md:231
msgid ""
"各セグメントに指定している `PT_LOAD` は、そのセグメントをメモリにロードするこ"
"とを意味します。 セクションに指定した `NOLOAD` はセクションに対する指定であ"
"り、`PT_LOAD` はセグメントに対する指定です。 `FLAGS` にはセグメントの属性を指"
"定します。 RWX の左から 4, 2, 1 の値を持ちます。 `text` / `rodata` / "
"`data` / `bss` セグメントには `FLAGS` を指定せず、セクションの属性をそのまま"
"使います。 `__stack` は RW (実行不可) にしたいため、`FLAGS(6)` です。 ガード"
"ページは read-only にするため、`FLAGS(4)` です。"
msgstr ""
"各セグメントに指定している `PT_LOAD` は、そのセグメントをメモリにロードするこ"
"とを意味します。 セクションに指定した `NOLOAD` はセクションに対する指定であ"
"り、`PT_LOAD` はセグメントに対する指定です。 `FLAGS` にはセグメントの属性を指"
"定します。 RWX の左から 4, 2, 1 の値を持ちます。 `text` / `rodata` / "
"`data` / `bss` セグメントには `FLAGS` を指定せず、セクションの属性をそのまま"
"使います。 `__stack` は RW (実行不可) にしたいため、`FLAGS(6)` です。 ガード"
"ページは read-only にするため、`FLAGS(4)` です。"

#: src/bootloader/jump_to_ymir.md:239
msgid "セクションとセグメントの確認"
msgstr "セクションとセグメントの確認"

#: src/bootloader/jump_to_ymir.md:241
msgid ""
"スタックを含めた Ymir のレイアウトが設定できたため、意図したとおりのレイアウ"
"トになっているかを確認しましょう。 `zig build install` で Ymir をビルドした"
"後、`readelf` でセクションとセグメントの情報を表示させます:"
msgstr ""
"スタックを含めた Ymir のレイアウトが設定できたため、意図したとおりのレイアウ"
"トになっているかを確認しましょう。 `zig build install` で Ymir をビルドした"
"後、`readelf` でセクションとセグメントの情報を表示させます:"

#: src/bootloader/jump_to_ymir.md:295
msgid "以下のようなことが分かります:"
msgstr "以下のようなことが分かります:"

#: src/bootloader/jump_to_ymir.md:297
msgid "`__stack` やガードページのセクションは:"
msgstr "`__stack` やガードページのセクションは:"

#: src/bootloader/jump_to_ymir.md:298
msgid "`Size` が指定したページサイズになっている。"
msgstr "`Size` が指定したページサイズになっている。"

#: src/bootloader/jump_to_ymir.md:299
msgid "`Addr` が指定した仮想アドレスになっている。"
msgstr "`Addr` が指定した仮想アドレスになっている。"

#: src/bootloader/jump_to_ymir.md:300
msgid ""
"`Offset` (ELFファイル内におけるセクションの開始アドレス) が同じ `0x2000` に"
"なっている。 これは、**セクション自体がサイズを持たず ELF バイナリ内に含まれ"
"ない**ことを示している。"
msgstr ""
"`Offset` (ELFファイル内におけるセクションの開始アドレス) が同じ `0x2000` に"
"なっている。 これは、**セクション自体がサイズを持たず ELF バイナリ内に含まれ"
"ない**ことを示している。"

#: src/bootloader/jump_to_ymir.md:302
msgid "`__stack` やガードページのセグメントは:"
msgstr "`__stack` やガードページのセグメントは:"

#: src/bootloader/jump_to_ymir.md:303
msgid ""
"`FileSize` が `0` になっている。これも ELF 内にデータが含まれないことを示す。"
msgstr ""
"`FileSize` が `0` になっている。これも ELF 内にデータが含まれないことを示す。"

#: src/bootloader/jump_to_ymir.md:304
msgid "`MemSize` が指定したページサイズになっている。"
msgstr "`MemSize` が指定したページサイズになっている。"

#: src/bootloader/jump_to_ymir.md:305
msgid ""
"`VirtAddr` と `PhysAddr` が指定した仮想アドレス・物理アドレスになっている。"
msgstr ""
"`VirtAddr` と `PhysAddr` が指定した仮想アドレス・物理アドレスになっている。"

#: src/bootloader/jump_to_ymir.md:306
msgid "スタックは read-write になっている。"
msgstr "スタックは read-write になっている。"

#: src/bootloader/jump_to_ymir.md:307
msgid "ガードページは read-only になっている。"
msgstr "ガードページは read-only になっている。"

#: src/bootloader/jump_to_ymir.md:308
msgid ""
"`.bss` セクションと `__stackguard_upper` セクションが同じセグメントになってい"
"る。 これは現在 Ymir が `.bss` に入れる変数を持っていないから。"
msgstr ""
"`.bss` セクションと `__stackguard_upper` セクションが同じセグメントになってい"
"る。 これは現在 Ymir が `.bss` に入れる変数を持っていないから。"

#: src/bootloader/jump_to_ymir.md:313
msgid ""
"余談ですが、セグメントやセクションの属性等は一般的な意味[^6]から逸脱していて"
"も全く問題ありません。 というのも、これらをパースするローダである Surtr は本"
"シリーズで自作するものであり、値をどう解釈するかはこちらの一存で決めることが"
"できるからです。"
msgstr ""
"余談ですが、セグメントやセクションの属性等は一般的な意味[^6]から逸脱していて"
"も全く問題ありません。 というのも、これらをパースするローダである Surtr は本"
"シリーズで自作するものであり、値をどう解釈するかはこちらの一存で決めることが"
"できるからです。"

#: src/bootloader/jump_to_ymir.md:316
msgid "Stack Trampoline"
msgstr "Stack Trampoline"

#: src/bootloader/jump_to_ymir.md:318
msgid ""
"スタックを用意したので、UEFI が用意したスタックからカーネルのスタックへと切り"
"替えます。"
msgstr ""
"スタックを用意したので、UEFI が用意したスタックからカーネルのスタックへと切り"
"替えます。"

#: src/bootloader/jump_to_ymir.md:320
msgid "Ymir のエントリポイントである `kernelEntry()` を以下のように変更します:"
msgstr ""
"Ymir のエントリポイントである `kernelEntry()` を以下のように変更します:"

#: src/bootloader/jump_to_ymir.md:336
msgid ""
"`__stackguard_lower` は先程リンカスクリプトで定義した `__stackguard_lower` セ"
"クションの先頭アドレスに位置しています。 この変数はアドレスしか使わないので実"
"際には型は不要です。 インラインアセンブラでは `__stackguard_lower` セクション"
"から `0x10` だけずらしたアドレスをスタックポインタにセットしています。 これで"
"スタックが用意したカーネルスタックに切り替わります。"
msgstr ""
"`__stackguard_lower` は先程リンカスクリプトで定義した `__stackguard_lower` セ"
"クションの先頭アドレスに位置しています。 この変数はアドレスしか使わないので実"
"際には型は不要です。 インラインアセンブラでは `__stackguard_lower` セクション"
"から `0x10` だけずらしたアドレスをスタックポインタにセットしています。 これで"
"スタックが用意したカーネルスタックに切り替わります。"

#: src/bootloader/jump_to_ymir.md:341
msgid ""
"`kernelTrampoline()` は Zig の通常の calling convention を持つ関数にジャンプ"
"するためのトランポリン関数です:"
msgstr ""
"`kernelTrampoline()` は Zig の通常の calling convention を持つ関数にジャンプ"
"するためのトランポリン関数です:"

#: src/bootloader/jump_to_ymir.md:358
msgid ""
"`kernelEntry()` は関数のプロローグを持ってはいけません。 スタックをカーネルの"
"ものに切り替える前に、プロローグがスタックに何かを push してしまう可能性があ"
"るためです。 よって、`callconv(.Naked)` を指定しています。"
msgstr ""
"`kernelEntry()` は関数のプロローグを持ってはいけません。 スタックをカーネルの"
"ものに切り替える前に、プロローグがスタックに何かを push してしまう可能性があ"
"るためです。 よって、`callconv(.Naked)` を指定しています。"

#: src/bootloader/jump_to_ymir.md:362
msgid ""
"Ymir のメイン関数は通常の Zig の calling convention を持ち、返り値としてエ"
"ラーも返せるようにしたいです。 そうしないと `try` などの便利キーワードも使え"
"なくなってしまうからです。 しかし、**`callconv(.Naked)` を持つ関数内では Zig "
"レベルでの関数呼び出しはできません**。 Inline assembly を使うしかないです。 "
"そこで、 `kernelTrampoline()` を間に入れます。 この関数は引数を適切に受け渡し"
"つつ、calling convention を切り替えます。"
msgstr ""
"Ymir のメイン関数は通常の Zig の calling convention を持ち、返り値としてエ"
"ラーも返せるようにしたいです。 そうしないと `try` などの便利キーワードも使え"
"なくなってしまうからです。 しかし、**`callconv(.Naked)` を持つ関数内では Zig "
"レベルでの関数呼び出しはできません**。 Inline assembly を使うしかないです。 "
"そこで、 `kernelTrampoline()` を間に入れます。 この関数は引数を適切に受け渡し"
"つつ、calling convention を切り替えます。"

#: src/bootloader/jump_to_ymir.md:369
msgid ""
"`kernelEntry()` の先頭では、Surtr から渡された引数が UEFI calling convention "
"に則って渡されており、 引数の `BootInfo` は RCX に入っています。 よって、"
"`kernelTrampoline()` は `callconv(.Win64)` を指定します。 `callconv(.Win64)` "
"の関数からは他の calling convention を持つ関数を通常通り呼び出すことができる"
"ため、 `kernelMain()` を Zig-way で呼び出せるという算段です。"
msgstr ""
"`kernelEntry()` の先頭では、Surtr から渡された引数が UEFI calling convention "
"に則って渡されており、 引数の `BootInfo` は RCX に入っています。 よって、"
"`kernelTrampoline()` は `callconv(.Win64)` を指定します。 `callconv(.Win64)` "
"の関数からは他の calling convention を持つ関数を通常通り呼び出すことができる"
"ため、 `kernelMain()` を Zig-way で呼び出せるという算段です。"

#: src/bootloader/jump_to_ymir.md:377
#, fuzzy
#| msgid ""
#| "\\[!INFO\\] export keyword `export` keyword を関数につけることで、その関数"
#| "は定義したままの名前で参照できるようになります。 `kernelMain()` や "
#| "`kernelTrampoline()` はアセンブラから `call` するため、`export` をつけてい"
#| "ます。 もしも `export` をつけない場合、関数の名前は `main."
#| "kernelTrampoline` のようなファイル名/モジュール名を含んだ名前になってしま"
#| "います。"
msgid ""
"`export` keyword を関数につけることで、その関数は定義したままの名前で参照でき"
"るようになります。 `kernelMain()` や `kernelTrampoline()` はアセンブラから "
"`call` するため、`export` をつけています。 もしも `export` をつけない場合、関"
"数の名前は `main.kernelTrampoline` のようなファイル名/モジュール名を含んだ名"
"前になってしまいます。"
msgstr ""
"\\[!INFO\\] export keyword `export` keyword を関数につけることで、その関数は"
"定義したままの名前で参照できるようになります。 `kernelMain()` や "
"`kernelTrampoline()` はアセンブラから `call` するため、`export` をつけていま"
"す。 もしも `export` をつけない場合、関数の名前は `main.kernelTrampoline` の"
"ようなファイル名/モジュール名を含んだ名前になってしまいます。"

#: src/bootloader/jump_to_ymir.md:381
msgid "`BootInfo` の検証"
msgstr "`BootInfo` の検証"

#: src/bootloader/jump_to_ymir.md:383
msgid ""
"Surtr の役割は終わり、Ymir が実権を握りました。 このチャプターの最後として、"
"Surtr が渡してくれた引数 `BootInfo` の sanity check をしておきましょう。"
msgstr ""
"Surtr の役割は終わり、Ymir が実権を握りました。 このチャプターの最後として、"
"Surtr が渡してくれた引数 `BootInfo` の sanity check をしておきましょう。"

#: src/bootloader/jump_to_ymir.md:386
msgid ""
"まず、Ymir が Surtr の定義した情報を参照できるように Surtr モジュールを作成"
"し Ymir に追加します。 `build.zig` に以下を追加します:"
msgstr ""
"まず、Ymir が Surtr の定義した情報を参照できるように Surtr モジュールを作成"
"し Ymir に追加します。 `build.zig` に以下を追加します:"

#: src/bootloader/jump_to_ymir.md:399
msgid ""
"これで、 `@import(\"surtr\")` によって `surtr/defs.zig` を参照できるようにな"
"りました。 `kernelMain()` で `BootInfo()` の検証をしましょう:"
msgstr ""
"これで、 `@import(\"surtr\")` によって `surtr/defs.zig` を参照できるようにな"
"りました。 `kernelMain()` で `BootInfo()` の検証をしましょう:"

#: src/bootloader/jump_to_ymir.md:417
msgid ""
"`BootInfo` の先頭には、Surtr がマジックナンバーを格納してくれているはずで"
"す。 この値が正しく設定されているかを確認することで、Surtr が正しく引数を渡し"
"てくれたかを検証します。"
msgstr ""
"`BootInfo` の先頭には、Surtr がマジックナンバーを格納してくれているはずで"
"す。 この値が正しく設定されているかを確認することで、Surtr が正しく引数を渡し"
"てくれたかを検証します。"

#: src/bootloader/jump_to_ymir.md:420
msgid ""
"仮に `magic` が正しくない場合、`error.InvalidMagic` を返します。 本来ならばこ"
"こでエラー出力をしたいところですが、まだ Ymir ではログシステムを用意していな"
"いため一旦無言でエラーを返しておきます。"
msgstr ""
"仮に `magic` が正しくない場合、`error.InvalidMagic` を返します。 本来ならばこ"
"こでエラー出力をしたいところですが、まだ Ymir ではログシステムを用意していな"
"いため一旦無言でエラーを返しておきます。"

#: src/bootloader/jump_to_ymir.md:425
msgid ""
"本チャプターでは Surtr から Ymir に渡す引数の準備をし、カーネルのエントリポイ"
"ントにジャンプしました。 カーネルのエントリポイントではスタックをカーネル用の"
"スタックに切り替え、Calling Convention も切り替えつつカーネルのメイン関数に制"
"御を移しました。"
msgstr ""
"本チャプターでは Surtr から Ymir に渡す引数の準備をし、カーネルのエントリポイ"
"ントにジャンプしました。 カーネルのエントリポイントではスタックをカーネル用の"
"スタックに切り替え、Calling Convention も切り替えつつカーネルのメイン関数に制"
"御を移しました。"

#: src/bootloader/jump_to_ymir.md:428
msgid ""
"本チャプターで Surtr のおおよその実装は終わりです。 またのちほどゲスト Linux "
"をロードするために機能を追加する必要がありますが、そのときにはぜひ可愛がって"
"あげてください。 次のチャプターでは Ymir Kernel に最初にやるべきこととして、"
"ログ出力を実装していくことにしましょう。"
msgstr ""
"本チャプターで Surtr のおおよその実装は終わりです。 またのちほどゲスト Linux "
"をロードするために機能を追加する必要がありますが、そのときにはぜひ可愛がって"
"あげてください。 次のチャプターでは Ymir Kernel に最初にやるべきこととして、"
"ログ出力を実装していくことにしましょう。"

#: src/bootloader/jump_to_ymir.md:432
msgid ""
"[Detailed Calling Conventions - UEFI Specification 2.9 Errata A](https://"
"uefi.org/specs/UEFI/2.9_A/02_Overview.html#detailed-calling-conventions)"
msgstr ""
"[Detailed Calling Conventions - UEFI Specification 2.9 Errata A](https://"
"uefi.org/specs/UEFI/2.9_A/02_Overview.html#detailed-calling-conventions)"

#: src/bootloader/jump_to_ymir.md:433
msgid ""
"本当はスタック用に動的にメモリを確保し、その領域に仮想アドレスをマップしてあ"
"げるべきですが、 めんどうなので本シリーズではこの領域をずっとスタックとして使"
"い続けることにします。"
msgstr ""
"本当はスタック用に動的にメモリを確保し、その領域に仮想アドレスをマップしてあ"
"げるべきですが、 めんどうなので本シリーズではこの領域をずっとスタックとして使"
"い続けることにします。"

#: src/bootloader/jump_to_ymir.md:435
msgid ""
"[Optional Section Attributes - Using ld The GNU linker](https://ftp.gnu.org/"
"old-gnu/Manuals/ld-2.9.1/html_node/ld_21.html)"
msgstr ""
"[Optional Section Attributes - Using ld The GNU linker](https://ftp.gnu.org/"
"old-gnu/Manuals/ld-2.9.1/html_node/ld_21.html)"

#: src/bootloader/jump_to_ymir.md:436
msgid ""
"通常、ガードページはそもそもマッピングしない場合が多いです。 しかし、やっぱり"
"めんどうなので今回は read-only にするという方法でガードすることにします。"
msgstr ""
"通常、ガードページはそもそもマッピングしない場合が多いです。 しかし、やっぱり"
"めんどうなので今回は read-only にするという方法でガードすることにします。"

#: src/bootloader/jump_to_ymir.md:438
msgid ""
"[Double Faults - Writing an OS in Rust](https://os.phil-opp.com/double-fault-"
"exceptions/)"
msgstr ""
"[Double Faults - Writing an OS in Rust](https://os.phil-opp.com/double-fault-"
"exceptions/)"

#: src/bootloader/jump_to_ymir.md:439
msgid ""
"[Linker and Libraries Guide](https://docs.oracle.com/cd/E19683-01/816-1386/"
"chapter6-83432/index.html)"
msgstr ""
"[Linker and Libraries Guide](https://docs.oracle.com/cd/E19683-01/816-1386/"
"chapter6-83432/index.html)"

#: src/kernel/serial_output.md:1
msgid "シリアルコンソールによるログ出力"
msgstr "シリアルコンソールによるログ出力"

#: src/kernel/serial_output.md:3
msgid ""
"前チャプターでは Surtr から Ymir に制御を移しました。 本チャプターからは "
"Ymir Kernel の実装を始めていきます。 まず最初にやることは、何はともあれログ出"
"力です。 [Surtr のとき](../bootloader/uefi_log.md)と同様ですね。 ログ出力には"
"シリアルポート[^serial]を使います。 `build.zig` で設定した起動オプションによ"
"り、QEMU はシリアルポートを標準出力にリダイレクトしてくれます。 このログ出力"
"が実装できれば続く開発が楽になります。 なお、ログシステムの構築自体は次チャプ"
"ターで行うこととして、本チャプターではシリアル出力すること自体を目標としま"
"す。"
msgstr ""
"前チャプターでは Surtr から Ymir に制御を移しました。 本チャプターからは "
"Ymir Kernel の実装を始めていきます。 まず最初にやることは、何はともあれログ出"
"力です。 [Surtr のとき](../bootloader/uefi_log.md)と同様ですね。 ログ出力には"
"シリアルポート[^serial]を使います。 `build.zig` で設定した起動オプションによ"
"り、QEMU はシリアルポートを標準出力にリダイレクトしてくれます。 このログ出力"
"が実装できれば続く開発が楽になります。 なお、ログシステムの構築自体は次チャプ"
"ターで行うこととして、本チャプターではシリアル出力すること自体を目標としま"
"す。"

#: src/kernel/serial_output.md:14
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-serial_output`]"
#| "(https://github.com/smallkirby/ymir/tree/whiz-ymir-serial_output) ブランチ"
#| "にあります。"
msgid ""
"本チャプターの最終コードは [`whiz-ymir-serial_output`](https://github.com/"
"smallkirby/ymir/tree/whiz-ymir-serial_output) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-serial_output`]"
"(https://github.com/smallkirby/ymir/tree/whiz-ymir-serial_output) ブランチに"
"あります。"

#: src/kernel/serial_output.md:19
msgid "[x86 ディレクトリ](#x86-ディレクトリ)"
msgstr "[x86 ディレクトリ](#x86-ディレクトリ)"

#: src/kernel/serial_output.md:20
msgid "[`ymir` モジュールの作成](#ymir-モジュールの作成)"
msgstr "[`ymir` モジュールの作成](#ymir-モジュールの作成)"

#: src/kernel/serial_output.md:21
msgid "[シリアルの基本の定義](#シリアルの基本の定義)"
msgstr "[シリアルの基本の定義](#シリアルの基本の定義)"

#: src/kernel/serial_output.md:22 src/kernel/general_allocator.md:18
msgid "[初期化](#初期化)"
msgstr "[初期化](#初期化)"

#: src/kernel/serial_output.md:23
msgid "[文字の書き込み](#文字の書き込み)"
msgstr "[文字の書き込み](#文字の書き込み)"

#: src/kernel/serial_output.md:24
msgid "[`Serial` ラッパークラス](#serial-ラッパークラス)"
msgstr "[`Serial` ラッパークラス](#serial-ラッパークラス)"

#: src/kernel/serial_output.md:29
msgid "x86 ディレクトリ"
msgstr "x86 ディレクトリ"

#: src/kernel/serial_output.md:31
msgid ""
"[Surtr のとき](../bootloader/simple_pg.md) と同様に、アーキテクチャに強く依存"
"するコードはディレクトリを分けて実装します。 Ymir のディレクトリは以下のよう"
"になります:"
msgstr ""
"[Surtr のとき](../bootloader/simple_pg.md) と同様に、アーキテクチャに強く依存"
"するコードはディレクトリを分けて実装します。 Ymir のディレクトリは以下のよう"
"になります:"

#: src/kernel/serial_output.md:49
msgid ""
"`ymir/arch.zig` の内容は `surtr/arch.zig` と同じです。 `ymir/arch/x86/arch."
"zig` を上位のディレクトリに export する目的です。"
msgstr ""
"`ymir/arch.zig` の内容は `surtr/arch.zig` と同じです。 `ymir/arch/x86/arch."
"zig` を上位のディレクトリに export する目的です。"

#: src/kernel/serial_output.md:52
msgid ""
"`ymir/arch/x86/arch.zig` は、`ymir/arch/x86` ディレクトリにおけるルートで"
"す。 アーキテクチャ依存のコードを `ymir/arch` より上のディレクトリから利用す"
"る際には、必ずこのファイルを import して使うことにします。 `ymir/arch/x86/"
"arch.zig` は以下のようにしておきます:"
msgstr ""
"`ymir/arch/x86/arch.zig` は、`ymir/arch/x86` ディレクトリにおけるルートで"
"す。 アーキテクチャ依存のコードを `ymir/arch` より上のディレクトリから利用す"
"る際には、必ずこのファイルを import して使うことにします。 `ymir/arch/x86/"
"arch.zig` は以下のようにしておきます:"

#: src/kernel/serial_output.md:64
msgid ""
"`serial.zig` は `pub` なので `arch.serial` として上位ディレクトリからアクセス"
"できます。 `asm.zig` は `pub` がついていないため、`arch` ディレクトリ以外から"
"アクセスできません。 アーキテクチャ依存のコードをできるだけ隠したいため、アセ"
"ンブリ関連のコードは `asm.zig` にまとめて隠していきます。"
msgstr ""
"`serial.zig` は `pub` なので `arch.serial` として上位ディレクトリからアクセス"
"できます。 `asm.zig` は `pub` がついていないため、`arch` ディレクトリ以外から"
"アクセスできません。 アーキテクチャ依存のコードをできるだけ隠したいため、アセ"
"ンブリ関連のコードは `asm.zig` にまとめて隠していきます。"

#: src/kernel/serial_output.md:68
msgid "`ymir` モジュールの作成"
msgstr "`ymir` モジュールの作成"

#: src/kernel/serial_output.md:70
msgid ""
"現在のところ、`ymir/hoge/fuga.zig` から `ymir/piyo/neko.zig` を参照するために"
"は、 以下のように相対パスで指定する必要があります:"
msgstr ""
"現在のところ、`ymir/hoge/fuga.zig` から `ymir/piyo/neko.zig` を参照するために"
"は、 以下のように相対パスで指定する必要があります:"

#: src/kernel/serial_output.md:78
msgid ""
"これは見た目が気持ち悪いだけではなく、以下のように **誤って秘匿したいモジュー"
"ルを参照してしまう可能性** があります:"
msgstr ""
"これは見た目が気持ち悪いだけではなく、以下のように **誤って秘匿したいモジュー"
"ルを参照してしまう可能性** があります:"

#: src/kernel/serial_output.md:85
msgid ""
"これを防ぐため、ルートモジュールを作成し、**全てのモジュールはルートモジュー"
"ルを経由してアクセスさせる** ことにします。 モジュールの作成は Surtr のときと"
"同様に `build.zig` で定義します:"
msgstr ""
"これを防ぐため、ルートモジュールを作成し、**全てのモジュールはルートモジュー"
"ルを経由してアクセスさせる** ことにします。 モジュールの作成は Surtr のときと"
"同様に `build.zig` で定義します:"

#: src/kernel/serial_output.md:97
msgid "定義した `ymir` モジュールを `ymir` 実行ファイルに追加します:"
msgstr "定義した `ymir` モジュールを `ymir` 実行ファイルに追加します:"

#: src/kernel/serial_output.md:104
msgid ""
"これで、`@import(\"ymir\")` のようにモジュール名で Ymir モジュールを import "
"できるようになりました。 モジュールのルートである `ymir/ymir.zig` は、必要な"
"全ての子モジュールを export します:"
msgstr ""
"これで、`@import(\"ymir\")` のようにモジュール名で Ymir モジュールを import "
"できるようになりました。 モジュールのルートである `ymir/ymir.zig` は、必要な"
"全ての子モジュールを export します:"

#: src/kernel/serial_output.md:112
msgid ""
"これで、全てのファイルから `@import(\"ymir\").arch` のようにして `arch/x86/"
"arch.zig` にアクセスできるようになりました。 試しに、`arch/x86/arch.zig` で適"
"当な関数を定義して `main.zig` からアクセスしてみましょう:"
msgstr ""
"これで、全てのファイルから `@import(\"ymir\").arch` のようにして `arch/x86/"
"arch.zig` にアクセスできるようになりました。 試しに、`arch/x86/arch.zig` で適"
"当な関数を定義して `main.zig` からアクセスしてみましょう:"

#: src/kernel/serial_output.md:126
msgid ""
"`std` と同じノリで `ymir` モジュールにアクセスできますね。 これ以降は意図しな"
"い import を防ぐため、**同一ディレクトリ以外のファイルを相対パスを使って直接 "
"import することは原則禁止**とします。"
msgstr ""
"`std` と同じノリで `ymir` モジュールにアクセスできますね。 これ以降は意図しな"
"い import を防ぐため、**同一ディレクトリ以外のファイルを相対パスを使って直接 "
"import することは原則禁止**とします。"

#: src/kernel/serial_output.md:131
#, fuzzy
#| msgid ""
#| "\\[!TIP\\] ymir への ymir の追加 Zig に馴染みがない人は、`ymir` "
#| "executable に `ymir` モジュールを追加するというのは気持ち悪いかもしれませ"
#| "ん。 筆者も当初は違和感を感じたため [Ziggit](https://ziggit.dev/) で聞いて"
#| "みたところ、このような書き方は合法なのは勿論、自然であるとのことでした"
#| "[^self-dependent]。"
msgid ""
"Zig に馴染みがない人は、`ymir` executable に `ymir` モジュールを追加するとい"
"うのは気持ち悪いかもしれません。 筆者も当初は違和感を感じたため [Ziggit]"
"(https://ziggit.dev/) で聞いてみたところ、このような書き方は合法なのは勿論、"
"自然であるとのことでした[^self-dependent]。"
msgstr ""
"\\[!TIP\\] ymir への ymir の追加 Zig に馴染みがない人は、`ymir` executable "
"に `ymir` モジュールを追加するというのは気持ち悪いかもしれません。 筆者も当初"
"は違和感を感じたため [Ziggit](https://ziggit.dev/) で聞いてみたところ、このよ"
"うな書き方は合法なのは勿論、自然であるとのことでした[^self-dependent]。"

#: src/kernel/serial_output.md:134
msgid "シリアルの基本の定義"
msgstr "シリアルの基本の定義"

#: src/kernel/serial_output.md:136
msgid ""
"今回想定するのは [8250 UART](https://en.wikipedia.org/wiki/8250_UART) です。 "
"入力と出力のどちらもできますが、このチャプターでは出力のみを扱います。"
msgstr ""
"今回想定するのは [8250 UART](https://en.wikipedia.org/wiki/8250_UART) です。 "
"入力と出力のどちらもできますが、このチャプターでは出力のみを扱います。"

#: src/kernel/serial_output.md:139
msgid ""
"シリアルポートにおける定数や構造体を定義していきます。 まずは COM ポートで"
"す。 COM ポートは I/O port を介してアクセスします。 COM ポートと I/O port の"
"対応関係を定義するため、`ymir/arch/x86/serial.zig` を作成します:"
msgstr ""
"シリアルポートにおける定数や構造体を定義していきます。 まずは COM ポートで"
"す。 COM ポートは I/O port を介してアクセスします。 COM ポートと I/O port の"
"対応関係を定義するため、`ymir/arch/x86/serial.zig` を作成します:"

#: src/kernel/serial_output.md:154
msgid ""
"今回は4つだけポートを定義します。 実際のハードウェアによってはもっと多いかも"
"しれませんし、もっと少ないかもしれません。 Ymir では COM1 だけを使います。"
msgstr ""
"今回は4つだけポートを定義します。 実際のハードウェアによってはもっと多いかも"
"しれませんし、もっと少ないかもしれません。 Ymir では COM1 だけを使います。"

#: src/kernel/serial_output.md:158
msgid ""
"各ポートはそれぞれのデータレジスタを持っています。 **データレジスタへは COM "
"ポートをベースとしたオフセットでアクセスします**:"
msgstr ""
"各ポートはそれぞれのデータレジスタを持っています。 **データレジスタへは COM "
"ポートをベースとしたオフセットでアクセスします**:"

#: src/kernel/serial_output.md:191
msgid ""
"実際には、オフセット・アクセスが read/write のどちらなのか・その時の "
"**DLAB** の値 の3要素によってアクセスするレジスタが異なります。 どのような場"
"合にどのレジスタにアクセスするのかは、`offsets` 内のコメントまたは参考文献"
"[^serial]を参照してください。"
msgstr ""
"実際には、オフセット・アクセスが read/write のどちらなのか・その時の "
"**DLAB** の値 の3要素によってアクセスするレジスタが異なります。 どのような場"
"合にどのレジスタにアクセスするのかは、`offsets` 内のコメントまたは参考文献"
"[^serial]を参照してください。"

#: src/kernel/serial_output.md:194 src/kernel/general_allocator.md:102
msgid "初期化"
msgstr "初期化"

#: src/kernel/serial_output.md:196
msgid ""
"シリアルの初期化を行います。 COM ポートへのアクセスは、対応する I/O port へ"
"の [IN](https://www.felixcloutier.com/x86/in) / [OUT](https://www."
"felixcloutier.com/x86/out) 命令を使っておこないます。 必要なアセンブリ命令を"
"定義しましょう:"
msgstr ""
"シリアルの初期化を行います。 COM ポートへのアクセスは、対応する I/O port へ"
"の [IN](https://www.felixcloutier.com/x86/in) / [OUT](https://www."
"felixcloutier.com/x86/out) 命令を使っておこないます。 必要なアセンブリ命令を"
"定義しましょう:"

#: src/kernel/serial_output.md:220
msgid ""
"この関数を利用して I/O port に読み書きし、シリアルを初期化します。 以下の表の"
"ようにレジスタを設定します[^am]。 なお、各レジスタは全て 8bit です:"
msgstr ""
"この関数を利用して I/O port に読み書きし、シリアルを初期化します。 以下の表の"
"ようにレジスタを設定します[^am]。 なお、各レジスタは全て 8bit です:"

#: src/kernel/serial_output.md:224
msgid "Register"
msgstr "Register"

#: src/kernel/serial_output.md:224
msgid "Value"
msgstr "Value"

#: src/kernel/serial_output.md:226
msgid "**LCR** (Line Control)"
msgstr "**LCR** (Line Control)"

#: src/kernel/serial_output.md:226
msgid "Line Protocol"
msgstr "Line Protocol"

#: src/kernel/serial_output.md:226
msgid "**8n1** (8 data bit / No parity / 1 stop bits)"
msgstr "**8n1** (8 data bit / No parity / 1 stop bits)"

#: src/kernel/serial_output.md:227
msgid "**IER** (Interrupt Enable)"
msgstr "**IER** (Interrupt Enable)"

#: src/kernel/serial_output.md:227
msgid "有効化する割り込み"
msgstr "有効化する割り込み"

#: src/kernel/serial_output.md:227
msgid "0 (全ての割り込みを無効化)"
msgstr "0 (全ての割り込みを無効化)"

#: src/kernel/serial_output.md:228
msgid "**FCR** (FIFO Control)"
msgstr "**FCR** (FIFO Control)"

#: src/kernel/serial_output.md:228
msgid "FIFO バッファ"
msgstr "FIFO バッファ"

#: src/kernel/serial_output.md:228
msgid "0 (FIFO を無効化)"
msgstr "0 (FIFO を無効化)"

#: src/kernel/serial_output.md:243
msgid ""
"続いて、[Baud Rate](https://en.wikipedia.org/wiki/Baud) を設定します。 Baud "
"Rate はその信号線に1秒間に送信されるビット数です。 各文字データの前には "
"**Start Bit** が、後には **Stop Bit** (今回は`1`)が付加されます。 そのため "
"8n1 の場合、1文字 (8bit) を送信するのに必要なビット数は 10 です。 送信した"
"ビット数の 80% がデータとなります。 安定して送信できる最大の Baud Rate は "
"`115200` らしいので、Ymir でもこの値を使います。"
msgstr ""
"続いて、[Baud Rate](https://en.wikipedia.org/wiki/Baud) を設定します。 Baud "
"Rate はその信号線に1秒間に送信されるビット数です。 各文字データの前には "
"**Start Bit** が、後には **Stop Bit** (今回は`1`)が付加されます。 そのため "
"8n1 の場合、1文字 (8bit) を送信するのに必要なビット数は 10 です。 送信した"
"ビット数の 80% がデータとなります。 安定して送信できる最大の Baud Rate は "
"`115200` らしいので、Ymir でもこの値を使います。"

#: src/kernel/serial_output.md:250
msgid ""
"UART は `115200`/sec で動作するクロックを持っています。 UEFI はこのクロック周"
"波数を、**Divisor** として設定された値で割ることで Baud Rate を計算します:"
msgstr ""
"UART は `115200`/sec で動作するクロックを持っています。 UEFI はこのクロック周"
"波数を、**Divisor** として設定された値で割ることで Baud Rate を計算します:"

#: src/kernel/serial_output.md:253
msgid "\\\\\\[ \\text{Baud Rate} = \\frac{115200} { \\text{Divisor} } \\\\\\]"
msgstr "\\\\\\[ \\text{Baud Rate} = \\frac{115200} { \\text{Divisor} } \\\\\\]"

#: src/kernel/serial_output.md:255
msgid ""
"よって、Baud Rate として \\\\(\\text{B}\\\\) を設定したい場合には、以下のよう"
"に Divisor を計算します:"
msgstr ""
"よって、Baud Rate として \\\\(\\text{B}\\\\) を設定したい場合には、以下のよう"
"に Divisor を計算します:"

#: src/kernel/serial_output.md:257
msgid "\\\\\\[ \\text{Divisor} = \\frac{115200} { \\text{B} } \\\\\\]"
msgstr "\\\\\\[ \\text{Divisor} = \\frac{115200} { \\text{B} } \\\\\\]"

#: src/kernel/serial_output.md:259
msgid "以下のように Baud Rate を設定します:"
msgstr "以下のように Baud Rate を設定します:"

#: src/kernel/serial_output.md:274
msgid ""
"LCR 中の _DLAB: Divisor Latch Access Bit_ をセットすると、 _DLL: Divisor "
"Latch Low_ と _DLH: Divisor Latch High_ にアクセスできるようになります。 "
"DLAB をセットしたあとで、計算した `divisor` の下位・上位バイトをそれぞれ DLL "
"と DLM に書き込みます。 `c` は DLAB を設定する前の LCR の値であり、divisor の"
"設定後に LCR を復元するのに使っています。"
msgstr ""
"LCR 中の _DLAB: Divisor Latch Access Bit_ をセットすると、 _DLL: Divisor "
"Latch Low_ と _DLH: Divisor Latch High_ にアクセスできるようになります。 "
"DLAB をセットしたあとで、計算した `divisor` の下位・上位バイトをそれぞれ DLL "
"と DLM に書き込みます。 `c` は DLAB を設定する前の LCR の値であり、divisor の"
"設定後に LCR を復元するのに使っています。"

#: src/kernel/serial_output.md:279
msgid "文字の書き込み"
msgstr "文字の書き込み"

#: src/kernel/serial_output.md:281
msgid "続いて、初期化したシリアルになにか文字を書き込んでみます。"
msgstr "続いて、初期化したシリアルになにか文字を書き込んでみます。"

#: src/kernel/serial_output.md:283
msgid ""
"シリアルに書き込むためには、**TX-buffer** が空になるのを待つ必要があります。 "
"TX-buffer が空なのかどうかは、 **LSR: Line Status Register** の _THRE: "
"Transmitter Holding Register Empty_ ビットで確認できます。 もしも空でなかった"
"場合には、空になるまで待ちます:"
msgstr ""
"シリアルに書き込むためには、**TX-buffer** が空になるのを待つ必要があります。 "
"TX-buffer が空なのかどうかは、 **LSR: Line Status Register** の _THRE: "
"Transmitter Holding Register Empty_ ビットで確認できます。 もしも空でなかった"
"場合には、空になるまで待ちます:"

#: src/kernel/serial_output.md:302
msgid ""
"`LSR[5]` が THRE であるため、これがセットされる、すなわち TX-buffer が空にな"
"るまで待ちます。 `am.relax()` は `rep; nop` をするアセンブリ関数です。 少しだ"
"けCPUを休ませるために使います。"
msgstr ""
"`LSR[5]` が THRE であるため、これがセットされる、すなわち TX-buffer が空にな"
"るまで待ちます。 `am.relax()` は `rep; nop` をするアセンブリ関数です。 少しだ"
"けCPUを休ませるために使います。"

#: src/kernel/serial_output.md:306
msgid ""
"TX-buffer が空になったら、引数で渡された `byte` を COM ポートに書き込みま"
"す。 COM ポートからのオフセット `0` が TX-buffer に対応しているため、ポート番"
"号に対してそのまま `am.outb(byte, @intFromEnum(port))` で書き込むことができま"
"す。"
msgstr ""
"TX-buffer が空になったら、引数で渡された `byte` を COM ポートに書き込みま"
"す。 COM ポートからのオフセット `0` が TX-buffer に対応しているため、ポート番"
"号に対してそのまま `am.outb(byte, @intFromEnum(port))` で書き込むことができま"
"す。"

#: src/kernel/serial_output.md:309
msgid ""
"実際に文字を書き込めるかどうか確認してみましょう。 `main.zig` に実験コードを"
"追加します。 Surtr のログとは違って、出力は USC-2 ではなく単なる ASCII 文字で"
"問題ないです:"
msgstr ""
"実際に文字を書き込めるかどうか確認してみましょう。 `main.zig` に実験コードを"
"追加します。 Surtr のログとは違って、出力は USC-2 ではなく単なる ASCII 文字で"
"問題ないです:"

#: src/kernel/serial_output.md:323
msgid "実行してみて、`Hello, Ymir!` が表示されれば成功です。"
msgstr "実行してみて、`Hello, Ymir!` が表示されれば成功です。"

#: src/kernel/serial_output.md:325
msgid "`Serial` ラッパークラス"
msgstr "`Serial` ラッパークラス"

#: src/kernel/serial_output.md:327
msgid ""
"シリアル出力はできるようになったものの、`Hello, Ymir!` という文字列を書き込む"
"ためだけにわざわざ `for` ループするのはめんどうです。 また、`arch` 以下のファ"
"イルを直接呼び出すのも少しアーキ依存が強すぎる気がします。 というわけで、生の"
"シリアルをラップする `Serial` 構造体を作成します。"
msgstr ""
"シリアル出力はできるようになったものの、`Hello, Ymir!` という文字列を書き込む"
"ためだけにわざわざ `for` ループするのはめんどうです。 また、`arch` 以下のファ"
"イルを直接呼び出すのも少しアーキ依存が強すぎる気がします。 というわけで、生の"
"シリアルをラップする `Serial` 構造体を作成します。"

#: src/kernel/serial_output.md:331
msgid ""
"`arch/x86/serial.zig` を抽象化するため、ルート直下に `ymir/serial.zig` を作成"
"します:"
msgstr ""
"`arch/x86/serial.zig` を抽象化するため、ルート直下に `ymir/serial.zig` を作成"
"します:"

#: src/kernel/serial_output.md:349
msgid ""
"`Serial` は、シリアル出力・入力用にそれぞれ `_write_fn` と `_read_fn` という"
"関数ポインタを持ちます[^input]。 `Serial` は以下のように Baud Rate を "
"`115200` としてインスタンス化します:"
msgstr ""
"`Serial` は、シリアル出力・入力用にそれぞれ `_write_fn` と `_read_fn` という"
"関数ポインタを持ちます[^input]。 `Serial` は以下のように Baud Rate を "
"`115200` としてインスタンス化します:"

#: src/kernel/serial_output.md:361
msgid ""
"空の `Serial` 構造体を作ったあと、`initSerial()` に渡しています。 先ほど実装"
"した `initSerial()` を修正し第1引数として `*Serial` を受け取れるように変更し"
"ます。 受け取った `*Serial` 内の関数ポインタ `_write_fn` に対し、適切な出力関"
"数を設定します:"
msgstr ""
"空の `Serial` 構造体を作ったあと、`initSerial()` に渡しています。 先ほど実装"
"した `initSerial()` を修正し第1引数として `*Serial` を受け取れるように変更し"
"ます。 受け取った `*Serial` 内の関数ポインタ `_write_fn` に対し、適切な出力関"
"数を設定します:"

#: src/kernel/serial_output.md:378
msgid ""
"`writeByteComN()` は `Port` に対応する COM ポートに出力するためのヘルパー関数"
"で、実体は先ほど実装した `writeByte()` です:"
msgstr ""
"`writeByteComN()` は `Port` に対応する COM ポートに出力するためのヘルパー関数"
"で、実体は先ほど実装した `writeByte()` です:"

#: src/kernel/serial_output.md:388
msgid ""
"これで `Serial` に出力用の関数を設定できました。 利用者側からは使いやすいよう"
"に、1文字だけを出力するための関数と文字列を出力する関数を提供しましょう:"
msgstr ""
"これで `Serial` に出力用の関数を設定できました。 利用者側からは使いやすいよう"
"に、1文字だけを出力するための関数と文字列を出力する関数を提供しましょう:"

#: src/kernel/serial_output.md:406
msgid ""
"本チャプターでは、シリアル出力をするための基本的な機能を実装しました。 また、"
"アーキテクチャに強く依存する部分を `arch` ディレクトリに分離し、それを抽象化"
"する `Serial` 構造体を作成しました。 `main.zig` において、以下のように初期化"
"して使ってみます:"
msgstr ""
"本チャプターでは、シリアル出力をするための基本的な機能を実装しました。 また、"
"アーキテクチャに強く依存する部分を `arch` ディレクトリに分離し、それを抽象化"
"する `Serial` 構造体を作成しました。 `main.zig` において、以下のように初期化"
"して使ってみます:"

#: src/kernel/serial_output.md:416
msgid "実行すると以下のように `Hello, Ymir!` が表示されるはずです:"
msgstr "実行すると以下のように `Hello, Ymir!` が表示されるはずです:"

#: src/kernel/serial_output.md:438
msgid ""
"本チャプターで実装したシリアル出力を利用して、Surtr で実装したのと同様なログ"
"システムを作ることができます。 次のチャプターでは一旦ビット演算を補助するライ"
"ブラリを作成し、その次のチャプターでログシステムの実装をしていくことにしま"
"す。"
msgstr ""
"本チャプターで実装したシリアル出力を利用して、Surtr で実装したのと同様なログ"
"システムを作ることができます。 次のチャプターでは一旦ビット演算を補助するライ"
"ブラリを作成し、その次のチャプターでログシステムの実装をしていくことにしま"
"す。"

#: src/kernel/serial_output.md:441 src/vmm/io.md:744
msgid "[Serial Ports - OSDev Wiki](https://wiki.osdev.org/Serial_Ports)"
msgstr "[Serial Ports - OSDev Wiki](https://wiki.osdev.org/Serial_Ports)"

#: src/kernel/serial_output.md:442
msgid ""
"[ZLS does not work for @import(“root”) when multiple artifacts are installed "
"- Ziggit](https://ziggit.dev/t/zls-does-not-work-for-import-root-when-"
"multiple-artifacts-are-installed/4190)"
msgstr ""
"[ZLS does not work for @import(“root”) when multiple artifacts are installed "
"- Ziggit](https://ziggit.dev/t/zls-does-not-work-for-import-root-when-"
"multiple-artifacts-are-installed/4190)"

#: src/kernel/serial_output.md:443
msgid ""
"コード中で `asm.zig` を `am` として import しているのは、`asm` が Zig の [予"
"約語](https://ziglang.org/documentation/master/#Keyword-Reference) であるため"
"です。"
msgstr ""
"コード中で `asm.zig` を `am` として import しているのは、`asm` が Zig の [予"
"約語](https://ziglang.org/documentation/master/#Keyword-Reference) であるため"
"です。"

#: src/kernel/serial_output.md:444
msgid "なお、シリアル入力はずっと先のチャプターで扱います。"
msgstr "なお、シリアル入力はずっと先のチャプターで扱います。"

#: src/kernel/bit_and_test.md:1
msgid "ビット演算ライブラリと Zig Test"
msgstr "ビット演算ライブラリと Zig Test"

#: src/kernel/bit_and_test.md:3
msgid ""
"本チャプターでは、ビット演算ライブラリを実装します。 ハードウェア、とりわけ "
"CPU の設定を直接行う Ymir では、ビット演算が頻繁に使われます。 Zig において"
"ビット演算はそこまで便利なシンタックスや標準ライブラリが用意されているわけで"
"はないため、自前で実装してしまいます。 また、ライブラリに対してテストを書くこ"
"とで Zig におけるテストの書き方を導入します。"
msgstr ""
"本チャプターでは、ビット演算ライブラリを実装します。 ハードウェア、とりわけ "
"CPU の設定を直接行う Ymir では、ビット演算が頻繁に使われます。 Zig において"
"ビット演算はそこまで便利なシンタックスや標準ライブラリが用意されているわけで"
"はないため、自前で実装してしまいます。 また、ライブラリに対してテストを書くこ"
"とで Zig におけるテストの書き方を導入します。"

#: src/kernel/bit_and_test.md:10
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-bit_and_test`]"
#| "(https://github.com/smallkirby/ymir/tree/whiz-ymir-bit_and_test) ブランチ"
#| "にあります。"
msgid ""
"本チャプターの最終コードは [`whiz-ymir-bit_and_test`](https://github.com/"
"smallkirby/ymir/tree/whiz-ymir-bit_and_test) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-bit_and_test`]"
"(https://github.com/smallkirby/ymir/tree/whiz-ymir-bit_and_test) ブランチにあ"
"ります。"

#: src/kernel/bit_and_test.md:14
msgid "[ビット演算ライブラリ](#ビット演算ライブラリ)"
msgstr "[ビット演算ライブラリ](#ビット演算ライブラリ)"

#: src/kernel/bit_and_test.md:15
msgid "[特定のビットを立てる](#特定のビットを立てる)"
msgstr "[特定のビットを立てる](#特定のビットを立てる)"

#: src/kernel/bit_and_test.md:16
msgid ""
"[特定のビットが立っているか確認する](#特定のビットが立っているか確認する)"
msgstr ""
"[特定のビットが立っているか確認する](#特定のビットが立っているか確認する)"

#: src/kernel/bit_and_test.md:17
msgid "[2つの整数を連結する](#2つの整数を連結する)"
msgstr "[2つの整数を連結する](#2つの整数を連結する)"

#: src/kernel/bit_and_test.md:18
msgid "[テストの作成](#テストの作成)"
msgstr "[テストの作成](#テストの作成)"

#: src/kernel/bit_and_test.md:19
msgid "[ビルド設定](#ビルド設定)"
msgstr "[ビルド設定](#ビルド設定)"

#: src/kernel/bit_and_test.md:20
msgid "[テストの定義](#テストの定義)"
msgstr "[テストの定義](#テストの定義)"

#: src/kernel/bit_and_test.md:23
msgid "ビット演算ライブラリ"
msgstr "ビット演算ライブラリ"

#: src/kernel/bit_and_test.md:25
msgid ""
"`bits.zig` というファイルを作成したあと、`ymir.zig` において `pub` 指定しま"
"す:"
msgstr ""
"`bits.zig` というファイルを作成したあと、`ymir.zig` において `pub` 指定しま"
"す:"

#: src/kernel/bit_and_test.md:32
msgid ""
"これにより、`bits.zig` に実装した関数を任意のファイルから以下のようにして呼び"
"出すことができます:"
msgstr ""
"これにより、`bits.zig` に実装した関数を任意のファイルから以下のようにして呼び"
"出すことができます:"

#: src/kernel/bit_and_test.md:42
msgid "特定のビットを立てる"
msgstr "特定のビットを立てる"

#: src/kernel/bit_and_test.md:44
msgid ""
"最初に実装するのは、ある整数 `N` を受取り、`N`番目のビットのみを立てた整数値"
"を返す `tobit()` 関数です。 使いみちとしては、IRQ の3番の割り込みを無効化した"
"い場合に `0b0000_1000` というマスクを作成したいような場合です。 愚直に実装す"
"ると `1 << N` ですが、Zig ではそう簡単には行きません。 `1`の型を明示する必要"
"があったり、`N`がシフトを許されている値の範囲内であるかをチェックする必要があ"
"るなど、想定以上にコード行数が増えてしまいます。 また、`N` が `enum` である場"
"合には都度 `@intFromEnum()` を呼び出す必要があります。 `tobit()` 関数はこれら"
"の煩雑な部分を隠蔽することを目的としています。"
msgstr ""
"最初に実装するのは、ある整数 `N` を受取り、`N`番目のビットのみを立てた整数値"
"を返す `tobit()` 関数です。 使いみちとしては、IRQ の3番の割り込みを無効化した"
"い場合に `0b0000_1000` というマスクを作成したいような場合です。 愚直に実装す"
"ると `1 << N` ですが、Zig ではそう簡単には行きません。 `1`の型を明示する必要"
"があったり、`N`がシフトを許されている値の範囲内であるかをチェックする必要があ"
"るなど、想定以上にコード行数が増えてしまいます。 また、`N` が `enum` である場"
"合には都度 `@intFromEnum()` を呼び出す必要があります。 `tobit()` 関数はこれら"
"の煩雑な部分を隠蔽することを目的としています。"

#: src/kernel/bit_and_test.md:51
msgid "`tobit()` は任意の型 `T` に対して呼び出せるようにします:"
msgstr "`tobit()` は任意の型 `T` に対して呼び出せるようにします:"

#: src/kernel/bit_and_test.md:65
msgid ""
"最初の `switch` で `T` の型によって処理を分岐します。 現在対応しているのは整"
"数値と enum の2つです。 enum であった場合には `@intFromEnum()` を呼び出して整"
"数値に変換します。 最後に、変換後の整数値分だけ `1` をシフトさせれば完了で"
"す。"
msgstr ""
"最初の `switch` で `T` の型によって処理を分岐します。 現在対応しているのは整"
"数値と enum の2つです。 enum であった場合には `@intFromEnum()` を呼び出して整"
"数値に変換します。 最後に、変換後の整数値分だけ `1` をシフトさせれば完了で"
"す。"

#: src/kernel/bit_and_test.md:70
msgid "この関数は以下のように利用できます:"
msgstr "この関数は以下のように利用できます:"

#: src/kernel/bit_and_test.md:81
#, fuzzy
#| msgid ""
#| "\\[!TIP\\] シフトと型 `@as(T, 1) << N` において、例えば `T` が `u8` である"
#| "場合には、オーバーフロー無しでシフトできる `N` の最大値は `7` です。 よっ"
#| "て、**Zig は `N` が `u3` よりも小さい整数型であることを要求します**。 "
#| "`@intCast(N)` は、`N` が `u3`型にキャストできるかどうかを実行時にチェック"
#| "してくれるため、コンパイルエラーを防ぐことができます。"
msgid ""
"`@as(T, 1) << N` において、例えば `T` が `u8` である場合には、オーバーフロー"
"無しでシフトできる `N` の最大値は `7` です。 よって、**Zig は `N` が `u3` よ"
"りも小さい整数型であることを要求します**。 `@intCast(N)` は、`N` が `u3`型に"
"キャストできるかどうかを実行時にチェックしてくれるため、コンパイルエラーを防"
"ぐことができます。"
msgstr ""
"\\[!TIP\\] シフトと型 `@as(T, 1) << N` において、例えば `T` が `u8` である場"
"合には、オーバーフロー無しでシフトできる `N` の最大値は `7` です。 よって、"
"**Zig は `N` が `u3` よりも小さい整数型であることを要求します**。 "
"`@intCast(N)` は、`N` が `u3`型にキャストできるかどうかを実行時にチェックして"
"くれるため、コンパイルエラーを防ぐことができます。"

#: src/kernel/bit_and_test.md:85
msgid "特定のビットが立っているか確認する"
msgstr "特定のビットが立っているか確認する"

#: src/kernel/bit_and_test.md:87
msgid ""
"続いて、ある整数値において特定のビットが立っているかを確認する `isset()` 関数"
"を実装します:"
msgstr ""
"続いて、ある整数値において特定のビットが立っているかを確認する `isset()` 関数"
"を実装します:"

#: src/kernel/bit_and_test.md:101
msgid ""
"ほとんど `tobit()` と同じです。 ただし、左シフトとは異なり右シフトでは `val` "
"の整数型が何であろうとOKであるため、`T` を引数に取る必要がありません。"
msgstr ""
"ほとんど `tobit()` と同じです。 ただし、左シフトとは異なり右シフトでは `val` "
"の整数型が何であろうとOKであるため、`T` を引数に取る必要がありません。"

#: src/kernel/bit_and_test.md:104
msgid "2つの整数を連結する"
msgstr "2つの整数を連結する"

#: src/kernel/bit_and_test.md:106
msgid ""
"`u32` 型の整数 `a` と `b` を受け取り、それらを連結して`u64`型の整数をつくりた"
"いということもしばしばあります。 例として、[WRMSR](https://www.felixcloutier."
"com/x86/wrmsr) 命令は EDX と EAX を連結した値を MSR に書き込みます。 普通に書"
"くと `@as(u64, a) << 32 | @as(u64, b)` となりますが、やはり少々煩雑なコードに"
"なります。 `concat()` 関数はこのような操作を隠蔽します:"
msgstr ""
"`u32` 型の整数 `a` と `b` を受け取り、それらを連結して`u64`型の整数をつくりた"
"いということもしばしばあります。 例として、[WRMSR](https://www.felixcloutier."
"com/x86/wrmsr) 命令は EDX と EAX を連結した値を MSR に書き込みます。 普通に書"
"くと `@as(u64, a) << 32 | @as(u64, b)` となりますが、やはり少々煩雑なコードに"
"なります。 `concat()` 関数はこのような操作を隠蔽します:"

#: src/kernel/bit_and_test.md:126
msgid ""
"今までよりも少しだけ複雑ですね。 `b` の型を `@TypeOf(a)` とすることで、引数"
"の `a` と `b` が同じ型を持つことを強制します。 `anytype` の型は自動的に "
"`comptime` になるため、引数の型として他の引数の型を `@TypeOf()` で指定できま"
"す。 また、最終的に生成する型 `T`の幅 (`width_T`) は `a` と `b` の型の幅の2"
"倍 (`width_U`) である必要があります。 もしもそうでない場合には "
"`@compileError()` でコンパイルエラーを発生させます。 この関数は enum には対応"
"していません。"
msgstr ""
"今までよりも少しだけ複雑ですね。 `b` の型を `@TypeOf(a)` とすることで、引数"
"の `a` と `b` が同じ型を持つことを強制します。 `anytype` の型は自動的に "
"`comptime` になるため、引数の型として他の引数の型を `@TypeOf()` で指定できま"
"す。 また、最終的に生成する型 `T`の幅 (`width_T`) は `a` と `b` の型の幅の2"
"倍 (`width_U`) である必要があります。 もしもそうでない場合には "
"`@compileError()` でコンパイルエラーを発生させます。 この関数は enum には対応"
"していません。"

#: src/kernel/bit_and_test.md:133
msgid "以下のように利用できます:"
msgstr "以下のように利用できます:"

#: src/kernel/bit_and_test.md:142
msgid "テストの作成"
msgstr "テストの作成"

#: src/kernel/bit_and_test.md:144
msgid ""
"このようなライブラリを作ると、テストを書きたくなるのが人のサガというもので"
"す。"
msgstr ""
"このようなライブラリを作ると、テストを書きたくなるのが人のサガというもので"
"す。"

#: src/kernel/bit_and_test.md:146
msgid ""
"Surtr や Ymir 全体に対してテストを書くというのは簡単なことではありません。 と"
"いうのも、**ベアメタルで動作する Surtr や Ymir はユーザランドでテストできない"
"**からです。 テストをしたい場合には、実行時にとある条件を満たしているかを "
"assert してテストするくらいしかありません。 本シリーズでは、そのようなアーキ"
"テクチャ依存のコードを含む実行ファイルのテストは扱いません。 興味がある人は自"
"前で実装してみてください。"
msgstr ""
"Surtr や Ymir 全体に対してテストを書くというのは簡単なことではありません。 と"
"いうのも、**ベアメタルで動作する Surtr や Ymir はユーザランドでテストできない"
"**からです。 テストをしたい場合には、実行時にとある条件を満たしているかを "
"assert してテストするくらいしかありません。 本シリーズでは、そのようなアーキ"
"テクチャ依存のコードを含む実行ファイルのテストは扱いません。 興味がある人は自"
"前で実装してみてください。"

#: src/kernel/bit_and_test.md:154
#, fuzzy
#| msgid ""
#| "\\[!INFO\\] ランタイムテスト Zig では実行ファイルをテスト用にビルドすると "
#| "`@import(\"builtin\").is_test` の値が `true` になります。 この値を `ymir."
#| "zig` で export することで、ランタイムテストをしたいファイルから容易に参照"
#| "できるようになります:"
msgid ""
"Zig では実行ファイルをテスト用にビルドすると `@import(\"builtin\").is_test` "
"の値が `true` になります。 この値を `ymir.zig` で export することで、ランタイ"
"ムテストをしたいファイルから容易に参照できるようになります:"
msgstr ""
"\\[!INFO\\] ランタイムテスト Zig では実行ファイルをテスト用にビルドすると "
"`@import(\"builtin\").is_test` の値が `true` になります。 この値を `ymir."
"zig` で export することで、ランタイムテストをしたいファイルから容易に参照でき"
"るようになります:"

#: src/kernel/bit_and_test.md:162
msgid ""
"ランタイムテストをしたい場合には、 `if (ymir.is_test) { ... }` というように条"
"件分岐を行います。 この条件分岐はコンパイル時に評価されるため、非テスト用の実"
"行ファイルでオーバーヘッドは発生しません。"
msgstr ""
"ランタイムテストをしたい場合には、 `if (ymir.is_test) { ... }` というように条"
"件分岐を行います。 この条件分岐はコンパイル時に評価されるため、非テスト用の実"
"行ファイルでオーバーヘッドは発生しません。"

#: src/kernel/bit_and_test.md:165
msgid ""
"一方で、今回実装したライブラリのようなコードに対してテストを書くことは容易で"
"す。 アーキテクチャ依存のコードを持たないため、ユーザランドで実行できます。 "
"以下では、`bits.zig` に対してユニットテストを書いてみます。"
msgstr ""
"一方で、今回実装したライブラリのようなコードに対してテストを書くことは容易で"
"す。 アーキテクチャ依存のコードを持たないため、ユーザランドで実行できます。 "
"以下では、`bits.zig` に対してユニットテストを書いてみます。"

#: src/kernel/bit_and_test.md:169
msgid "ビルド設定"
msgstr "ビルド設定"

#: src/kernel/bit_and_test.md:171
msgid "まずは Ymir のユニットテスト用のビルドターゲットを追加します:"
msgstr "まずは Ymir のユニットテスト用のビルドターゲットを追加します:"

#: src/kernel/bit_and_test.md:185
msgid ""
"テストにおけるルートファイルは `ymir/ymir.zig` とします。 `.target` は Ymir "
"executable とは異なりホストOSのユーザランドで動かせばよいため、 デフォルトで"
"ある `b.standardTargetOptions(.{})` を指定します。 また、依存として Ymir モ"
"ジュールを指定します。"
msgstr ""
"テストにおけるルートファイルは `ymir/ymir.zig` とします。 `.target` は Ymir "
"executable とは異なりホストOSのユーザランドで動かせばよいため、 デフォルトで"
"ある `b.standardTargetOptions(.{})` を指定します。 また、依存として Ymir モ"
"ジュールを指定します。"

#: src/kernel/bit_and_test.md:190
msgid ""
"これは Ymir のユニットテスト用ターゲットを追加しただけであり、まだ実行するた"
"めのターゲットがありません。 実行するためのターゲットも追加します:"
msgstr ""
"これは Ymir のユニットテスト用ターゲットを追加しただけであり、まだ実行するた"
"めのターゲットがありません。 実行するためのターゲットも追加します:"

#: src/kernel/bit_and_test.md:200
msgid ""
"これにより、`test` というターゲットを指定することでユニットテストを実行できる"
"ようになります。"
msgstr ""
"これにより、`test` というターゲットを指定することでユニットテストを実行できる"
"ようになります。"

#: src/kernel/bit_and_test.md:202
msgid "テストの定義"
msgstr "テストの定義"

#: src/kernel/bit_and_test.md:204
msgid ""
"Zig において、テストは [`test {}`](https://ziglang.org/documentation/master/"
"#Zig-Test) ブロック内に記述します。 例として、`tobit()` に対するテストを書い"
"てみます:"
msgstr ""
"Zig において、テストは [`test {}`](https://ziglang.org/documentation/master/"
"#Zig-Test) ブロック内に記述します。 例として、`tobit()` に対するテストを書い"
"てみます:"

#: src/kernel/bit_and_test.md:218
msgid "テストを実行してみましょう:"
msgstr "テストを実行してみましょう:"

#: src/kernel/bit_and_test.md:229
msgid ""
"非常に分かりにくいですが、**実はテストは1つも実行されていません**...。 現段階"
"の Zig は、実行されたテストの一覧を表示する簡単な方法がありません。 そのせい"
"で、テストが実行されているかどうかを確認するのがぱっと見で分かりにくいという"
"問題があります。"
msgstr ""
"非常に分かりにくいですが、**実はテストは1つも実行されていません**...。 現段階"
"の Zig は、実行されたテストの一覧を表示する簡単な方法がありません。 そのせい"
"で、テストが実行されているかどうかを確認するのがぱっと見で分かりにくいという"
"問題があります。"

#: src/kernel/bit_and_test.md:233
msgid ""
"それはさておき、**テストが実行されていない理由は `bits.zig` 自体が評価されて"
"いないから**です。 Zig では、「あらゆるものは参照されるまで評価されない」とい"
"う原則があります。 今回の場合、ユニットテストのルートファイルである `ymir."
"zig` から `bits.zig` が参照されていません。 `@import(\"bits.zig\")` はされて"
"いますが、実際にその中身が利用されていないため、Zig はこのファイルを評価しま"
"せん。 その証拠に、`bits.zig` の末尾などに `hogehoge` という明らかに不正な"
"コードを追加して `zig build test` してもエラーになりません。 **参照されていな"
"いため評価されず、評価されない限りはどんなに不正なコードでも問題ない**という"
"ことです。"
msgstr ""
"それはさておき、**テストが実行されていない理由は `bits.zig` 自体が評価されて"
"いないから**です。 Zig では、「あらゆるものは参照されるまで評価されない」とい"
"う原則があります。 今回の場合、ユニットテストのルートファイルである `ymir."
"zig` から `bits.zig` が参照されていません。 `@import(\"bits.zig\")` はされて"
"いますが、実際にその中身が利用されていないため、Zig はこのファイルを評価しま"
"せん。 その証拠に、`bits.zig` の末尾などに `hogehoge` という明らかに不正な"
"コードを追加して `zig build test` してもエラーになりません。 **参照されていな"
"いため評価されず、評価されない限りはどんなに不正なコードでも問題ない**という"
"ことです。"

#: src/kernel/bit_and_test.md:240
msgid ""
"この原則自体は基本的に有用なものです。 実行バイナリには不要なコードが含まれ"
"ず、評価自体されないためコンパイル時間も削減できます。 しかし、ことテストに"
"限ってはこの原則が邪魔をします。 実装した関数自体はまだ利用する箇所がないけれ"
"ど、テストは実行したいという場合があるからです。"
msgstr ""
"この原則自体は基本的に有用なものです。 実行バイナリには不要なコードが含まれ"
"ず、評価自体されないためコンパイル時間も削減できます。 しかし、ことテストに"
"限ってはこの原則が邪魔をします。 実装した関数自体はまだ利用する箇所がないけれ"
"ど、テストは実行したいという場合があるからです。"

#: src/kernel/bit_and_test.md:245
msgid ""
"これに対処するため、Zig には `testing.refAllDecls()` という関数が用意されてい"
"ます。 この関数は、指定された型 (Zigではファイルも型のようなものです) で定義"
"されるフィールドを全て評価してくれます。 評価するということは、そこにあるテス"
"トも実行してくれるようになるということです。 ルートファイルである Ymir に以下"
"を追加します:"
msgstr ""
"これに対処するため、Zig には `testing.refAllDecls()` という関数が用意されてい"
"ます。 この関数は、指定された型 (Zigではファイルも型のようなものです) で定義"
"されるフィールドを全て評価してくれます。 評価するということは、そこにあるテス"
"トも実行してくれるようになるということです。 ルートファイルである Ymir に以下"
"を追加します:"

#: src/kernel/bit_and_test.md:259
msgid ""
"`refAllDeclsRecursive()` を指定したため、`@This()`で定義される全てのフィール"
"ドに加え、 そのフィールドが参照するフィールドも再帰的に評価されます。 これに"
"より、`bits.zig` にあるテストも実行されるようになります:"
msgstr ""
"`refAllDeclsRecursive()` を指定したため、`@This()`で定義される全てのフィール"
"ドに加え、 そのフィールドが参照するフィールドも再帰的に評価されます。 これに"
"より、`bits.zig` にあるテストも実行されるようになります:"

#: src/kernel/bit_and_test.md:272
msgid ""
"今度は `2 passed` という表示になりました。ちゃんとテストが実行されています。"
msgstr ""
"今度は `2 passed` という表示になりました。ちゃんとテストが実行されています。"

#: src/kernel/bit_and_test.md:276
msgid ""
"本チャプターではビット演算ライブラリを実装し、そのライブラリに対してユニット"
"テストを書く方法を扱いました。 実際にテストを書いたのは `tobit()` だけでした"
"が、それ以外の2つの関数に対してもぜひユニットテストを書いてみてください。 今"
"後本シリーズではユニットテストの実装を省略しますが、実際に開発する際には Zig "
"のテスト機能を活用するのも良いかもしれません。 以降のチャプターでは今回実装し"
"たライブラリを随所で利用していきます。"
msgstr ""
"本チャプターではビット演算ライブラリを実装し、そのライブラリに対してユニット"
"テストを書く方法を扱いました。 実際にテストを書いたのは `tobit()` だけでした"
"が、それ以外の2つの関数に対してもぜひユニットテストを書いてみてください。 今"
"後本シリーズではユニットテストの実装を省略しますが、実際に開発する際には Zig "
"のテスト機能を活用するのも良いかもしれません。 以降のチャプターでは今回実装し"
"たライブラリを随所で利用していきます。"

#: src/kernel/serial_logsystem.md:3
msgid ""
"[シリアル出力のチャプター](serial_output.md) ではシリアルポートに対して出力が"
"できるようになりました。 本チャプターでは、このシリアル出力を用いて Zig のロ"
"グシステムを実装します。 基本的には [Surtr のログ出力](../bootloader/"
"uefi_log.md) でやったことと同じになります。 そのため、本チャプターは一瞬で終"
"わります。やったね、今日は早く寝てください。"
msgstr ""
"[シリアル出力のチャプター](serial_output.md) ではシリアルポートに対して出力が"
"できるようになりました。 本チャプターでは、このシリアル出力を用いて Zig のロ"
"グシステムを実装します。 基本的には [Surtr のログ出力](../bootloader/"
"uefi_log.md) でやったことと同じになります。 そのため、本チャプターは一瞬で終"
"わります。やったね、今日は早く寝てください。"

#: src/kernel/serial_logsystem.md:10
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-serial_logsystem`]"
#| "(https://github.com/smallkirby/ymir/tree/whiz-ymir-serial_logsystem) ブラ"
#| "ンチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-ymir-serial_logsystem`](https://github.com/"
"smallkirby/ymir/tree/whiz-ymir-serial_logsystem) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-serial_logsystem`]"
"(https://github.com/smallkirby/ymir/tree/whiz-ymir-serial_logsystem) ブランチ"
"にあります。"

#: src/kernel/serial_logsystem.md:14
msgid "[デフォルトのオーバーライド](#デフォルトのオーバーライド)"
msgstr "[デフォルトのオーバーライド](#デフォルトのオーバーライド)"

#: src/kernel/serial_logsystem.md:15
msgid "[シリアルの初期化と利用](#シリアルの初期化と利用)"
msgstr "[シリアルの初期化と利用](#シリアルの初期化と利用)"

#: src/kernel/serial_logsystem.md:18
msgid "デフォルトのオーバーライド"
msgstr "デフォルトのオーバーライド"

#: src/kernel/serial_logsystem.md:20
msgid "まずは、必要な構造体や関数を一気に定義してしまいます:"
msgstr "まずは、必要な構造体や関数を一気に定義してしまいます:"

#: src/kernel/serial_logsystem.md:67
msgid ""
"Surtr のときと同様に、デフォルトの `std_options` をオーバーライドするための "
"`default_log_options` を定義します。 `log_level` はビルド時に指定できるように"
"し、`logFn` には `log` 関数を指定します。 `log()` は本当に Surtr と同じで"
"す。 強いて言えば、スコープ文字列の最大長を7文字に制限しています。 7文字以下"
"の場合はスペースで埋め、7文字以上の場合は `-` で省略します。"
msgstr ""
"Surtr のときと同様に、デフォルトの `std_options` をオーバーライドするための "
"`default_log_options` を定義します。 `log_level` はビルド時に指定できるように"
"し、`logFn` には `log` 関数を指定します。 `log()` は本当に Surtr と同じで"
"す。 強いて言えば、スコープ文字列の最大長を7文字に制限しています。 7文字以下"
"の場合はスペースで埋め、7文字以上の場合は `-` で省略します。"

#: src/kernel/serial_logsystem.md:73
msgid "`option` モジュールを使えるように `build.zig` に以下を追加します:"
msgstr "`option` モジュールを使えるように `build.zig` に以下を追加します:"

#: src/kernel/serial_logsystem.md:81
msgid ""
"`main.zig` から `ymir/log.zig` を使えるように、`ymir/ymir.zig` から export し"
"ます。 この際、`log` という名前で export すると `std.log` と混同してしまうお"
"それがあるため、`klog` として export します:"
msgstr ""
"`main.zig` から `ymir/log.zig` を使えるように、`ymir/ymir.zig` から export し"
"ます。 この際、`log` という名前で export すると `std.log` と混同してしまうお"
"それがあるため、`klog` として export します:"

#: src/kernel/serial_logsystem.md:89
msgid "定義した `default_log_options` を使って、デフォルトの値を上書きします:"
msgstr "定義した `default_log_options` を使って、デフォルトの値を上書きします:"

#: src/kernel/serial_logsystem.md:97
msgid "シリアルの初期化と利用"
msgstr "シリアルの初期化と利用"

#: src/kernel/serial_logsystem.md:99
msgid ""
"このログシステムは出力を完全にシリアルに依存しています。 そのため、このログシ"
"ステムを利用する前にシリアルを初期化し、その後ログシステムに `Serial` を渡し"
"て初期化する必要があります:"
msgstr ""
"このログシステムは出力を完全にシリアルに依存しています。 そのため、このログシ"
"ステムを利用する前にシリアルを初期化し、その後ログシステムに `Serial` を渡し"
"て初期化する必要があります:"

#: src/kernel/serial_logsystem.md:109
msgid "渡された `Serial` は `log.zig` の変数に保存し、出力時に利用します:"
msgstr "渡された `Serial` は `log.zig` の変数に保存し、出力時に利用します:"

#: src/kernel/serial_logsystem.md:127
msgid ""
"以上でシリアル出力を用いたログの用意は完了です。 以降は全てのファイルにおい"
"て `std.log.info()` のようにシリアルログ出力ができます。 `ymir/log.zig` を "
"import する必要はありません。 楽ですね。 起動してみると、以下のようにスコープ"
"とログレベルが一緒に出力されるはずです:"
msgstr ""
"以上でシリアル出力を用いたログの用意は完了です。 以降は全てのファイルにおい"
"て `std.log.info()` のようにシリアルログ出力ができます。 `ymir/log.zig` を "
"import する必要はありません。 楽ですね。 起動してみると、以下のようにスコープ"
"とログレベルが一緒に出力されるはずです:"

#: src/kernel/serial_logsystem.md:138
msgid ""
"[カーネルの起動](../bootloader/jump_to_ymir.md#bootinfo-の検証) では Surtr か"
"らの引数である `BootInfo` を検証しました。 その時点ではログシステムを用意して"
"いなかったため、検証に失敗しても無言で `return` することにしていました。 せっ"
"かくログが使えるようになったので、以下のようにエラー出力をできるようにしてお"
"きましょう:"
msgstr ""
"[カーネルの起動](../bootloader/jump_to_ymir.md#bootinfo-の検証) では Surtr か"
"らの引数である `BootInfo` を検証しました。 その時点ではログシステムを用意して"
"いなかったため、検証に失敗しても無言で `return` することにしていました。 せっ"
"かくログが使えるようになったので、以下のようにエラー出力をできるようにしてお"
"きましょう:"

#: src/kernel/serial_logsystem.md:150
msgid ""
"本チャプターでは、シリアル出力を利用して Zig のログシステムを実装しました。 "
"以降は裏側でシリアルが使われているということを意識することなく Zig のログシス"
"テムを利用することができるようになります。 これで Ymir の実装を進める準備がで"
"きました。 次のチャプターからは、UEFI が用意したさまざまなデータ構造を Ymir "
"自身のものに置き換えていきます。"
msgstr ""
"本チャプターでは、シリアル出力を利用して Zig のログシステムを実装しました。 "
"以降は裏側でシリアルが使われているということを意識することなく Zig のログシス"
"テムを利用することができるようになります。 これで Ymir の実装を進める準備がで"
"きました。 次のチャプターからは、UEFI が用意したさまざまなデータ構造を Ymir "
"自身のものに置き換えていきます。"

#: src/kernel/gdt.md:4
msgid ""
"このチャプターから数回にかけて、UEFI が用意してくれた構造を Ymir のものに置き"
"換えていきます。 この置き換え作業は Ymir がメモリアロケータを実装するに当た"
"り、UEFI の領域を解放するために必要なステップです。 その第1弾が GDT です。"
msgstr ""
"このチャプターから数回にかけて、UEFI が用意してくれた構造を Ymir のものに置き"
"換えていきます。 この置き換え作業は Ymir がメモリアロケータを実装するに当た"
"り、UEFI の領域を解放するために必要なステップです。 その第1弾が GDT です。"

#: src/kernel/gdt.md:10
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-gdt`](https://"
#| "github.com/smallkirby/ymir/tree/whiz-ymir-gdt) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-ymir-gdt`](https://github.com/smallkirby/"
"ymir/tree/whiz-ymir-gdt) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-gdt`](https://github."
"com/smallkirby/ymir/tree/whiz-ymir-gdt) ブランチにあります。"

#: src/kernel/gdt.md:14
msgid "[GDT の概要](#gdt-の概要)"
msgstr "[GDT の概要](#gdt-の概要)"

#: src/kernel/gdt.md:15
msgid ""
"[Linear Address と Segment Selector](#linear-address-と-segment-selector)"
msgstr ""
"[Linear Address と Segment Selector](#linear-address-と-segment-selector)"

#: src/kernel/gdt.md:16
msgid "[Segment Register](#segment-register)"
msgstr "[Segment Register](#segment-register)"

#: src/kernel/gdt.md:17
msgid "[Global Descriptor Table](#global-descriptor-table)"
msgstr "[Global Descriptor Table](#global-descriptor-table)"

#: src/kernel/gdt.md:18
msgid "[Privilege Level](#privilege-level)"
msgstr "[Privilege Level](#privilege-level)"

#: src/kernel/gdt.md:19
msgid "[TSS](#tss)"
msgstr "[TSS](#tss)"

#: src/kernel/gdt.md:20
msgid "[64bit モードのセグメンテーション](#64bit-モードのセグメンテーション)"
msgstr "[64bit モードのセグメンテーション](#64bit-モードのセグメンテーション)"

#: src/kernel/gdt.md:21
msgid "[Ymir のセグメンテーション](#ymir-のセグメンテーション)"
msgstr "[Ymir のセグメンテーション](#ymir-のセグメンテーション)"

#: src/kernel/gdt.md:22
msgid "[基本構造の定義](#基本構造の定義)"
msgstr "[基本構造の定義](#基本構造の定義)"

#: src/kernel/gdt.md:23
msgid "[NULL Descriptor](#null-descriptor)"
msgstr "[NULL Descriptor](#null-descriptor)"

#: src/kernel/gdt.md:24
msgid "[エントリの作成](#エントリの作成)"
msgstr "[エントリの作成](#エントリの作成)"

#: src/kernel/gdt.md:25
msgid "[Segment Register のフラッシュ](#segment-register-のフラッシュ)"
msgstr "[Segment Register のフラッシュ](#segment-register-のフラッシュ)"

#: src/kernel/gdt.md:28
msgid "GDT の概要"
msgstr "GDT の概要"

#: src/kernel/gdt.md:30
msgid ""
"**GDT: Global Descriptor Table** は、セグメンテーションの設定をするテーブル構"
"造です[^ldt]。 セグメンテーションは、メモリをいくつかの仮想的なブロックに分割"
"する機能です。 x86-64 には3つのアドレスの種類があり、以下のように変換されま"
"す:"
msgstr ""
"**GDT: Global Descriptor Table** は、セグメンテーションの設定をするテーブル構"
"造です[^ldt]。 セグメンテーションは、メモリをいくつかの仮想的なブロックに分割"
"する機能です。 x86-64 には3つのアドレスの種類があり、以下のように変換されま"
"す:"

#: src/kernel/gdt.md:41
msgid ""
"**Logical Address** はソフトウェアが直接扱うアドレスです。 **Linear "
"Address** は Logical Address に対してセグメンテーションを適用したアドレスで"
"す。 **Physical Address** は Linear Address に対して **MMU: Memory "
"Management Unit** がページテーブルによる変換をしたアドレスです。"
msgstr ""
"**Logical Address** はソフトウェアが直接扱うアドレスです。 **Linear "
"Address** は Logical Address に対してセグメンテーションを適用したアドレスで"
"す。 **Physical Address** は Linear Address に対して **MMU: Memory "
"Management Unit** がページテーブルによる変換をしたアドレスです。"

#: src/kernel/gdt.md:46
msgid ""
"ページテーブルについては [Surtr の簡易ページテーブル](../bootloader/"
"simple_pg.md) で既に実装済みです。 本チャプターでは Logical to Linear の変換"
"をする GDT の設定をします。"
msgstr ""
"ページテーブルについては [Surtr の簡易ページテーブル](../bootloader/"
"simple_pg.md) で既に実装済みです。 本チャプターでは Logical to Linear の変換"
"をする GDT の設定をします。"

#: src/kernel/gdt.md:49
msgid "Linear Address と Segment Selector"
msgstr "Linear Address と Segment Selector"

#: src/kernel/gdt.md:51
msgid ""
"Linear Address は Logical Address にセグメンテーションによる変換を施した "
"64bit のアドレスです[^phys-space]。 Logical to Linear 変換には GDT と "
"**Segment Selector** が使われます。 GDT と Segment Selector の2つから、そのセ"
"グメントの _Base_ / _Limit_ / _Access Right_ などを取得できます。"
msgstr ""
"Linear Address は Logical Address にセグメンテーションによる変換を施した "
"64bit のアドレスです[^phys-space]。 Logical to Linear 変換には GDT と "
"**Segment Selector** が使われます。 GDT と Segment Selector の2つから、そのセ"
"グメントの _Base_ / _Limit_ / _Access Right_ などを取得できます。"

#: src/kernel/gdt.md:55
msgid ""
"![Logical Address to Linear Address Translation](../assets/sdm/logi2lin.png) "
"_Logical Address to Linear Address Translation. SDM Vol.3A 3.4_"
msgstr ""
"![Logical Address to Linear Address Translation](../assets/sdm/logi2lin.png) "
"_Logical Address to Linear Address Translation. SDM Vol.3A 3.4_"

#: src/kernel/gdt.md:58
msgid "変換は以下の手順で行われます:"
msgstr "変換は以下の手順で行われます:"

#: src/kernel/gdt.md:60
msgid "**Segment Register** から Segment Selector を取得。"
msgstr "**Segment Register** から Segment Selector を取得。"

#: src/kernel/gdt.md:61
msgid "Segment Selector が指す GDT のエントリを取得。"
msgstr "Segment Selector が指す GDT のエントリを取得。"

#: src/kernel/gdt.md:62
msgid ""
"取得した GDT エントリから **Base** を取得し、Logical Address のオフセット部に"
"加算し、64bit Linear Address を計算。"
msgstr ""
"取得した GDT エントリから **Base** を取得し、Logical Address のオフセット部に"
"加算し、64bit Linear Address を計算。"

#: src/kernel/gdt.md:64
msgid "Segment Register"
msgstr "Segment Register"

#: src/kernel/gdt.md:66
msgid ""
"x64 の Segment Register は **CS** / **SS** / **DS** / **ES** / **FS** / "
"**GS** の6つがあります。 各レジスタは **Segment Selector** と **Hidden "
"Part** から成ります:"
msgstr ""
"x64 の Segment Register は **CS** / **SS** / **DS** / **ES** / **FS** / "
"**GS** の6つがあります。 各レジスタは **Segment Selector** と **Hidden "
"Part** から成ります:"

#: src/kernel/gdt.md:69
msgid ""
"![Segment Registers](../assets/sdm/segment_register.png) _Segment Registers. "
"SDM Vol.3A 3.4.3_"
msgstr ""
"![Segment Registers](../assets/sdm/segment_register.png) _Segment Registers. "
"SDM Vol.3A 3.4.3_"

#: src/kernel/gdt.md:72
msgid ""
"Segment Selector は、GDT のエントリを指すインデックスです。 このインデックス"
"をもとにして GDT が取得され、そのエントリの _Base_ から Linear Address が取得"
"されます。 **Hidden Part は、selector が指す GDT のエントリの\"一部\"をキャッ"
"シュします**。 アドレス変換の際には Hidden Part に GDT の中身がキャッシュされ"
"ているため、 CPU は GDT からエントリを取得する必要がなくなります[^hidden-"
"cache]。"
msgstr ""
"Segment Selector は、GDT のエントリを指すインデックスです。 このインデックス"
"をもとにして GDT が取得され、そのエントリの _Base_ から Linear Address が取得"
"されます。 **Hidden Part は、selector が指す GDT のエントリの\"一部\"をキャッ"
"シュします**。 アドレス変換の際には Hidden Part に GDT の中身がキャッシュされ"
"ているため、 CPU は GDT からエントリを取得する必要がなくなります[^hidden-"
"cache]。"

#: src/kernel/gdt.md:78
msgid ""
"**プログラムから直接設定できるのは selector のみ** です。 プログラムが "
"selector を設定すると、CPU が自動的に GDT からエントリを取得し、Hidden Part "
"にキャッシュします。"
msgstr ""
"**プログラムから直接設定できるのは selector のみ** です。 プログラムが "
"selector を設定すると、CPU が自動的に GDT からエントリを取得し、Hidden Part "
"にキャッシュします。"

#: src/kernel/gdt.md:83
#, fuzzy
#| msgid ""
#| "\\[!NOTE\\] セグメントとアクセスチェック Logical to Linear 変換の際には、"
#| "アドレスの計算以外にも以下のチェックが行われます:"
msgid ""
"Logical to Linear 変換の際には、アドレスの計算以外にも以下のチェックが行われ"
"ます:"
msgstr ""
"\\[!NOTE\\] セグメントとアクセスチェック Logical to Linear 変換の際には、アド"
"レスの計算以外にも以下のチェックが行われます:"

#: src/kernel/gdt.md:85
msgid "Logical Address のオフセット部が **Limit** を超えていないか"
msgstr "Logical Address のオフセット部が **Limit** を超えていないか"

#: src/kernel/gdt.md:86
msgid "セグメントの **Access Right** が適切か"
msgstr "セグメントの **Access Right** が適切か"

#: src/kernel/gdt.md:88
msgid "Global Descriptor Table"
msgstr "Global Descriptor Table"

#: src/kernel/gdt.md:90
msgid ""
"GDT は各セグメントの定義をするテーブルです。 Linear to Physical 変換における "
"_Page Table_ に相当する概念です。 GDT エントリは 64bit で以下の構造をしていま"
"す:"
msgstr ""
"GDT は各セグメントの定義をするテーブルです。 Linear to Physical 変換における "
"_Page Table_ に相当する概念です。 GDT エントリは 64bit で以下の構造をしていま"
"す:"

#: src/kernel/gdt.md:94
msgid ""
"![Segment Descriptor](../assets/sdm/segment_descriptor.png) _Segment "
"Descriptor. SDM Vol.3A 3.4.5_"
msgstr ""
"![Segment Descriptor](../assets/sdm/segment_descriptor.png) _Segment "
"Descriptor. SDM Vol.3A 3.4.5_"

#: src/kernel/gdt.md:97
msgid "GDT エントリは各セグメントに対して以下の主な情報を定義します:"
msgstr "GDT エントリは各セグメントに対して以下の主な情報を定義します:"

#: src/kernel/gdt.md:99
msgid "**Base**: セグメントの開始 Linear Address"
msgstr "**Base**: セグメントの開始 Linear Address"

#: src/kernel/gdt.md:100
msgid "**Limit**: セグメントのサイズ。_Granularity_ によって単位が変わる"
msgstr "**Limit**: セグメントのサイズ。_Granularity_ によって単位が変わる"

#: src/kernel/gdt.md:101
msgid ""
"**DPL (Descriptor Privilege Level)**: セグメントの特権レベル。CPL が DPL 以下"
"でないとアクセスできない。"
msgstr ""
"**DPL (Descriptor Privilege Level)**: セグメントの特権レベル。CPL が DPL 以下"
"でないとアクセスできない。"

#: src/kernel/gdt.md:103
msgid ""
"GDT 自体のアドレスは **GDTR: GDT Register** に格納されています。 GDT のサイ"
"ズ、つまりエントリ数は可変であるため、GDT のサイズ情報も GDTR に格納されてい"
"ます。"
msgstr ""
"GDT 自体のアドレスは **GDTR: GDT Register** に格納されています。 GDT のサイ"
"ズ、つまりエントリ数は可変であるため、GDT のサイズ情報も GDTR に格納されてい"
"ます。"

#: src/kernel/gdt.md:106
msgid "Privilege Level"
msgstr "Privilege Level"

#: src/kernel/gdt.md:108
msgid ""
"CPU が持つ権限レベルは [Ring (Protection Ring)](https://en.wikipedia.org/"
"wiki/Protection_ring) と呼ばれたりもします。 Ring は時折複数の異なる概念を指"
"す場合もありますが、基本的には **CPL: Current Privilege Level** のことを指す"
"場合が多いです。"
msgstr ""
"CPU が持つ権限レベルは [Ring (Protection Ring)](https://en.wikipedia.org/"
"wiki/Protection_ring) と呼ばれたりもします。 Ring は時折複数の異なる概念を指"
"す場合もありますが、基本的には **CPL: Current Privilege Level** のことを指す"
"場合が多いです。"

#: src/kernel/gdt.md:111
msgid ""
"CPL は CS レジスタの下位 2bit で表され、`0` - `3` の値を取ります。 Logical "
"to Linear 変換の際には、CPL が変換に利用するセグメントの DPL 以下であるか(権"
"限が強いか)どうかがチェックされます。 その他にも、CPL(Ring) は特権レジスタや"
"特権命令の実行ができるかどうかの判断にも使われます。 例として [Control "
"Register](https://wiki.osdev.org/CPU_Registers_x86-64#Control_Registers) に"
"は Ring-0 でないとアクセスできません。"
msgstr ""
"CPL は CS レジスタの下位 2bit で表され、`0` - `3` の値を取ります。 Logical "
"to Linear 変換の際には、CPL が変換に利用するセグメントの DPL 以下であるか(権"
"限が強いか)どうかがチェックされます。 その他にも、CPL(Ring) は特権レジスタや"
"特権命令の実行ができるかどうかの判断にも使われます。 例として [Control "
"Register](https://wiki.osdev.org/CPU_Registers_x86-64#Control_Registers) に"
"は Ring-0 でないとアクセスできません。"

#: src/kernel/gdt.md:118
#, fuzzy
#| msgid ""
#| "\\[!NOTE\\] IOPL x64 には CPL とは別に **IOPL: I/O Privilege Level** があ"
#| "ります。 IOPL は I/O 命令の実行に必要な CPL を定義します。 CPL が CS レジ"
#| "スタに格納されているのに対し、IOPL は RFLAGS レジスタに格納されています。 "
#| "IOPL は Ring-0 の場合に限り POPF か IRET 命令のいずれかでのみ変更できま"
#| "す。"
msgid ""
"x64 には CPL とは別に **IOPL: I/O Privilege Level** があります。 IOPL は I/O "
"命令の実行に必要な CPL を定義します。 CPL が CS レジスタに格納されているのに"
"対し、IOPL は RFLAGS レジスタに格納されています。 IOPL は Ring-0 の場合に限"
"り POPF か IRET 命令のいずれかでのみ変更できます。"
msgstr ""
"\\[!NOTE\\] IOPL x64 には CPL とは別に **IOPL: I/O Privilege Level** がありま"
"す。 IOPL は I/O 命令の実行に必要な CPL を定義します。 CPL が CS レジスタに格"
"納されているのに対し、IOPL は RFLAGS レジスタに格納されています。 IOPL は "
"Ring-0 の場合に限り POPF か IRET 命令のいずれかでのみ変更できます。"

#: src/kernel/gdt.md:123
msgid "TSS"
msgstr "TSS"

#: src/kernel/gdt.md:125
msgid ""
"CS / DS / FS / GS 等のアプリケーションセグメントに加え、**TSS (Task State "
"Segment)** というシステムセグメントもあります。 TSS は 32bit mode において"
"ハードウェアタスクスイッチに使われてきましたが、64bit mode ではハードウェアタ"
"スクスイッチはサポートされていません。 64-bit mode の TSS は以下の3つの情報だ"
"けを保持します:"
msgstr ""
"CS / DS / FS / GS 等のアプリケーションセグメントに加え、**TSS (Task State "
"Segment)** というシステムセグメントもあります。 TSS は 32bit mode において"
"ハードウェアタスクスイッチに使われてきましたが、64bit mode ではハードウェアタ"
"スクスイッチはサポートされていません。 64-bit mode の TSS は以下の3つの情報だ"
"けを保持します:"

#: src/kernel/gdt.md:129
msgid "_RSPn_: Ring-0 から Ring-2 までの RSP"
msgstr "_RSPn_: Ring-0 から Ring-2 までの RSP"

#: src/kernel/gdt.md:130
msgid "_ISTn_: 割り込みハンドラ用のスタック"
msgstr "_ISTn_: 割り込みハンドラ用のスタック"

#: src/kernel/gdt.md:131
msgid "_I/O map base address_: I/O permission map のアドレス"
msgstr "_I/O map base address_: I/O permission map のアドレス"

#: src/kernel/gdt.md:133
msgid ""
"![64-Bit TSS Format](../assets/sdm/64bit_tss.png) _64-Bit TSS Format. SDM "
"Vol.3A Figure 9-11._"
msgstr ""
"![64-Bit TSS Format](../assets/sdm/64bit_tss.png) _64-Bit TSS Format. SDM "
"Vol.3A Figure 9-11._"

#: src/kernel/gdt.md:136
msgid ""
"TSS のアドレスは **TSS Descriptor** によって指定されます。 TSS Descriptor は "
"LDT Descriptor と同じフォーマットを持ちます。 なお、他のセグメントディスクリ"
"プタとは異なり、TSS Descriptor のサイズは 16byte であることに注意してくださ"
"い:"
msgstr ""
"TSS のアドレスは **TSS Descriptor** によって指定されます。 TSS Descriptor は "
"LDT Descriptor と同じフォーマットを持ちます。 なお、他のセグメントディスクリ"
"プタとは異なり、TSS Descriptor のサイズは 16byte であることに注意してくださ"
"い:"

#: src/kernel/gdt.md:140
msgid ""
"![Format of TSS and LDT Descriptors in 64-bit Mode](../assets/sdm/"
"tss_descriptor.png) _Format of TSS and LDT Descriptors in 64-bit Mode. SDM "
"Vol.3A Figure 9-4._"
msgstr ""
"![Format of TSS and LDT Descriptors in 64-bit Mode](../assets/sdm/"
"tss_descriptor.png) _Format of TSS and LDT Descriptors in 64-bit Mode. SDM "
"Vol.3A Figure 9-4._"

#: src/kernel/gdt.md:143
msgid ""
"GDT における TSS Descriptor のインデックスは **TR: Task Register** に格納され"
"ます。 TSS Descriptor は GDT のエントリを2つ専有します。"
msgstr ""
"GDT における TSS Descriptor のインデックスは **TR: Task Register** に格納され"
"ます。 TSS Descriptor は GDT のエントリを2つ専有します。"

#: src/kernel/gdt.md:146
msgid "64bit モードのセグメンテーション"
msgstr "64bit モードのセグメンテーション"

#: src/kernel/gdt.md:148
msgid ""
"ここまでセグメントについて説明してきましたが、 **x64 ではセグメンテーションの"
"機能のほとんどはハードウェア的に無効化されています**。 厳密には、Intel 64 "
"アーキテクチャの [64bit mode (IA-32e mode の 64bit mode)](https://ja."
"wikipedia.org/wiki/X64) においてセグメンテーションがほぼ無効化されています。 "
"_Base_ は `0` として解釈され、_Limit_ によるチェックは行われません。 よって、"
"Logical to Linear 変換では実際にはアドレスの変換は行われず、フラットで巨大な1"
"つのセグメントが使われているものとして扱われます[^virt]。"
msgstr ""
"ここまでセグメントについて説明してきましたが、 **x64 ではセグメンテーションの"
"機能のほとんどはハードウェア的に無効化されています**。 厳密には、Intel 64 "
"アーキテクチャの [64bit mode (IA-32e mode の 64bit mode)](https://ja."
"wikipedia.org/wiki/X64) においてセグメンテーションがほぼ無効化されています。 "
"_Base_ は `0` として解釈され、_Limit_ によるチェックは行われません。 よって、"
"Logical to Linear 変換では実際にはアドレスの変換は行われず、フラットで巨大な1"
"つのセグメントが使われているものとして扱われます[^virt]。"

#: src/kernel/gdt.md:154
msgid ""
"例外は **FS** と **GS** セグメントです。 この2つに対しては依然としてセグメン"
"トが設定ができ、どのように利用するかはソフトウェア依存です。 [glibc](https://"
"www.gnu.org/software/libc/) では FS は **TLS: Thread Local Storage** を表現す"
"るのに使われます。 Linux Kernel では、GS は Per-CPU データを表現するのに使わ"
"れます[^linux-fsgs]。"
msgstr ""
"例外は **FS** と **GS** セグメントです。 この2つに対しては依然としてセグメン"
"トが設定ができ、どのように利用するかはソフトウェア依存です。 [glibc](https://"
"www.gnu.org/software/libc/) では FS は **TLS: Thread Local Storage** を表現す"
"るのに使われます。 Linux Kernel では、GS は Per-CPU データを表現するのに使わ"
"れます[^linux-fsgs]。"

#: src/kernel/gdt.md:159
msgid ""
"なお、FS/GS を使う場合にも実際に利用されるのは _Base_ 部分のみです。 FS/GS "
"の Hidden Part における _Base_ 部分は、 **FSBASE** / **GSBASE** という MSR に"
"マップされています。 FS/GS の Base の設定を変更するには Segment Selector "
"(Segment Register) に書き込む従来の方法に加え、 FSBASE / GSBASE  MSR に "
"_Base_ を直接書き込むことも可能です。 ちなみに、MSR への書き込み ([WRMSR]"
"(https://www.felixcloutier.com/x86/wrmsr)) は特権命令であるため context "
"switch を伴います。 そのため Ivy Bridge からは [FSGSBASE](https://www.intel."
"com/content/www/us/en/developer/articles/technical/software-security-"
"guidance/best-practices/guidance-enabling-fsgsbase.html) という拡張機能が実装"
"され、ユーザランドから直接 _FSBASE_ / _GSBASE_ にアクセスできるようになりまし"
"た ([RDFSBASE / RDGSBASE](https://www.felixcloutier.com/x86/rdfsbase:"
"rdgsbase))。"
msgstr ""
"なお、FS/GS を使う場合にも実際に利用されるのは _Base_ 部分のみです。 FS/GS "
"の Hidden Part における _Base_ 部分は、 **FSBASE** / **GSBASE** という MSR に"
"マップされています。 FS/GS の Base の設定を変更するには Segment Selector "
"(Segment Register) に書き込む従来の方法に加え、 FSBASE / GSBASE  MSR に "
"_Base_ を直接書き込むことも可能です。 ちなみに、MSR への書き込み ([WRMSR]"
"(https://www.felixcloutier.com/x86/wrmsr)) は特権命令であるため context "
"switch を伴います。 そのため Ivy Bridge からは [FSGSBASE](https://www.intel."
"com/content/www/us/en/developer/articles/technical/software-security-"
"guidance/best-practices/guidance-enabling-fsgsbase.html) という拡張機能が実装"
"され、ユーザランドから直接 _FSBASE_ / _GSBASE_ にアクセスできるようになりまし"
"た ([RDFSBASE / RDGSBASE](https://www.felixcloutier.com/x86/rdfsbase:"
"rdgsbase))。"

#: src/kernel/gdt.md:166
msgid ""
"とどのつまり、Ymir においてはほとんどセグメントの設定をする必要はないというこ"
"とです。"
msgstr ""
"とどのつまり、Ymir においてはほとんどセグメントの設定をする必要はないというこ"
"とです。"

#: src/kernel/gdt.md:168 src/kernel/gdt.md:445
msgid "\\[!WARN\\]"
msgstr ""

#: src/kernel/gdt.md:170
#, fuzzy
#| msgid ""
#| "\\[!WARN\\] 64bit mode における権限チェック セグメンテーションが無効化され"
#| "ると書きましたが、これはアドレス変換が行われないという意味です。 64bit "
#| "mode においてもセグメントへのアクセス権限チェックは行われます。"
msgid ""
"セグメンテーションが無効化されると書きましたが、これはアドレス変換が行われな"
"いという意味です。 64bit mode においてもセグメントへのアクセス権限チェックは"
"行われます。"
msgstr ""
"\\[!WARN\\] 64bit mode における権限チェック セグメンテーションが無効化される"
"と書きましたが、これはアドレス変換が行われないという意味です。 64bit mode に"
"おいてもセグメントへのアクセス権限チェックは行われます。"

#: src/kernel/gdt.md:173
msgid ""
"権限チェックは、CPL/DPL/RPL の3つの値をもとに行われます。 この辺は少し複雑な"
"ため、気になる人は _SDM Vol.3A 5.5: PRIVILEGE LEVELS_ を参照してください。"
msgstr ""
"権限チェックは、CPL/DPL/RPL の3つの値をもとに行われます。 この辺は少し複雑な"
"ため、気になる人は _SDM Vol.3A 5.5: PRIVILEGE LEVELS_ を参照してください。"

#: src/kernel/gdt.md:176
msgid "Ymir のセグメンテーション"
msgstr "Ymir のセグメンテーション"

#: src/kernel/gdt.md:178
msgid ""
"Ymir では2種類のセグメントしか設定しません。 CS とそれ以外の2つです。 Linux "
"と異なり、GS も現在は使う予定がありません。 この2つのセグメントを GDT に設定"
"していきましょう。"
msgstr ""
"Ymir では2種類のセグメントしか設定しません。 CS とそれ以外の2つです。 Linux "
"と異なり、GS も現在は使う予定がありません。 この2つのセグメントを GDT に設定"
"していきましょう。"

#: src/kernel/gdt.md:183
msgid "基本構造の定義"
msgstr "基本構造の定義"

#: src/kernel/gdt.md:185
msgid "Figure 3-8 で示される GDT エントリを定義します:"
msgstr "Figure 3-8 で示される GDT エントリを定義します:"

#: src/kernel/gdt.md:187
msgid ""
"```ymir/arch/x86/gdt.zig\n"
"pub const SegmentDescriptor = packed struct(u64) {\n"
"    /// Lower 16 bits of the segment limit.\n"
"    limit_low: u16,\n"
"    /// Lower 24 bits of the base address.\n"
"    base_low: u24,\n"
"    /// Segment is accessed.\n"
"    accessed: bool = true,\n"
"    /// Readable / Writable.\n"
"    rw: bool,\n"
"    /// Direction / Conforming.\n"
"    dc: bool,\n"
"    /// Executable.\n"
"    executable: bool,\n"
"    /// Descriptor type.\n"
"    desc_type: DescriptorType,\n"
"    /// Descriptor Privilege Level.\n"
"    dpl: u2,\n"
"    /// Segment present.\n"
"    present: bool = true,\n"
"    /// Upper 4 bits of the segment limit.\n"
"    limit_high: u4,\n"
"    /// Available for use by system software.\n"
"    avl: u1 = 0,\n"
"    /// 64-bit code segment.\n"
"    long: bool,\n"
"    /// Size flag.\n"
"    db: u1,\n"
"    /// Granularity.\n"
"    granularity: Granularity,\n"
"    /// Upper 8 bits of the base address.\n"
"    base_high: u8,\n"
"};\n"
"\n"
"pub const DescriptorType = enum(u1) {\n"
"    system = 0,\n"
"    code_data = 1,\n"
"};\n"
"\n"
"pub const Granularity = enum(u1) {\n"
"    byte = 0,\n"
"    kbyte = 1,\n"
"};\n"
"```"
msgstr ""
"```ymir/arch/x86/gdt.zig\n"
"pub const SegmentDescriptor = packed struct(u64) {\n"
"    /// Lower 16 bits of the segment limit.\n"
"    limit_low: u16,\n"
"    /// Lower 24 bits of the base address.\n"
"    base_low: u24,\n"
"    /// Segment is accessed.\n"
"    accessed: bool = true,\n"
"    /// Readable / Writable.\n"
"    rw: bool,\n"
"    /// Direction / Conforming.\n"
"    dc: bool,\n"
"    /// Executable.\n"
"    executable: bool,\n"
"    /// Descriptor type.\n"
"    desc_type: DescriptorType,\n"
"    /// Descriptor Privilege Level.\n"
"    dpl: u2,\n"
"    /// Segment present.\n"
"    present: bool = true,\n"
"    /// Upper 4 bits of the segment limit.\n"
"    limit_high: u4,\n"
"    /// Available for use by system software.\n"
"    avl: u1 = 0,\n"
"    /// 64-bit code segment.\n"
"    long: bool,\n"
"    /// Size flag.\n"
"    db: u1,\n"
"    /// Granularity.\n"
"    granularity: Granularity,\n"
"    /// Upper 8 bits of the base address.\n"
"    base_high: u8,\n"
"};\n"
"\n"
"pub const DescriptorType = enum(u1) {\n"
"    system = 0,\n"
"    code_data = 1,\n"
"};\n"
"\n"
"pub const Granularity = enum(u1) {\n"
"    byte = 0,\n"
"    kbyte = 1,\n"
"};\n"
"```"

#: src/kernel/gdt.md:232
msgid "これまで説明していなかったフィールドについて以下の表で説明します:"
msgstr "これまで説明していなかったフィールドについて以下の表で説明します:"

#: src/kernel/gdt.md:234 src/vmm/linux_boot.md:500
msgid "Field"
msgstr "Field"

#: src/kernel/gdt.md:236
msgid "`accessed`, `rw`, `dc`, `executable`"
msgstr "`accessed`, `rw`, `dc`, `executable`"

#: src/kernel/gdt.md:236
msgid ""
"Type field. セグメントに対するアクセスの設定[^type]。 `dc` は Code / Data "
"Segment 種別。"
msgstr ""
"Type field. セグメントに対するアクセスの設定[^type]。 `dc` は Code / Data "
"Segment 種別。"

#: src/kernel/gdt.md:237
msgid "`desc_type`"
msgstr "`desc_type`"

#: src/kernel/gdt.md:237
msgid "Application Descriptor / System Descriptor[^sys] の区別"
msgstr "Application Descriptor / System Descriptor[^sys] の区別"

#: src/kernel/gdt.md:238
msgid "`present`"
msgstr "`present`"

#: src/kernel/gdt.md:238
msgid "セグメントがスワップアウトされていれば `false`"
msgstr "セグメントがスワップアウトされていれば `false`"

#: src/kernel/gdt.md:239
msgid "`avl`"
msgstr "`avl`"

#: src/kernel/gdt.md:239
msgid "自由に使っていいビット"
msgstr "自由に使っていいビット"

#: src/kernel/gdt.md:240
msgid "`db`"
msgstr "`db`"

#: src/kernel/gdt.md:240
msgid "Type field によって意味が異なる。何らかデフォルトのサイズを決める。"
msgstr "Type field によって意味が異なる。何らかデフォルトのサイズを決める。"

#: src/kernel/gdt.md:241
msgid "`long`"
msgstr "`long`"

#: src/kernel/gdt.md:241
msgid "Code Segment が 64bit かどうか"
msgstr "Code Segment が 64bit かどうか"

#: src/kernel/gdt.md:243
msgid ""
"続いて、TSS 用のエントリを作成します。他のディスクリプタとは異なり、TSS "
"Descriptor は 16byte なので新しい構造体を定義します:"
msgstr ""
"続いて、TSS 用のエントリを作成します。他のディスクリプタとは異なり、TSS "
"Descriptor は 16byte なので新しい構造体を定義します:"

#: src/kernel/gdt.md:245
msgid ""
"```ymir/arch/x86/gdt.zig\n"
"const TssDescriptor = packed struct(u128) {\n"
"    /// Lower 16 bits of the segment limit.\n"
"    limit_low: u16,\n"
"    /// Lower 24 bits of the base address.\n"
"    base_low: u24,\n"
"\n"
"    /// Type: TSS.\n"
"    type: u4 = 0b1001, // tss-avail\n"
"    /// Descriptor type: System.\n"
"    desc_type: DescriptorType = .system,\n"
"    /// Descriptor Privilege Level.\n"
"    dpl: u2 = 0,\n"
"    present: bool = true,\n"
"\n"
"    /// Upper 4 bits of the segment limit.\n"
"    limit_high: u4,\n"
"    /// Available for use by system software.\n"
"    avl: u1 = 0,\n"
"    /// Reserved.\n"
"    long: bool = true,\n"
"    /// Size flag.\n"
"    db: u1 = 0,\n"
"    /// Granularity.\n"
"    granularity: Granularity = .kbyte,\n"
"    /// Upper 40 bits of the base address.\n"
"    base_high: u40,\n"
"    /// Reserved.\n"
"    _reserved: u32 = 0,\n"
"\n"
"    /// Create a new 64-bit TSS descriptor.\n"
"    pub fn new(base: Virt, limit: u20) TssDescriptor {\n"
"        return TssDescriptor{\n"
"            .limit_low = @truncate(limit),\n"
"            .base_low = @truncate(base),\n"
"            .limit_high = @truncate(limit >> 16),\n"
"            .base_high = @truncate(base >> 24),\n"
"        };\n"
"    }\n"
"};\n"
"```"
msgstr ""
"```ymir/arch/x86/gdt.zig\n"
"const TssDescriptor = packed struct(u128) {\n"
"    /// Lower 16 bits of the segment limit.\n"
"    limit_low: u16,\n"
"    /// Lower 24 bits of the base address.\n"
"    base_low: u24,\n"
"\n"
"    /// Type: TSS.\n"
"    type: u4 = 0b1001, // tss-avail\n"
"    /// Descriptor type: System.\n"
"    desc_type: DescriptorType = .system,\n"
"    /// Descriptor Privilege Level.\n"
"    dpl: u2 = 0,\n"
"    present: bool = true,\n"
"\n"
"    /// Upper 4 bits of the segment limit.\n"
"    limit_high: u4,\n"
"    /// Available for use by system software.\n"
"    avl: u1 = 0,\n"
"    /// Reserved.\n"
"    long: bool = true,\n"
"    /// Size flag.\n"
"    db: u1 = 0,\n"
"    /// Granularity.\n"
"    granularity: Granularity = .kbyte,\n"
"    /// Upper 40 bits of the base address.\n"
"    base_high: u40,\n"
"    /// Reserved.\n"
"    _reserved: u32 = 0,\n"
"\n"
"    /// Create a new 64-bit TSS descriptor.\n"
"    pub fn new(base: Virt, limit: u20) TssDescriptor {\n"
"        return TssDescriptor{\n"
"            .limit_low = @truncate(limit),\n"
"            .base_low = @truncate(base),\n"
"            .limit_high = @truncate(limit >> 16),\n"
"            .base_high = @truncate(base >> 24),\n"
"        };\n"
"    }\n"
"};\n"
"```"

#: src/kernel/gdt.md:287
msgid "NULL Descriptor"
msgstr "NULL Descriptor"

#: src/kernel/gdt.md:289
msgid ""
"GDT の 0 番目のエントリは **NULL Descriptor** として使われます。 NULL "
"descriptor は CPU が実際に利用することはありません。 NULL descriptor を指す "
"Segment Selector は **NULL segment selector** と呼ばれます。 CS/SS を除く使わ"
"ない Segment Selector には _NULL segment selector_ を入れることができます。 "
"ただし、NULL segment selector を使ってメモリアクセスをしようとすると _\\#GP: "
"General Protection Fault_ になります。"
msgstr ""
"GDT の 0 番目のエントリは **NULL Descriptor** として使われます。 NULL "
"descriptor は CPU が実際に利用することはありません。 NULL descriptor を指す "
"Segment Selector は **NULL segment selector** と呼ばれます。 CS/SS を除く使わ"
"ない Segment Selector には _NULL segment selector_ を入れることができます。 "
"ただし、NULL segment selector を使ってメモリアクセスをしようとすると _\\#GP: "
"General Protection Fault_ になります。"

#: src/kernel/gdt.md:295
msgid "エントリの作成"
msgstr "エントリの作成"

#: src/kernel/gdt.md:297
msgid "それではコードセグメント・データセグメントを初期化していきます:"
msgstr "それではコードセグメント・データセグメントを初期化していきます:"

#: src/kernel/gdt.md:307
msgid ""
"GDT のエントリ数は可変であり自由に決めることができる[^num_gdt]ので、適当に "
"10 にしています。 この個数分だけ GDT エントリの配列を用意します。 "
"`newNull()` は空のエントリを作成する関数です:"
msgstr ""
"GDT のエントリ数は可変であり自由に決めることができる[^num_gdt]ので、適当に "
"10 にしています。 この個数分だけ GDT エントリの配列を用意します。 "
"`newNull()` は空のエントリを作成する関数です:"

#: src/kernel/gdt.md:344
msgid ""
"Segment Descriptor エントリはフィールド数も多くて初期化がめんどうなので、 "
"`new()` ヘルパー関数もついでに定義しています。"
msgstr ""
"Segment Descriptor エントリはフィールド数も多くて初期化がめんどうなので、 "
"`new()` ヘルパー関数もついでに定義しています。"

#: src/kernel/gdt.md:346
msgid ""
"必要なエントリを初期化しましょう。 今回はコード・データセグメント用の2つを作"
"成し、CS は前者を、DS/ES/FS/GS は後者を指すようにします:"
msgstr ""
"必要なエントリを初期化しましょう。 今回はコード・データセグメント用の2つを作"
"成し、CS は前者を、DS/ES/FS/GS は後者を指すようにします:"

#: src/kernel/gdt.md:377
msgid ""
"CS と DS の違いは `executable` かどうかだけです。 `.rw` はデータセグメントで"
"は `writable`、コードセグメントでは `readable` という意味になります。"
msgstr ""
"CS と DS の違いは `executable` かどうかだけです。 `.rw` はデータセグメントで"
"は `writable`、コードセグメントでは `readable` という意味になります。"

#: src/kernel/gdt.md:380
msgid ""
"続いて、TSS を設定します。TSS セグメントは使わないため適当な領域を1ページ分確"
"保し、TSS Descriptor がそこを指すように設定します:"
msgstr ""
"続いて、TSS を設定します。TSS セグメントは使わないため適当な領域を1ページ分確"
"保し、TSS Descriptor がそこを指すように設定します:"

#: src/kernel/gdt.md:382
msgid ""
"```ymir/arch/x86/gdt.zig\n"
"/// Unused TSS segment.\n"
"const tssUnused: [4096]u8 align(4096) = [_]u8{0} ** 4096;\n"
"\n"
"pub fn init() void {\n"
"    ...\n"
"    // TSS is not used by Ymir. But we have to set it for VMX.\n"
"    setTss(@intFromPtr(&tssUnused));\n"
"    ...\n"
"}\n"
"\n"
"fn setTss(tss: Virt) void {\n"
"    const desc = TssDescriptor.new(tss, std.math.maxInt(u20));\n"
"    @as(*TssDescriptor, @ptrCast(&gdt[kernel_tss_index])).* = desc;\n"
"\n"
"    loadKernelTss();\n"
"}\n"
"\n"
"fn loadKernelTss() void {\n"
"    asm volatile (\n"
"        \\\\mov %[kernel_tss], %%di\n"
"        \\\\ltr %%di\n"
"        :\n"
"        : [kernel_tss] \"n\" (@as(u16, @bitCast(SegmentSelector{\n"
"            .rpl = 0,\n"
"            .index = kernel_tss_index,\n"
"          }))),\n"
"        : \"di\"\n"
"    );\n"
"}\n"
"```"
msgstr ""
"```ymir/arch/x86/gdt.zig\n"
"/// Unused TSS segment.\n"
"const tssUnused: [4096]u8 align(4096) = [_]u8{0} ** 4096;\n"
"\n"
"pub fn init() void {\n"
"    ...\n"
"    // TSS is not used by Ymir. But we have to set it for VMX.\n"
"    setTss(@intFromPtr(&tssUnused));\n"
"    ...\n"
"}\n"
"\n"
"fn setTss(tss: Virt) void {\n"
"    const desc = TssDescriptor.new(tss, std.math.maxInt(u20));\n"
"    @as(*TssDescriptor, @ptrCast(&gdt[kernel_tss_index])).* = desc;\n"
"\n"
"    loadKernelTss();\n"
"}\n"
"\n"
"fn loadKernelTss() void {\n"
"    asm volatile (\n"
"        \\\\mov %[kernel_tss], %%di\n"
"        \\\\ltr %%di\n"
"        :\n"
"        : [kernel_tss] \"n\" (@as(u16, @bitCast(SegmentSelector{\n"
"            .rpl = 0,\n"
"            .index = kernel_tss_index,\n"
"          }))),\n"
"        : \"di\"\n"
"    );\n"
"}\n"
"```"

#: src/kernel/gdt.md:416
#, fuzzy
#| msgid ""
#| "\\[!NOTE\\] TSS と VM-Entry Ymir ではユーザランドを実装せず、かつ割り込み"
#| "用のスタックも用意しないため TSS も使いません。 しかし、のちほど VM-Entry "
#| "をする際に \"ホストの TR は 0 であってはならない\" という制約があるため、"
#| "ここでは空の TSS を作成しています。"
msgid ""
"Ymir ではユーザランドを実装せず、かつ割り込み用のスタックも用意しないため "
"TSS も使いません。 しかし、のちほど VM-Entry をする際に \"ホストの TR は 0 で"
"あってはならない\" という制約があるため、ここでは空の TSS を作成しています。"
msgstr ""
"\\[!NOTE\\] TSS と VM-Entry Ymir ではユーザランドを実装せず、かつ割り込み用の"
"スタックも用意しないため TSS も使いません。 しかし、のちほど VM-Entry をする"
"際に \"ホストの TR は 0 であってはならない\" という制約があるため、ここでは空"
"の TSS を作成しています。"

#: src/kernel/gdt.md:419
msgid ""
"GDT 自体の初期化が終わったため、GDT Register に GDT のアドレスを設定します:"
msgstr ""
"GDT 自体の初期化が終わったため、GDT Register に GDT のアドレスを設定します:"

#: src/kernel/gdt.md:440
msgid ""
"GDTR は GDT のアドレスとサイズのみを持ちます。 アドレスは本来であれば物理アド"
"レスを指定するべきですが、Ymir はまだ UEFI が提供してくれたストレートマップを"
"利用しており、 仮想アドレスと物理アドレスが等しいです。 そのため、`&gdt` (仮"
"想アドレス) をそのまま物理アドレスとして使っています。"
msgstr ""
"GDTR は GDT のアドレスとサイズのみを持ちます。 アドレスは本来であれば物理アド"
"レスを指定するべきですが、Ymir はまだ UEFI が提供してくれたストレートマップを"
"利用しており、 仮想アドレスと物理アドレスが等しいです。 そのため、`&gdt` (仮"
"想アドレス) をそのまま物理アドレスとして使っています。"

#: src/kernel/gdt.md:447
#, fuzzy
#| msgid ""
#| "\\[!WARN\\] Zig の static initialization バグ 本当は `gdtr` の宣言時に `."
#| "base = &gdt` として初期化したかったのですが、 現在 Zig or LLVM にバグ"
#| "[^zig-bug]があり、この初期化方法はエラーになってしまいます。 そのため、仕"
#| "方なく `init()` の中で `&gdt` を代入しています。"
msgid ""
"本当は `gdtr` の宣言時に `.base = &gdt` として初期化したかったのですが、 現"
"在 Zig or LLVM にバグ[^zig-bug]があり、この初期化方法はエラーになってしまいま"
"す。 そのため、仕方なく `init()` の中で `&gdt` を代入しています。"
msgstr ""
"\\[!WARN\\] Zig の static initialization バグ 本当は `gdtr` の宣言時に `."
"base = &gdt` として初期化したかったのですが、 現在 Zig or LLVM にバグ[^zig-"
"bug]があり、この初期化方法はエラーになってしまいます。 そのため、仕方なく "
"`init()` の中で `&gdt` を代入しています。"

#: src/kernel/gdt.md:451
msgid ""
"`am.lgdt()` は [LGDT](https://www.felixcloutier.com/x86/lgdt:lidt) 命令をする"
"だけのアセンブリ関数です:"
msgstr ""
"`am.lgdt()` は [LGDT](https://www.felixcloutier.com/x86/lgdt:lidt) 命令をする"
"だけのアセンブリ関数です:"

#: src/kernel/gdt.md:453
msgid ""
"```ymir/arch/x86/asm.zig\n"
"pub inline fn lgdt(gdtr: u64) void {\n"
"    asm volatile (\n"
"        \\\\lgdt (%[gdtr])\n"
"        :\n"
"        : [gdtr] \"r\" (gdtr),\n"
"    );\n"
"}\n"
"```"
msgstr ""
"```ymir/arch/x86/asm.zig\n"
"pub inline fn lgdt(gdtr: u64) void {\n"
"    asm volatile (\n"
"        \\\\lgdt (%[gdtr])\n"
"        :\n"
"        : [gdtr] \"r\" (gdtr),\n"
"    );\n"
"}\n"
"```"

#: src/kernel/gdt.md:463
msgid "Segment Register のフラッシュ"
msgstr "Segment Register のフラッシュ"

#: src/kernel/gdt.md:465
msgid ""
"GDT の初期化は終わりましたが、まだ新しいセグメントの設定は反映されません。 な"
"ぜならば、**セグメントの _Base_ は Segment Register の Hidden Part にキャッ"
"シュされているから**です。 Segment Register の selector 部に新しく GDT のイン"
"デックスを設定し Hidden Part をフラッシュすることで、初めて新しいセグメント設"
"定が使われるようになります:"
msgstr ""
"GDT の初期化は終わりましたが、まだ新しいセグメントの設定は反映されません。 な"
"ぜならば、**セグメントの _Base_ は Segment Register の Hidden Part にキャッ"
"シュされているから**です。 Segment Register の selector 部に新しく GDT のイン"
"デックスを設定し Hidden Part をフラッシュすることで、初めて新しいセグメント設"
"定が使われるようになります:"

#: src/kernel/gdt.md:469
msgid ""
"```ymir/arch/x86/gdt.zig\n"
"fn loadKernelDs() void {\n"
"    asm volatile (\n"
"        \\\\mov %[kernel_ds], %di\n"
"        \\\\mov %%di, %%ds\n"
"        \\\\mov %%di, %%es\n"
"        \\\\mov %%di, %%fs\n"
"        \\\\mov %%di, %%gs\n"
"        \\\\mov %%di, %%ss\n"
"        :\n"
"        : [kernel_ds] \"n\" (@as(u16, @bitCast(SegmentSelector{\n"
"            .rpl = 0,\n"
"            .index = kernel_ds_index,\n"
"          }))),\n"
"        : \"di\",\n"
"    );\n"
"}\n"
"```"
msgstr ""
"```ymir/arch/x86/gdt.zig\n"
"fn loadKernelDs() void {\n"
"    asm volatile (\n"
"        \\\\mov %[kernel_ds], %di\n"
"        \\\\mov %%di, %%ds\n"
"        \\\\mov %%di, %%es\n"
"        \\\\mov %%di, %%fs\n"
"        \\\\mov %%di, %%gs\n"
"        \\\\mov %%di, %%ss\n"
"        :\n"
"        : [kernel_ds] \"n\" (@as(u16, @bitCast(SegmentSelector{\n"
"            .rpl = 0,\n"
"            .index = kernel_ds_index,\n"
"          }))),\n"
"        : \"di\",\n"
"    );\n"
"}\n"
"```"

#: src/kernel/gdt.md:488
msgid ""
"Segment Register には [MOV](https://www.felixcloutier.com/x86/mov) 命令を使っ"
"て直接代入できます。 DI レジスタを使って代入しているため、DI レジスタを "
"[clobber](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Clobbers-and-"
"Scratch-Registers) しています。"
msgstr ""
"Segment Register には [MOV](https://www.felixcloutier.com/x86/mov) 命令を使っ"
"て直接代入できます。 DI レジスタを使って代入しているため、DI レジスタを "
"[clobber](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Clobbers-and-"
"Scratch-Registers) しています。"

#: src/kernel/gdt.md:491
msgid ""
"ただし、CS レジスタに関しては直接 MOV はできません。 そのため、[Long Return]"
"(https://docs.oracle.com/cd/E19620-01/805-4693/instructionset-68/index.html) "
"することで CS を設定します:"
msgstr ""
"ただし、CS レジスタに関しては直接 MOV はできません。 そのため、[Long Return]"
"(https://docs.oracle.com/cd/E19620-01/805-4693/instructionset-68/index.html) "
"することで CS を設定します:"

#: src/kernel/gdt.md:494
msgid ""
"```ymir/arch/x86/gdt.zig\n"
"fn loadKernelCs() void {\n"
"    asm volatile (\n"
"        \\\\\n"
"        // Push CS\n"
"        \\\\mov %[kernel_cs], %%rax\n"
"        \\\\push %%rax\n"
"        // Push RIP\n"
"        \\\\leaq next(%%rip), %%rax\n"
"        \\\\pushq %%rax\n"
"        \\\\lretq\n"
"        \\\\next:\n"
"        \\\\\n"
"        :\n"
"        : [kernel_cs] \"n\" (@as(u16, @bitCast(SegmentSelector{\n"
"            .rpl = 0,\n"
"            .index = kernel_cs_index,\n"
"          }))),\n"
"    );\n"
"}\n"
"```"
msgstr ""
"```ymir/arch/x86/gdt.zig\n"
"fn loadKernelCs() void {\n"
"    asm volatile (\n"
"        \\\\\n"
"        // Push CS\n"
"        \\\\mov %[kernel_cs], %%rax\n"
"        \\\\push %%rax\n"
"        // Push RIP\n"
"        \\\\leaq next(%%rip), %%rax\n"
"        \\\\pushq %%rax\n"
"        \\\\lretq\n"
"        \\\\next:\n"
"        \\\\\n"
"        :\n"
"        : [kernel_cs] \"n\" (@as(u16, @bitCast(SegmentSelector{\n"
"            .rpl = 0,\n"
"            .index = kernel_cs_index,\n"
"          }))),\n"
"    );\n"
"}\n"
"```"

#: src/kernel/gdt.md:516
msgid ""
"`lret` はスタックに積んだ CS/RIP を POP してレジスタにセットしてくれます。 "
"RIP は変更させたくないため `lret` の直後のアドレスを PUSH することで、CS を設"
"定する効果だけを得ています。"
msgstr ""
"`lret` はスタックに積んだ CS/RIP を POP してレジスタにセットしてくれます。 "
"RIP は変更させたくないため `lret` の直後のアドレスを PUSH することで、CS を設"
"定する効果だけを得ています。"

#: src/kernel/gdt.md:519
msgid ""
"以上で GDT の更新が反映されるようになります。 `init()` から呼び出すようにして"
"おきましょう:"
msgstr ""
"以上で GDT の更新が反映されるようになります。 `init()` から呼び出すようにして"
"おきましょう:"

#: src/kernel/gdt.md:533
msgid "実装した GDT の初期化関数を `kernelMain()` から呼び出すようにします:"
msgstr "実装した GDT の初期化関数を `kernelMain()` から呼び出すようにします:"

#: src/kernel/gdt.md:535
msgid ""
"```ymir/main.zig\n"
"arch.gdt.init();\n"
"log.info(\"Initialized GDT.\", .{});\n"
"```"
msgstr ""
"```ymir/main.zig\n"
"arch.gdt.init();\n"
"log.info(\"Initialized GDT.\", .{});\n"
"```"

#: src/kernel/gdt.md:540
msgid ""
"実行すると、見た目は何も変わらず HLT ループまで到達すると思います。 そこで "
"QEMU monitor を立ち上げ、レジスタをチェックしてみましょう:"
msgstr ""
"実行すると、見た目は何も変わらず HLT ループまで到達すると思います。 そこで "
"QEMU monitor を立ち上げ、レジスタをチェックしてみましょう:"

#: src/kernel/gdt.md:566
msgid ""
"セグメントレジスタの一番左の 4nibble の数字が Segment Selector です。 "
"Selector のうち下位 3bit は _RPL_/_TI_ であり、それ以降が GDT index になって"
"います。 CS では selector が `0x10`、つまり index が `0x02` になっています。 "
"DS/ES/FS/GS は selector が `0x08`、つまり index が `0x01` になっています。 そ"
"れぞれ `kernel_ds_index` / `kernel_cs_index` に設定した値になっていることが確"
"認できます。 用意した GDT がちゃんと反映されていることが確認できました。"
msgstr ""
"セグメントレジスタの一番左の 4nibble の数字が Segment Selector です。 "
"Selector のうち下位 3bit は _RPL_/_TI_ であり、それ以降が GDT index になって"
"います。 CS では selector が `0x10`、つまり index が `0x02` になっています。 "
"DS/ES/FS/GS は selector が `0x08`、つまり index が `0x01` になっています。 そ"
"れぞれ `kernel_ds_index` / `kernel_cs_index` に設定した値になっていることが確"
"認できます。 用意した GDT がちゃんと反映されていることが確認できました。"

#: src/kernel/gdt.md:573
msgid ""
"本チャプターでは、GDT の初期化を行いました。 x64 の 64bit モードではほとんど"
"セグメンテーションは使われないため、2つのセグメントだけを設定しました。 もう "
"UEFI が提供していた GDT は使われないため、その領域は Ymir が自由に使えるよう"
"に成りました。 次のチャプターでは UEFI が提供する他の構造である IDT を Ymir "
"のものに置き換えていきます。"
msgstr ""
"本チャプターでは、GDT の初期化を行いました。 x64 の 64bit モードではほとんど"
"セグメンテーションは使われないため、2つのセグメントだけを設定しました。 もう "
"UEFI が提供していた GDT は使われないため、その領域は Ymir が自由に使えるよう"
"に成りました。 次のチャプターでは UEFI が提供する他の構造である IDT を Ymir "
"のものに置き換えていきます。"

#: src/kernel/gdt.md:578
msgid ""
"同様にセグメントを設定する構造に **LDT: Local Descriptor Table** があります"
"が、Ymir では GDT のみを使います。"
msgstr ""
"同様にセグメントを設定する構造に **LDT: Local Descriptor Table** があります"
"が、Ymir では GDT のみを使います。"

#: src/kernel/gdt.md:579
msgid ""
"x64 (Intel64) における物理アドレス空間のサイズは実装依存です。 CPUID "
"`0x80000008` で実際のサイズを取得できます。 最近の CPU だと 46bit の場合が多"
"いと思います。"
msgstr ""
"x64 (Intel64) における物理アドレス空間のサイズは実装依存です。 CPUID "
"`0x80000008` で実際のサイズを取得できます。 最近の CPU だと 46bit の場合が多"
"いと思います。"

#: src/kernel/gdt.md:582
msgid ""
"Page Table を使ったアドレス変換における、**TLB: Translation Lookaside "
"Buffer** と似たような感じですね。"
msgstr ""
"Page Table を使ったアドレス変換における、**TLB: Translation Lookaside "
"Buffer** と似たような感じですね。"

#: src/kernel/gdt.md:583
msgid ""
"Logical to Linear 変換が行われないため、本シリーズでは Logical/Linear "
"Address のことをまとめて仮想アドレスと呼びます。"
msgstr ""
"Logical to Linear 変換が行われないため、本シリーズでは Logical/Linear "
"Address のことをまとめて仮想アドレスと呼びます。"

#: src/kernel/gdt.md:584
msgid ""
"[A possible end to the FSGSBASE saga - LWN.net](https://lwn.net/"
"Articles/821723/)"
msgstr ""
"[A possible end to the FSGSBASE saga - LWN.net](https://lwn.net/"
"Articles/821723/)"

#: src/kernel/gdt.md:585
msgid ""
"この 4bit 分のフィールドは、_Descriptor Type_ が _application (code / data)_ "
"か _system_ かによって変わります。 本シリーズでは _system_ セグメントを扱わな"
"いため、_application_ 用のフィールドのみを定義します。"
msgstr ""
"この 4bit 分のフィールドは、_Descriptor Type_ が _application (code / data)_ "
"か _system_ かによって変わります。 本シリーズでは _system_ セグメントを扱わな"
"いため、_application_ 用のフィールドのみを定義します。"

#: src/kernel/gdt.md:587
msgid ""
"System Descriptor には、_LDT_ / _TSS_ / Call-gate / Interrupt-gate / Trap-"
"gate / Task-gate descriptor があります。"
msgstr ""
"System Descriptor には、_LDT_ / _TSS_ / Call-gate / Interrupt-gate / Trap-"
"gate / Task-gate descriptor があります。"

#: src/kernel/gdt.md:588
msgid "ただし、上限は IA-32e mode で \\\\(2^{13} = 8192\\\\) 個です。"
msgstr "ただし、上限は IA-32e mode で \\\\(2^{13} = 8192\\\\) 個です。"

#: src/kernel/gdt.md:589
msgid ""
"[error: LLVM ERROR: Unsupported expression in static initializer #17856]"
"(https://github.com/ziglang/zig/issues/17856)"
msgstr ""
"[error: LLVM ERROR: Unsupported expression in static initializer #17856]"
"(https://github.com/ziglang/zig/issues/17856)"

#: src/kernel/interrupt.md:3
msgid ""
"本チャプターは UEFI が用意してくれたものを Ymir が置き換えていくシリーズの第2"
"弾です。 今回は割り込みと例外を扱います。 UEFI が Surtr に処理を渡した時点"
"で、基本的な例外設定は UEFI がしてくれています。 どの例外ハンドラもアボートす"
"るだけのようですが。 Ymir ではこれを置き換えて、割り込みの適切な処理や例外時"
"のエラー表示等をします。"
msgstr ""
"本チャプターは UEFI が用意してくれたものを Ymir が置き換えていくシリーズの第2"
"弾です。 今回は割り込みと例外を扱います。 UEFI が Surtr に処理を渡した時点"
"で、基本的な例外設定は UEFI がしてくれています。 どの例外ハンドラもアボートす"
"るだけのようですが。 Ymir ではこれを置き換えて、割り込みの適切な処理や例外時"
"のエラー表示等をします。"

#: src/kernel/interrupt.md:9
msgid ""
"なお、本チャプターは _SDM Vol.3A Chapter 6 INTERRUPT AND EXCEPTION HANDLING_ "
"に基づいています。 より詳細を知りたい人はあわせて参照してください。"
msgstr ""
"なお、本チャプターは _SDM Vol.3A Chapter 6 INTERRUPT AND EXCEPTION HANDLING_ "
"に基づいています。 より詳細を知りたい人はあわせて参照してください。"

#: src/kernel/interrupt.md:14
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-interrupt`]"
#| "(https://github.com/smallkirby/ymir/tree/whiz-ymir-interrupt) ブランチにあ"
#| "ります。"
msgid ""
"本チャプターの最終コードは [`whiz-ymir-interrupt`](https://github.com/"
"smallkirby/ymir/tree/whiz-ymir-interrupt) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-interrupt`](https://"
"github.com/smallkirby/ymir/tree/whiz-ymir-interrupt) ブランチにあります。"

#: src/kernel/interrupt.md:18
msgid "[割り込みと例外の基礎](#割り込みと例外の基礎)"
msgstr "[割り込みと例外の基礎](#割り込みと例外の基礎)"

#: src/kernel/interrupt.md:19
msgid "[分類](#分類)"
msgstr "[分類](#分類)"

#: src/kernel/interrupt.md:20
msgid "[Interrupt Descriptor Table](#interrupt-descriptor-table)"
msgstr "[Interrupt Descriptor Table](#interrupt-descriptor-table)"

#: src/kernel/interrupt.md:21
msgid "[ハンドラの呼び出し](#ハンドラの呼び出し)"
msgstr "[ハンドラの呼び出し](#ハンドラの呼び出し)"

#: src/kernel/interrupt.md:22
msgid "[Gate Descriptor の実装](#gate-descriptor-の実装)"
msgstr "[Gate Descriptor の実装](#gate-descriptor-の実装)"

#: src/kernel/interrupt.md:23
msgid "[空の IDT の初期化](#空の-idt-の初期化)"
msgstr "[空の IDT の初期化](#空の-idt-の初期化)"

#: src/kernel/interrupt.md:24
msgid "[割り込みハンドラの共通部分](#割り込みハンドラの共通部分)"
msgstr "[割り込みハンドラの共通部分](#割り込みハンドラの共通部分)"

#: src/kernel/interrupt.md:25
msgid "[vector 固有のハンドラ](#vector-固有のハンドラ)"
msgstr "[vector 固有のハンドラ](#vector-固有のハンドラ)"

#: src/kernel/interrupt.md:26
msgid "[IDT にハンドラのセット](#idt-にハンドラのセット)"
msgstr "[IDT にハンドラのセット](#idt-にハンドラのセット)"

#: src/kernel/interrupt.md:29
msgid "割り込みと例外の基礎"
msgstr "割り込みと例外の基礎"

#: src/kernel/interrupt.md:31
msgid ""
"CPU は **割り込み (Interrupts)** と **例外 (Excetpions)**  という2つのイベン"
"ト[^call]を受け取ることができます。 割り込みはハードウェアからの信号によって"
"任意のタイミングで発生[^timing]するのに対し、 例外は CPU が instruction を実"
"行するタイミングでエラーを検知して発生します。 なお、どちらもハンドラが呼び出"
"されるのは Instruction Boundary に制限されるため、命令の途中で割り込みハンド"
"ラが呼び出されることはありません。"
msgstr ""
"CPU は **割り込み (Interrupts)** と **例外 (Excetpions)**  という2つのイベン"
"ト[^call]を受け取ることができます。 割り込みはハードウェアからの信号によって"
"任意のタイミングで発生[^timing]するのに対し、 例外は CPU が instruction を実"
"行するタイミングでエラーを検知して発生します。 なお、どちらもハンドラが呼び出"
"されるのは Instruction Boundary に制限されるため、命令の途中で割り込みハンド"
"ラが呼び出されることはありません。"

#: src/kernel/interrupt.md:36
msgid "分類"
msgstr "分類"

#: src/kernel/interrupt.md:38
msgid "**割り込み** は Interrupt Source によって以下の2つに分類されます:"
msgstr "**割り込み** は Interrupt Source によって以下の2つに分類されます:"

#: src/kernel/interrupt.md:40 src/kernel/interrupt.md:51
#: src/kernel/interrupt.md:60
msgid "Name"
msgstr "Name"

#: src/kernel/interrupt.md:42
msgid "**External Interrupts**"
msgstr "**External Interrupts**"

#: src/kernel/interrupt.md:42
msgid "CPU 内部から発生する割り込み。"
msgstr "CPU 内部から発生する割り込み。"

#: src/kernel/interrupt.md:43
msgid "**Software-generated Interrupts**"
msgstr "**Software-generated Interrupts**"

#: src/kernel/interrupt.md:43
msgid ""
"ソフトウェアから [INT](https://www.felixcloutier.com/x86/intn:into:int3:"
"int1) 命令で発生。任意の番号の割り込みを発生可能。"
msgstr ""
"ソフトウェアから [INT](https://www.felixcloutier.com/x86/intn:into:int3:"
"int1) 命令で発生。任意の番号の割り込みを発生可能。"

#: src/kernel/interrupt.md:45
msgid ""
"**例外** も Interrupt Source によって3種類に分類されますが、そんなに使い分け"
"ることがないので省略します。 割り込みと同様に [INT](https://www."
"felixcloutier.com/x86/intn:into:int3:int1) 命令で任意の vector の例外を発生さ"
"せることができます。 ただし、INT 命令による例外には **Error Code** がスタック"
"に PUSH されないという制約があります。"
msgstr ""
"**例外** も Interrupt Source によって3種類に分類されますが、そんなに使い分け"
"ることがないので省略します。 割り込みと同様に [INT](https://www."
"felixcloutier.com/x86/intn:into:int3:int1) 命令で任意の vector の例外を発生さ"
"せることができます。 ただし、INT 命令による例外には **Error Code** がスタック"
"に PUSH されないという制約があります。"

#: src/kernel/interrupt.md:49
msgid ""
"例外には、例外を発生させたタスクの再開が可能かどうかに応じて以下の3つのクラス"
"があります:"
msgstr ""
"例外には、例外を発生させたタスクの再開が可能かどうかに応じて以下の3つのクラス"
"があります:"

#: src/kernel/interrupt.md:51
msgid "Can Resume?"
msgstr "Can Resume?"

#: src/kernel/interrupt.md:51
msgid "Return Address"
msgstr "Return Address"

#: src/kernel/interrupt.md:53
msgid "**Faults**"
msgstr "**Faults**"

#: src/kernel/interrupt.md:53 src/kernel/interrupt.md:54
msgid "Yes"
msgstr "Yes"

#: src/kernel/interrupt.md:53
msgid "Faulting instruction."
msgstr "Faulting instruction."

#: src/kernel/interrupt.md:54
msgid "**Traps**"
msgstr "**Traps**"

#: src/kernel/interrupt.md:54
msgid "Next instruction."
msgstr "Next instruction."

#: src/kernel/interrupt.md:55
msgid "**Aborts**"
msgstr "**Aborts**"

#: src/kernel/interrupt.md:55
msgid "No"
msgstr "No"

#: src/kernel/interrupt.md:55 src/kernel/interrupt.md:64
#: src/kernel/interrupt.md:71 src/kernel/interrupt.md:77
msgid "\\-"
msgstr "\\-"

#: src/kernel/interrupt.md:57
msgid ""
"例外は CPU が定義するものであるため、例外の種類はアーキテクチャに依存しま"
"す。 x64 では以下のように例外が定義されています:"
msgstr ""
"例外は CPU が定義するものであるため、例外の種類はアーキテクチャに依存しま"
"す。 x64 では以下のように例外が定義されています:"

#: src/kernel/interrupt.md:60
msgid "Vector"
msgstr "Vector"

#: src/kernel/interrupt.md:60
msgid "Class"
msgstr "Class"

#: src/kernel/interrupt.md:62
msgid "0"
msgstr "0"

#: src/kernel/interrupt.md:62
msgid "\\#DE: Divide Error"
msgstr "\\#DE: Divide Error"

#: src/kernel/interrupt.md:62 src/kernel/interrupt.md:67
#: src/kernel/interrupt.md:68 src/kernel/interrupt.md:69
#: src/kernel/interrupt.md:72 src/kernel/interrupt.md:73
#: src/kernel/interrupt.md:74 src/kernel/interrupt.md:75
#: src/kernel/interrupt.md:76 src/kernel/interrupt.md:78
#: src/kernel/interrupt.md:79 src/kernel/interrupt.md:81
#: src/kernel/interrupt.md:82 src/kernel/interrupt.md:83
msgid "Fault"
msgstr "Fault"

#: src/kernel/interrupt.md:63
msgid "1"
msgstr "1"

#: src/kernel/interrupt.md:63
msgid "\\#DB: Debug"
msgstr "\\#DB: Debug"

#: src/kernel/interrupt.md:63
msgid "Fault/Trap"
msgstr "Fault/Trap"

#: src/kernel/interrupt.md:64
msgid "2"
msgstr "2"

#: src/kernel/interrupt.md:64
msgid "NMI: Non-Maskable Interrupt"
msgstr "NMI: Non-Maskable Interrupt"

#: src/kernel/interrupt.md:65
msgid "3"
msgstr "3"

#: src/kernel/interrupt.md:65
msgid "\\#BP: Breakpoint"
msgstr "\\#BP: Breakpoint"

#: src/kernel/interrupt.md:65 src/kernel/interrupt.md:66
msgid "Trap"
msgstr "Trap"

#: src/kernel/interrupt.md:66
msgid "4"
msgstr "4"

#: src/kernel/interrupt.md:66
msgid "\\#OF: Overflow"
msgstr "\\#OF: Overflow"

#: src/kernel/interrupt.md:67
msgid "5"
msgstr "5"

#: src/kernel/interrupt.md:67
msgid "\\#BR: BOUND Range Exceeded"
msgstr "\\#BR: BOUND Range Exceeded"

#: src/kernel/interrupt.md:68
msgid "6"
msgstr "6"

#: src/kernel/interrupt.md:68
msgid "\\#UD: Invalid Opcode"
msgstr "\\#UD: Invalid Opcode"

#: src/kernel/interrupt.md:69
msgid "7"
msgstr "7"

#: src/kernel/interrupt.md:69
msgid "\\#NM: Device Not Available"
msgstr "\\#NM: Device Not Available"

#: src/kernel/interrupt.md:70
msgid "8"
msgstr "8"

#: src/kernel/interrupt.md:70
msgid "\\#DF: Double Fault"
msgstr "\\#DF: Double Fault"

#: src/kernel/interrupt.md:70 src/kernel/interrupt.md:80
msgid "Abort"
msgstr "Abort"

#: src/kernel/interrupt.md:71
msgid "9"
msgstr "9"

#: src/kernel/interrupt.md:72
msgid "10"
msgstr "10"

#: src/kernel/interrupt.md:72
msgid "\\#TS: Invalid TSS"
msgstr "\\#TS: Invalid TSS"

#: src/kernel/interrupt.md:73
msgid "11"
msgstr "11"

#: src/kernel/interrupt.md:73
msgid "\\#NP: Segment Not Present"
msgstr "\\#NP: Segment Not Present"

#: src/kernel/interrupt.md:74
msgid "12"
msgstr "12"

#: src/kernel/interrupt.md:74
msgid "\\#SS: Stack-Segment Fault"
msgstr "\\#SS: Stack-Segment Fault"

#: src/kernel/interrupt.md:75
msgid "13"
msgstr "13"

#: src/kernel/interrupt.md:75
msgid "\\#GP: General Protection"
msgstr "\\#GP: General Protection"

#: src/kernel/interrupt.md:76
msgid "14"
msgstr "14"

#: src/kernel/interrupt.md:76
msgid "\\#PF: Page Fault"
msgstr "\\#PF: Page Fault"

#: src/kernel/interrupt.md:77
msgid "15"
msgstr "15"

#: src/kernel/interrupt.md:78
msgid "16"
msgstr "16"

#: src/kernel/interrupt.md:78
msgid "\\#MF: x87 FPU Floating-Point Error"
msgstr "\\#MF: x87 FPU Floating-Point Error"

#: src/kernel/interrupt.md:79
msgid "17"
msgstr "17"

#: src/kernel/interrupt.md:79
msgid "\\#AC: Alignment Check"
msgstr "\\#AC: Alignment Check"

#: src/kernel/interrupt.md:80
msgid "18"
msgstr "18"

#: src/kernel/interrupt.md:80
msgid "\\#MC: Machine Check"
msgstr "\\#MC: Machine Check"

#: src/kernel/interrupt.md:81
msgid "19"
msgstr "19"

#: src/kernel/interrupt.md:81
msgid "\\#XM: SIMD Floating-Point Exception"
msgstr "\\#XM: SIMD Floating-Point Exception"

#: src/kernel/interrupt.md:82
msgid "20"
msgstr "20"

#: src/kernel/interrupt.md:82
msgid "\\#VE: Virtualization Exception"
msgstr "\\#VE: Virtualization Exception"

#: src/kernel/interrupt.md:83
msgid "21"
msgstr "21"

#: src/kernel/interrupt.md:83
msgid "\\#CP: Control Protection Exception"
msgstr "\\#CP: Control Protection Exception"

#: src/kernel/interrupt.md:85
msgid ""
"割り込みと例外の vector は 0 から 255 までの 256 個です。 そのうちの 0 から "
"31 までが例外に割当てられているか予約されているため、割り込みとして使えるの"
"は 32 から 255 までです。"
msgstr ""
"割り込みと例外の vector は 0 から 255 までの 256 個です。 そのうちの 0 から "
"31 までが例外に割当てられているか予約されているため、割り込みとして使えるの"
"は 32 から 255 までです。"

#: src/kernel/interrupt.md:88
msgid "Interrupt Descriptor Table"
msgstr "Interrupt Descriptor Table"

#: src/kernel/interrupt.md:90
msgid ""
"**IDT: Interrupt Descriptor Table** は割り込みと例外のハンドラを保持するテー"
"ブルです。 GDT と同様に **Gate Descriptor** という 8byte のエントリから成る配"
"列[^idt-size]です。 Gate Descriptor には _Task Gate_ / _Interrupt Gate_ / "
"_Trap Gate_ という3つの種類があります。 Task Gate は HW タスクスイッチに使わ"
"れますが本シリーズでは使いません。 Interrupt Gate と Trap Gate の違いは、ハン"
"ドラ呼び出し時に割り込みを無効化する ( `RFLAGS.IF` をクリアする) かどうかで"
"す。 **本シリーズでは Interrupt Gate だけを使います**。"
msgstr ""
"**IDT: Interrupt Descriptor Table** は割り込みと例外のハンドラを保持するテー"
"ブルです。 GDT と同様に **Gate Descriptor** という 8byte のエントリから成る配"
"列[^idt-size]です。 Gate Descriptor には _Task Gate_ / _Interrupt Gate_ / "
"_Trap Gate_ という3つの種類があります。 Task Gate は HW タスクスイッチに使わ"
"れますが本シリーズでは使いません。 Interrupt Gate と Trap Gate の違いは、ハン"
"ドラ呼び出し時に割り込みを無効化する ( `RFLAGS.IF` をクリアする) かどうかで"
"す。 **本シリーズでは Interrupt Gate だけを使います**。"

#: src/kernel/interrupt.md:97
msgid "Gate Descriptor は以下の構造を持ちます:"
msgstr "Gate Descriptor は以下の構造を持ちます:"

#: src/kernel/interrupt.md:99
msgid ""
"![64-Bit IDT Descriptors](../assets/sdm/idt_gate_descriptors.png) _SDM "
"Vol.3A 6.14.1 Figure 6-8. 64-Bit IDT Gate Descriptors_"
msgstr ""
"![64-Bit IDT Descriptors](../assets/sdm/idt_gate_descriptors.png) _SDM "
"Vol.3A 6.14.1 Figure 6-8. 64-Bit IDT Gate Descriptors_"

#: src/kernel/interrupt.md:102
msgid ""
"_Offset_ / _Segment Selector_ / _DPL_ 以外は固定値です。 **Segment "
"Selector** は例外・割り込みハンドラが位置するセグメントを選択するためのセレク"
"タです。 Segment Selector が指定するセグメント内のオフセットは **Offset** に"
"よって指定されます。"
msgstr ""
"_Offset_ / _Segment Selector_ / _DPL_ 以外は固定値です。 **Segment "
"Selector** は例外・割り込みハンドラが位置するセグメントを選択するためのセレク"
"タです。 Segment Selector が指定するセグメント内のオフセットは **Offset** に"
"よって指定されます。"

#: src/kernel/interrupt.md:106
msgid "ハンドラの呼び出し"
msgstr "ハンドラの呼び出し"

#: src/kernel/interrupt.md:108
msgid ""
"割り込みが発生した場合、その vector に対応する Gate Descriptor が IDT から取"
"得されます。 IDT には **Segment Selector** が入っており、ハンドラがあるセグメ"
"ントを指定します。 FS/GS 等の Segment Selector と全く同じです。 セグメント内"
"のハンドラのオフセットは _Offset_ で指定されます。 つまり、Logical to Linear "
"変換と全く同じ方法でハンドラの物理アドレスが計算されます:"
msgstr ""
"割り込みが発生した場合、その vector に対応する Gate Descriptor が IDT から取"
"得されます。 IDT には **Segment Selector** が入っており、ハンドラがあるセグメ"
"ントを指定します。 FS/GS 等の Segment Selector と全く同じです。 セグメント内"
"のハンドラのオフセットは _Offset_ で指定されます。 つまり、Logical to Linear "
"変換と全く同じ方法でハンドラの物理アドレスが計算されます:"

#: src/kernel/interrupt.md:114
msgid ""
"![Interrupt Procedure Call](../assets/sdm/interrupt_procedure_call.png) _SDM "
"Vol.3A 6.12.1 Figure 6-3. Interrupt Procedure Call_"
msgstr ""
"![Interrupt Procedure Call](../assets/sdm/interrupt_procedure_call.png) _SDM "
"Vol.3A 6.12.1 Figure 6-3. Interrupt Procedure Call_"

#: src/kernel/interrupt.md:117
msgid "Gate Descriptor の実装"
msgstr "Gate Descriptor の実装"

#: src/kernel/interrupt.md:119
msgid ""
"まずは Gate Descriptor 構造体を定義します。 一応 `GateType` も定義しますが、"
"本シリーズでは Interrupt Gate しか使いません:"
msgstr ""
"まずは Gate Descriptor 構造体を定義します。 一応 `GateType` も定義しますが、"
"本シリーズでは Interrupt Gate しか使いません:"

#: src/kernel/interrupt.md:162
msgid ""
"続いて、IDT を定義します。 GDT と同様に `.data` セクションに確保される配列と"
"します。 なお、GDT の [NULL Descriptor](./gdt.md#null-descriptor) とは異なり "
"0 番目の要素も実際に使うことができます:"
msgstr ""
"続いて、IDT を定義します。 GDT と同様に `.data` セクションに確保される配列と"
"します。 なお、GDT の [NULL Descriptor](./gdt.md#null-descriptor) とは異なり "
"0 番目の要素も実際に使うことができます:"

#: src/kernel/interrupt.md:172
msgid "最後に、IDT にエントリを追加する関数を用意します:"
msgstr "最後に、IDT にエントリを追加する関数を用意します:"

#: src/kernel/interrupt.md:194
msgid ""
"`Isr` は後述する割り込みハンドラの関数型です。 ハンドラはコード領域に置かれる"
"ため、セグメントは CS を指定します (下位 3bit は RPL/TI[^ti] なのでその分だけ"
"シフトします)。"
msgstr ""
"`Isr` は後述する割り込みハンドラの関数型です。 ハンドラはコード領域に置かれる"
"ため、セグメントは CS を指定します (下位 3bit は RPL/TI[^ti] なのでその分だけ"
"シフトします)。"

#: src/kernel/interrupt.md:198
msgid "空の IDT の初期化"
msgstr "空の IDT の初期化"

#: src/kernel/interrupt.md:200
msgid ""
"一旦ちゃんとしたハンドラを設定する前に、空の IDT を初期化して使ってみましょ"
"う。 IDT の初期化関数を用意します:"
msgstr ""
"一旦ちゃんとしたハンドラを設定する前に、空の IDT を初期化して使ってみましょ"
"う。 IDT の初期化関数を用意します:"

#: src/kernel/interrupt.md:221
msgid ""
"IDT 自体のアドレスは **IDTR: Interrupt Descriptor Table Register** にセットし"
"ます。 GDT における GDTR に対応するレジスタです。 やはり GDT と同様に、Zig "
"0.13.0 時点のバグのせいで `.base = &idt` というような定義ができないため、 "
"`init()` の中で IDT のアドレスをセットします。 `am.lidt()` は [LIDT](https://"
"www.felixcloutier.com/x86/lgdt:lidt) を実行するためのアセンブリ関数です。"
msgstr ""
"IDT 自体のアドレスは **IDTR: Interrupt Descriptor Table Register** にセットし"
"ます。 GDT における GDTR に対応するレジスタです。 やはり GDT と同様に、Zig "
"0.13.0 時点のバグのせいで `.base = &idt` というような定義ができないため、 "
"`init()` の中で IDT のアドレスをセットします。 `am.lidt()` は [LIDT](https://"
"www.felixcloutier.com/x86/lgdt:lidt) を実行するためのアセンブリ関数です。"

#: src/kernel/interrupt.md:227
msgid "`kernelMain()` から呼び出して初期化します:"
msgstr "`kernelMain()` から呼び出して初期化します:"

#: src/kernel/interrupt.md:235
msgid ""
"これで空の IDT を設定できました。 実際に例外を起こしてみましょう。 Zig で定数"
"値を使って `#DE: Devide Error` を引き起こすのは少し面倒なため、今回は `#GP: "
"General Protection Fault` を引き起こしてみます:"
msgstr ""
"これで空の IDT を設定できました。 実際に例外を起こしてみましょう。 Zig で定数"
"値を使って `#DE: Devide Error` を引き起こすのは少し面倒なため、今回は `#GP: "
"General Protection Fault` を引き起こしてみます:"

#: src/kernel/interrupt.md:245
msgid ""
"`0xDEAD000000000000` というアドレスは、**Canonical Form** ではありません。 "
"Canonical Form は仮想アドレスが満たすべきフォーマットのことで、 _Most "
"Significant Implemented Bit_ (おそらく最近のCPUだと 47-th bit) とそれより高位"
"のビットが全て同じであることを要求します。 今回のアドレスは 47-th bit が `0` "
"なのに対し、それより上位のビットが `0x00000000` ではないため `#GP` が発生しま"
"す。"
msgstr ""
"`0xDEAD000000000000` というアドレスは、**Canonical Form** ではありません。 "
"Canonical Form は仮想アドレスが満たすべきフォーマットのことで、 _Most "
"Significant Implemented Bit_ (おそらく最近のCPUだと 47-th bit) とそれより高位"
"のビットが全て同じであることを要求します。 今回のアドレスは 47-th bit が `0` "
"なのに対し、それより上位のビットが `0x00000000` ではないため `#GP` が発生しま"
"す。"

#: src/kernel/interrupt.md:249
msgid ""
"実行すると、おそらく QEMU が終了します。 これは **Triple Fault** が発生したた"
"めです。 まず、指定したアドレスから値を取得しようとして `#GP` が発生します。 "
"CPU は `#GP` のベクタである 13 番目のエントリを IDT から取得します。 現在 "
"IDT は全て 0 で埋めてあるため、_Segment Selector_ が 0 (_NULL Segment "
"Selector_) として解釈されます。 Null Segment Selector を使ったメモリアクセス"
"は `#GP` を発生させようとしますが[^deref-null]、 2回連続の `#GP` なので "
"`#DF: Double Fault` が発生します[^double-fault]。 ここでもやはりハンドラのア"
"ドレス解決時に `#GP` が発生し、最終的には Triple Fault が発生します。 Triple "
"Fault はシステムをシャットダウンするため、QEMU が終了します。"
msgstr ""
"実行すると、おそらく QEMU が終了します。 これは **Triple Fault** が発生したた"
"めです。 まず、指定したアドレスから値を取得しようとして `#GP` が発生します。 "
"CPU は `#GP` のベクタである 13 番目のエントリを IDT から取得します。 現在 "
"IDT は全て 0 で埋めてあるため、_Segment Selector_ が 0 (_NULL Segment "
"Selector_) として解釈されます。 Null Segment Selector を使ったメモリアクセス"
"は `#GP` を発生させようとしますが[^deref-null]、 2回連続の `#GP` なので "
"`#DF: Double Fault` が発生します[^double-fault]。 ここでもやはりハンドラのア"
"ドレス解決時に `#GP` が発生し、最終的には Triple Fault が発生します。 Triple "
"Fault はシステムをシャットダウンするため、QEMU が終了します。"

#: src/kernel/interrupt.md:259
msgid ""
"なにはともあれ、UEFI の用意した IDT から Ymir の IDT に置き換えること自体には"
"成功しているようです。"
msgstr ""
"なにはともあれ、UEFI の用意した IDT から Ymir の IDT に置き換えること自体には"
"成功しているようです。"

#: src/kernel/interrupt.md:263
#, fuzzy
#| msgid ""
#| "\\[!NOTE\\] UEFI の用意する IDT `main.zig` において、IDT と GDT の初期化を"
#| "する関数呼び出しをコメントアウトした状態で `#GP` を発生させると、UEFI が用"
#| "意してくれた IDT が使われます。 このハンドラは、例外の種類とレジスタの状態"
#| "をダンプしてくれるものです:"
msgid ""
"`main.zig` において、IDT と GDT の初期化をする関数呼び出しをコメントアウトし"
"た状態で `#GP` を発生させると、UEFI が用意してくれた IDT が使われます。 この"
"ハンドラは、例外の種類とレジスタの状態をダンプしてくれるものです:"
msgstr ""
"\\[!NOTE\\] UEFI の用意する IDT `main.zig` において、IDT と GDT の初期化をす"
"る関数呼び出しをコメントアウトした状態で `#GP` を発生させると、UEFI が用意し"
"てくれた IDT が使われます。 このハンドラは、例外の種類とレジスタの状態をダン"
"プしてくれるものです:"

#: src/kernel/interrupt.md:286
msgid ""
"なお、IDT の初期化だけをコメントアウトするとやはり Triple Fault が発生しま"
"す。 GDT のコメントアウトも必要です。クイズとして理由を考えてみるのも良いかも"
"しれません。"
msgstr ""
"なお、IDT の初期化だけをコメントアウトするとやはり Triple Fault が発生しま"
"す。 GDT のコメントアウトも必要です。クイズとして理由を考えてみるのも良いかも"
"しれません。"

#: src/kernel/interrupt.md:289
msgid "割り込みハンドラの共通部分"
msgstr "割り込みハンドラの共通部分"

#: src/kernel/interrupt.md:291
msgid ""
"ここからは、作成した IDT にセットする割り込みハンドラを書いていきます。 割り"
"込みハンドラは **ISR: Interrupt Service Routine** とも呼ばれます。 短くて書き"
"やすいので以降は ISR と呼びます。"
msgstr ""
"ここからは、作成した IDT にセットする割り込みハンドラを書いていきます。 割り"
"込みハンドラは **ISR: Interrupt Service Routine** とも呼ばれます。 短くて書き"
"やすいので以降は ISR と呼びます。"

#: src/kernel/interrupt.md:295
msgid ""
"ISR には vector に関わらず共通でするべき処理があります。 レジスタの退避・復帰"
"などです。 そのため、Ymir では共通の処理を呼び出した後に vector に対応する個"
"別のハンドラを呼び出すような ISR を作成します。"
msgstr ""
"ISR には vector に関わらず共通でするべき処理があります。 レジスタの退避・復帰"
"などです。 そのため、Ymir では共通の処理を呼び出した後に vector に対応する個"
"別のハンドラを呼び出すような ISR を作成します。"

#: src/kernel/interrupt.md:299
msgid ""
"以下では ISR の共通部分を実装していきましょう。 ISR の共通部分は以下のように"
"生成します:"
msgstr ""
"以下では ISR の共通部分を実装していきましょう。 ISR の共通部分は以下のように"
"生成します:"

#: src/kernel/interrupt.md:332
msgid ""
"`generateIsr()` は、割り込み vector を受取り、その vector に対応する ISR を生"
"成します。 全 ISR に「共通」の処理ではありますが、**関数自体は vector の個数"
"分だけ生成する**ということです。 これがなぜかというと、CPU は ISR の呼び出し"
"時に vector をスタックやレジスタに保存してくれないからです。 全 ISR に対して1"
"つの関数しか用意しない場合、現在処理されている割り込み vector を知る方法があ"
"りません。 これを避けるため、vector ごとに関数を生成します。"
msgstr ""
"`generateIsr()` は、割り込み vector を受取り、その vector に対応する ISR を生"
"成します。 全 ISR に「共通」の処理ではありますが、**関数自体は vector の個数"
"分だけ生成する**ということです。 これがなぜかというと、CPU は ISR の呼び出し"
"時に vector をスタックやレジスタに保存してくれないからです。 全 ISR に対して1"
"つの関数しか用意しない場合、現在処理されている割り込み vector を知る方法があ"
"りません。 これを避けるため、vector ごとに関数を生成します。"

#: src/kernel/interrupt.md:340
#, fuzzy
#| msgid ""
#| "\\[!NOTE\\] 関数を返す関数 Zig では構造体を返す関数はとても簡単かつ自然に"
#| "書くことができます。 一方で、関数を返す場合には `struct` のメンバ関数ポイ"
#| "ンタを返すという少し歪な方法を取る必要があります。 もっと良い方法をご存知"
#| "の方がいれば教えてください。"
msgid ""
"Zig では構造体を返す関数はとても簡単かつ自然に書くことができます。 一方で、関"
"数を返す場合には `struct` のメンバ関数ポインタを返すという少し歪な方法を取る"
"必要があります。 もっと良い方法をご存知の方がいれば教えてください。"
msgstr ""
"\\[!NOTE\\] 関数を返す関数 Zig では構造体を返す関数はとても簡単かつ自然に書く"
"ことができます。 一方で、関数を返す場合には `struct` のメンバ関数ポインタを返"
"すという少し歪な方法を取る必要があります。 もっと良い方法をご存知の方がいれば"
"教えてください。"

#: src/kernel/interrupt.md:344
msgid ""
"ISR では、まず [CLI](https://www.felixcloutier.com/x86/cli) 命令で割り込みを"
"無効化します。 CPU は Interrupt Gate 経由で ISR にジャンプする時には _RFLAGS."
"IF_ をクリアしますが、 Trap Gate 経由でジャンプするときにはクリアしません。 "
"よって、Trap Gate 内で割り込みを禁止したい場合には明示的に CLI する必要があり"
"ます[^cli]。"
msgstr ""
"ISR では、まず [CLI](https://www.felixcloutier.com/x86/cli) 命令で割り込みを"
"無効化します。 CPU は Interrupt Gate 経由で ISR にジャンプする時には _RFLAGS."
"IF_ をクリアしますが、 Trap Gate 経由でジャンプするときにはクリアしません。 "
"よって、Trap Gate 内で割り込みを禁止したい場合には明示的に CLI する必要があり"
"ます[^cli]。"

#: src/kernel/interrupt.md:349
msgid ""
"続いて、例外が **Error Code** を提供しない場合にはダミーのエラーコードを "
"PUSH します。 一部の例外は Error Code によって例外の原因などを少し詳しく通知"
"してくれます。 例えば、`#PF: Page Fault` はフォルトを起こしたアクセスが read/"
"write のどちらなのか等を Error Code に含めます。 Error Code を提供するものと"
"しないもののスタックの状態を同じにするため、 ISR では Error Code を提供しない"
"例外にもダミーのエラーコードを PUSH します。 各例外の Error Code の有無や意味"
"は _SDM Vol.3A 6.15 Exception and Interrupt Reference_ を参照してください。"
msgstr ""
"続いて、例外が **Error Code** を提供しない場合にはダミーのエラーコードを "
"PUSH します。 一部の例外は Error Code によって例外の原因などを少し詳しく通知"
"してくれます。 例えば、`#PF: Page Fault` はフォルトを起こしたアクセスが read/"
"write のどちらなのか等を Error Code に含めます。 Error Code を提供するものと"
"しないもののスタックの状態を同じにするため、 ISR では Error Code を提供しない"
"例外にもダミーのエラーコードを PUSH します。 各例外の Error Code の有無や意味"
"は _SDM Vol.3A 6.15 Exception and Interrupt Reference_ を参照してください。"

#: src/kernel/interrupt.md:356
msgid ""
"最後に、ISR の vectorによらない共通部分にジャンプする前に vector を PUSH しま"
"す。 これによって、全割り込みで1つしか用意されていない関数の中でも vector を"
"取得できます。"
msgstr ""
"最後に、ISR の vectorによらない共通部分にジャンプする前に vector を PUSH しま"
"す。 これによって、全割り込みで1つしか用意されていない関数の中でも vector を"
"取得できます。"

#: src/kernel/interrupt.md:359
msgid "全割り込みで共通して使う部分は以下です:"
msgstr "全割り込みで共通して使う部分は以下です:"

#: src/kernel/interrupt.md:422
msgid ""
"まず最初に現在のレジスタの状態を保存します。 続いて、vector ごとの関数を呼び"
"出すための関数である `intrZigEntry()` を呼び出します。 この際、引数には現在"
"の RSP を渡すため、RSP を RDI にコピーしています[^rsp]。 各 vector ごとの引数"
"を呼び出したあとは、保存していたレジスタを復元します。"
msgstr ""
"まず最初に現在のレジスタの状態を保存します。 続いて、vector ごとの関数を呼び"
"出すための関数である `intrZigEntry()` を呼び出します。 この際、引数には現在"
"の RSP を渡すため、RSP を RDI にコピーしています[^rsp]。 各 vector ごとの引数"
"を呼び出したあとは、保存していたレジスタを復元します。"

#: src/kernel/interrupt.md:427
msgid ""
"最後に、[IRET](https://www.felixcloutier.com/x86/iret:iretd:iretq) 命令で割り"
"込みから復帰します。 IRET はスタックの上から順に RIP / CS / RFLAGS を POP す"
"る命令です。 この3つをスタックに積んだ覚えがないと思ったあなた、正解です。 こ"
"の3つは ISR に入る際に CPU が自動的に PUSH してくれるものです。 ISR を呼び出"
"す直前に CPU はスタックに以下のものを積んでくれます:"
msgstr ""
"最後に、[IRET](https://www.felixcloutier.com/x86/iret:iretd:iretq) 命令で割り"
"込みから復帰します。 IRET はスタックの上から順に RIP / CS / RFLAGS を POP す"
"る命令です。 この3つをスタックに積んだ覚えがないと思ったあなた、正解です。 こ"
"の3つは ISR に入る際に CPU が自動的に PUSH してくれるものです。 ISR を呼び出"
"す直前に CPU はスタックに以下のものを積んでくれます:"

#: src/kernel/interrupt.md:433
msgid ""
"![Stack Usage on Transfers to Interrupt and Exception-Handling Routines](../"
"assets/sdm/intr_stack.png) _SDM Vol.3A 6.4 Figure 6-4. Stack Usage on "
"Transfers to Interrupt and Exception-Handling Routines_"
msgstr ""
"![Stack Usage on Transfers to Interrupt and Exception-Handling Routines](../"
"assets/sdm/intr_stack.png) _SDM Vol.3A 6.4 Figure 6-4. Stack Usage on "
"Transfers to Interrupt and Exception-Handling Routines_"

#: src/kernel/interrupt.md:436
msgid ""
"本シリーズでは Ymir はユーザランドを実装しないため、 `with No Privilege-"
"Level Change` の場合のみを考えれば良いです。 たとえ Error Code が提供されない"
"場合でも、ISR の共通部分でダミーの Error Code を PUSH していたため、 スタック"
"は必ずこの図のとおりになります。 加えて、Ymir の ISR ではこれに vector も "
"PUSH していました。 よって、IRET する前には vector と Error Code をスタックか"
"ら取り除くために `add $0x10, %%rsp` を行っています。"
msgstr ""
"本シリーズでは Ymir はユーザランドを実装しないため、 `with No Privilege-"
"Level Change` の場合のみを考えれば良いです。 たとえ Error Code が提供されない"
"場合でも、ISR の共通部分でダミーの Error Code を PUSH していたため、 スタック"
"は必ずこの図のとおりになります。 加えて、Ymir の ISR ではこれに vector も "
"PUSH していました。 よって、IRET する前には vector と Error Code をスタックか"
"ら取り除くために `add $0x10, %%rsp` を行っています。"

#: src/kernel/interrupt.md:444
#, fuzzy
#| msgid ""
#| "\\[!NOTE\\] スタックのアライン x64 の命令の中には、スタックが 16byte にア"
#| "ラインされていることを要求する命令があります。 その一例は [MOVAPS]"
#| "(https://www.felixcloutier.com/x86/movaps) 命令です。 この命令はスタック"
#| "が 16byte にアラインされていない場合に `#GP` を発生させます。 ISR から "
#| "`intrZigEntry()` を呼び出す際にはスタックを 16byte にアラインする操作を挟"
#| "んでいます。"
msgid ""
"x64 の命令の中には、スタックが 16byte にアラインされていることを要求する命令"
"があります。 その一例は [MOVAPS](https://www.felixcloutier.com/x86/movaps) 命"
"令です。 この命令はスタックが 16byte にアラインされていない場合に `#GP` を発"
"生させます。 ISR から `intrZigEntry()` を呼び出す際にはスタックを 16byte にア"
"ラインする操作を挟んでいます。"
msgstr ""
"\\[!NOTE\\] スタックのアライン x64 の命令の中には、スタックが 16byte にアライ"
"ンされていることを要求する命令があります。 その一例は [MOVAPS](https://www."
"felixcloutier.com/x86/movaps) 命令です。 この命令はスタックが 16byte にアライ"
"ンされていない場合に `#GP` を発生させます。 ISR から `intrZigEntry()` を呼び"
"出す際にはスタックを 16byte にアラインする操作を挟んでいます。"

#: src/kernel/interrupt.md:449
msgid "vector 固有のハンドラ"
msgstr "vector 固有のハンドラ"

#: src/kernel/interrupt.md:451
msgid ""
"ISR の共通部分が完成したので、各 vector に対応するハンドラを呼び出します。 先"
"程の共通 ISR で呼び出していた `intrZigEntry()` は以下のように定義します:"
msgstr ""
"ISR の共通部分が完成したので、各 vector に対応するハンドラを呼び出します。 先"
"程の共通 ISR で呼び出していた `intrZigEntry()` は以下のように定義します:"

#: src/kernel/interrupt.md:495
msgid ""
"引数の `Context` は ISR が呼び出された直後のレジスタの状態です。 "
"**`intrZigEntry()` を呼び出す直前のスタックが、そのまま `Context` の中身にな"
"ります**。 先ほど `intrZigEntry()` に RSP の値を引数と渡していたのは、このた"
"めです。 vector 固有のハンドラ内では、これらの `Context` の情報を使うことがで"
"きます。"
msgstr ""
"引数の `Context` は ISR が呼び出された直後のレジスタの状態です。 "
"**`intrZigEntry()` を呼び出す直前のスタックが、そのまま `Context` の中身にな"
"ります**。 先ほど `intrZigEntry()` に RSP の値を引数と渡していたのは、このた"
"めです。 vector 固有のハンドラ内では、これらの `Context` の情報を使うことがで"
"きます。"

#: src/kernel/interrupt.md:500
msgid ""
"`callconv(.C)` とすることで、第1引数が必ず RDI (今回は RSP の値) になるように"
"します。 これをしないと、Zig が最適化のためにどのレジスタ(またはスタック)を"
"使って引数を渡すのかを変える可能性があります。 `intr.dispatch()` は以下のよう"
"に vector 固有のハンドラを呼び出します:"
msgstr ""
"`callconv(.C)` とすることで、第1引数が必ず RDI (今回は RSP の値) になるように"
"します。 これをしないと、Zig が最適化のためにどのレジスタ(またはスタック)を"
"使って引数を渡すのかを変える可能性があります。 `intr.dispatch()` は以下のよう"
"に vector 固有のハンドラを呼び出します:"

#: src/kernel/interrupt.md:515
msgid ""
"`handlers` は vector ごとのハンドラを保持する配列です。 `dispatch()` は登録さ"
"れたハンドラのうち、vector に対応するものを呼び出します。 仮にハンドラが登録"
"されていなかった場合には、デフォルトの `unhandledHandler()` を呼び出すことに"
"します:"
msgstr ""
"`handlers` は vector ごとのハンドラを保持する配列です。 `dispatch()` は登録さ"
"れたハンドラのうち、vector に対応するものを呼び出します。 仮にハンドラが登録"
"されていなかった場合には、デフォルトの `unhandledHandler()` を呼び出すことに"
"します:"

#: src/kernel/interrupt.md:554
msgid ""
"このハンドラは、`Context` に保存された状態をダンプしたあと、無限 HLT ループす"
"るだけです。"
msgstr ""
"このハンドラは、`Context` に保存された状態をダンプしたあと、無限 HLT ループす"
"るだけです。"

#: src/kernel/interrupt.md:556
msgid "IDT にハンドラのセット"
msgstr "IDT にハンドラのセット"

#: src/kernel/interrupt.md:558
msgid ""
"ISR の共通部分、およびそこから vector 固有のハンドラを呼び出す部分が完成しま"
"した。 残る処理は IDT に ISR をセットすることだけです。 全 IDT エントリに対し"
"て ISR をセットしましょう:"
msgstr ""
"ISR の共通部分、およびそこから vector 固有のハンドラを呼び出す部分が完成しま"
"した。 残る処理は IDT に ISR をセットすることだけです。 全 IDT エントリに対し"
"て ISR をセットしましょう:"

#: src/kernel/interrupt.md:579
msgid ""
"`inline for` を使って、256 回だけ `idt.setGate()` を呼び出します。 `inline "
"for` が必要なのは、`isr.generateIsr()` が関数を返すためコンパイル時に `for` "
"が評価される必要があるためです。 `generateIsr(i)` を使って生成された ISR は、"
"先ほど実装した `idt.setGate()` によって Interrupt Gate として IDT にセットさ"
"れます。 最後に、[STI](https://www.felixcloutier.com/x86/sti) で `RFLAGS.IF` "
"をセットして割り込みを有効化します。"
msgstr ""
"`inline for` を使って、256 回だけ `idt.setGate()` を呼び出します。 `inline "
"for` が必要なのは、`isr.generateIsr()` が関数を返すためコンパイル時に `for` "
"が評価される必要があるためです。 `generateIsr(i)` を使って生成された ISR は、"
"先ほど実装した `idt.setGate()` によって Interrupt Gate として IDT にセットさ"
"れます。 最後に、[STI](https://www.felixcloutier.com/x86/sti) で `RFLAGS.IF` "
"をセットして割り込みを有効化します。"

#: src/kernel/interrupt.md:586
msgid ""
"本チャプターでは vector に関わらず共通な部分と vector 固有の部分に分けて ISR "
"を実装しました。 全ての割り込みに対して ISR を生成し、IDT に登録しました。 登"
"録された ISR は、各 vector ごとのハンドラを呼び出します。 現在はまだ vector "
"ごとのハンドラをひとつも登録していないため、全ての割り込みが "
"`unhandledHandler()` によって処理されます。 先ほどの `#GP` を発生させるコード"
"をもう一度実行すると、以下のようになります:"
msgstr ""
"本チャプターでは vector に関わらず共通な部分と vector 固有の部分に分けて ISR "
"を実装しました。 全ての割り込みに対して ISR を生成し、IDT に登録しました。 登"
"録された ISR は、各 vector ごとのハンドラを呼び出します。 現在はまだ vector "
"ごとのハンドラをひとつも登録していないため、全ての割り込みが "
"`unhandledHandler()` によって処理されます。 先ほどの `#GP` を発生させるコード"
"をもう一度実行すると、以下のようになります:"

#: src/kernel/interrupt.md:620
msgid "ちゃんとレジスタの状態がダンプされていますね。"
msgstr "ちゃんとレジスタの状態がダンプされていますね。"

#: src/kernel/interrupt.md:622
msgid ""
"なお、本シリーズでは **Ymir で例外が発生することは想定しません**。 のちのチャ"
"プターで扱いますが、カーネルは全ての物理アドレス空間を初期化時にマップするた"
"め、`#PF` も発生しません (Linuxと同じです)。 一方で割り込みはいくつか登録する"
"ため、その時になったら今回実装した vector ごとのハンドラを登録する仕組みが活"
"躍することになります。"
msgstr ""
"なお、本シリーズでは **Ymir で例外が発生することは想定しません**。 のちのチャ"
"プターで扱いますが、カーネルは全ての物理アドレス空間を初期化時にマップするた"
"め、`#PF` も発生しません (Linuxと同じです)。 一方で割り込みはいくつか登録する"
"ため、その時になったら今回実装した vector ごとのハンドラを登録する仕組みが活"
"躍することになります。"

#: src/kernel/interrupt.md:626
msgid ""
"以上で UEFI が提供する IDT から独自の IDT に切り替えることができました。 "
"UEFI に依存しているものは、残すところページテーブルだけです。 しかし、ページ"
"テーブルを切り替えるにはその過程の中でページアロケータが必要になります。 次"
"チャプターではページアロケータを実装していきましょう。"
msgstr ""
"以上で UEFI が提供する IDT から独自の IDT に切り替えることができました。 "
"UEFI に依存しているものは、残すところページテーブルだけです。 しかし、ページ"
"テーブルを切り替えるにはその過程の中でページアロケータが必要になります。 次"
"チャプターではページアロケータを実装していきましょう。"

#: src/kernel/interrupt.md:631
msgid ""
"本シリーズでは割り込みと例外を区別する必要がない場合にまとめて _割り込み_ と"
"呼びます。"
msgstr ""
"本シリーズでは割り込みと例外を区別する必要がない場合にまとめて _割り込み_ と"
"呼びます。"

#: src/kernel/interrupt.md:632
msgid ""
"割り込み信号は任意のタイミングで CPU に通知される可能性があるものの、 実際に"
"割り込みが CPU から報告されるのは instruction boundary であることが保証されま"
"す。 つまり、命令の実行途中で割り込みが発生することはありません。 例外に関し"
"ても同様です。"
msgstr ""
"割り込み信号は任意のタイミングで CPU に通知される可能性があるものの、 実際に"
"割り込みが CPU から報告されるのは instruction boundary であることが保証されま"
"す。 つまり、命令の実行途中で割り込みが発生することはありません。 例外に関し"
"ても同様です。"

#: src/kernel/interrupt.md:636
msgid ""
"GDT が最大で \\\\(2^{13} = 8192\\\\) 個のエントリを持てるのに対し、割り込みは"
"最大256個しかないため IDT も 256 個のエントリしか意味を持ちません。"
msgstr ""
"GDT が最大で \\\\(2^{13} = 8192\\\\) 個のエントリを持てるのに対し、割り込みは"
"最大256個しかないため IDT も 256 個のエントリしか意味を持ちません。"

#: src/kernel/interrupt.md:637
msgid ""
"_Segment Selector_ の _TI_ が `0` なら GDT が、`1` なら LDT が使われます。"
msgstr ""
"_Segment Selector_ の _TI_ が `0` なら GDT が、`1` なら LDT が使われます。"

#: src/kernel/interrupt.md:638
msgid "SDM Vol.3A 5.4.1"
msgstr "SDM Vol.3A 5.4.1"

#: src/kernel/interrupt.md:639
msgid ""
"厳密には、Double Fault を発生させる例外の組み合わせは非常に限られています。 "
"詳しくは SDM か [Double Faults - Writing an OS in Rust](https://os.phil-opp."
"com/double-fault-exceptions/#causes-of-double-faults) を参照してください。"
msgstr ""
"厳密には、Double Fault を発生させる例外の組み合わせは非常に限られています。 "
"詳しくは SDM か [Double Faults - Writing an OS in Rust](https://os.phil-opp."
"com/double-fault-exceptions/#causes-of-double-faults) を参照してください。"

#: src/kernel/interrupt.md:641
msgid ""
"ところで Ymir では Interrupt Gate しか扱わないため、やっぱりこの CLI は不要で"
"すね..."
msgstr ""
"ところで Ymir では Interrupt Gate しか扱わないため、やっぱりこの CLI は不要で"
"すね..."

#: src/kernel/interrupt.md:642
msgid "x64 では RSP に直接 MOV できません。"
msgstr "x64 では RSP に直接 MOV できません。"

#: src/kernel/page_allocator.md:4
msgid ""
"前チャプターまでは UEFI から提供されるデータ構造を Ymir のものに置き換えてい"
"きました。 ページテーブルもその1つであり、現在は UEFI が用意したページテーブ"
"ルを使っています。 ページテーブルを Ymir 用に新しく作成したいのですが、その作"
"業自体に Page Allocator が必要となります。"
msgstr ""
"前チャプターまでは UEFI から提供されるデータ構造を Ymir のものに置き換えてい"
"きました。 ページテーブルもその1つであり、現在は UEFI が用意したページテーブ"
"ルを使っています。 ページテーブルを Ymir 用に新しく作成したいのですが、その作"
"業自体に Page Allocator が必要となります。"

#: src/kernel/page_allocator.md:8
msgid ""
"このチャプターでは、ページ割当てを司る Page Allocator を実装します。 Zig には"
"「暗黙的なメモリ割当てが極めて少ない」という特徴があります。 `std` ライブラリ"
"でメモリ割当てを必要とする関数は全て引数に `Allocator` をとります。 逆に言う"
"と、`Allocator` をとらない関数は動的なメモリ割当てを行いません。 このチャプ"
"ターでは、Zig の要でもある `Allocator` インタフェース[^interface]をもつ Page "
"Allocator を実装していきます。"
msgstr ""
"このチャプターでは、ページ割当てを司る Page Allocator を実装します。 Zig には"
"「暗黙的なメモリ割当てが極めて少ない」という特徴があります。 `std` ライブラリ"
"でメモリ割当てを必要とする関数は全て引数に `Allocator` をとります。 逆に言う"
"と、`Allocator` をとらない関数は動的なメモリ割当てを行いません。 このチャプ"
"ターでは、Zig の要でもある `Allocator` インタフェース[^interface]をもつ Page "
"Allocator を実装していきます。"

#: src/kernel/page_allocator.md:16
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-page_allocator`]"
#| "(https://github.com/smallkirby/ymir/tree/whiz-ymir-page_allocator) ブラン"
#| "チにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-ymir-page_allocator`](https://github.com/"
"smallkirby/ymir/tree/whiz-ymir-page_allocator) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-page_allocator`]"
"(https://github.com/smallkirby/ymir/tree/whiz-ymir-page_allocator) ブランチに"
"あります。"

#: src/kernel/page_allocator.md:20
msgid "[Allocator インタフェース](#allocator-インタフェース)"
msgstr "[Allocator インタフェース](#allocator-インタフェース)"

#: src/kernel/page_allocator.md:21
msgid "[Bitmap](#bitmap)"
msgstr "[Bitmap](#bitmap)"

#: src/kernel/page_allocator.md:22
msgid "[Ymir が利用可能なメモリ](#ymir-が利用可能なメモリ)"
msgstr "[Ymir が利用可能なメモリ](#ymir-が利用可能なメモリ)"

#: src/kernel/page_allocator.md:23
msgid "[管理できるメモリサイズ](#管理できるメモリサイズ)"
msgstr "[管理できるメモリサイズ](#管理できるメモリサイズ)"

#: src/kernel/page_allocator.md:24
msgid "[Phys-Virt 変換](#phys-virt-変換)"
msgstr "[Phys-Virt 変換](#phys-virt-変換)"

#: src/kernel/page_allocator.md:25
msgid "[ユーティリティ](#ユーティリティ)"
msgstr "[ユーティリティ](#ユーティリティ)"

#: src/kernel/page_allocator.md:26
msgid "[メモリマップの探索と初期化](#メモリマップの探索と初期化)"
msgstr "[メモリマップの探索と初期化](#メモリマップの探索と初期化)"

#: src/kernel/page_allocator.md:27 src/kernel/general_allocator.md:21
msgid "[allocate](#allocate)"
msgstr "[allocate](#allocate)"

#: src/kernel/page_allocator.md:28 src/kernel/general_allocator.md:22
msgid "[free](#free)"
msgstr "[free](#free)"

#: src/kernel/page_allocator.md:29 src/kernel/general_allocator.md:23
msgid "[resize](#resize)"
msgstr "[resize](#resize)"

#: src/kernel/page_allocator.md:30
msgid "[ページ単位での確保](#ページ単位での確保)"
msgstr "[ページ単位での確保](#ページ単位での確保)"

#: src/kernel/page_allocator.md:31
msgid "[Allocator の作成](#allocator-の作成)"
msgstr "[Allocator の作成](#allocator-の作成)"

#: src/kernel/page_allocator.md:34
msgid "Allocator インタフェース"
msgstr "Allocator インタフェース"

#: src/kernel/page_allocator.md:36
msgid ""
"まず Zig の `Allocator` を実装する手順を概観するため、スケルトンの実装をしま"
"しょう:"
msgstr ""
"まず Zig の `Allocator` を実装する手順を概観するため、スケルトンの実装をしま"
"しょう:"

#: src/kernel/page_allocator.md:55
msgid ""
"`PageAllocator.zig` は今までのファイルとは少し異なり、**このファイル自体を構"
"造体(型)として扱います**[^file-struct]。 そのため、この型は他のファイルから以"
"下のようにしてアクセスできます:"
msgstr ""
"`PageAllocator.zig` は今までのファイルとは少し異なり、**このファイル自体を構"
"造体(型)として扱います**[^file-struct]。 そのため、この型は他のファイルから以"
"下のようにしてアクセスできます:"

#: src/kernel/page_allocator.md:65
msgid ""
"`Self` と `PageAllocator` は、`PageAllocator.zig` 自身を指す型のエイリアスで"
"す。 このファイル自体が構造体であるため、`vtable` はこの構造体の定数フィール"
"ドになります (定数ではない通常のメンバ変数の定義もすぐに出てきます)。"
msgstr ""
"`Self` と `PageAllocator` は、`PageAllocator.zig` 自身を指す型のエイリアスで"
"す。 このファイル自体が構造体であるため、`vtable` はこの構造体の定数フィール"
"ドになります (定数ではない通常のメンバ変数の定義もすぐに出てきます)。"

#: src/kernel/page_allocator.md:69
msgid ""
"本題の [`Allocator`](https://github.com/ziglang/zig/"
"blob/6a364b4a5e71b971b753d2b62c7708ae1e76d707/lib/std/mem/Allocator.zig#L1) "
"ですが、 この型は `ptr` と `vtable` という2つのメンバ変数を持ちます。 `ptr` "
"は実際のアロケータインスタンスへのポインタであり、`vtable` はアロケータが持つ"
"べき[関数ポインタのテーブル](https://github.com/ziglang/zig/"
"blob/6a364b4a5e71b971b753d2b62c7708ae1e76d707/lib/std/mem/Allocator.zig#L17-"
"L54)です。 [Zig の標準のアロケータたち](https://zig.guide/standard-library/"
"allocators/) は、この `Allocator` を返すメソッドを持っています。 アロケータを"
"利用する側は、**そのアロケータの内部実装に関わらず `Allocator` として扱うこと"
"ができる** というメリットがあります。"
msgstr ""
"本題の [`Allocator`](https://github.com/ziglang/zig/"
"blob/6a364b4a5e71b971b753d2b62c7708ae1e76d707/lib/std/mem/Allocator.zig#L1) "
"ですが、 この型は `ptr` と `vtable` という2つのメンバ変数を持ちます。 `ptr` "
"は実際のアロケータインスタンスへのポインタであり、`vtable` はアロケータが持つ"
"べき[関数ポインタのテーブル](https://github.com/ziglang/zig/"
"blob/6a364b4a5e71b971b753d2b62c7708ae1e76d707/lib/std/mem/Allocator.zig#L17-"
"L54)です。 [Zig の標準のアロケータたち](https://zig.guide/standard-library/"
"allocators/) は、この `Allocator` を返すメソッドを持っています。 アロケータを"
"利用する側は、**そのアロケータの内部実装に関わらず `Allocator` として扱うこと"
"ができる** というメリットがあります。"

#: src/kernel/page_allocator.md:75
msgid ""
"`vtable` は3つの関数を要求します。 各関数の役割はおそらく名前から明らかだと思"
"いますが、それぞれメモリの確保・解放・再確保をします。 `Allocator` 経由で呼ば"
"れたこれらの関数は、第1引数 `ctx` に `Allocator.ptr` が渡されます。 これはア"
"ロケータインスタンスであるため、共通の `Allocator` 経由で呼ばれても各アロケー"
"タの内部実装を呼び出すことができます。 つまりここでやるべきことは、"
"`PageAllocator.zig` にページアロケータの内部実装を定義した上で、 "
"`allocate()` / `free()` / `resize()` の 3API を提供することです。 この3つさえ"
"実装すれば、残りの細々としたユーティリティ関数は `Allocator` が提供してくれま"
"す。"
msgstr ""
"`vtable` は3つの関数を要求します。 各関数の役割はおそらく名前から明らかだと思"
"いますが、それぞれメモリの確保・解放・再確保をします。 `Allocator` 経由で呼ば"
"れたこれらの関数は、第1引数 `ctx` に `Allocator.ptr` が渡されます。 これはア"
"ロケータインスタンスであるため、共通の `Allocator` 経由で呼ばれても各アロケー"
"タの内部実装を呼び出すことができます。 つまりここでやるべきことは、"
"`PageAllocator.zig` にページアロケータの内部実装を定義した上で、 "
"`allocate()` / `free()` / `resize()` の 3API を提供することです。 この3つさえ"
"実装すれば、残りの細々としたユーティリティ関数は `Allocator` が提供してくれま"
"す。"

#: src/kernel/page_allocator.md:83
msgid "Bitmap"
msgstr "Bitmap"

#: src/kernel/page_allocator.md:85
msgid "Ymir が利用可能なメモリ"
msgstr "Ymir が利用可能なメモリ"

#: src/kernel/page_allocator.md:87
msgid ""
"Ymir の `PageAllocator` では、利用できる(割当可能な)ページをビットマップで管"
"理することにします。 「利用できるページ」をどうやって知るのかというと、UEFI "
"から提供されるメモリマップを使います。 [カーネルの起動](../bootloader/"
"jump_to_ymir.md) では、Surtr から Ymir に対してメモリマップを渡していまし"
"た。 `PageAllocator` では初期化時にこのメモリマップを受取り、メモリを探査して"
"利用可能なページをビットマップに記録していきます:"
msgstr ""
"Ymir の `PageAllocator` では、利用できる(割当可能な)ページをビットマップで管"
"理することにします。 「利用できるページ」をどうやって知るのかというと、UEFI "
"から提供されるメモリマップを使います。 [カーネルの起動](../bootloader/"
"jump_to_ymir.md) では、Surtr から Ymir に対してメモリマップを渡していまし"
"た。 `PageAllocator` では初期化時にこのメモリマップを受取り、メモリを探査して"
"利用可能なページをビットマップに記録していきます:"

#: src/kernel/page_allocator.md:105
msgid ""
"`MemoryDescriptorIterator` は [メモリマップとお片付け](../bootloader/"
"cleanup_memmap.md) で実装したものであり、 メモリマップに対するイテレータを提"
"供します。 このイテレータを使ってメモリマップを順に取り出していきます。 メモ"
"リマップには、その [メモリの種類](https://uefi.org/specs/"
"UEFI/2.9_A/07_Services_Boot_Services.html#memory-type-usage-before-"
"exitbootservices) も記録されています。 この内、Ymir では _Conventional "
"Memory_ と _Boot Services Code_ の2つを OS(Ymir) が自由に利用可能な領域として"
"扱います。"
msgstr ""
"`MemoryDescriptorIterator` は [メモリマップとお片付け](../bootloader/"
"cleanup_memmap.md) で実装したものであり、 メモリマップに対するイテレータを提"
"供します。 このイテレータを使ってメモリマップを順に取り出していきます。 メモ"
"リマップには、その [メモリの種類](https://uefi.org/specs/"
"UEFI/2.9_A/07_Services_Boot_Services.html#memory-type-usage-before-"
"exitbootservices) も記録されています。 この内、Ymir では _Conventional "
"Memory_ と _Boot Services Code_ の2つを OS(Ymir) が自由に利用可能な領域として"
"扱います。"

#: src/kernel/page_allocator.md:113
#, fuzzy
#| msgid ""
#| "\\[!NOTE\\] 本当はまだある利用可能領域 本当は _Boot Services Data_ も利用"
#| "可能な領域です。 しかし、この領域にはまだ Ymir が利用中のデータが入ってい"
#| "ます。 そう、ページテーブルです。 まだ Ymir はページテーブルを自前で用意せ"
#| "ず UEFI が用意してくれたものを使いまわしているため、 この領域は利用(上書"
#| "き)してはいけません。 のちのチャプターで自前のページテーブルを用意したあと"
#| "で _Boot Services Data_ を解放し Ymir が利用可能な領域にすることができます"
#| "が、本シリーズでは扱いません。 [オリジナルの Ymir](https://github.com/"
#| "smallkirby/ymir) ではこの領域も利用可能な領域として扱っているため、気にな"
#| "る人はそちらを参照してください。"
msgid ""
"本当は _Boot Services Data_ も利用可能な領域です。 しかし、この領域にはまだ "
"Ymir が利用中のデータが入っています。 そう、ページテーブルです。 まだ Ymir は"
"ページテーブルを自前で用意せず UEFI が用意してくれたものを使いまわしているた"
"め、 この領域は利用(上書き)してはいけません。 のちのチャプターで自前のページ"
"テーブルを用意したあとで _Boot Services Data_ を解放し Ymir が利用可能な領域"
"にすることができますが、本シリーズでは扱いません。 [オリジナルの Ymir]"
"(https://github.com/smallkirby/ymir) ではこの領域も利用可能な領域として扱って"
"いるため、気になる人はそちらを参照してください。"
msgstr ""
"\\[!NOTE\\] 本当はまだある利用可能領域 本当は _Boot Services Data_ も利用可能"
"な領域です。 しかし、この領域にはまだ Ymir が利用中のデータが入っています。 "
"そう、ページテーブルです。 まだ Ymir はページテーブルを自前で用意せず UEFI が"
"用意してくれたものを使いまわしているため、 この領域は利用(上書き)してはいけま"
"せん。 のちのチャプターで自前のページテーブルを用意したあとで _Boot Services "
"Data_ を解放し Ymir が利用可能な領域にすることができますが、本シリーズでは扱"
"いません。 [オリジナルの Ymir](https://github.com/smallkirby/ymir) ではこの領"
"域も利用可能な領域として扱っているため、気になる人はそちらを参照してくださ"
"い。"

#: src/kernel/page_allocator.md:121
msgid ""
"Memory Descriptor を受け取って、そのメモリが利用可能かどうかを返す関数を定義"
"しておきます:"
msgstr ""
"Memory Descriptor を受け取って、そのメモリが利用可能かどうかを返す関数を定義"
"しておきます:"

#: src/kernel/page_allocator.md:135
msgid "管理できるメモリサイズ"
msgstr "管理できるメモリサイズ"

#: src/kernel/page_allocator.md:137
msgid ""
"`PageAllocator` が使うビットマップは、1ビットを1ページに対応させます。 Zig で"
"は任意のビット幅を持つ整数型を利用することができますが、 `[N]u1` のような配列"
"を作っても一要素が 1byte になってしまいます。 よって、今回は `u64` 型の配列と"
"してビットマップを実装していきます:"
msgstr ""
"`PageAllocator` が使うビットマップは、1ビットを1ページに対応させます。 Zig で"
"は任意のビット幅を持つ整数型を利用することができますが、 `[N]u1` のような配列"
"を作っても一要素が 1byte になってしまいます。 よって、今回は `u64` 型の配列と"
"してビットマップを実装していきます:"

#: src/kernel/page_allocator.md:159
msgid ""
"ビットマップのサイズは固定サイズにします。 そのため、ビットマップのサイズがそ"
"のまま管理できるメモリサイズの上限になります。 今回は 128GiB にしました。 "
"ページ数換算で 128GiB / 4KiB = 32Mi ページです (`frame_count`)。 まあおそらく"
"十分なのではないかと思います。 このページ数をもとにビットマップのサイズを計算"
"した結果が `num_maplines` です。 `num_maplines` が 512Ki なので、ビットマップ"
"のサイズは \\\\( 512\\text{Ki} \\times 8 = 4\\text{MiB} \\\\) になります。 "
"ビットマップだけで 4MiB 使うのは少し癪ですが、実装が楽なので受け入れることに"
"します。 まぁそもそも Ymir はほとんどメモリを使わないので問題なしです。"
msgstr ""
"ビットマップのサイズは固定サイズにします。 そのため、ビットマップのサイズがそ"
"のまま管理できるメモリサイズの上限になります。 今回は 128GiB にしました。 "
"ページ数換算で 128GiB / 4KiB = 32Mi ページです (`frame_count`)。 まあおそらく"
"十分なのではないかと思います。 このページ数をもとにビットマップのサイズを計算"
"した結果が `num_maplines` です。 `num_maplines` が 512Ki なので、ビットマップ"
"のサイズは \\\\( 512\\text{Ki} \\times 8 = 4\\text{MiB} \\\\) になります。 "
"ビットマップだけで 4MiB 使うのは少し癪ですが、実装が楽なので受け入れることに"
"します。 まぁそもそも Ymir はほとんどメモリを使わないので問題なしです。"

#: src/kernel/page_allocator.md:169
msgid "Phys-Virt 変換"
msgstr "Phys-Virt 変換"

#: src/kernel/page_allocator.md:171
msgid ""
"`PageAllocator` はページ番号を使ってページを管理します。 ページ番号は、物理ア"
"ドレスから計算できます:"
msgstr ""
"`PageAllocator` はページ番号を使ってページを管理します。 ページ番号は、物理ア"
"ドレスから計算できます:"

#: src/kernel/page_allocator.md:188
msgid ""
"`FrameId` がページ番号です。 ページ番号は、物理アドレスの下位10bitを切り詰め"
"ることで得られます。"
msgstr ""
"`FrameId` がページ番号です。 ページ番号は、物理アドレスの下位10bitを切り詰め"
"ることで得られます。"

#: src/kernel/page_allocator.md:191
msgid ""
"ページ番号を扱うということは、このアロケータは物理アドレスを扱うということで"
"す。 しかしながら、アロケータが返すアドレスは仮想アドレスでなければいけませ"
"ん。 よって、仮想アドレスと物理アドレスの変換をする必要があります。 今のとこ"
"ろ UEFI から提供されたページテーブルはダイレクトマップであり、物理アドレスと"
"仮想アドレスが等しいです。 しかし、次チャプターでメモリマップを再構築すると両"
"者は等しくなくなります。 そのときに備えて、物理アドレスと仮想アドレスの変換を"
"してくれる関数を用意しておきましょう:"
msgstr ""
"ページ番号を扱うということは、このアロケータは物理アドレスを扱うということで"
"す。 しかしながら、アロケータが返すアドレスは仮想アドレスでなければいけませ"
"ん。 よって、仮想アドレスと物理アドレスの変換をする必要があります。 今のとこ"
"ろ UEFI から提供されたページテーブルはダイレクトマップであり、物理アドレスと"
"仮想アドレスが等しいです。 しかし、次チャプターでメモリマップを再構築すると両"
"者は等しくなくなります。 そのときに備えて、物理アドレスと仮想アドレスの変換を"
"してくれる関数を用意しておきましょう:"

#: src/kernel/page_allocator.md:208
msgid ""
"現在は引数をそのまま返すだけの関数ですが、メモリマップを再構築した暁には適切"
"な変換をするようにします。"
msgstr ""
"現在は引数をそのまま返すだけの関数ですが、メモリマップを再構築した暁には適切"
"な変換をするようにします。"

#: src/kernel/page_allocator.md:210
msgid "ユーティリティ"
msgstr "ユーティリティ"

#: src/kernel/page_allocator.md:212
msgid "定義したビットマップに対する操作をする関数を用意します:"
msgstr "定義したビットマップに対する操作をする関数を用意します:"

#: src/kernel/page_allocator.md:243
msgid ""
"`Status` はビットマップの 1bit に対応し、そのビットが表現するページの割当て状"
"態を表します。 `get()` はビットマップの指定したページ番号 (`FrameId`) の "
"`Status` を取得します。 途中で登場する `bit_index` はビットマップの1単位であ"
"る 64bit の中でのオフセットを表します。 0 ~ 63 の値を取るため、`u6` 型として"
"います。 `set()` は逆にビットマップの指定したページ番号の `Status` を設定しま"
"す。"
msgstr ""
"`Status` はビットマップの 1bit に対応し、そのビットが表現するページの割当て状"
"態を表します。 `get()` はビットマップの指定したページ番号 (`FrameId`) の "
"`Status` を取得します。 途中で登場する `bit_index` はビットマップの1単位であ"
"る 64bit の中でのオフセットを表します。 0 ~ 63 の値を取るため、`u6` 型として"
"います。 `set()` は逆にビットマップの指定したページ番号の `Status` を設定しま"
"す。"

#: src/kernel/page_allocator.md:249
msgid ""
"1ページ単位ではなく複数ページの状態をまとめて変更するヘルパー関数も用意してお"
"きます:"
msgstr ""
"1ページ単位ではなく複数ページの状態をまとめて変更するヘルパー関数も用意してお"
"きます:"

#: src/kernel/page_allocator.md:266
msgid "メモリマップの探索と初期化"
msgstr "メモリマップの探索と初期化"

#: src/kernel/page_allocator.md:268
msgid ""
"ここまでで作成したビットマップを使い、メモリアロケータを初期化します。 "
"`init()` においてメモリマップをひとつずつイテレートし、そのメモリ領域が Ymir "
"が利用可能なものであればビットマップに記録します:"
msgstr ""
"ここまでで作成したビットマップを使い、メモリアロケータを初期化します。 "
"`init()` においてメモリマップをひとつずつイテレートし、そのメモリ領域が Ymir "
"が利用可能なものであればビットマップに記録します:"

#: src/kernel/page_allocator.md:299
msgid ""
"`frame_begin` と `frame_end` は `PageAllocator` のメンバ変数であり、このアロ"
"ケータが管理するページ番号の範囲を記録します。 後半の `if` ではメモリ領域が利"
"用可能かどうかに応じて、ビットマップに確保済みまたは利用可能なページを記録し"
"ます。"
msgstr ""
"`frame_begin` と `frame_end` は `PageAllocator` のメンバ変数であり、このアロ"
"ケータが管理するページ番号の範囲を記録します。 後半の `if` ではメモリ領域が利"
"用可能かどうかに応じて、ビットマップに確保済みまたは利用可能なページを記録し"
"ます。"

#: src/kernel/page_allocator.md:302
msgid ""
"これで UEFI のメモリマップを探索し、割当て可能なページをビットマップに記録で"
"きました。"
msgstr ""
"これで UEFI のメモリマップを探索し、割当て可能なページをビットマップに記録で"
"きました。"

#: src/kernel/page_allocator.md:304 src/kernel/general_allocator.md:197
msgid "allocate"
msgstr "allocate"

#: src/kernel/page_allocator.md:306
msgid ""
"ここからは `Allocator` が要求する vtable の各関数を実装していきます。 まずは"
"指定されたサイズだけメモリを確保する `allocate()` です:"
msgstr ""
"ここからは `Allocator` が要求する vtable の各関数を実装していきます。 まずは"
"指定されたサイズだけメモリを確保する `allocate()` です:"

#: src/kernel/page_allocator.md:338
msgid "0: `ctx`"
msgstr "0: `ctx`"

#: src/kernel/page_allocator.md:338
msgid "`Allocator.ptr`. `PageAllocator` インスタンスへのポインタ。"
msgstr "`Allocator.ptr`. `PageAllocator` インスタンスへのポインタ。"

#: src/kernel/page_allocator.md:339
msgid "1: `n`"
msgstr "1: `n`"

#: src/kernel/page_allocator.md:339
msgid "確保するメモリのサイズ (in bytes)"
msgstr "確保するメモリのサイズ (in bytes)"

#: src/kernel/page_allocator.md:340
msgid "2: `_`"
msgstr "2: `_`"

#: src/kernel/page_allocator.md:340
msgid "要求するアラインメント"
msgstr "要求するアラインメント"

#: src/kernel/page_allocator.md:341
msgid "3: `_`"
msgstr "3: `_`"

#: src/kernel/page_allocator.md:341
msgid "謎[^ret_addr]"
msgstr "謎[^ret_addr]"

#: src/kernel/page_allocator.md:343
msgid ""
"第0引数の `ctx` は `Allocator.ptr` へのポインタです。 `Allocator` の実体は任"
"意の構造体に成り得るため `anyopaque` という型になっています。 ここでは受け"
"取ったポインタを `*PageAllocator` 型にキャストして、`*Self` として使えるよう"
"にしています。"
msgstr ""
"第0引数の `ctx` は `Allocator.ptr` へのポインタです。 `Allocator` の実体は任"
"意の構造体に成り得るため `anyopaque` という型になっています。 ここでは受け"
"取ったポインタを `*PageAllocator` 型にキャストして、`*Self` として使えるよう"
"にしています。"

#: src/kernel/page_allocator.md:347
msgid ""
"最初に要求されるアドレスをページ番号に変換したあと、ビットマップを探索して利"
"用可能なページを探します。 領域は必ず連続して利用可能である必要があるため、連"
"続して空いているページを探します。 利用可能な領域が見つかった場合、"
"`markAllocated()` でそのページを確保済みにし、そのアドレスを返します。 見つか"
"らなかった場合には `null` を返します。"
msgstr ""
"最初に要求されるアドレスをページ番号に変換したあと、ビットマップを探索して利"
"用可能なページを探します。 領域は必ず連続して利用可能である必要があるため、連"
"続して空いているページを探します。 利用可能な領域が見つかった場合、"
"`markAllocated()` でそのページを確保済みにし、そのアドレスを返します。 見つか"
"らなかった場合には `null` を返します。"

#: src/kernel/page_allocator.md:354
#, fuzzy
#| msgid ""
#| "\\[!NOTE\\] アラインメント `allocate()` の第2引数は要求するアラインメント"
#| "です。 `0x30` を指定された場合、返す領域のポインタは `0x00`, `0x30`, "
#| "`0x60`, ... で終わる必要があります。 しかし、`Allocator` が想定するアライ"
#| "ンメントの最大値はページサイズです[^align]。 ページアロケータは原理上必ず"
#| "ページアラインされたアドレスしか返さないため、この引数は無視することができ"
#| "ます。"
msgid ""
"`allocate()` の第2引数は要求するアラインメントです。 `0x30` を指定された場"
"合、返す領域のポインタは `0x00`, `0x30`, `0x60`, ... で終わる必要がありま"
"す。 しかし、`Allocator` が想定するアラインメントの最大値はページサイズです"
"[^align]。 ページアロケータは原理上必ずページアラインされたアドレスしか返さな"
"いため、この引数は無視することができます。"
msgstr ""
"\\[!NOTE\\] アラインメント `allocate()` の第2引数は要求するアラインメントで"
"す。 `0x30` を指定された場合、返す領域のポインタは `0x00`, `0x30`, "
"`0x60`, ... で終わる必要があります。 しかし、`Allocator` が想定するアラインメ"
"ントの最大値はページサイズです[^align]。 ページアロケータは原理上必ずページア"
"ラインされたアドレスしか返さないため、この引数は無視することができます。"

#: src/kernel/page_allocator.md:359 src/kernel/general_allocator.md:236
msgid "free"
msgstr "free"

#: src/kernel/page_allocator.md:361
msgid ""
"続いて、確保したメモリを解放する `free()` を実装します。 `free()` が受け取る"
"メモリへのポインタは、`[]u8` になっています。 これは [Slice](https://ziglang."
"org/documentation/master/#Slices) 型といい、ポインタとサイズを持った fat "
"pointer です。 このおかげで、**Zig のアロケータは解放を要求されたメモリアドレ"
"スとそのサイズを紐付ける必要がありません**。 代わりに利用者側がアドレスとサイ"
"ズ (= スライス) を渡す責任を負います。 もし生のポインタを渡せるようになってい"
"た場合、指定されたアドレスがどれだけのサイズで確保されたのかについてメタデー"
"タを保持する必要が出てきます (Cの `malloc()` などがそうですね)。 実装がかなり"
"簡単になるので嬉しいですね:"
msgstr ""
"続いて、確保したメモリを解放する `free()` を実装します。 `free()` が受け取る"
"メモリへのポインタは、`[]u8` になっています。 これは [Slice](https://ziglang."
"org/documentation/master/#Slices) 型といい、ポインタとサイズを持った fat "
"pointer です。 このおかげで、**Zig のアロケータは解放を要求されたメモリアドレ"
"スとそのサイズを紐付ける必要がありません**。 代わりに利用者側がアドレスとサイ"
"ズ (= スライス) を渡す責任を負います。 もし生のポインタを渡せるようになってい"
"た場合、指定されたアドレスがどれだけのサイズで確保されたのかについてメタデー"
"タを保持する必要が出てきます (Cの `malloc()` などがそうですね)。 実装がかなり"
"簡単になるので嬉しいですね:"

#: src/kernel/page_allocator.md:381 src/kernel/general_allocator.md:260
msgid "resize"
msgstr "resize"

#: src/kernel/page_allocator.md:383
msgid ""
"最後に、確保したメモリのサイズを変更する `resize()` です。 本シリーズでは、こ"
"の関数は実装しません。 ユースケースとしてリサイズをしたいときがないので、問題"
"なしです:"
msgstr ""
"最後に、確保したメモリのサイズを変更する `resize()` です。 本シリーズでは、こ"
"の関数は実装しません。 ユースケースとしてリサイズをしたいときがないので、問題"
"なしです:"

#: src/kernel/page_allocator.md:394
msgid ""
"ちゃんとした `resize()` も実装自体はそんなに難しくありません。 `free()` を呼"
"んだ後に `allocate()` を呼ぶだけです。 実装したい方はしてみてください。"
msgstr ""
"ちゃんとした `resize()` も実装自体はそんなに難しくありません。 `free()` を呼"
"んだ後に `allocate()` を呼ぶだけです。 実装したい方はしてみてください。"

#: src/kernel/page_allocator.md:398
msgid "ページ単位での確保"
msgstr "ページ単位での確保"

#: src/kernel/page_allocator.md:400
msgid ""
"これで `Allocator` インタフェースの実装が終わりました。 もう `Allocator` を作"
"成可能なのですが、もうひとつだけ追加で関数を実装しておきます。 `Allocator` は"
"基本的にページ単位でのメモリ確保を想定していません[^page-alloc]。 しかし、OS "
"ではページ単位でのメモリ確保をしたい場合が多くあります。 よって、ページ数を指"
"定してメモリを確保できるような関数があると便利です。 また、ページサイズ以上の"
"アラインを指定したい場合にも必要となります[^align]。"
msgstr ""
"これで `Allocator` インタフェースの実装が終わりました。 もう `Allocator` を作"
"成可能なのですが、もうひとつだけ追加で関数を実装しておきます。 `Allocator` は"
"基本的にページ単位でのメモリ確保を想定していません[^page-alloc]。 しかし、OS "
"ではページ単位でのメモリ確保をしたい場合が多くあります。 よって、ページ数を指"
"定してメモリを確保できるような関数があると便利です。 また、ページサイズ以上の"
"アラインを指定したい場合にも必要となります[^align]。"

#: src/kernel/page_allocator.md:407
msgid ""
"作成した関数は、`Allocator` を介して呼び出すことはできません。 しかしながら "
"`Allocator` はあくまでもインタフェースであり、 その裏側にあるアロケータインス"
"タンスに対して直接アクセスすることで `Allocator` が備えていない関数を呼び出す"
"ことは可能です。"
msgstr ""
"作成した関数は、`Allocator` を介して呼び出すことはできません。 しかしながら "
"`Allocator` はあくまでもインタフェースであり、 その裏側にあるアロケータインス"
"タンスに対して直接アクセスすることで `Allocator` が備えていない関数を呼び出す"
"ことは可能です。"

#: src/kernel/page_allocator.md:411
msgid "それでは、ページ単位でのメモリ確保をする関数を実装します:"
msgstr "それでは、ページ単位でのメモリ確保をする関数を実装します:"

#: src/kernel/page_allocator.md:438
msgid ""
"中身はほぼ `allocate()` と同じです。 引数はサイズをの代わりにページ数を受け取"
"ります。 `align_size` にはページサイズ以上のアラインメントを指定することがで"
"き、秋ページを探索する際にはこのアラインメントを考慮します。"
msgstr ""
"中身はほぼ `allocate()` と同じです。 引数はサイズをの代わりにページ数を受け取"
"ります。 `align_size` にはページサイズ以上のアラインメントを指定することがで"
"き、秋ページを探索する際にはこのアラインメントを考慮します。"

#: src/kernel/page_allocator.md:442
msgid "Allocator の作成"
msgstr "Allocator の作成"

#: src/kernel/page_allocator.md:444
msgid ""
"以上で準備が整いました。 Ymir で利用できる `Allocator` を作成しましょう:"
msgstr ""
"以上で準備が整いました。 Ymir で利用できる `Allocator` を作成しましょう:"

#: src/kernel/page_allocator.md:471
msgid ""
"`page_allocator_instance` は `PageAllocator` の唯一のインスタンスです。 基本"
"的にこちらのインスタンスは直接触ることはありません。 唯一使う必要があるのは、"
"先ほどの `allocPages()` を呼び出す場合のみです。 というか、このインスタンスは"
"直接触らせたくないので本当は `pub` 指定したくありません。 `PageAllocator` と"
"いう型自体も同様です。 しかし、`Allocator.alignedAlloc()` がページサイズ以上"
"のアラインを許容しないため致し方ありません[^align]。"
msgstr ""
"`page_allocator_instance` は `PageAllocator` の唯一のインスタンスです。 基本"
"的にこちらのインスタンスは直接触ることはありません。 唯一使う必要があるのは、"
"先ほどの `allocPages()` を呼び出す場合のみです。 というか、このインスタンスは"
"直接触らせたくないので本当は `pub` 指定したくありません。 `PageAllocator` と"
"いう型自体も同様です。 しかし、`Allocator.alignedAlloc()` がページサイズ以上"
"のアラインを許容しないため致し方ありません[^align]。"

#: src/kernel/page_allocator.md:478
msgid ""
"肝心の `Allocator` は、`ptr` と `vtable` を指定してあげることで作成します。 "
"`ptr` は `page_allocator_instance` インスタンスへのポインタです。 これにより"
"先ほど実装した3つの関数だけでなく、`alloc()`, `create()`, `alignedAlloc()`, "
"`allocSentinel()` など `Allocator` インタフェースが提供するさまざまな関数を利"
"用できるようになります。"
msgstr ""
"肝心の `Allocator` は、`ptr` と `vtable` を指定してあげることで作成します。 "
"`ptr` は `page_allocator_instance` インスタンスへのポインタです。 これにより"
"先ほど実装した3つの関数だけでなく、`alloc()`, `create()`, `alignedAlloc()`, "
"`allocSentinel()` など `Allocator` インタフェースが提供するさまざまな関数を利"
"用できるようになります。"

#: src/kernel/page_allocator.md:482
msgid ""
"利用時には以下のようにして `Allocator` として利用します (内部実装を気にする必"
"要がありません):"
msgstr ""
"利用時には以下のようにして `Allocator` として利用します (内部実装を気にする必"
"要がありません):"

#: src/kernel/page_allocator.md:497
msgid ""
"本チャプターでは UEFI から提供されたメモリマップをもとに利用可能なページを追"
"跡する `PageAllocator` を実装しました。 メモリアロケータができたことで、いろ"
"いろなことができるようになります。 たとえばページテーブル用のページを確保でき"
"るようになったため、メモリマップを再構築できるようになります。 また、VT-x で"
"は vCPU ごとに VMCS 用のページを確保してあげる必要もあります。 今回実装した "
"`PageAllocator` はページを確保する以外にも、汎用的な(小さいサイズを確保する)"
"アロケータとしても使えます。 もちろん 8byte を確保しようとしても 4KiB ページ"
"を確保してしまうのでメモリ効率はよくありませんが...。 というわけで、次はより"
"効率的に汎用用途で使えるアロケータを実装していきます。 と言いたいところです"
"が、次のチャプターでは一旦ページテーブルの再構築をしてしまいましょう。 物理ア"
"ドレスと仮想アドレスがストレートではなくなったあとで、再びアロケータを実装し"
"ていくことにします。"
msgstr ""
"本チャプターでは UEFI から提供されたメモリマップをもとに利用可能なページを追"
"跡する `PageAllocator` を実装しました。 メモリアロケータができたことで、いろ"
"いろなことができるようになります。 たとえばページテーブル用のページを確保でき"
"るようになったため、メモリマップを再構築できるようになります。 また、VT-x で"
"は vCPU ごとに VMCS 用のページを確保してあげる必要もあります。 今回実装した "
"`PageAllocator` はページを確保する以外にも、汎用的な(小さいサイズを確保する)"
"アロケータとしても使えます。 もちろん 8byte を確保しようとしても 4KiB ページ"
"を確保してしまうのでメモリ効率はよくありませんが...。 というわけで、次はより"
"効率的に汎用用途で使えるアロケータを実装していきます。 と言いたいところです"
"が、次のチャプターでは一旦ページテーブルの再構築をしてしまいましょう。 物理ア"
"ドレスと仮想アドレスがストレートではなくなったあとで、再びアロケータを実装し"
"ていくことにします。"

#: src/kernel/page_allocator.md:507
msgid ""
"厳密には Zig には _interface_ という概念はありません。 しかし、他の言語で言う"
"ところの _interface_ と大体似たようなものなのでこう呼んでいます。"
msgstr ""
"厳密には Zig には _interface_ という概念はありません。 しかし、他の言語で言う"
"ところの _interface_ と大体似たようなものなのでこう呼んでいます。"

#: src/kernel/page_allocator.md:509
msgid ""
"厳密に言うと、今まで作成した全てのファイルも型(構造体のようなもの)として扱わ"
"れています。 だからこそ、`ymir.bits.XXX()` のようなアクセスが可能になっていま"
"す。"
msgstr ""
"厳密に言うと、今まで作成した全てのファイルも型(構造体のようなもの)として扱わ"
"れています。 だからこそ、`ymir.bits.XXX()` のようなアクセスが可能になっていま"
"す。"

#: src/kernel/page_allocator.md:511
msgid "この引数が何なのかは、誰も知りません。"
msgstr "この引数が何なのかは、誰も知りません。"

#: src/kernel/page_allocator.md:512
msgid ""
"`Allocator` では、[ページサイズ以上のアラインは禁止されています](https://"
"github.com/ziglang/zig/blob/a03ab9ee01129913af526a38b688313ccd83dca2/lib/std/"
"mem/Allocator.zig#L218)。"
msgstr ""
"`Allocator` では、[ページサイズ以上のアラインは禁止されています](https://"
"github.com/ziglang/zig/blob/a03ab9ee01129913af526a38b688313ccd83dca2/lib/std/"
"mem/Allocator.zig#L218)。"

#: src/kernel/page_allocator.md:513
msgid ""
"これはアロケータインスタンスがページ単位の確保をあまり想定していないというこ"
"とではなく、`Allocator` インタフェースのことです。"
msgstr ""
"これはアロケータインスタンスがページ単位の確保をあまり想定していないというこ"
"とではなく、`Allocator` インタフェースのことです。"

#: src/kernel/paging.md:3
msgid ""
"本チャプターは UEFI が用意してくれたものを Ymir のものに置き換えていこうシ"
"リーズの最終弾です。 最後を飾るのはページテーブルです。 UEFI が用意したページ"
"テーブルは仮想アドレスをそのまま物理アドレスにするダイレクトマップ(ストレート"
"マップ)でした。 Ymir が新しく用意するマッピングもダイレクトマップではあります"
"が、仮想アドレスと物理アドレスが異なるようにオフセットを加算します。 本チャプ"
"ターを終えると、UEFI が提供したものを全て破棄できる状態になります。"
msgstr ""
"本チャプターは UEFI が用意してくれたものを Ymir のものに置き換えていこうシ"
"リーズの最終弾です。 最後を飾るのはページテーブルです。 UEFI が用意したページ"
"テーブルは仮想アドレスをそのまま物理アドレスにするダイレクトマップ(ストレート"
"マップ)でした。 Ymir が新しく用意するマッピングもダイレクトマップではあります"
"が、仮想アドレスと物理アドレスが異なるようにオフセットを加算します。 本チャプ"
"ターを終えると、UEFI が提供したものを全て破棄できる状態になります。"

#: src/kernel/paging.md:11
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-paging`](https://"
#| "github.com/smallkirby/ymir/tree/whiz-ymir-paging) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-ymir-paging`](https://github.com/"
"smallkirby/ymir/tree/whiz-ymir-paging) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-paging`](https://"
"github.com/smallkirby/ymir/tree/whiz-ymir-paging) ブランチにあります。"

#: src/kernel/paging.md:15
msgid "[仮想アドレスレイアウト](#仮想アドレスレイアウト)"
msgstr "[仮想アドレスレイアウト](#仮想アドレスレイアウト)"

#: src/kernel/paging.md:16
msgid "[再構築の流れ](#再構築の流れ)"
msgstr "[再構築の流れ](#再構築の流れ)"

#: src/kernel/paging.md:17
msgid "[新しい Lv4 ページテーブルの確保](#新しい-lv4-ページテーブルの確保)"
msgstr "[新しい Lv4 ページテーブルの確保](#新しい-lv4-ページテーブルの確保)"

#: src/kernel/paging.md:18
msgid "[Direct Map Region](#direct-map-region)"
msgstr "[Direct Map Region](#direct-map-region)"

#: src/kernel/paging.md:19
msgid "[古いページテーブルのクローン](#古いページテーブルのクローン)"
msgstr "[古いページテーブルのクローン](#古いページテーブルのクローン)"

#: src/kernel/paging.md:20
msgid "[新しいテーブルのロード](#新しいテーブルのロード)"
msgstr "[新しいテーブルのロード](#新しいテーブルのロード)"

#: src/kernel/paging.md:21
msgid "[仮想-物理アドレス変換](#仮想-物理アドレス変換)"
msgstr "[仮想-物理アドレス変換](#仮想-物理アドレス変換)"

#: src/kernel/paging.md:22
msgid "[Surtr のマッピング改良](#surtr-のマッピング改良)"
msgstr "[Surtr のマッピング改良](#surtr-のマッピング改良)"

#: src/kernel/paging.md:25
msgid "仮想アドレスレイアウト"
msgstr "仮想アドレスレイアウト"

#: src/kernel/paging.md:27
msgid ""
"[カーネルのロード](../bootloader/load_kernel.md) でも扱いましたが、Ymir では"
"以下の仮想アドレスレイアウトを採用します:"
msgstr ""
"[カーネルのロード](../bootloader/load_kernel.md) でも扱いましたが、Ymir では"
"以下の仮想アドレスレイアウトを採用します:"

#: src/kernel/paging.md:29
msgid "Virtual Address"
msgstr "Virtual Address"

#: src/kernel/paging.md:29
msgid "Physical Address"
msgstr "Physical Address"

#: src/kernel/paging.md:31 src/kernel/paging.md:115
msgid "Direct Map Region"
msgstr "Direct Map Region"

#: src/kernel/paging.md:31
msgid "`0xFFFF888000000000` - `0xFFFF88FFFFFFFFFF` (512GiB)"
msgstr "`0xFFFF888000000000` - `0xFFFF88FFFFFFFFFF` (512GiB)"

#: src/kernel/paging.md:31
msgid "`0x0` - `0xFFFFFFFFFF`"
msgstr "`0x0` - `0xFFFFFFFFFF`"

#: src/kernel/paging.md:32
msgid "Kernel Base"
msgstr "Kernel Base"

#: src/kernel/paging.md:32
msgid "`0x0` -"
msgstr "`0x0` -"

#: src/kernel/paging.md:33
msgid "Kernel Text"
msgstr "Kernel Text"

#: src/kernel/paging.md:33
msgid "`0x100000` -"
msgstr "`0x100000` -"

#: src/kernel/paging.md:35
msgid ""
"**Direct Map Region** は全物理アドレスをダイレクトマップします。 ダイレクト"
"マップとはいっても、仮想アドレスと物理アドレスが等しくなるわけではありませ"
"ん。 仮想アドレスと物理アドレスの間には `0xFFFF888000000000` だけオフセットが"
"あります。 この領域にはアロケータが利用するヒープも含まれます。"
msgstr ""
"**Direct Map Region** は全物理アドレスをダイレクトマップします。 ダイレクト"
"マップとはいっても、仮想アドレスと物理アドレスが等しくなるわけではありませ"
"ん。 仮想アドレスと物理アドレスの間には `0xFFFF888000000000` だけオフセットが"
"あります。 この領域にはアロケータが利用するヒープも含まれます。"

#: src/kernel/paging.md:40
msgid ""
"**Kernel Base** と **Kernel Text** はカーネルイメージをロードする領域です。 "
"`ymir/linker.ld` によってカーネルイメージはこのアドレスにロードされるよう要求"
"するようになっています。 この仮想アドレスは既に [カーネルのロード](../"
"bootloader/load_kernel.md#仮想アドレスのマップ) の部分でマップ済みです。"
msgstr ""
"**Kernel Base** と **Kernel Text** はカーネルイメージをロードする領域です。 "
"`ymir/linker.ld` によってカーネルイメージはこのアドレスにロードされるよう要求"
"するようになっています。 この仮想アドレスは既に [カーネルのロード](../"
"bootloader/load_kernel.md#仮想アドレスのマップ) の部分でマップ済みです。"

#: src/kernel/paging.md:44
msgid ""
"各仮想アドレスがマップされる物理アドレスを見て分かるように、Direct Map "
"Region と Kernel Base は重複しています。 同じ物理アドレスが複数の仮想アドレス"
"からマップされること自体はごく普通のことです。 基本的にソフト側で扱うアドレス"
"は仮想アドレスであるため、アドレスからどの領域かがわかりやすくなるように異な"
"る仮想アドレスをマップしています。 `0xFFFFFFFF8010DEAD` というアドレスを見た"
"らすぐに「Ymir のコード領域だな」とわかるので便利ですね。"
msgstr ""
"各仮想アドレスがマップされる物理アドレスを見て分かるように、Direct Map "
"Region と Kernel Base は重複しています。 同じ物理アドレスが複数の仮想アドレス"
"からマップされること自体はごく普通のことです。 基本的にソフト側で扱うアドレス"
"は仮想アドレスであるため、アドレスからどの領域かがわかりやすくなるように異な"
"る仮想アドレスをマップしています。 `0xFFFFFFFF8010DEAD` というアドレスを見た"
"らすぐに「Ymir のコード領域だな」とわかるので便利ですね。"

#: src/kernel/paging.md:49
msgid ""
"もちろん、これ以外のレイアウトを採用することも容易にできます。 最も簡単なの"
"は、全ての仮想アドレスを物理アドレスにオフセット無しで 1:1 にマップすることで"
"す。 本シリーズで実装する Ymir に関しては、そうした場合でもデメリットはありま"
"せん。 お好きなレイアウトを採用してください。"
msgstr ""
"もちろん、これ以外のレイアウトを採用することも容易にできます。 最も簡単なの"
"は、全ての仮想アドレスを物理アドレスにオフセット無しで 1:1 にマップすることで"
"す。 本シリーズで実装する Ymir に関しては、そうした場合でもデメリットはありま"
"せん。 お好きなレイアウトを採用してください。"

#: src/kernel/paging.md:54
msgid "再構築の流れ"
msgstr "再構築の流れ"

#: src/kernel/paging.md:56
msgid ""
"ここからは、UEFI が提供してくれたページテーブルを「_古いページテーブル_」、"
"Ymir が提供するページテーブルを「_新しいページテーブル_」と呼びます。 古い"
"ページテーブルを新しいものに置き換えるには、以下の手順を踏みます:"
msgstr ""
"ここからは、UEFI が提供してくれたページテーブルを「_古いページテーブル_」、"
"Ymir が提供するページテーブルを「_新しいページテーブル_」と呼びます。 古い"
"ページテーブルを新しいものに置き換えるには、以下の手順を踏みます:"

#: src/kernel/paging.md:59
msgid "新しい Lv4 ページテーブル用の領域を確保する"
msgstr "新しい Lv4 ページテーブル用の領域を確保する"

#: src/kernel/paging.md:60
msgid "1GiB ページを使って Direct Map Region をマップする"
msgstr "1GiB ページを使って Direct Map Region をマップする"

#: src/kernel/paging.md:61
msgid "古いページテーブルから Kernel Base Region のマップをクローンする"
msgstr "古いページテーブルから Kernel Base Region のマップをクローンする"

#: src/kernel/paging.md:62
msgid "新しいページテーブルをロードする"
msgstr "新しいページテーブルをロードする"

#: src/kernel/paging.md:64
msgid ""
"2 で Direct Map Region である `0xFFFF888000000000` からの 512GiB をマップしま"
"す。 これは古いページテーブルの内容を参照すること無く行うことができます。 し"
"かしながら、カーネルがどこにマップされたのかは古いページテーブルを見ないとわ"
"かりません[^kernel-map]。 よって、この領域は古いページテーブルを参照して内容"
"をクローンする必要があります。"
msgstr ""
"2 で Direct Map Region である `0xFFFF888000000000` からの 512GiB をマップしま"
"す。 これは古いページテーブルの内容を参照すること無く行うことができます。 し"
"かしながら、カーネルがどこにマップされたのかは古いページテーブルを見ないとわ"
"かりません[^kernel-map]。 よって、この領域は古いページテーブルを参照して内容"
"をクローンする必要があります。"

#: src/kernel/paging.md:69
msgid "新しい Lv4 ページテーブルの確保"
msgstr "新しい Lv4 ページテーブルの確保"

#: src/kernel/paging.md:71
msgid ""
"以前 Surtr で実装した `page.zig` は、ほとんどそのまま `ymir/arch/x86/page."
"zig` にコピーできます。 具体的には、各種定数や `EntryBase`構造体, "
"`getTable()`, `getEntry()` 等の関数をコピーします。"
msgstr ""
"以前 Surtr で実装した `page.zig` は、ほとんどそのまま `ymir/arch/x86/page."
"zig` にコピーできます。 具体的には、各種定数や `EntryBase`構造体, "
"`getTable()`, `getEntry()` 等の関数をコピーします。"

#: src/kernel/paging.md:74
msgid ""
"ページテーブルは 8byte のエントリが 512 個並んだものです。 すなわち、サイズ"
"は 4KiB (1ページ) です。 ページテーブル1つにつき1ページを確保するため、1ペー"
"ジを確保するためのヘルパー関数を用意します:"
msgstr ""
"ページテーブルは 8byte のエントリが 512 個並んだものです。 すなわち、サイズ"
"は 4KiB (1ページ) です。 ページテーブル1つにつき1ページを確保するため、1ペー"
"ジを確保するためのヘルパー関数を用意します:"

#: src/kernel/paging.md:89
msgid ""
"`Allocator` は [前チャプター](./page_allocator.md) で実装した "
"`PageAllocator` をバックに持つアロケータです。 しかしながら、`PageAllocator` "
"であることは意識せずに Zig 標準の `Allocator` として使うことができます。 確保"
"するページは性質上 4KiB アラインが要求されるため、`alignedAlloc()` でアライン"
"された領域を確保します。"
msgstr ""
"`Allocator` は [前チャプター](./page_allocator.md) で実装した "
"`PageAllocator` をバックに持つアロケータです。 しかしながら、`PageAllocator` "
"であることは意識せずに Zig 標準の `Allocator` として使うことができます。 確保"
"するページは性質上 4KiB アラインが要求されるため、`alignedAlloc()` でアライン"
"された領域を確保します。"

#: src/kernel/paging.md:93
msgid "マッピングを再構築する関数は `reconstruct()` とします:"
msgstr "マッピングを再構築する関数は `reconstruct()` とします:"

#: src/kernel/paging.md:105
msgid ""
"まず最初に新しい Lv4 ページテーブルを確保します。 `allocatePage()` が返す領域"
"は [many-item pointer](https://ziglang.org/documentation/master/#Pointers) で"
"あるため、 テーブルあたりのエントリ数 512 でスライスを作っています。 作成した"
"ページテーブルはとりあえず全部ゼロ埋めしておきます。 ゼロ埋めすることでエント"
"リの `present` フィールドが 0 になるため、何もマップしない状態になります。 念"
"の為以下にページテーブルエントリの構造を再掲しておきます:"
msgstr ""
"まず最初に新しい Lv4 ページテーブルを確保します。 `allocatePage()` が返す領域"
"は [many-item pointer](https://ziglang.org/documentation/master/#Pointers) で"
"あるため、 テーブルあたりのエントリ数 512 でスライスを作っています。 作成した"
"ページテーブルはとりあえず全部ゼロ埋めしておきます。 ゼロ埋めすることでエント"
"リの `present` フィールドが 0 になるため、何もマップしない状態になります。 念"
"の為以下にページテーブルエントリの構造を再掲しておきます:"

#: src/kernel/paging.md:117
msgid "作成したまっさらなページテーブルに Direct Map Region をマップします:"
msgstr "作成したまっさらなページテーブルに Direct Map Region をマップします:"

#: src/kernel/paging.md:145
msgid ""
"`direct_map_base` は `0xFFFF888000000000` です。 この仮想アドレスを解決するた"
"めの Lv4 エントリのインデックスは、アドレスを `lv4_shift`(`39`) だけシフトす"
"ることで得られます。 `lv4idx_end` は 512GiB をマップするのに必要なだけのエン"
"トリ数を `lv4idx_start` に足したものです。 Lv3 テーブルにはエントリが 512 個"
"あり、それぞれが 1GiB をマップできるため、必要な Lv3 テーブルは 1つです。"
msgstr ""
"`direct_map_base` は `0xFFFF888000000000` です。 この仮想アドレスを解決するた"
"めの Lv4 エントリのインデックスは、アドレスを `lv4_shift`(`39`) だけシフトす"
"ることで得られます。 `lv4idx_end` は 512GiB をマップするのに必要なだけのエン"
"トリ数を `lv4idx_start` に足したものです。 Lv3 テーブルにはエントリが 512 個"
"あり、それぞれが 1GiB をマップできるため、必要な Lv3 テーブルは 1つです。"

#: src/kernel/paging.md:152
#, fuzzy
#| msgid ""
#| "\\[!NOTE\\] ページサイズ 今回は Direct Map Region を 1GiB ページでマップし"
#| "ました。 4KiB ページを使うと 1GiB をマップするのに \\\\( 2^{18} \\\\) 個の"
#| "エントリが必要になります。 1エントリあたり 8byte なので、合計で \\"
#| "\\( 2^{18} \\times 8 = 2^{21} = 2\\text{MiB} \\\\) になります。 今回は "
#| "512GiB をマップするため、4KiB ページを使うとテーブルエントリだけで 1GiB に"
#| "なってしまいます。 できるだけ大きいページを使うことでページテーブルのエン"
#| "トリ数を減らすことができます。 今回 1GiB ページを使ったのもそのためです。"
msgid ""
"今回は Direct Map Region を 1GiB ページでマップしました。 4KiB ページを使う"
"と 1GiB をマップするのに \\\\( 2^{18} \\\\) 個のエントリが必要になります。 1"
"エントリあたり 8byte なので、合計で \\\\( 2^{18} \\times 8 = 2^{21} = "
"2\\text{MiB} \\\\) になります。 今回は 512GiB をマップするため、4KiB ページを"
"使うとテーブルエントリだけで 1GiB になってしまいます。 できるだけ大きいページ"
"を使うことでページテーブルのエントリ数を減らすことができます。 今回 1GiB ペー"
"ジを使ったのもそのためです。"
msgstr ""
"\\[!NOTE\\] ページサイズ 今回は Direct Map Region を 1GiB ページでマップしま"
"した。 4KiB ページを使うと 1GiB をマップするのに \\\\( 2^{18} \\\\) 個のエン"
"トリが必要になります。 1エントリあたり 8byte なので、合計で \\\\( 2^{18} "
"\\times 8 = 2^{21} = 2\\text{MiB} \\\\) になります。 今回は 512GiB をマップす"
"るため、4KiB ページを使うとテーブルエントリだけで 1GiB になってしまいます。 "
"できるだけ大きいページを使うことでページテーブルのエントリ数を減らすことがで"
"きます。 今回 1GiB ページを使ったのもそのためです。"

#: src/kernel/paging.md:159
msgid ""
"`for` ループでは、Lv4 エントリに対して Lv3 テーブルを確保し、そのエントリを作"
"成しています。 今回 Lv3 テーブルは1つしか必要ないためこの `for` ループは1回し"
"か実行されませんが、 direct map region を大きくしたいような場合にも対応できる"
"ようにしています。"
msgstr ""
"`for` ループでは、Lv4 エントリに対して Lv3 テーブルを確保し、そのエントリを作"
"成しています。 今回 Lv3 テーブルは1つしか必要ないためこの `for` ループは1回し"
"か実行されませんが、 direct map region を大きくしたいような場合にも対応できる"
"ようにしています。"

#: src/kernel/paging.md:163
msgid "この関数を図示すると以下のようになります:"
msgstr "この関数を図示すると以下のようになります:"

#: src/kernel/paging.md:165
msgid ""
"![Direct Map Region](../assets/drawio/remap.drawio.png) _Direct Map Region_"
msgstr ""
"![Direct Map Region](../assets/drawio/remap.drawio.png) _Direct Map Region_"

#: src/kernel/paging.md:168
msgid "古いページテーブルのクローン"
msgstr "古いページテーブルのクローン"

#: src/kernel/paging.md:170
msgid ""
"続いて、UEFI が提供するページテーブルから Direct Map Region よりも高位にマッ"
"プされている領域をクローンします。 この領域を使っているのはカーネルイメージだ"
"けです。"
msgstr ""
"続いて、UEFI が提供するページテーブルから Direct Map Region よりも高位にマッ"
"プされている領域をクローンします。 この領域を使っているのはカーネルイメージだ"
"けです。"

#: src/kernel/paging.md:173
msgid "まずは Lv4 エントリを探索してクローンするべきエントリを探します:"
msgstr "まずは Lv4 エントリを探索してクローンするべきエントリを探します:"

#: src/kernel/paging.md:192
msgid ""
"現在利用中の Lv4 テーブルのアドレスは CR3 の値から取得できます。 既に実装し"
"た `getLv4Table()` でテーブルを取得した後、Direct Map Region 以降のエントリか"
"ら有効 (`present`) なエントリを探します。 有効な Lv4 エントリは Lv3 ページ"
"テーブルを指していますが、この Lv3 ページテーブルも UEFI が提供するものであり"
"新しく確保する必要があります。"
msgstr ""
"現在利用中の Lv4 テーブルのアドレスは CR3 の値から取得できます。 既に実装し"
"た `getLv4Table()` でテーブルを取得した後、Direct Map Region 以降のエントリか"
"ら有効 (`present`) なエントリを探します。 有効な Lv4 エントリは Lv3 ページ"
"テーブルを指していますが、この Lv3 ページテーブルも UEFI が提供するものであり"
"新しく確保する必要があります。"

#: src/kernel/paging.md:196
msgid ""
"Lv3 ページを確保したあとは、同様にしてテーブル内の有効なエントリが指すテーブ"
"ルを再帰的にクローンしていきます:"
msgstr ""
"Lv3 ページを確保したあとは、同様にしてテーブル内の有効なエントリが指すテーブ"
"ルを再帰的にクローンしていきます:"

#: src/kernel/paging.md:235
msgid ""
"Lv3 と Lv2 のクローンはほぼ同じです。 `getLvXTable()` 等と同様に内部実装を統"
"一しても良かったのですが、どうせ2つしかない上に1度しか使われないためこれで十"
"分です。"
msgstr ""
"Lv3 と Lv2 のクローンはほぼ同じです。 `getLvXTable()` 等と同様に内部実装を統"
"一しても良かったのですが、どうせ2つしかない上に1度しか使われないためこれで十"
"分です。"

#: src/kernel/paging.md:238
msgid ""
"Lv3 と Lv2 ページエントリは Lv4 と異なり、次レベルのページテーブルを指してい"
"る場合 (`ps == true`) の他に、 ページをマップしている場合 (`present == "
"true`) があります。 ページをマップしている場合には新しく作成・コピーするべき"
"ものがないため `continue` でスキップしています。"
msgstr ""
"Lv3 と Lv2 ページエントリは Lv4 と異なり、次レベルのページテーブルを指してい"
"る場合 (`ps == true`) の他に、 ページをマップしている場合 (`present == "
"true`) があります。 ページをマップしている場合には新しく作成・コピーするべき"
"ものがないため `continue` でスキップしています。"

#: src/kernel/paging.md:242
msgid ""
"Lv1 エントリはテーブルを指すことがなく必ず物理ページをマップしています。 よっ"
"て、`cloneLevel1Table()` は単純にテーブルを新たに作成してコピーするだけです:"
msgstr ""
"Lv1 エントリはテーブルを指すことがなく必ず物理ページをマップしています。 よっ"
"て、`cloneLevel1Table()` は単純にテーブルを新たに作成してコピーするだけです:"

#: src/kernel/paging.md:256
msgid ""
"以上で新しい Lv4 テーブルに既存のカーネル用領域のマップが作成できました。"
msgstr ""
"以上で新しい Lv4 テーブルに既存のカーネル用領域のマップが作成できました。"

#: src/kernel/paging.md:258
msgid "新しいテーブルのロード"
msgstr "新しいテーブルのロード"

#: src/kernel/paging.md:260
msgid ""
"最後に、新しいページテーブルをロードします。 Lv4 ページテーブルのアドレスは "
"CR3 レジスタに書き込むことで変更できます。"
msgstr ""
"最後に、新しいページテーブルをロードします。 Lv4 ページテーブルのアドレスは "
"CR3 レジスタに書き込むことで変更できます。"

#: src/kernel/paging.md:273
msgid ""
"CR3 へ書き込みを行うと、TLB の前エントリがフラッシュされ古いエントリが無効に"
"なります。 以降は新しくセットしたページテーブルがアドレス解決に使われます。"
msgstr ""
"CR3 へ書き込みを行うと、TLB の前エントリがフラッシュされ古いエントリが無効に"
"なります。 以降は新しくセットしたページテーブルがアドレス解決に使われます。"

#: src/kernel/paging.md:276
msgid ""
"なお、本来 CR3 は単にページテーブルの物理アドレスを保持する他にも別のフィール"
"ドを持ちます:"
msgstr ""
"なお、本来 CR3 は単にページテーブルの物理アドレスを保持する他にも別のフィール"
"ドを持ちます:"

#: src/kernel/paging.md:278
msgid ""
"![Use of CR3 with 4-Level Paging and 5-level Paging and CR4.PCIDE = 0](../"
"assets/sdm/cr3.png) _Use of CR3 with 4-Level Paging and 5-level Paging and "
"CR4.PCIDE = 0. SDM Vol.3A 4.5.2_ ![Use of CR3 with 4-Level Paging and 5-"
"level Paging and CR4.PCIDE = 0](../assets/sdm/cr3_cont.png) _Use of CR3 with "
"4-Level Paging and 5-level Paging and CR4.PCIDE = 0 (Contd.). SDM Vol.3A "
"4.5.2_"
msgstr ""
"![Use of CR3 with 4-Level Paging and 5-level Paging and CR4.PCIDE = 0](../"
"assets/sdm/cr3.png) _Use of CR3 with 4-Level Paging and 5-level Paging and "
"CR4.PCIDE = 0. SDM Vol.3A 4.5.2_ ![Use of CR3 with 4-Level Paging and 5-"
"level Paging and CR4.PCIDE = 0](../assets/sdm/cr3_cont.png) _Use of CR3 with "
"4-Level Paging and 5-level Paging and CR4.PCIDE = 0 (Contd.). SDM Vol.3A "
"4.5.2_"

#: src/kernel/paging.md:283
msgid ""
"本シリーズの Ymir では [PCID: Process Context Identifiers](https://en."
"wikipedia.org/wiki/Translation_lookaside_buffer#PCID) は使わないため，この表"
"のフォーマットに従います[^pcid]。 表中の `M` は物理アドレスのサイズであり、お"
"そらく最近の Core シリーズでは `46` になるのではないかと思います。 3-rd / 4-"
"th bit は Lv4 テーブルにアクセスする際のキャッシュタイプを決定する要因の1つに"
"なります。 今回は特にこのあたりは気にせず、どちらも `0` としています。"
msgstr ""
"本シリーズの Ymir では [PCID: Process Context Identifiers](https://en."
"wikipedia.org/wiki/Translation_lookaside_buffer#PCID) は使わないため，この表"
"のフォーマットに従います[^pcid]。 表中の `M` は物理アドレスのサイズであり、お"
"そらく最近の Core シリーズでは `46` になるのではないかと思います。 3-rd / 4-"
"th bit は Lv4 テーブルにアクセスする際のキャッシュタイプを決定する要因の1つに"
"なります。 今回は特にこのあたりは気にせず、どちらも `0` としています。"

#: src/kernel/paging.md:288
msgid "仮想-物理アドレス変換"
msgstr "仮想-物理アドレス変換"

#: src/kernel/paging.md:290
msgid "実装した関数を使ってメモリマップを再構築します:"
msgstr "実装した関数を使ってメモリマップを再構築します:"

#: src/kernel/paging.md:303
msgid ""
"ところで、[Page Allocator](./page_allocator#phys-virt-変換) のチャプターでは"
"仮想アドレスと物理アドレスの変換をする関数を定義しました。 その時はまだ UEFI "
"のページテーブルを使っていたため物理アドレスと仮想アドレスは等しいものとして"
"扱いました。 しかし、`reconstruct()` を呼び出すことでページテーブルは新しいも"
"のに置き換わり、仮想-物理アドレスの変換も変わります。 例えば、`0x1000` という"
"仮想アドレスはこれまでは `0x1000` という物理アドレスにマップされていました"
"が、 新しいページテーブルではもはやマップされていません。 テーブルを再構築し"
"たあとには変換の挙動を変更する必要があります:"
msgstr ""
"ところで、[Page Allocator](./page_allocator#phys-virt-変換) のチャプターでは"
"仮想アドレスと物理アドレスの変換をする関数を定義しました。 その時はまだ UEFI "
"のページテーブルを使っていたため物理アドレスと仮想アドレスは等しいものとして"
"扱いました。 しかし、`reconstruct()` を呼び出すことでページテーブルは新しいも"
"のに置き換わり、仮想-物理アドレスの変換も変わります。 例えば、`0x1000` という"
"仮想アドレスはこれまでは `0x1000` という物理アドレスにマップされていました"
"が、 新しいページテーブルではもはやマップされていません。 テーブルを再構築し"
"たあとには変換の挙動を変更する必要があります:"

#: src/kernel/paging.md:336
msgid ""
"ページテーブルが再構築されたかどうかを `mapping_reconstructed` で管理し、その"
"値に応じて変換ロジックを変更します。 仮想から物理への変換では、仮想アドレス"
"が Direct Map Region とカーネルイメージ領域のどちらなのかを判定する必要があり"
"ます。 一方で物理から仮想への変換の際には、全て Direct Map Region 用の仮想ア"
"ドレスを返すことにします。 もちろんカーネルイメージ領域の物理アドレスは2つの"
"仮想アドレスにマップされているため、カーネル領域の仮想アドレスとして返すこと"
"も可能ですが、ここではシンプルにしています。"
msgstr ""
"ページテーブルが再構築されたかどうかを `mapping_reconstructed` で管理し、その"
"値に応じて変換ロジックを変更します。 仮想から物理への変換では、仮想アドレス"
"が Direct Map Region とカーネルイメージ領域のどちらなのかを判定する必要があり"
"ます。 一方で物理から仮想への変換の際には、全て Direct Map Region 用の仮想ア"
"ドレスを返すことにします。 もちろんカーネルイメージ領域の物理アドレスは2つの"
"仮想アドレスにマップされているため、カーネル領域の仮想アドレスとして返すこと"
"も可能ですが、ここではシンプルにしています。"

#: src/kernel/paging.md:341
msgid ""
"さて、以上でページテーブルの再構築が完了しました。 `kernelMain()` から呼び出"
"します:"
msgstr ""
"さて、以上でページテーブルの再構築が完了しました。 `kernelMain()` から呼び出"
"します:"

#: src/kernel/paging.md:350
msgid ""
"Ymir を実行し、HALT ループに入ったところで GDB をアタッチしてメモリマップを確"
"認すると以下のようになります:"
msgstr ""
"Ymir を実行し、HALT ループに入ったところで GDB をアタッチしてメモリマップを確"
"認すると以下のようになります:"

#: src/kernel/paging.md:359
msgid ""
"Direct Map Region とカーネルイメージ領域がマップされていることが分かります。 "
"マップの再構築完了です。"
msgstr ""
"Direct Map Region とカーネルイメージ領域がマップされていることが分かります。 "
"マップの再構築完了です。"

#: src/kernel/paging.md:362
msgid "Surtr のマッピング改良"
msgstr "Surtr のマッピング改良"

#: src/kernel/paging.md:366
#, fuzzy
#| msgid ""
#| "\\[!INFO\\] スキップ可能 この部分はスキップして次に進むことが可能です。"
msgid "この部分はスキップして次に進むことが可能です。"
msgstr ""
"\\[!INFO\\] スキップ可能 この部分はスキップして次に進むことが可能です。"

#: src/kernel/paging.md:368
msgid ""
"新しいアドレスマップを見て気づいたことがあります。 せっかく `linker.ld` でセ"
"グメント構成を設定してあげたのに、カーネルイメージ領域が単一の RWX な領域に"
"なってしまっています。 これは、[カーネルのロード](../bootloader/load_kernel."
"md#セグメントの読み込み) で Surtr がセグメントの属性を無視してロードしたため"
"です。 結果として全セグメントが同じ RWX 属性でマップされたため、ひと続きの領"
"域として表示されてしまっています。 わざわざ作ったスタックガードページも全く意"
"味がありませんね。"
msgstr ""
"新しいアドレスマップを見て気づいたことがあります。 せっかく `linker.ld` でセ"
"グメント構成を設定してあげたのに、カーネルイメージ領域が単一の RWX な領域に"
"なってしまっています。 これは、[カーネルのロード](../bootloader/load_kernel."
"md#セグメントの読み込み) で Surtr がセグメントの属性を無視してロードしたため"
"です。 結果として全セグメントが同じ RWX 属性でマップされたため、ひと続きの領"
"域として表示されてしまっています。 わざわざ作ったスタックガードページも全く意"
"味がありませんね。"

#: src/kernel/paging.md:374
msgid ""
"というわけで、Surtr のカーネルローダ部分が、セグメントの属性を考慮してロード"
"するように修正します。 まずは Surtr に 4KiB ページの属性を変更する関数を定義"
"します:"
msgstr ""
"というわけで、Surtr のカーネルローダ部分が、セグメントの属性を考慮してロード"
"するように修正します。 まずは Surtr に 4KiB ページの属性を変更する関数を定義"
"します:"

#: src/kernel/paging.md:409
msgid ""
"この関数は指定した仮想アドレスが 4KiB 物理ページにマップされていることを暗黙"
"的に前提とします。 もしも途中で 1GiB や 2MiB のページがマップされていたとして"
"も、それらはページテーブルをマップするものとして扱ってしまうためバグります。 "
"ただし、Surtr はカーネルのロードで 4KiB だけを使うため、この関数の前提は満た"
"されます。 途中で存在しない (`present == false`) ページエントリが見つかった場"
"合には gracefull にエラーを返すようにしています。"
msgstr ""
"この関数は指定した仮想アドレスが 4KiB 物理ページにマップされていることを暗黙"
"的に前提とします。 もしも途中で 1GiB や 2MiB のページがマップされていたとして"
"も、それらはページテーブルをマップするものとして扱ってしまうためバグります。 "
"ただし、Surtr はカーネルのロードで 4KiB だけを使うため、この関数の前提は満た"
"されます。 途中で存在しない (`present == false`) ページエントリが見つかった場"
"合には gracefull にエラーを返すようにしています。"

#: src/kernel/paging.md:414
msgid ""
"特定の TLB エントリをフラッシュするヘルパー関数は、INVLPG 命令を使用します:"
msgstr ""
"特定の TLB エントリをフラッシュするヘルパー関数は、INVLPG 命令を使用します:"

#: src/kernel/paging.md:428
msgid "続いて、カーネルのロード部分を修正します:"
msgstr "続いて、カーネルのロード部分を修正します:"

#: src/kernel/paging.md:454
msgid ""
"セグメントヘッダを順に読んでカーネルをロードする `while` ループの最後に、セグ"
"メントをロードしたページの属性を変更する処理を追加します。 なお、セグメントの"
"属性の内 executable 属性は本シリーズで無視します。 サポートする場合には、"
"`page.EntryBase` 構造体の最後に `xd` というフィールドを追加します。 この"
"フィールドが `true` の場合、そのページは NX (non-executable) になります。 [オ"
"リジナルの Ymir](https://github.com/smallkirby/ymir) では NX ページをサポート"
"しているため、気になるひとは参照してください。"
msgstr ""
"セグメントヘッダを順に読んでカーネルをロードする `while` ループの最後に、セグ"
"メントをロードしたページの属性を変更する処理を追加します。 なお、セグメントの"
"属性の内 executable 属性は本シリーズで無視します。 サポートする場合には、"
"`page.EntryBase` 構造体の最後に `xd` というフィールドを追加します。 この"
"フィールドが `true` の場合、そのページは NX (non-executable) になります。 [オ"
"リジナルの Ymir](https://github.com/smallkirby/ymir) では NX ページをサポート"
"しているため、気になるひとは参照してください。"

#: src/kernel/paging.md:460
msgid ""
"以上で Ymir のセグメントを属性を考慮してロードできるようになりました。 現在の"
"メモリマップは以下のようになっています:"
msgstr ""
"以上で Ymir のセグメントを属性を考慮してロードできるようになりました。 現在の"
"メモリマップは以下のようになっています:"

#: src/kernel/paging.md:475
msgid ""
"Direct Map Region はこれまでと同様一律に RWX な領域ですが、カーネル部分がセグ"
"メントの属性に従ってマップされていることが分かります。 これは `readelf` で読"
"み取れるセグメント情報と一致しています:"
msgstr ""
"Direct Map Region はこれまでと同様一律に RWX な領域ですが、カーネル部分がセグ"
"メントの属性に従ってマップされていることが分かります。 これは `readelf` で読"
"み取れるセグメント情報と一致しています:"

#: src/kernel/paging.md:575
msgid ""
"本チャプターでは Ymir のメモリマップとして Direct Map Region とカーネルイメー"
"ジ領域をマッピングしました。 これにより UEFI から提供されたページテーブルは不"
"要になり、解放することができます。 また、前チャプターまでとあわせて UEFI が提"
"供するデータ構造全てを置き換えることが完了しました。 もう UEFI メモリマップに"
"おける `BootServiceData` 領域を `PageAllocator` から利用することが可能になり"
"ます。 次のチャプターでは、Zig が提供する `@panic()` の実装をすることで、今後"
"のデバッグを少しだけ楽にしていきます。"
msgstr ""
"本チャプターでは Ymir のメモリマップとして Direct Map Region とカーネルイメー"
"ジ領域をマッピングしました。 これにより UEFI から提供されたページテーブルは不"
"要になり、解放することができます。 また、前チャプターまでとあわせて UEFI が提"
"供するデータ構造全てを置き換えることが完了しました。 もう UEFI メモリマップに"
"おける `BootServiceData` 領域を `PageAllocator` から利用することが可能になり"
"ます。 次のチャプターでは、Zig が提供する `@panic()` の実装をすることで、今後"
"のデバッグを少しだけ楽にしていきます。"

#: src/kernel/paging.md:581
msgid ""
"厳密には、「どこにロードされたのか」は Ymir 側で指定しているので分かります。 "
"分からないのは、ロードされたイメージのサイズや、(セグメント等のページ属性を分"
"けてロードした場合には)各セグメントのサイズやアドレス等です。"
msgstr ""
"厳密には、「どこにロードされたのか」は Ymir 側で指定しているので分かります。 "
"分からないのは、ロードされたイメージのサイズや、(セグメント等のページ属性を分"
"けてロードした場合には)各セグメントのサイズやアドレス等です。"

#: src/kernel/paging.md:583
msgid ""
"[オリジナルの Ymir](https://github.com/smallkirby/ymir) では PCID を有効化し"
"ています。"
msgstr ""
"[オリジナルの Ymir](https://github.com/smallkirby/ymir) では PCID を有効化し"
"ています。"

#: src/kernel/panic.md:1
msgid "パニック実装"
msgstr "パニック実装"

#: src/kernel/panic.md:3
msgid ""
"本チャプターでは Zig [Builtin Functions](https://ziglang.org/documentation/"
"master/#Builtin-Functions) である [`@panic()`](https://ziglang.org/"
"documentation/master/#panic) の実装をします。 今後 Ymir VMM 部分の実装をする"
"にあたり、パニックが生じることが多々あります。 その時のためにスタックトレース"
"を表示し、適切にエラー内容を表示してくれるようなパニックハンドラを実装するこ"
"とで、今後のデバッグを楽にしていきます。"
msgstr ""
"本チャプターでは Zig [Builtin Functions](https://ziglang.org/documentation/"
"master/#Builtin-Functions) である [`@panic()`](https://ziglang.org/"
"documentation/master/#panic) の実装をします。 今後 Ymir VMM 部分の実装をする"
"にあたり、パニックが生じることが多々あります。 その時のためにスタックトレース"
"を表示し、適切にエラー内容を表示してくれるようなパニックハンドラを実装するこ"
"とで、今後のデバッグを楽にしていきます。"

#: src/kernel/panic.md:9
#, fuzzy
#| msgid ""
#| "\\[!NOTE\\] スキップ可能 本チャプターはまるごとスキップして次のチャプター"
#| "に進んでも問題ありません。"
msgid ""
"本チャプターはまるごとスキップして次のチャプターに進んでも問題ありません。"
msgstr ""
"\\[!NOTE\\] スキップ可能 本チャプターはまるごとスキップして次のチャプターに進"
"んでも問題ありません。"

#: src/kernel/panic.md:13
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-panic`](https://"
#| "github.com/smallkirby/ymir/tree/whiz-ymir-panic) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-ymir-panic`](https://github.com/smallkirby/"
"ymir/tree/whiz-ymir-panic) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-panic`](https://"
"github.com/smallkirby/ymir/tree/whiz-ymir-panic) ブランチにあります。"

#: src/kernel/panic.md:17
msgid "[デフォルトパニック](#デフォルトパニック)"
msgstr "[デフォルトパニック](#デフォルトパニック)"

#: src/kernel/panic.md:18
msgid "[メッセージの表示](#メッセージの表示)"
msgstr "[メッセージの表示](#メッセージの表示)"

#: src/kernel/panic.md:19
msgid "[スタックトレース](#スタックトレース)"
msgstr "[スタックトレース](#スタックトレース)"

#: src/kernel/panic.md:20
msgid "[デフォルトハンドラの上書き](#デフォルトハンドラの上書き)"
msgstr "[デフォルトハンドラの上書き](#デフォルトハンドラの上書き)"

#: src/kernel/panic.md:23
msgid "デフォルトパニック"
msgstr "デフォルトパニック"

#: src/kernel/panic.md:25
msgid ""
"Zig の [@panic()](https://ziglang.org/documentation/master/#panic) はプログラ"
"ムが復帰不可能なエラーに遭遇した場合に呼び出され、プログラムを終了させます。 "
"`@panic()` は単に登録されたパニックハンドラを呼び出すのですが、このハンドラの"
"実装は [プラットフォーム依存](https://github.com/ziglang/zig/"
"blob/3054486d1dedd49553680da2c074d1ab413797fd/lib/std/debug.zig#L462) です。 "
"通常の OS の場合は指定したメッセージを表示した上でスタックトレースも表示して"
"くれます。 しかしながら、`.freestanding` な環境でのデフォルトのパニックハンド"
"ラは単に `@trap()` を呼ぶだけです。 指定したメッセージを表示することすらして"
"くれません。"
msgstr ""
"Zig の [@panic()](https://ziglang.org/documentation/master/#panic) はプログラ"
"ムが復帰不可能なエラーに遭遇した場合に呼び出され、プログラムを終了させます。 "
"`@panic()` は単に登録されたパニックハンドラを呼び出すのですが、このハンドラの"
"実装は [プラットフォーム依存](https://github.com/ziglang/zig/"
"blob/3054486d1dedd49553680da2c074d1ab413797fd/lib/std/debug.zig#L462) です。 "
"通常の OS の場合は指定したメッセージを表示した上でスタックトレースも表示して"
"くれます。 しかしながら、`.freestanding` な環境でのデフォルトのパニックハンド"
"ラは単に `@trap()` を呼ぶだけです。 指定したメッセージを表示することすらして"
"くれません。"

#: src/kernel/panic.md:31
msgid ""
"これでは不便なので、Ymir では自前のパニックハンドラを実装することにします。 "
"このハンドラはまず指定されたメッセージをシリアル出力します。 また、スタックト"
"レースも表示します。 最後に Ymir を終了させるのではなく無限ループさせることに"
"します。 これにより GDB でアタッチしてデバッグする機会を与え、より詳細なデ"
"バッグを可能にします。"
msgstr ""
"これでは不便なので、Ymir では自前のパニックハンドラを実装することにします。 "
"このハンドラはまず指定されたメッセージをシリアル出力します。 また、スタックト"
"レースも表示します。 最後に Ymir を終了させるのではなく無限ループさせることに"
"します。 これにより GDB でアタッチしてデバッグする機会を与え、より詳細なデ"
"バッグを可能にします。"

#: src/kernel/panic.md:37
msgid "メッセージの表示"
msgstr "メッセージの表示"

#: src/kernel/panic.md:39
msgid ""
"Zig のパニックハンドラは3つの引数を取ります。 1つ目は出力するメッセージで"
"す。 ログ系の関数とは異なり、フォーマット文字列を出力をすることはできないた"
"め、メッセージ用の引数はこの1つだけです。 2つ目と3つ目はスタックトレース関連"
"の情報なのですが、`.freestanding` ではこれらの引数は常に `null` でした。 まぁ"
"スタックトレースはレジスタの状態から自前で取得することができるため問題ありま"
"せん。 以下でパニックハンドラを定義します:"
msgstr ""
"Zig のパニックハンドラは3つの引数を取ります。 1つ目は出力するメッセージで"
"す。 ログ系の関数とは異なり、フォーマット文字列を出力をすることはできないた"
"め、メッセージ用の引数はこの1つだけです。 2つ目と3つ目はスタックトレース関連"
"の情報なのですが、`.freestanding` ではこれらの引数は常に `null` でした。 まぁ"
"スタックトレースはレジスタの状態から自前で取得することができるため問題ありま"
"せん。 以下でパニックハンドラを定義します:"

#: src/kernel/panic.md:67
msgid ""
"`@setCold()` はこの関数(ブランチ)がめったに呼ばれないことを示します。 なぜか"
"は分かりませんが、Zig のドキュメントにはこのビルトイン関数についての記述があ"
"りません。 おそらく [@branchHint()](https://ziglang.org/documentation/master/"
"#branchHint) と似たようなものだと思われます。 きっとコンパイラに最適化のヒン"
"トを与えてくれるものだと思っています、多分。"
msgstr ""
"`@setCold()` はこの関数(ブランチ)がめったに呼ばれないことを示します。 なぜか"
"は分かりませんが、Zig のドキュメントにはこのビルトイン関数についての記述があ"
"りません。 おそらく [@branchHint()](https://ziglang.org/documentation/master/"
"#branchHint) と似たようなものだと思われます。 きっとコンパイラに最適化のヒン"
"トを与えてくれるものだと思っています、多分。"

#: src/kernel/panic.md:72
msgid ""
"パニックハンドラの中では割り込みを無効化します。 パニックハンドラの中で割り込"
"みが発生すると、さらなるパニックが発生してしまう可能性があるためです。 メッ"
"セージの出力には他のファイルと同様に `std.log` を使用します。 ログ関数は既に"
"シリアルを利用するように実装されているため、パニック実装で自前のシリアル出力"
"を用意する必要はありません。"
msgstr ""
"パニックハンドラの中では割り込みを無効化します。 パニックハンドラの中で割り込"
"みが発生すると、さらなるパニックが発生してしまう可能性があるためです。 メッ"
"セージの出力には他のファイルと同様に `std.log` を使用します。 ログ関数は既に"
"シリアルを利用するように実装されているため、パニック実装で自前のシリアル出力"
"を用意する必要はありません。"

#: src/kernel/panic.md:77
msgid ""
"なお、割り込みを禁止した場合でも、パニックハンドラの中でさらなるパニックが発"
"生する可能性は否定できません。 そのためグローバル変数に `panicked` という変数"
"を用意しておき、一度パニックハンドラが呼び出されたらこのフラグを立てるように"
"しておきます。 このフラグが立っている時にハンドラが呼ばれたら何もせずに終了す"
"るようにしています。"
msgstr ""
"なお、割り込みを禁止した場合でも、パニックハンドラの中でさらなるパニックが発"
"生する可能性は否定できません。 そのためグローバル変数に `panicked` という変数"
"を用意しておき、一度パニックハンドラが呼び出されたらこのフラグを立てるように"
"しておきます。 このフラグが立っている時にハンドラが呼ばれたら何もせずに終了す"
"るようにしています。"

#: src/kernel/panic.md:81
msgid ""
"パニックハンドラの最後には無限 HLT ループに入るようにします。 割り込みを禁止"
"しているため、この HLT から抜け出すことはありません:"
msgstr ""
"パニックハンドラの最後には無限 HLT ループに入るようにします。 割り込みを禁止"
"しているため、この HLT から抜け出すことはありません:"

#: src/kernel/panic.md:92
msgid "スタックトレース"
msgstr "スタックトレース"

#: src/kernel/panic.md:94
msgid ""
"続いて、スタックトレースの表示をします。 スタックトレースは RSP / RBP の値を"
"順に辿っていくことで取得することができます。 Zig にはスタックトレースを取得す"
"るためのユーティリティ構造体である `StackIterator` があるため今回はこれを使い"
"ます:"
msgstr ""
"続いて、スタックトレースの表示をします。 スタックトレースは RSP / RBP の値を"
"順に辿っていくことで取得することができます。 Zig にはスタックトレースを取得す"
"るためのユーティリティ構造体である `StackIterator` があるため今回はこれを使い"
"ます:"

#: src/kernel/panic.md:114
msgid ""
"本来であればスタックトレースにはファイル名・関数名・行番号なども表示できると"
"嬉しいところですが、Ymir では実装しません。 Zig には `std.dwarf` というライブ"
"ラリで DWARF デバッグ情報を取り扱うことができるらしいため、実装したい人は活用"
"すると良いかもしれません。 その場合には、Ymir の ELF ファイル自体をメモリ上に"
"ロードし Ymir に渡す必要があることに注意してください。"
msgstr ""
"本来であればスタックトレースにはファイル名・関数名・行番号なども表示できると"
"嬉しいところですが、Ymir では実装しません。 Zig には `std.dwarf` というライブ"
"ラリで DWARF デバッグ情報を取り扱うことができるらしいため、実装したい人は活用"
"すると良いかもしれません。 その場合には、Ymir の ELF ファイル自体をメモリ上に"
"ロードし Ymir に渡す必要があることに注意してください。"

#: src/kernel/panic.md:118
msgid "デフォルトハンドラの上書き"
msgstr "デフォルトハンドラの上書き"

#: src/kernel/panic.md:120
msgid ""
"Zig のデフォルトのパニックハンドラを上書きするには、Root Source File におい"
"て `panic()` 関数を定義します:"
msgstr ""
"Zig のデフォルトのパニックハンドラを上書きするには、Root Source File におい"
"て `panic()` 関数を定義します:"

#: src/kernel/panic.md:127
msgid ""
"それでは実際にパニックさせてみましょう。 なお、最適化レベルは `Debug` にして"
"おくのがおすすめです。 `ReleaseFast` レベルだと最適化が結構強く働くため、関数"
"がインライン化されてスタックトレースが出力できない場合があります:"
msgstr ""
"それでは実際にパニックさせてみましょう。 なお、最適化レベルは `Debug` にして"
"おくのがおすすめです。 `ReleaseFast` レベルだと最適化が結構強く働くため、関数"
"がインライン化されてスタックトレースが出力できない場合があります:"

#: src/kernel/panic.md:136 src/vmm/vmcs.md:571 src/vmm/vmcs.md:662
#: src/vmm/vmlaunch.md:1019
msgid "出力は以下のようになります:"
msgstr "出力は以下のようになります:"

#: src/kernel/panic.md:146
msgid ""
"ちゃんとスタックトレースが出力されていることが分かります。 デバッグ情報がない"
"ためソースファイルにおける行番号などは表示されませんが、 それらは "
"`addr2line` コマンドで実現することができます:"
msgstr ""
"ちゃんとスタックトレースが出力されていることが分かります。 デバッグ情報がない"
"ためソースファイルにおける行番号などは表示されませんが、 それらは "
"`addr2line` コマンドで実現することができます:"

#: src/kernel/panic.md:158
msgid ""
"本チャプターでは Zig の Builtin Functions である `@panic()` の実装をしまし"
"た。 パニックハンドラは指定されたメッセージを表示した後、スタックトレースを表"
"示して HLT ループに入ります。 これにより、自分で明示的に `@panic()` を書いた"
"場合に加えて、Zig の `Debug` モードにおけるアラインの不一致やオーバーフロー等"
"でも今回のパニックハンドラが呼ばれるようになります。 デバッグが楽になることで"
"しょう。"
msgstr ""
"本チャプターでは Zig の Builtin Functions である `@panic()` の実装をしまし"
"た。 パニックハンドラは指定されたメッセージを表示した後、スタックトレースを表"
"示して HLT ループに入ります。 これにより、自分で明示的に `@panic()` を書いた"
"場合に加えて、Zig の `Debug` モードにおけるアラインの不一致やオーバーフロー等"
"でも今回のパニックハンドラが呼ばれるようになります。 デバッグが楽になることで"
"しょう。"

#: src/kernel/general_allocator.md:1
msgid "General-Purpose Memomry Allocator"
msgstr "General-Purpose Memomry Allocator"

#: src/kernel/general_allocator.md:3
msgid ""
"[Page Allocator](./page_allocator.md) のチャプターでは、ページ単位でメモリを"
"確保するページアロケータを作成しました。 このアロケータは `Allocator` インタ"
"フェースを実装しているため、汎用的なメモリ確保に利用できます。 しかし、どんな"
"に小さなサイズのメモリを要求する場合でもバックエンドがページアロケータである"
"以上、 実際に確保されるメモリの最小サイズは 4KiB になってしまいます。 本チャ"
"プターでは、より効率的に小さなサイズのメモリを確保できる汎用的なアロケータを"
"実装します。 これにより、ページアロケータよりも遥かに小さなメモリオーバヘッド"
"でメモリを確保できるようになります。"
msgstr ""
"[Page Allocator](./page_allocator.md) のチャプターでは、ページ単位でメモリを"
"確保するページアロケータを作成しました。 このアロケータは `Allocator` インタ"
"フェースを実装しているため、汎用的なメモリ確保に利用できます。 しかし、どんな"
"に小さなサイズのメモリを要求する場合でもバックエンドがページアロケータである"
"以上、 実際に確保されるメモリの最小サイズは 4KiB になってしまいます。 本チャ"
"プターでは、より効率的に小さなサイズのメモリを確保できる汎用的なアロケータを"
"実装します。 これにより、ページアロケータよりも遥かに小さなメモリオーバヘッド"
"でメモリを確保できるようになります。"

#: src/kernel/general_allocator.md:12
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-"
#| "general_allocator`](https://github.com/smallkirby/ymir/tree/whiz-ymir-"
#| "general_allocator) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-ymir-general_allocator`](https://github."
"com/smallkirby/ymir/tree/whiz-ymir-general_allocator) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-general_allocator`]"
"(https://github.com/smallkirby/ymir/tree/whiz-ymir-general_allocator) ブラン"
"チにあります。"

#: src/kernel/general_allocator.md:16
msgid "[Bin Allocator](#bin-allocator)"
msgstr "[Bin Allocator](#bin-allocator)"

#: src/kernel/general_allocator.md:17
msgid "[メタデータ](#メタデータ)"
msgstr "[メタデータ](#メタデータ)"

#: src/kernel/general_allocator.md:19
msgid "[Bin からのメモリ確保・解放](#bin-からのメモリ確保解放)"
msgstr "[Bin からのメモリ確保・解放](#bin-からのメモリ確保解放)"

#: src/kernel/general_allocator.md:20
msgid "[インタフェースの実装](#インタフェースの実装)"
msgstr "[インタフェースの実装](#インタフェースの実装)"

#: src/kernel/general_allocator.md:26
msgid "Bin Allocator"
msgstr "Bin Allocator"

#: src/kernel/general_allocator.md:28
msgid ""
"今回実装する汎用アロケータは `BinAllocator` という名前です[^bin]。 他の広く使"
"われているアロケータと同様に、 **bin** と呼ばれる固定サイズのメモリブロックを"
"管理します。 Ymir の汎用アロケータの概略を以下に示します:"
msgstr ""
"今回実装する汎用アロケータは `BinAllocator` という名前です[^bin]。 他の広く使"
"われているアロケータと同様に、 **bin** と呼ばれる固定サイズのメモリブロックを"
"管理します。 Ymir の汎用アロケータの概略を以下に示します:"

#: src/kernel/general_allocator.md:32
msgid ""
"![Ymir BinAllocator Overview](../assets/drawio/binallocator.drawio.png) "
"_Ymir BinAllocator Overview_"
msgstr ""
"![Ymir BinAllocator Overview](../assets/drawio/binallocator.drawio.png) "
"_Ymir BinAllocator Overview_"

#: src/kernel/general_allocator.md:35
msgid ""
"各 bin は固定サイズの領域 **chunk** の連結リストを保持します。 Chunck は 利用"
"中 (_in-use_) か 割当て可能 (_free_) のどちらかの状態を持ちます。 Free な "
"chunk は次の chunk へのポインタを持ち、全体としてリストを構成します。 アロ"
"ケータは利用中の chunk は管理しません。"
msgstr ""
"各 bin は固定サイズの領域 **chunk** の連結リストを保持します。 Chunck は 利用"
"中 (_in-use_) か 割当て可能 (_free_) のどちらかの状態を持ちます。 Free な "
"chunk は次の chunk へのポインタを持ち、全体としてリストを構成します。 アロ"
"ケータは利用中の chunk は管理しません。"

#: src/kernel/general_allocator.md:40
msgid ""
"各 chunk は 4KiB ページを分割して作成されます。 よって、ページの中には同一サ"
"イズの chunk しか含まれません。 Bin のリストの中に割り当て可能な chunk がない"
"場合、新しく 4KiB ページを作成し、それを固定サイズで分割して free な chunk を"
"作成します。"
msgstr ""
"各 chunk は 4KiB ページを分割して作成されます。 よって、ページの中には同一サ"
"イズの chunk しか含まれません。 Bin のリストの中に割り当て可能な chunk がない"
"場合、新しく 4KiB ページを作成し、それを固定サイズで分割して free な chunk を"
"作成します。"

#: src/kernel/general_allocator.md:44
msgid ""
"このアロケータはページアロケータよりもオーバヘッドが小さくなります。 例とし"
"て `0x10` サイズの領域を確保する場合、ページアロケータだと `4096 - 16 = "
"4080` bytes が無駄になってしまいます。 一方 BinAllocator では `0x20` の bin "
"から確保することで、オーバヘッドは `32 - 16 = 16` bytes に抑えることができま"
"す。 もちろん bin のサイズをより細かくすることでオーバヘッドをさらに減らすこ"
"ともできます。"
msgstr ""
"このアロケータはページアロケータよりもオーバヘッドが小さくなります。 例とし"
"て `0x10` サイズの領域を確保する場合、ページアロケータだと `4096 - 16 = "
"4080` bytes が無駄になってしまいます。 一方 BinAllocator では `0x20` の bin "
"から確保することで、オーバヘッドは `32 - 16 = 16` bytes に抑えることができま"
"す。 もちろん bin のサイズをより細かくすることでオーバヘッドをさらに減らすこ"
"ともできます。"

#: src/kernel/general_allocator.md:49
msgid "メタデータ"
msgstr "メタデータ"

#: src/kernel/general_allocator.md:51
msgid ""
"`BinAllocator` も `PageAllocator` と同様にファイル全体を構造体として扱いま"
"す。 新たに `BinAllocator.zig` を作成し、必要な定数・変数を定義します:"
msgstr ""
"`BinAllocator` も `PageAllocator` と同様にファイル全体を構造体として扱いま"
"す。 新たに `BinAllocator.zig` を作成し、必要な定数・変数を定義します:"

#: src/kernel/general_allocator.md:73
msgid ""
"`BinAllocator` にも `Allocator` インタフェースを実装するため、`vtable`フィー"
"ルドを作成します。 各関数の実装はのちほど行います。"
msgstr ""
"`BinAllocator` にも `Allocator` インタフェースを実装するため、`vtable`フィー"
"ルドを作成します。 各関数の実装はのちほど行います。"

#: src/kernel/general_allocator.md:76
msgid ""
"Bin のサイズは7種類用意しました。 これよりも細かいサイズを用意しても良いです"
"が、bin を細かくするほどメモリアクセスの空間局所性が悪化する場合もあり、単に"
"細かくすればよいというものでもありません。 なお、本シリーズではページサイズを"
"超える bin はサポートしていないため `comptime` でチェックしています。 ページ"
"サイズを超える確保要求が来た場合は、そのまま `PageAllocator` に処理を委譲して"
"ページ単位で確保することにします。"
msgstr ""
"Bin のサイズは7種類用意しました。 これよりも細かいサイズを用意しても良いです"
"が、bin を細かくするほどメモリアクセスの空間局所性が悪化する場合もあり、単に"
"細かくすればよいというものでもありません。 なお、本シリーズではページサイズを"
"超える bin はサポートしていないため `comptime` でチェックしています。 ページ"
"サイズを超える確保要求が来た場合は、そのまま `PageAllocator` に処理を委譲して"
"ページ単位で確保することにします。"

#: src/kernel/general_allocator.md:81
msgid ""
"Free な chunk は **メタデータ** を持ちます。 このメタデータは bin を管理する"
"ために必要な情報を持ちますが、 **`BinAllocator` で必要な情報は次の free な "
"chunk へのポインタだけ**です。 メタデータを表す構造体を定義します:"
msgstr ""
"Free な chunk は **メタデータ** を持ちます。 このメタデータは bin を管理する"
"ために必要な情報を持ちますが、 **`BinAllocator` で必要な情報は次の free な "
"chunk へのポインタだけ**です。 メタデータを表す構造体を定義します:"

#: src/kernel/general_allocator.md:97
msgid ""
"`ChunkMetaNode` は次の chunk へのポインタだけを持ちます。 もしも次の free "
"chunk が存在しない場合には `null` を持ちます。 `list_heads` は、各 bin の先頭"
"の chunk を指すポインタを保持します。 図における上部の四角で囲まれた部分が "
"`list_heads` に相当する部分ですね。"
msgstr ""
"`ChunkMetaNode` は次の chunk へのポインタだけを持ちます。 もしも次の free "
"chunk が存在しない場合には `null` を持ちます。 `list_heads` は、各 bin の先頭"
"の chunk を指すポインタを保持します。 図における上部の四角で囲まれた部分が "
"`list_heads` に相当する部分ですね。"

#: src/kernel/general_allocator.md:104
msgid ""
"`BinAllocator` は chunk 用のページ確保や、サポートする bin よりも大きいサイズ"
"の要求が来た場合のために、 バックエンドのアロケータとして `PageAllocator` を"
"保持することにします。 `BinAllocator` を初期化する際には、`PageAllocator` を"
"引数として受け取ります:"
msgstr ""
"`BinAllocator` は chunk 用のページ確保や、サポートする bin よりも大きいサイズ"
"の要求が来た場合のために、 バックエンドのアロケータとして `PageAllocator` を"
"保持することにします。 `BinAllocator` を初期化する際には、`PageAllocator` を"
"引数として受け取ります:"

#: src/kernel/general_allocator.md:118
msgid ""
"初期化時には、各 bin のヘッドを `null` で初期化します。 これは全ての bin が空"
"であることを意味します。 続いて、bin が空である場合に新しくページを確保し、"
"chunk を作成する関数を実装します:"
msgstr ""
"初期化時には、各 bin のヘッドを `null` で初期化します。 これは全ての bin が空"
"であることを意味します。 続いて、bin が空である場合に新しくページを確保し、"
"chunk を作成する関数を実装します:"

#: src/kernel/general_allocator.md:148
msgid ""
"ページの確保は `PageAllocator` に依頼します。 確保したページを `bin_size` の "
"chunk に分割し、それぞれに対して `while` の中を実行します。 各 chunk は生成し"
"た直後は free であるため、`ChunkMetaNode` として解釈します。 それらの "
"`ChunkMetaNode` を対応する bin リストに対して push すれば、新しい chunk がリ"
"ストに追加されます。"
msgstr ""
"ページの確保は `PageAllocator` に依頼します。 確保したページを `bin_size` の "
"chunk に分割し、それぞれに対して `while` の中を実行します。 各 chunk は生成し"
"た直後は free であるため、`ChunkMetaNode` として解釈します。 それらの "
"`ChunkMetaNode` を対応する bin リストに対して push すれば、新しい chunk がリ"
"ストに追加されます。"

#: src/kernel/general_allocator.md:153
msgid "Bin からのメモリ確保・解放"
msgstr "Bin からのメモリ確保・解放"

#: src/kernel/general_allocator.md:155
msgid ""
"メモリを確保する関数は bin のインデックスを受け取って、その bin から chunk を"
"取り出します:"
msgstr ""
"メモリを確保する関数は bin のインデックスを受け取って、その bin から chunk を"
"取り出します:"

#: src/kernel/general_allocator.md:176
msgid ""
"もしも指定された bin のリストが空であった場合、先ほど実装した "
"`initBinPage()` を呼び出して新しいページを確保します。 Bin に chunk があれば "
"(または新しく chunk を作成した場合には)、その chunk をリストから pop して返し"
"ます。 すごくシンプルです。"
msgstr ""
"もしも指定された bin のリストが空であった場合、先ほど実装した "
"`initBinPage()` を呼び出して新しいページを確保します。 Bin に chunk があれば "
"(または新しく chunk を作成した場合には)、その chunk をリストから pop して返し"
"ます。 すごくシンプルです。"

#: src/kernel/general_allocator.md:180
msgid "メモリの解放は確保時と逆の操作をします:"
msgstr "メモリの解放は確保時と逆の操作をします:"

#: src/kernel/general_allocator.md:190
msgid ""
"なお chunk を bin に返却したあと、もしもそのページ内の chunk が全て free に"
"なっている場合には、ページを解放することも考えられます。 本シリーズでは簡単の"
"ためにそのような処理は行いません。"
msgstr ""
"なお chunk を bin に返却したあと、もしもそのページ内の chunk が全て free に"
"なっている場合には、ページを解放することも考えられます。 本シリーズでは簡単の"
"ためにそのような処理は行いません。"

#: src/kernel/general_allocator.md:193
msgid "インタフェースの実装"
msgstr "インタフェースの実装"

#: src/kernel/general_allocator.md:195
msgid ""
"Bin から chunk を取得したり返却する処理が実装できたため、これらを使って "
"`Allocate` インタフェースに必要な関数を実装していきます:"
msgstr ""
"Bin から chunk を取得したり返却する処理が実装できたため、これらを使って "
"`Allocate` インタフェースに必要な関数を実装していきます:"

#: src/kernel/general_allocator.md:199
msgid ""
"`PageAllocator` の場合と異なり、`BinAllocator` はページサイズ以下の領域を確保"
"する可能性があります。 よって、 `BinAllocator` 要求されたアラインを考慮する必"
"要があります。 要求されるアラインは、`allocate()`の第3引数に渡されます:"
msgstr ""
"`PageAllocator` の場合と異なり、`BinAllocator` はページサイズ以下の領域を確保"
"する可能性があります。 よって、 `BinAllocator` 要求されたアラインを考慮する必"
"要があります。 要求されるアラインは、`allocate()`の第3引数に渡されます:"

#: src/kernel/general_allocator.md:229
msgid ""
"要求されるアライン `ptr_align` は、 \\\\(\\text{ptr\\_align} = "
"2^{\\text{log2\\_align}}\\\\) で計算されます。 **各 bin の chunk は bin のサ"
"イズごとにアラインされていることは保証されている**ため、 要求されるアライン"
"が bin のサイズよりも小さい場合には、単にその bin から chunk を取得するだけで"
"OKです。 要求されるアラインサイズが要求されるメモリサイズよりも大きいような場"
"合には、アラインサイズを bin のサイズとして扱います。 Chunk を確保する bin が"
"決まれば、先ほどの `allocFromBin()` を呼び出してメモリを確保します。 もしも適"
"切な bin が見つからなかった場合には、ページアロケータに処理を委譲します。"
msgstr ""
"要求されるアライン `ptr_align` は、 \\\\(\\text{ptr\\_align} = "
"2^{\\text{log2\\_align}}\\\\) で計算されます。 **各 bin の chunk は bin のサ"
"イズごとにアラインされていることは保証されている**ため、 要求されるアライン"
"が bin のサイズよりも小さい場合には、単にその bin から chunk を取得するだけで"
"OKです。 要求されるアラインサイズが要求されるメモリサイズよりも大きいような場"
"合には、アラインサイズを bin のサイズとして扱います。 Chunk を確保する bin が"
"決まれば、先ほどの `allocFromBin()` を呼び出してメモリを確保します。 もしも適"
"切な bin が見つからなかった場合には、ページアロケータに処理を委譲します。"

#: src/kernel/general_allocator.md:238
msgid ""
"`free()` 関数は、確保されたメモリを解放する際に呼び出されます。 実装は "
"`allocate()` と対称になります。 なお、`free()`には解放するメモリ領域のサイズ"
"が slice の形で渡されます。 よって、**解放されようとしているメモリがどの bin "
"に属するか(サイズがいくらなのか)を保存しておく必要はありません**。 この特性に"
"より、glibc などのヒープ実装とは異なり利用中の chunk の先頭にメタデータを入れ"
"ておく必要がなくなります:"
msgstr ""
"`free()` 関数は、確保されたメモリを解放する際に呼び出されます。 実装は "
"`allocate()` と対称になります。 なお、`free()`には解放するメモリ領域のサイズ"
"が slice の形で渡されます。 よって、**解放されようとしているメモリがどの bin "
"に属するか(サイズがいくらなのか)を保存しておく必要はありません**。 この特性に"
"より、glibc などのヒープ実装とは異なり利用中の chunk の先頭にメタデータを入れ"
"ておく必要がなくなります:"

#: src/kernel/general_allocator.md:262
msgid ""
"`PageAllocator` と同様に、`BinAllocator` はサイズ変更をサポートしないことにし"
"ます:"
msgstr ""
"`PageAllocator` と同様に、`BinAllocator` はサイズ変更をサポートしないことにし"
"ます:"

#: src/kernel/general_allocator.md:273
msgid "`BinAllocator` をインスタンス化して利用可能な状態にします:"
msgstr "`BinAllocator` をインスタンス化して利用可能な状態にします:"

#: src/kernel/general_allocator.md:299
msgid ""
"`bin_allocator_instance` は `BinAllocator` のインスタンスです。 このインスタ"
"ンス自体は他のファイルに対して露出させません。 このアロケータを使いたい場合に"
"は、必ず `Allocator` インタフェースを介してアクセスさせるようにします。"
msgstr ""
"`bin_allocator_instance` は `BinAllocator` のインスタンスです。 このインスタ"
"ンス自体は他のファイルに対して露出させません。 このアロケータを使いたい場合に"
"は、必ず `Allocator` インタフェースを介してアクセスさせるようにします。"

#: src/kernel/general_allocator.md:303
msgid "`kernelMain()` でアロケータを初期化します:"
msgstr "`kernelMain()` でアロケータを初期化します:"

#: src/kernel/general_allocator.md:311
msgid "最後に、作りたてほやほやのアロケータを使ってメモリを確保してみましょう:"
msgstr ""
"最後に、作りたてほやほやのアロケータを使ってメモリを確保してみましょう:"

#: src/kernel/general_allocator.md:321
msgid "結果は以下のようになります:"
msgstr "結果は以下のようになります:"

#: src/kernel/general_allocator.md:330
msgid ""
"`p` と `q` はそれぞれ `0x20` bytes のメモリ領域を指すポインタです。 `0x20` "
"bytes の領域は 0x20-bin から確保されるため、ちょうど `p` と `q` が隣接してい"
"ることが分かります。 ついでに、前チャプターでアドレスマップを再構築したため、"
"仮想アドレスも Direct Map Region のものが使われていることが分かりますね。"
msgstr ""
"`p` と `q` はそれぞれ `0x20` bytes のメモリ領域を指すポインタです。 `0x20` "
"bytes の領域は 0x20-bin から確保されるため、ちょうど `p` と `q` が隣接してい"
"ることが分かります。 ついでに、前チャプターでアドレスマップを再構築したため、"
"仮想アドレスも Direct Map Region のものが使われていることが分かりますね。"

#: src/kernel/general_allocator.md:334
msgid "検索したところ、この名前は一般的ではないようです。"
msgstr "検索したところ、この名前は一般的ではないようです。"

#: src/kernel/pic.md:3
msgid ""
"[割り込みと例外のチャプター](./interrupt.md) では IDT の設定をすることで割り"
"込みを受け取る準備をしました。 しかし、まだ外部割り込みに関する設定をしていな"
"いためそもそも割り込みが発生することがありません。 本チャプターでは **PIC: "
"Programmable Interrupt Controller** の初期化・設定をおこないます。 これによ"
"り、タイマーやキーボード等の外部デバイスから割り込みを受け取ることができるよ"
"うになります。"
msgstr ""
"[割り込みと例外のチャプター](./interrupt.md) では IDT の設定をすることで割り"
"込みを受け取る準備をしました。 しかし、まだ外部割り込みに関する設定をしていな"
"いためそもそも割り込みが発生することがありません。 本チャプターでは **PIC: "
"Programmable Interrupt Controller** の初期化・設定をおこないます。 これによ"
"り、タイマーやキーボード等の外部デバイスから割り込みを受け取ることができるよ"
"うになります。"

#: src/kernel/pic.md:10
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-pic`](https://"
#| "github.com/smallkirby/ymir/tree/whiz-ymir-pic) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-ymir-pic`](https://github.com/smallkirby/"
"ymir/tree/whiz-ymir-pic) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-ymir-pic`](https://github."
"com/smallkirby/ymir/tree/whiz-ymir-pic) ブランチにあります。"

#: src/kernel/pic.md:14
msgid "[Intel 8259 PIC](#intel-8259-pic)"
msgstr "[Intel 8259 PIC](#intel-8259-pic)"

#: src/kernel/pic.md:15
msgid "[IRR](#irr)"
msgstr "[IRR](#irr)"

#: src/kernel/pic.md:16
msgid "[ISR](#isr)"
msgstr "[ISR](#isr)"

#: src/kernel/pic.md:17
msgid "[IMR](#imr)"
msgstr "[IMR](#imr)"

#: src/kernel/pic.md:18
msgid "[Command Words](#command-words)"
msgstr "[Command Words](#command-words)"

#: src/kernel/pic.md:19
msgid "[ICW](#icw)"
msgstr "[ICW](#icw)"

#: src/kernel/pic.md:20
msgid "[ICW1](#icw1)"
msgstr "[ICW1](#icw1)"

#: src/kernel/pic.md:21
msgid "[ICW2](#icw2)"
msgstr "[ICW2](#icw2)"

#: src/kernel/pic.md:22
msgid "[ICW3](#icw3)"
msgstr "[ICW3](#icw3)"

#: src/kernel/pic.md:23
msgid "[ICW4](#icw4)"
msgstr "[ICW4](#icw4)"

#: src/kernel/pic.md:24
msgid "[OCW](#ocw)"
msgstr "[OCW](#ocw)"

#: src/kernel/pic.md:25
msgid "[OCW1](#ocw1)"
msgstr "[OCW1](#ocw1)"

#: src/kernel/pic.md:26
msgid "[OCW2](#ocw2)"
msgstr "[OCW2](#ocw2)"

#: src/kernel/pic.md:27
msgid "[OCW3](#ocw3)"
msgstr "[OCW3](#ocw3)"

#: src/kernel/pic.md:28
msgid "[PIC の初期化](#pic-の初期化)"
msgstr "[PIC の初期化](#pic-の初期化)"

#: src/kernel/pic.md:29
msgid "[Vector Offset](#vector-offset)"
msgstr "[Vector Offset](#vector-offset)"

#: src/kernel/pic.md:30
msgid "[EOI](#eoi)"
msgstr "[EOI](#eoi)"

#: src/kernel/pic.md:31
msgid "[ヘルパーの実装](#ヘルパーの実装)"
msgstr "[ヘルパーの実装](#ヘルパーの実装)"

#: src/kernel/pic.md:32
msgid "[割り込みのアンマスク](#割り込みのアンマスク)"
msgstr "[割り込みのアンマスク](#割り込みのアンマスク)"

#: src/kernel/pic.md:36
msgid "Intel 8259 PIC"
msgstr "Intel 8259 PIC"

#: src/kernel/pic.md:38
msgid ""
"本シリーズで扱う PIC は **Intel 8259A** です。 最近の Intel CPU では 8259A 相"
"当コントローラのが2つ搭載されているそうです。 それぞれ _Master PIC_ と "
"_Slave PIC_ と呼ばれます。 本シリーズでは **Primary PIC** と **Secondary "
"PIC** と呼びます。 それぞれが **Interrupt Requested Line (IRQ)** と呼ばれる入"
"力線を8つずつ持ち、Secondary は Primary に対してカスケード接続されています。 "
"なお、最近の CPU では 8259 PIC の代わりに **APIC: Advanced Programmable "
"Interrupt Controller** が広く使われています。 PIC はチップとして搭載されるこ"
"とはほぼなくなったものの、8259A 相当の機能は southbridge が依然として提供して"
"くれているようです。"
msgstr ""
"本シリーズで扱う PIC は **Intel 8259A** です。 最近の Intel CPU では 8259A 相"
"当コントローラのが2つ搭載されているそうです。 それぞれ _Master PIC_ と "
"_Slave PIC_ と呼ばれます。 本シリーズでは **Primary PIC** と **Secondary "
"PIC** と呼びます。 それぞれが **Interrupt Requested Line (IRQ)** と呼ばれる入"
"力線を8つずつ持ち、Secondary は Primary に対してカスケード接続されています。 "
"なお、最近の CPU では 8259 PIC の代わりに **APIC: Advanced Programmable "
"Interrupt Controller** が広く使われています。 PIC はチップとして搭載されるこ"
"とはほぼなくなったものの、8259A 相当の機能は southbridge が依然として提供して"
"くれているようです。"

#: src/kernel/pic.md:46
msgid ""
"![Functional Overview of 8259A PIC](../assets/drawio/8259pic.drawio.png) "
"_Functional Overview of 8259A PIC_"
msgstr ""
"![Functional Overview of 8259A PIC](../assets/drawio/8259pic.drawio.png) "
"_Functional Overview of 8259A PIC_"

#: src/kernel/pic.md:49
msgid "各PICの内部は以下の概念図のようになっています:"
msgstr "各PICの内部は以下の概念図のようになっています:"

#: src/kernel/pic.md:51
msgid ""
"![Functional Overview of the Internal Structure of 8259A PIC](../assets/"
"drawio/8259pic_internal.drawio.png) _Functional Overview of the Internal "
"Structure of 8259A PIC_"
msgstr ""
"![Functional Overview of the Internal Structure of 8259A PIC](../assets/"
"drawio/8259pic_internal.drawio.png) _Functional Overview of the Internal "
"Structure of 8259A PIC_"

#: src/kernel/pic.md:54
msgid "IRR"
msgstr "IRR"

#: src/kernel/pic.md:56
msgid ""
"**IRR: Interrupt Request Register** は PIC が受け取った割り込み要求を保持する"
"レジスタです。 IRR が何らかの割り込み要求を保持している場合、PIC は CPU に対"
"して **INT** 信号を送信し割り込みを要求します。 IRR は常に CPU から read 可能"
"です。"
msgstr ""
"**IRR: Interrupt Request Register** は PIC が受け取った割り込み要求を保持する"
"レジスタです。 IRR が何らかの割り込み要求を保持している場合、PIC は CPU に対"
"して **INT** 信号を送信し割り込みを要求します。 IRR は常に CPU から read 可能"
"です。"

#: src/kernel/pic.md:60
msgid "ISR"
msgstr "ISR"

#: src/kernel/pic.md:62
msgid ""
"**ISR: In-Service Register** は CPU によって処理が受け付けられた割り込み要求"
"を保持するレジスタです。 CPU が割り込み要求を受理した場合、\\"
"\\( \\overline{INTA} \\\\) 信号を PIC に送ります[^inta]。 この信号を受け取る"
"と、Priority Resolver が IRR の中から最も優先度の高い割り込み要求を選びま"
"す。 選んだ IRQ を ISR の対応するビットにセットし、IRR から対応するビットをク"
"リアします。 優先度はデフォルトでは IRQ0 が最も高く、IRQ7 が最も低いです。 な"
"お ISR にビットがセットされると、それ以下の優先度の IRQ は自動的にマスクされ"
"ます。 ISR は常に CPU から read 可能です。"
msgstr ""
"**ISR: In-Service Register** は CPU によって処理が受け付けられた割り込み要求"
"を保持するレジスタです。 CPU が割り込み要求を受理した場合、\\"
"\\( \\overline{INTA} \\\\) 信号を PIC に送ります[^inta]。 この信号を受け取る"
"と、Priority Resolver が IRR の中から最も優先度の高い割り込み要求を選びま"
"す。 選んだ IRQ を ISR の対応するビットにセットし、IRR から対応するビットをク"
"リアします。 優先度はデフォルトでは IRQ0 が最も高く、IRQ7 が最も低いです。 な"
"お ISR にビットがセットされると、それ以下の優先度の IRQ は自動的にマスクされ"
"ます。 ISR は常に CPU から read 可能です。"

#: src/kernel/pic.md:70
msgid "IMR"
msgstr "IMR"

#: src/kernel/pic.md:72
msgid ""
"**IMR: Interrupt Mask Register** は PIC が受け取った割り込み要求をマスクする"
"ためのレジスタです。 IMR でセットされたビットに対応する IRR のビットは無視さ"
"れます。"
msgstr ""
"**IMR: Interrupt Mask Register** は PIC が受け取った割り込み要求をマスクする"
"ためのレジスタです。 IMR でセットされたビットに対応する IRR のビットは無視さ"
"れます。"

#: src/kernel/pic.md:75
msgid "Command Words"
msgstr "Command Words"

#: src/kernel/pic.md:77
msgid ""
"8259A PIC は **CW: Command Words** という命令[^cw]を CPU から受け付けます。 "
"CW には **ICW: Initialization Command Words** と **OCW: Operation Command "
"Words** の2つがあります。 ICW は PIC を初期化するためのコマンドであり、OCW は"
"初期化後に PIC を操作するためのコマンドです。 どちらも 1byte のデータを PIC "
"に送信することで実行されます。 以降は CW に送信する 1byte のうち、N-th bit "
"を `D[N]` と表記します。"
msgstr ""
"8259A PIC は **CW: Command Words** という命令[^cw]を CPU から受け付けます。 "
"CW には **ICW: Initialization Command Words** と **OCW: Operation Command "
"Words** の2つがあります。 ICW は PIC を初期化するためのコマンドであり、OCW は"
"初期化後に PIC を操作するためのコマンドです。 どちらも 1byte のデータを PIC "
"に送信することで実行されます。 以降は CW に送信する 1byte のうち、N-th bit "
"を `D[N]` と表記します。"

#: src/kernel/pic.md:83
msgid "ICW"
msgstr "ICW"

#: src/kernel/pic.md:85
msgid ""
"ICW は PIC を初期化するためのコマンドです。 一度初期化シーケンスに入ると、続"
"く CW は ICW として解釈されます。 以下の 4 つのコマンドシーケンスからなり、そ"
"れぞれが設定項目を決定します。 一応(ほぼ)全ての設定項目を書いていますが、"
"Ymir で利用するのはごく一部です。"
msgstr ""
"ICW は PIC を初期化するためのコマンドです。 一度初期化シーケンスに入ると、続"
"く CW は ICW として解釈されます。 以下の 4 つのコマンドシーケンスからなり、そ"
"れぞれが設定項目を決定します。 一応(ほぼ)全ての設定項目を書いていますが、"
"Ymir で利用するのはごく一部です。"

#: src/kernel/pic.md:90
msgid "ICW1"
msgstr "ICW1"

#: src/kernel/pic.md:92
msgid ""
"PIC を初期化モードにする。`D[4]` が `1` の場合、ICW1として解釈される。 以下の"
"設定をする:"
msgstr ""
"PIC を初期化モードにする。`D[4]` が `1` の場合、ICW1として解釈される。 以下の"
"設定をする:"

#: src/kernel/pic.md:95
msgid "ICW4 が必要かどうか"
msgstr "ICW4 が必要かどうか"

#: src/kernel/pic.md:96
msgid "シングルモードかカスケードモードか (PICが1つか2つか)"
msgstr "シングルモードかカスケードモードか (PICが1つか2つか)"

#: src/kernel/pic.md:97
msgid "レベルトリガかエッジトリガか"
msgstr "レベルトリガかエッジトリガか"

#: src/kernel/pic.md:99
msgid "ICW2"
msgstr "ICW2"

#: src/kernel/pic.md:101
msgid ""
"ICW1 に続く CW は ICW2 として解釈される。 CPU に通知される割り込み番号と IRQ "
"のオフセットを設定する。 ここに `0x20` を設定した場合、IRQ1 は割り込みベクタ "
"`0x21`、IRQ2 はベクタ `0x22`... のように CPU から通知される。"
msgstr ""
"ICW1 に続く CW は ICW2 として解釈される。 CPU に通知される割り込み番号と IRQ "
"のオフセットを設定する。 ここに `0x20` を設定した場合、IRQ1 は割り込みベクタ "
"`0x21`、IRQ2 はベクタ `0x22`... のように CPU から通知される。"

#: src/kernel/pic.md:105
msgid "ICW3"
msgstr "ICW3"

#: src/kernel/pic.md:107
msgid ""
"ICW2 に続く CW は ICW3 として解釈される。 Primay PIC に対して送信する場合は、"
"各 IRQ が Secondary にカスケードされているかどうかをビットマップで設定する。 "
"Secondary PIC に対して送信する場合は、カスケードされている Primary PIC の "
"_Cascade ID_ を設定する。"
msgstr ""
"ICW2 に続く CW は ICW3 として解釈される。 Primay PIC に対して送信する場合は、"
"各 IRQ が Secondary にカスケードされているかどうかをビットマップで設定する。 "
"Secondary PIC に対して送信する場合は、カスケードされている Primary PIC の "
"_Cascade ID_ を設定する。"

#: src/kernel/pic.md:111
msgid "ICW4"
msgstr "ICW4"

#: src/kernel/pic.md:113
msgid "ICW3 に続く CW は ICW4 として解釈される。 以下の設定をする:"
msgstr "ICW3 に続く CW は ICW4 として解釈される。 以下の設定をする:"

#: src/kernel/pic.md:116
msgid "モード: 8086/8088 モードか MCS-80/85 モードか"
msgstr "モード: 8086/8088 モードか MCS-80/85 モードか"

#: src/kernel/pic.md:117
msgid "EOI: Auto-EOI か Normal EOI か (EOI については後述)"
msgstr "EOI: Auto-EOI か Normal EOI か (EOI については後述)"

#: src/kernel/pic.md:118
msgid "バッファリングモード"
msgstr "バッファリングモード"

#: src/kernel/pic.md:119
msgid "ネストモード"
msgstr "ネストモード"

#: src/kernel/pic.md:121
msgid "OCW"
msgstr "OCW"

#: src/kernel/pic.md:123
msgid "PIC の初期化後に PIC の状態を設定したりするコマンドを発行します。"
msgstr "PIC の初期化後に PIC の状態を設定したりするコマンドを発行します。"

#: src/kernel/pic.md:125
msgid "OCW1"
msgstr "OCW1"

#: src/kernel/pic.md:127
msgid "IMR を設定する。 IMR の各ビットは対応する IRQ をマスクする。"
msgstr "IMR を設定する。 IMR の各ビットは対応する IRQ をマスクする。"

#: src/kernel/pic.md:130
msgid "OCW2"
msgstr "OCW2"

#: src/kernel/pic.md:132
msgid "以下のコマンドを実行する:"
msgstr "以下のコマンドを実行する:"

#: src/kernel/pic.md:134
msgid "EOI: 後述"
msgstr "EOI: 後述"

#: src/kernel/pic.md:135
msgid "Rotate: 優先度回転する。低い優先度の IRQ から処理されるようにする"
msgstr "Rotate: 優先度回転する。低い優先度の IRQ から処理されるようにする"

#: src/kernel/pic.md:136
msgid "Set: 優先度の設定をする"
msgstr "Set: 優先度の設定をする"

#: src/kernel/pic.md:138
msgid "OCW3"
msgstr "OCW3"

#: src/kernel/pic.md:140
msgid "基本的には IRR/ISR の値を読み出すために使われる。"
msgstr "基本的には IRR/ISR の値を読み出すために使われる。"

#: src/kernel/pic.md:142
msgid "PIC の初期化"
msgstr "PIC の初期化"

#: src/kernel/pic.md:144
msgid ""
"以上の知識を踏まえて、PIC を初期化していきます。 x64 では Primary PIC と "
"Secondary PIC のそれぞれに対して Command Port と Data Port が用意されています"
"[^port]。 各 I/O ポートは以下のとおりです:"
msgstr ""
"以上の知識を踏まえて、PIC を初期化していきます。 x64 では Primary PIC と "
"Secondary PIC のそれぞれに対して Command Port と Data Port が用意されています"
"[^port]。 各 I/O ポートは以下のとおりです:"

#: src/kernel/pic.md:156
msgid "まずは ICW を定義します:"
msgstr "まずは ICW を定義します:"

#: src/kernel/pic.md:205
msgid ""
"`Icw` は [Tagged Union](https://ziglang.org/documentation/master/#Tagged-"
"union) です。 C の共用体のように、`union` は active なフィールドを常に1つ持ち"
"ます。 もしも active でないフィールドに対してアクセスした場合には、`Debug`ビ"
"ルドならランタイムエラーに、それ以外なら UD になります。"
msgstr ""
"`Icw` は [Tagged Union](https://ziglang.org/documentation/master/#Tagged-"
"union) です。 C の共用体のように、`union` は active なフィールドを常に1つ持ち"
"ます。 もしも active でないフィールドに対してアクセスした場合には、`Debug`ビ"
"ルドならランタイムエラーに、それ以外なら UD になります。"

#: src/kernel/pic.md:209
msgid "同様に OCW も定義します:"
msgstr "同様に OCW も定義します:"

#: src/kernel/pic.md:254
msgid ""
"なお ICW でも OCW でも、ハードウェア的に固定値であるフィールドや Ymir で使わ"
"ないフィールドはデフォルト値を設定しています。"
msgstr ""
"なお ICW でも OCW でも、ハードウェア的に固定値であるフィールドや Ymir で使わ"
"ないフィールドはデフォルト値を設定しています。"

#: src/kernel/pic.md:256
msgid ""
"続いて、これらの CW を PIC に対して発行するためのヘルパー関数を定義します:"
msgstr ""
"続いて、これらの CW を PIC に対して発行するためのヘルパー関数を定義します:"

#: src/kernel/pic.md:274
msgid ""
"`issue()` は `Icw` か `Ocw` のみを受け付けることを保証しています。 `union` に"
"対する `switch` は、active なフィールドに応じて処理を変更させることができま"
"す。 今回はどのフィールドに対しても同様に `@bitCast()` して [OUTB](https://"
"www.felixcloutier.com/x86/out) を実行したいです。 そのため、`inline else` に"
"よって無条件に `union` の中身のフィールドを取り出しています。"
msgstr ""
"`issue()` は `Icw` か `Ocw` のみを受け付けることを保証しています。 `union` に"
"対する `switch` は、active なフィールドに応じて処理を変更させることができま"
"す。 今回はどのフィールドに対しても同様に `@bitCast()` して [OUTB](https://"
"www.felixcloutier.com/x86/out) を実行したいです。 そのため、`inline else` に"
"よって無条件に `union` の中身のフィールドを取り出しています。"

#: src/kernel/pic.md:279
msgid "この関数を使うと、PIC の初期化関数は簡単に書けます:"
msgstr "この関数を使うと、PIC の初期化関数は簡単に書けます:"

#: src/kernel/pic.md:317
msgid ""
"今のところ IRQ 用の割り込みハンドラを用意していないため、IRQ から割り込みが発"
"生すると割り込みハンドラとして`unhandledHandler()` が呼び出されてしまいま"
"す。 これを避けるため、まず最初に割り込みを無効化しておきます。 無効化した割"
"り込みは `init()` から戻るときに再び有効化したいです。 このような RAII パター"
"ンは、Zig では [defer](https://ziglang.org/documentation/master/#defer) を使"
"うことで実現できます。"
msgstr ""
"今のところ IRQ 用の割り込みハンドラを用意していないため、IRQ から割り込みが発"
"生すると割り込みハンドラとして`unhandledHandler()` が呼び出されてしまいま"
"す。 これを避けるため、まず最初に割り込みを無効化しておきます。 無効化した割"
"り込みは `init()` から戻るときに再び有効化したいです。 このような RAII パター"
"ンは、Zig では [defer](https://ziglang.org/documentation/master/#defer) を使"
"うことで実現できます。"

#: src/kernel/pic.md:322
msgid ""
"コマンドは先ほど定義した `Icw` のうちデフォルト値がセットされていないものを設"
"定しながら使っています。 ICW1 では ICW4 が必要であることを示しています。 "
"ICW2 では IRQ と割り込みベクタのオフセットを設定しています。これについては後"
"述します。 ICW3 では Primary/Secondary PIC の接続関係を設定しています。 "
"8259A では IRQ2 に Secondary PIC が接続されているため、Primary PIC には "
"`0b100 == 4` を指定しています。 ICW4 では Normal EOI を指定しています。EOI に"
"ついても後述します。"
msgstr ""
"コマンドは先ほど定義した `Icw` のうちデフォルト値がセットされていないものを設"
"定しながら使っています。 ICW1 では ICW4 が必要であることを示しています。 "
"ICW2 では IRQ と割り込みベクタのオフセットを設定しています。これについては後"
"述します。 ICW3 では Primary/Secondary PIC の接続関係を設定しています。 "
"8259A では IRQ2 に Secondary PIC が接続されているため、Primary PIC には "
"`0b100 == 4` を指定しています。 ICW4 では Normal EOI を指定しています。EOI に"
"ついても後述します。"

#: src/kernel/pic.md:329
msgid "Vector Offset"
msgstr "Vector Offset"

#: src/kernel/pic.md:331
msgid ""
"IRQ-N は、デフォルトで N 番目の割り込みベクタを発生させます。 Real Mode にお"
"いてはこれで問題ないのですが、Protected Mode においてはベクタの `0` から "
"`31` までは Intel が予約しています。 見事に衝突していますね。IBM さんやってし"
"まいました。"
msgstr ""
"IRQ-N は、デフォルトで N 番目の割り込みベクタを発生させます。 Real Mode にお"
"いてはこれで問題ないのですが、Protected Mode においてはベクタの `0` から "
"`31` までは Intel が予約しています。 見事に衝突していますね。IBM さんやってし"
"まいました。"

#: src/kernel/pic.md:335
msgid ""
"仕方がないので、Linux を含むほとんどの OS は IRQ からの割り込みベクタを他のベ"
"クタに **リマップ** しています。 Ymir では、Primary PIC と Secondary PIC に対"
"してそれぞれ `32` と `40` をオフセットとして設定しています。 これにより、IRQ-"
"N は `32 + N` 番目の割り込みベクタを発生させるようになります。 このオフセット"
"の指定は ICW2 によって行います。"
msgstr ""
"仕方がないので、Linux を含むほとんどの OS は IRQ からの割り込みベクタを他のベ"
"クタに **リマップ** しています。 Ymir では、Primary PIC と Secondary PIC に対"
"してそれぞれ `32` と `40` をオフセットとして設定しています。 これにより、IRQ-"
"N は `32 + N` 番目の割り込みベクタを発生させるようになります。 このオフセット"
"の指定は ICW2 によって行います。"

#: src/kernel/pic.md:340
msgid "EOI"
msgstr "EOI"

#: src/kernel/pic.md:342
msgid ""
"**EOI: End of Interrupt** は PIC に対してさらなる割り込みの送信を許可するため"
"の通知です。 EOI には以下の2つのモードがあり、ICW4 で設定できます:"
msgstr ""
"**EOI: End of Interrupt** は PIC に対してさらなる割り込みの送信を許可するため"
"の通知です。 EOI には以下の2つのモードがあり、ICW4 で設定できます:"

#: src/kernel/pic.md:345
msgid ""
"**Automatic EOI**: PIC が CPU に対して割り込みを通知し、CPU から最後の \\"
"\\( \\overline{INTA} \\\\) 信号を受け取ると自動的に EOI を受理したものとしま"
"す。"
msgstr ""
"**Automatic EOI**: PIC が CPU に対して割り込みを通知し、CPU から最後の \\"
"\\( \\overline{INTA} \\\\) 信号を受け取ると自動的に EOI を受理したものとしま"
"す。"

#: src/kernel/pic.md:346
msgid "**Normal EOI**: CPU が明示的に EOI コマンドを送信します。"
msgstr "**Normal EOI**: CPU が明示的に EOI コマンドを送信します。"

#: src/kernel/pic.md:348
msgid ""
"Ymir では Normal EOI を採用します。 Normal EOI では、通知の種類が2つあります:"
msgstr ""
"Ymir では Normal EOI を採用します。 Normal EOI では、通知の種類が2つあります:"

#: src/kernel/pic.md:351
msgid "**Specific EOI**: 特定の IRQ に対して EOI を送信します。"
msgstr "**Specific EOI**: 特定の IRQ に対して EOI を送信します。"

#: src/kernel/pic.md:352
msgid ""
"**Non-Specific EOI**: IRQ 番号を指定せず、最も優先度の高い IRQ が自動的に選択"
"されます。"
msgstr ""
"**Non-Specific EOI**: IRQ 番号を指定せず、最も優先度の高い IRQ が自動的に選択"
"されます。"

#: src/kernel/pic.md:354
msgid ""
"Ymir では Specific EOI を採用します。 Specific EOI は OCW2 によって送信されま"
"す。 この際、3bit の `level` フィールドで IRQ 番号を指定します。 指定した "
"IRQ は ISR からクリアされます。"
msgstr ""
"Ymir では Specific EOI を採用します。 Specific EOI は OCW2 によって送信されま"
"す。 この際、3bit の `level` フィールドで IRQ 番号を指定します。 指定した "
"IRQ は ISR からクリアされます。"

#: src/kernel/pic.md:359
msgid ""
"処理中の割り込みが Secondary PIC に属する IRQ8~IRQ15 である場合、EOI は "
"Primary PIC と Secondary PIC の両方に送信する必要はあります。 Primary PIC に"
"対しては Secondary がカスケードされた IRQ2 に対して EOI を送信します。"
msgstr ""
"処理中の割り込みが Secondary PIC に属する IRQ8~IRQ15 である場合、EOI は "
"Primary PIC と Secondary PIC の両方に送信する必要はあります。 Primary PIC に"
"対しては Secondary がカスケードされた IRQ2 に対して EOI を送信します。"

#: src/kernel/pic.md:362
msgid "ヘルパーの実装"
msgstr "ヘルパーの実装"

#: src/kernel/pic.md:364
msgid ""
"PIC の初期化はできました。 続いて、他のファイルから PIC を操作するためのヘル"
"パー関数を実装します。"
msgstr ""
"PIC の初期化はできました。 続いて、他のファイルから PIC を操作するためのヘル"
"パー関数を実装します。"

#: src/kernel/pic.md:367
msgid "まずは IRQ に対応する `enum` を定義します:"
msgstr "まずは IRQ に対応する `enum` を定義します:"

#: src/kernel/pic.md:411
msgid ""
"IRQ 番号を扱う際には、Primary と Secondary を合わせた連番 (`0`\\-`15`) ではな"
"く、 各 PIC における連番 (`0`\\-`7`) として扱いたいことが多々あります。 "
"`delta()` は、Primary に対してはそのままの値を返し、Secondary に対しては `8` "
"を引いた値を返します。"
msgstr ""
"IRQ 番号を扱う際には、Primary と Secondary を合わせた連番 (`0`\\-`15`) ではな"
"く、 各 PIC における連番 (`0`\\-`7`) として扱いたいことが多々あります。 "
"`delta()` は、Primary に対してはそのままの値を返し、Secondary に対しては `8` "
"を引いた値を返します。"

#: src/kernel/pic.md:415
msgid "`IrqLine` を指定して対応する IMR (マスク)を設定する関数を定義します:"
msgstr "`IrqLine` を指定して対応する IMR (マスク)を設定する関数を定義します:"

#: src/kernel/pic.md:430
msgid ""
"IMR は各 PIC がそれぞれ持っており、IRQ の `0-7` と `8-15` はそれぞれ分けて設"
"定する必要があります。 先ほど用意したヘルパー関数を利用することで、Primary/"
"Secondary 用のポート指定が簡単にできていますね。"
msgstr ""
"IMR は各 PIC がそれぞれ持っており、IRQ の `0-7` と `8-15` はそれぞれ分けて設"
"定する必要があります。 先ほど用意したヘルパー関数を利用することで、Primary/"
"Secondary 用のポート指定が簡単にできていますね。"

#: src/kernel/pic.md:433
msgid "最後に、指定した `IrqLine` に対して EOI を通知する関数を定義します:"
msgstr "最後に、指定した `IrqLine` に対して EOI を通知する関数を定義します:"

#: src/kernel/pic.md:451
msgid ""
"前述したように Secondary に対する EOI は Primary/Secondary の両方に送信する必"
"要があります。 よって、先ほど用意した `isPrimary()` を使って分岐しています。"
msgstr ""
"前述したように Secondary に対する EOI は Primary/Secondary の両方に送信する必"
"要があります。 よって、先ほど用意した `isPrimary()` を使って分岐しています。"

#: src/kernel/pic.md:454
msgid "割り込みのアンマスク"
msgstr "割り込みのアンマスク"

#: src/kernel/pic.md:456
msgid ""
"`kernelMain()` から PIC の初期化を実行しましょう (`arch.zig` において `pic."
"zig` を export するのを忘れずに):"
msgstr ""
"`kernelMain()` から PIC の初期化を実行しましょう (`arch.zig` において `pic."
"zig` を export するのを忘れずに):"

#: src/kernel/pic.md:464
msgid ""
"これで PIC の初期化が完了しました。 ただし、実行したところで前回までと何も変"
"わりません。 なにせまだ全ての IRQ は IMR でマスクされてるため、どんな IRQ も"
"割り込みを発生させません。 本チャプターの締めくくりとして、シリアルの割り込み"
"を有効化してみます。"
msgstr ""
"これで PIC の初期化が完了しました。 ただし、実行したところで前回までと何も変"
"わりません。 なにせまだ全ての IRQ は IMR でマスクされてるため、どんな IRQ も"
"割り込みを発生させません。 本チャプターの締めくくりとして、シリアルの割り込み"
"を有効化してみます。"

#: src/kernel/pic.md:469
msgid ""
"まず、シリアル用の割り込みハンドラを定義します。 とはいっても、Ymir 自体は入"
"力を受け付けて処理するような機能は実装しません。 そのため、とりあえずログだけ"
"出力したあと EOI を送信するだけの割り込みハンドラを用意します:"
msgstr ""
"まず、シリアル用の割り込みハンドラを定義します。 とはいっても、Ymir 自体は入"
"力を受け付けて処理するような機能は実装しません。 そのため、とりあえずログだけ"
"出力したあと EOI を送信するだけの割り込みハンドラを用意します:"

#: src/kernel/pic.md:482
msgid ""
"[割り込みと例外](./interrupt.md) で実装したように、割り込みハンドラは "
"`Context`  というコンテキスト情報を受けとります。 この中には割り込みベクタも"
"入っています。 IRQ の番号を取得するには、割り込みベクタから ICW2 で設定したオ"
"フセットを引くだけです。 算出した IRQ の番号を出力したあと、`notifyEoi()` で "
"EOI を送信します。"
msgstr ""
"[割り込みと例外](./interrupt.md) で実装したように、割り込みハンドラは "
"`Context`  というコンテキスト情報を受けとります。 この中には割り込みベクタも"
"入っています。 IRQ の番号を取得するには、割り込みベクタから ICW2 で設定したオ"
"フセットを引くだけです。 算出した IRQ の番号を出力したあと、`notifyEoi()` で "
"EOI を送信します。"

#: src/kernel/pic.md:487
msgid ""
"続いて、この割り込みハンドラを登録します。 そういえば割り込みハンドラを登録す"
"る関数を実装していなかったため、ここで実装しておきます:"
msgstr ""
"続いて、この割り込みハンドラを登録します。 そういえば割り込みハンドラを登録す"
"る関数を実装していなかったため、ここで実装しておきます:"

#: src/kernel/pic.md:502
msgid ""
"`kernelMain()` で割り込みハンドラを登録し、PIC にシリアルの割り込みマスクを外"
"すように指示します:"
msgstr ""
"`kernelMain()` で割り込みハンドラを登録し、PIC にシリアルの割り込みマスクを外"
"すように指示します:"

#: src/kernel/pic.md:510
msgid ""
"これで準備万端と思いきや、これでもまだ割り込みは発生しません。 シリアル自体に"
"割り込みを発生させるように設定してあげる必要があります。 シリアルの **IER: "
"Interrupt Enable Register** に対して `0b01` という値を書き込むことで、Rx-"
"available または TX-available な状態になった時に割り込みを発生させることがで"
"きます。 TX-available は、シリアル出力が完了し、出力バッファに新しいデータを"
"書き込める状態になった場合に発生します。 Rx-available は、シリアル入力がバッ"
"ファから読み取り可能な状態になった場合に発生します:"
msgstr ""
"これで準備万端と思いきや、これでもまだ割り込みは発生しません。 シリアル自体に"
"割り込みを発生させるように設定してあげる必要があります。 シリアルの **IER: "
"Interrupt Enable Register** に対して `0b01` という値を書き込むことで、Rx-"
"available または TX-available な状態になった時に割り込みを発生させることがで"
"きます。 TX-available は、シリアル出力が完了し、出力バッファに新しいデータを"
"書き込める状態になった場合に発生します。 Rx-available は、シリアル入力がバッ"
"ファから読み取り可能な状態になった場合に発生します:"

#: src/kernel/pic.md:526
msgid "`idefs` は、`interrupts.zig` のインポートです:"
msgstr "`idefs` は、`interrupts.zig` のインポートです:"

#: src/kernel/pic.md:539
msgid ""
"なお、IER の 1-th bit をクリアしているのは無限割り込みを防ぐためです。 Tx-"
"empty は、シリアル出力しようとしたデータが実際に送信され、出力バッファに他の"
"データを書き込める状態になった時に発生します。 しかし、割り込みハンドラの中で"
"さらにシリアルログ出力をしており、これがまた Tx-empty を発生させます。 永遠"
"に TX-empty → シリアルログ出力 → TX-empty → ... というループが発生してしまう"
"ため、この割り込みは無効化しておきます。"
msgstr ""
"なお、IER の 1-th bit をクリアしているのは無限割り込みを防ぐためです。 Tx-"
"empty は、シリアル出力しようとしたデータが実際に送信され、出力バッファに他の"
"データを書き込める状態になった時に発生します。 しかし、割り込みハンドラの中で"
"さらにシリアルログ出力をしており、これがまた Tx-empty を発生させます。 永遠"
"に TX-empty → シリアルログ出力 → TX-empty → ... というループが発生してしまう"
"ため、この割り込みは無効化しておきます。"

#: src/kernel/pic.md:544
msgid "これでシリアルの割り込みが有効化されました。 実際に実行してみましょう:"
msgstr "これでシリアルの割り込みが有効化されました。 実際に実行してみましょう:"

#: src/kernel/pic.md:559
msgid ""
"`Initialized PIC` という表示の後に適当なキーを押すと、`IRQ: 4` という表示が出"
"力されました。 しっかりとシリアルの割り込みが発生していることがわかります。 "
"PIC の設定がちゃんとできていることの証拠ですね。"
msgstr ""
"`Initialized PIC` という表示の後に適当なキーを押すと、`IRQ: 4` という表示が出"
"力されました。 しっかりとシリアルの割り込みが発生していることがわかります。 "
"PIC の設定がちゃんとできていることの証拠ですね。"

#: src/kernel/pic.md:563
msgid ""
"なお、`enableInterrupt()` で設定した IER ですが、Tx-empty の無効化はコードか"
"ら消して、逆に有効化するようにしておいてください。 本シリーズでは Ymir が "
"CPU を仮想化する際、シリアルへの操作はすべて仮想化します。 その際、IER は固定"
"で Tx-empty と Rx-available だけを有効化しておくように仮想化し、ゲストには触"
"らせないようにする予定です。 そのため、IER はあらかじめホストである Ymir が設"
"定しておく必要があるというわけです:"
msgstr ""
"なお、`enableInterrupt()` で設定した IER ですが、Tx-empty の無効化はコードか"
"ら消して、逆に有効化するようにしておいてください。 本シリーズでは Ymir が "
"CPU を仮想化する際、シリアルへの操作はすべて仮想化します。 その際、IER は固定"
"で Tx-empty と Rx-available だけを有効化しておくように仮想化し、ゲストには触"
"らせないようにする予定です。 そのため、IER はあらかじめホストである Ymir が設"
"定しておく必要があるというわけです:"

#: src/kernel/pic.md:573
msgid ""
"また、ついでに [PIT](https://wiki.osdev.org/Programmable_Interval_Timer) もマ"
"スクだけ外しておきましょう:"
msgstr ""
"また、ついでに [PIT](https://wiki.osdev.org/Programmable_Interval_Timer) もマ"
"スクだけ外しておきましょう:"

#: src/kernel/pic.md:582
msgid ""
"PIT の設定はしていませんが、デフォルトの状態で(または UEFI が設定したおかげ"
"で)タイマーは動いているようです。 このまま実行すると `IRQ: 0` という表示が一"
"定間隔で出力され続けるはずです。"
msgstr ""
"PIT の設定はしていませんが、デフォルトの状態で(または UEFI が設定したおかげ"
"で)タイマーは動いているようです。 このまま実行すると `IRQ: 0` という表示が一"
"定間隔で出力され続けるはずです。"

#: src/kernel/pic.md:585
msgid ""
"最後に、タイマーもシリアルも割り込みハンドラでログ出力をすると非常に鬱陶しい"
"ため `log.debug()` は削除しておいてください。"
msgstr ""
"最後に、タイマーもシリアルも割り込みハンドラでログ出力をすると非常に鬱陶しい"
"ため `log.debug()` は削除しておいてください。"

#: src/kernel/pic.md:589
msgid ""
"本チャプターでは Intel 8259A PIC の初期化と割込みの有効化をしました。 タイ"
"マーとシリアルの割り込みマスクを外し、実際に割り込みハンドラが呼ばれることを"
"確認しました。 Ymir では直接 IRQ をハンドルすることはありませんが、ゲストに対"
"して PIC の一部を仮想化する上でもホスト側での PIC の設定は必要です。"
msgstr ""
"本チャプターでは Intel 8259A PIC の初期化と割込みの有効化をしました。 タイ"
"マーとシリアルの割り込みマスクを外し、実際に割り込みハンドラが呼ばれることを"
"確認しました。 Ymir では直接 IRQ をハンドルすることはありませんが、ゲストに対"
"して PIC の一部を仮想化する上でもホスト側での PIC の設定は必要です。"

#: src/kernel/pic.md:593
msgid ""
"そして！ 本チャプターで Ymir Kernel 部分の実装は完了になります！ Writing "
"Hypervisor というタイトルなのにも関わらず、hypervisor にあまり関係ない部分が"
"多くなってしまいました。 しかし、ベアメタルな hypervisor を書くということは、"
"まずはベアメタルな OS を書くことから始まります。 今回までで OS という下地を作"
"ることができたので、次回からはいよいよ hypervisor の章に入っていこうと思いま"
"す。 今日は温かくして早めに寝てください。"
msgstr ""
"そして！ 本チャプターで Ymir Kernel 部分の実装は完了になります！ Writing "
"Hypervisor というタイトルなのにも関わらず、hypervisor にあまり関係ない部分が"
"多くなってしまいました。 しかし、ベアメタルな hypervisor を書くということは、"
"まずはベアメタルな OS を書くことから始まります。 今回までで OS という下地を作"
"ることができたので、次回からはいよいよ hypervisor の章に入っていこうと思いま"
"す。 今日は温かくして早めに寝てください。"

#: src/kernel/pic.md:602
msgid ""
"[8259A PROGRAMMABLE INTERRUPT CONTROLLER (8259A/8259A-2) - Intel](https://"
"pdos.csail.mit.edu/6.828/2014/readings/hardware/8259A.pdf)"
msgstr ""
"[8259A PROGRAMMABLE INTERRUPT CONTROLLER (8259A/8259A-2) - Intel](https://"
"pdos.csail.mit.edu/6.828/2014/readings/hardware/8259A.pdf)"

#: src/kernel/pic.md:603
msgid "[8259 PIC - OSDev Wiki](https://wiki.osdev.org/8259_PIC)"
msgstr "[8259 PIC - OSDev Wiki](https://wiki.osdev.org/8259_PIC)"

#: src/kernel/pic.md:604
msgid ""
"[パソコンのレガシィI/O活用大全 - 桑野 雅彦](https://www.cqpub.co.jp/column/"
"books/2001a/34331pc_legacy/default.htm)"
msgstr ""
"[パソコンのレガシィI/O活用大全 - 桑野 雅彦](https://www.cqpub.co.jp/column/"
"books/2001a/34331pc_legacy/default.htm)"

#: src/kernel/pic.md:606
msgid ""
"実際には、CPU が割り込みを受理して \\\\( \\overline{INTA} \\\\) 信号を送信し "
"ISR がセットされたあと、CPU は追加で \\\\( \\overline{INTA} \\\\) 信号を送信"
"してきます。 これにより、PIC は処理対象にした割り込みのベクタ番号を **Data "
"Bus Buffer** と呼ばれるバッファにセットします。 Auto-EOI が有効な場合、この時"
"点で ISR がクリアされます。"
msgstr ""
"実際には、CPU が割り込みを受理して \\\\( \\overline{INTA} \\\\) 信号を送信し "
"ISR がセットされたあと、CPU は追加で \\\\( \\overline{INTA} \\\\) 信号を送信"
"してきます。 これにより、PIC は処理対象にした割り込みのベクタ番号を **Data "
"Bus Buffer** と呼ばれるバッファにセットします。 Auto-EOI が有効な場合、この時"
"点で ISR がクリアされます。"

#: src/kernel/pic.md:609
msgid ""
"Command Words は命令というよりレジスタと解釈してもいいかもしれません。 ただし"
"通常の I/O mapped register とは異なり、同じI/Oポートに書き込んでも状況によっ"
"てどの CW に書き込むかどうかが変わることに注意してください。"
msgstr ""
"Command Words は命令というよりレジスタと解釈してもいいかもしれません。 ただし"
"通常の I/O mapped register とは異なり、同じI/Oポートに書き込んでも状況によっ"
"てどの CW に書き込むかどうかが変わることに注意してください。"

#: src/kernel/pic.md:611
msgid ""
"Command Port 経由で送信すると \\\\( A_0 \\\\) が `0` に、Data Port 経由で送信"
"すると `1` になるようです。"
msgstr ""
"Command Port 経由で送信すると \\\\( A_0 \\\\) が `0` に、Data Port 経由で送信"
"すると `1` になるようです。"

#: src/vmm/vmx_root.md:1
msgid "VT-x の基礎と VMX Root Operation"
msgstr "VT-x の基礎と VMX Root Operation"

#: src/vmm/vmx_root.md:3
msgid ""
"長かった Ymir Kernel の実装も一段落し、いよいよ VMM 部分の実装に入っていきま"
"す。 本チャプターは VT-x の基礎的な概念の説明から始まり、VMX Root Operation "
"という VMM 用のモードに遷移するところまでを目的にします。"
msgstr ""
"長かった Ymir Kernel の実装も一段落し、いよいよ VMM 部分の実装に入っていきま"
"す。 本チャプターは VT-x の基礎的な概念の説明から始まり、VMX Root Operation "
"という VMM 用のモードに遷移するところまでを目的にします。"

#: src/vmm/vmx_root.md:8
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-vmx_root`](https://"
#| "github.com/smallkirby/ymir/tree/whiz-vmm-vmx_root) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-vmm-vmx_root`](https://github.com/"
"smallkirby/ymir/tree/whiz-vmm-vmx_root) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-vmx_root`](https://"
"github.com/smallkirby/ymir/tree/whiz-vmm-vmx_root) ブランチにあります。"

#: src/vmm/vmx_root.md:12
msgid "[VMM 概観](#vmm-概観)"
msgstr "[VMM 概観](#vmm-概観)"

#: src/vmm/vmx_root.md:13
msgid "[VMX サポートの確認](#vmx-サポートの確認)"
msgstr "[VMX サポートの確認](#vmx-サポートの確認)"

#: src/vmm/vmx_root.md:14
msgid "[CPUID](#cpuid)"
msgstr "[CPUID](#cpuid)"

#: src/vmm/vmx_root.md:15 src/vmm/vmlaunch.md:21
msgid "[MSR](#msr)"
msgstr "[MSR](#msr)"

#: src/vmm/vmx_root.md:16
msgid "[Vendor ID の確認](#vendor-id-の確認)"
msgstr "[Vendor ID の確認](#vendor-id-の確認)"

#: src/vmm/vmx_root.md:17
msgid "[VMX サポートを確認](#vmx-サポートを確認)"
msgstr "[VMX サポートを確認](#vmx-サポートを確認)"

#: src/vmm/vmx_root.md:18
msgid "[vCPU](#vcpu)"
msgstr "[vCPU](#vcpu)"

#: src/vmm/vmx_root.md:19
msgid "[VMX Operation への遷移](#vmx-operation-への遷移)"
msgstr "[VMX Operation への遷移](#vmx-operation-への遷移)"

#: src/vmm/vmx_root.md:20
msgid "[CR レジスタの設定](#cr-レジスタの設定)"
msgstr "[CR レジスタの設定](#cr-レジスタの設定)"

#: src/vmm/vmx_root.md:21
msgid "[VMXON](#vmxon)"
msgstr "[VMXON](#vmxon)"

#: src/vmm/vmx_root.md:22 src/vmm/vmcs.md:24
msgid "[VMX Instruction Error](#vmx-instruction-error)"
msgstr "[VMX Instruction Error](#vmx-instruction-error)"

#: src/vmm/vmx_root.md:23
msgid ""
"[VMX Root Operation に遷移できたことの確認](#vmx-root-operation-に遷移できた"
"ことの確認)"
msgstr ""
"[VMX Root Operation に遷移できたことの確認](#vmx-root-operation-に遷移できた"
"ことの確認)"

#: src/vmm/vmx_root.md:26
msgid "VMM 概観"
msgstr "VMM 概観"

#: src/vmm/vmx_root.md:28
msgid ""
"まずは Hypervisor における基礎的な概念や用語を確認します。 以降は、Ymir のよ"
"うにベアメタルで動作し CPU や外部リソースに対する完全な制御権を持つソフトを "
"**VMM: Virtual-Machine Monitor** (hypervisor) と呼びます。 VMM の上で動作し、"
"CPU 上で直接動作するものの VMM によってリソースへのアクセス権など仮想化される"
"ソフトを **ゲスト** と呼びます。"
msgstr ""
"まずは Hypervisor における基礎的な概念や用語を確認します。 以降は、Ymir のよ"
"うにベアメタルで動作し CPU や外部リソースに対する完全な制御権を持つソフトを "
"**VMM: Virtual-Machine Monitor** (hypervisor) と呼びます。 VMM の上で動作し、"
"CPU 上で直接動作するものの VMM によってリソースへのアクセス権など仮想化される"
"ソフトを **ゲスト** と呼びます。"

#: src/vmm/vmx_root.md:32
msgid ""
"仮想化を支援する Intel CPU では、**VMX Operation** というモードに入ることがで"
"きます。 このモードでは仮想化を支援する命令が追加されたり、CPU の挙動が変更さ"
"れたりします。 VMX Operation には **VMX Root Operation** と **VMX Non-root "
"Operation** の2つのモードがあります。 VMM は VMX Root Operation で動作しま"
"す。 このモードは VMX Operation ではない場合とほぼ同じですが、新たに VMX に関"
"連する命令が追加されています。 ゲストは VMX Non-root Operation で動作しま"
"す。 このモードでは一部の特権命令が制限され、それらの命令を実行すると処理が "
"VMM に移されます。 このような、VMX Non-root から VMX Root へのモード遷移を "
"**VM Exit** と呼び、 逆に VMX Root から VMX Non-root へのモード遷移を **VM "
"Entry** と呼びます。 両者をまとめて **VMX Transition** と呼ぶことがありま"
"す。 特権命令が VM Exit を引き起こすことで、VMM はゲストの挙動に介入し、リ"
"ソースを仮想化できます。"
msgstr ""
"仮想化を支援する Intel CPU では、**VMX Operation** というモードに入ることがで"
"きます。 このモードでは仮想化を支援する命令が追加されたり、CPU の挙動が変更さ"
"れたりします。 VMX Operation には **VMX Root Operation** と **VMX Non-root "
"Operation** の2つのモードがあります。 VMM は VMX Root Operation で動作しま"
"す。 このモードは VMX Operation ではない場合とほぼ同じですが、新たに VMX に関"
"連する命令が追加されています。 ゲストは VMX Non-root Operation で動作しま"
"す。 このモードでは一部の特権命令が制限され、それらの命令を実行すると処理が "
"VMM に移されます。 このような、VMX Non-root から VMX Root へのモード遷移を "
"**VM Exit** と呼び、 逆に VMX Root から VMX Non-root へのモード遷移を **VM "
"Entry** と呼びます。 両者をまとめて **VMX Transition** と呼ぶことがありま"
"す。 特権命令が VM Exit を引き起こすことで、VMM はゲストの挙動に介入し、リ"
"ソースを仮想化できます。"

#: src/vmm/vmx_root.md:44
msgid ""
"![Interaction of a Virtual-Machine Monitor and Guests](../assets/sdm/"
"interaction_vmm.png) _Interaction of a Virtual-Machine Monitor and Guests. "
"SDM Vol.3C 24.4 Figure 24-1._"
msgstr ""
"![Interaction of a Virtual-Machine Monitor and Guests](../assets/sdm/"
"interaction_vmm.png) _Interaction of a Virtual-Machine Monitor and Guests. "
"SDM Vol.3C 24.4 Figure 24-1._"

#: src/vmm/vmx_root.md:47
msgid ""
"Ymir Kernel は [VMXON](https://www.felixcloutier.com/x86/vmxon) 命令によって "
"VMX Root Operation に遷移します。 逆に VMX Root Operation から通常のモードに"
"遷移する際には [VMXOFF](https://www.felixcloutier.com/x86/vmxoff) 命令を使用"
"します。 VMX Operation に遷移した CPU は新たに拡張命令である **VMX "
"Instructions** を利用できるようになります。 その1つである [VMLAUNCH](https://"
"www.felixcloutier.com/x86/vmlaunch:vmresume) や [VMRESUME](https://www."
"felixcloutier.com/x86/vmlaunch:vmresume) 命令を使用して VM Entry を行いま"
"す。 ゲスト(VMX Non-Root Operation) に遷移したあとは、基本的には通常通り CPU "
"上で直接ゲストの命令が実行できます。 ソフトウェアによる命令のエミュレーション"
"が必要ないため、VT-x によるハードウェアレベルでの仮想化はソフトウェア仮想化よ"
"りも高速になります。 ゲストが特権命令を実行したり特定の条件を満たした場合"
"[^condition]には VM Exit が発生し、Root Operation への遷移が発生します。 VMM "
"は VM Exit の発生原因をもとにして適切な処理をし、再度 VM Entry でゲストに制御"
"を戻します。"
msgstr ""
"Ymir Kernel は [VMXON](https://www.felixcloutier.com/x86/vmxon) 命令によって "
"VMX Root Operation に遷移します。 逆に VMX Root Operation から通常のモードに"
"遷移する際には [VMXOFF](https://www.felixcloutier.com/x86/vmxoff) 命令を使用"
"します。 VMX Operation に遷移した CPU は新たに拡張命令である **VMX "
"Instructions** を利用できるようになります。 その1つである [VMLAUNCH](https://"
"www.felixcloutier.com/x86/vmlaunch:vmresume) や [VMRESUME](https://www."
"felixcloutier.com/x86/vmlaunch:vmresume) 命令を使用して VM Entry を行いま"
"す。 ゲスト(VMX Non-Root Operation) に遷移したあとは、基本的には通常通り CPU "
"上で直接ゲストの命令が実行できます。 ソフトウェアによる命令のエミュレーション"
"が必要ないため、VT-x によるハードウェアレベルでの仮想化はソフトウェア仮想化よ"
"りも高速になります。 ゲストが特権命令を実行したり特定の条件を満たした場合"
"[^condition]には VM Exit が発生し、Root Operation への遷移が発生します。 VMM "
"は VM Exit の発生原因をもとにして適切な処理をし、再度 VM Entry でゲストに制御"
"を戻します。"

#: src/vmm/vmx_root.md:56
msgid ""
"なお、VMX Operation は Ring とは別の概念です。 ゲストが Ring-0 で動作している"
"場合でも VMX Non-root Operation で動作している限りは VMM による支配を受けるこ"
"とになります。"
msgstr ""
"なお、VMX Operation は Ring とは別の概念です。 ゲストが Ring-0 で動作している"
"場合でも VMX Non-root Operation で動作している限りは VMM による支配を受けるこ"
"とになります。"

#: src/vmm/vmx_root.md:59
msgid "VMX サポートの確認"
msgstr "VMX サポートの確認"

#: src/vmm/vmx_root.md:61
msgid ""
"まずは CPU が VT-x をサポートしているかどうかを確認する必要があります。 これ"
"には以下の段階を踏みます:"
msgstr ""
"まずは CPU が VT-x をサポートしているかどうかを確認する必要があります。 これ"
"には以下の段階を踏みます:"

#: src/vmm/vmx_root.md:64
msgid ""
"[CPUID](https://www.felixcloutier.com/x86/cpuid) 命令で Vendor ID を確認する"
msgstr ""
"[CPUID](https://www.felixcloutier.com/x86/cpuid) 命令で Vendor ID を確認する"

#: src/vmm/vmx_root.md:65
msgid ""
"同じ x64 アーキテクチャでもベンダが異なれば提供する仮想化支援機構が異なる"
msgstr ""
"同じ x64 アーキテクチャでもベンダが異なれば提供する仮想化支援機構が異なる"

#: src/vmm/vmx_root.md:66
msgid "Vendor ID が `GenuineIntel` であることを確認する[^genuine]"
msgstr "Vendor ID が `GenuineIntel` であることを確認する[^genuine]"

#: src/vmm/vmx_root.md:67
msgid ""
"[CPUID](https://www.felixcloutier.com/x86/cpuid) 命令で VMX がサポートされて"
"いるかを確認する"
msgstr ""
"[CPUID](https://www.felixcloutier.com/x86/cpuid) 命令で VMX がサポートされて"
"いるかを確認する"

#: src/vmm/vmx_root.md:68
msgid ""
"[CPUID](https://www.felixcloutier.com/x86/cpuid) 命令で [SMX Operation]"
"(https://www.intel.co.jp/content/www/jp/ja/content-details/315168/intel-"
"trusted-execution-technology-intel-txt-software-development-guide.html) でな"
"くとも VMXON できることを確認する"
msgstr ""
"[CPUID](https://www.felixcloutier.com/x86/cpuid) 命令で [SMX Operation]"
"(https://www.intel.co.jp/content/www/jp/ja/content-details/315168/intel-"
"trusted-execution-technology-intel-txt-software-development-guide.html) でな"
"くとも VMXON できることを確認する"

#: src/vmm/vmx_root.md:69
msgid ""
"**SMX: Safer Mode Extension** は、Intel® Trusted Execution Technology で提供"
"されるモード。Ymir では使わないため SMX の外でも VMXON できる必要がある"
msgstr ""
"**SMX: Safer Mode Extension** は、Intel® Trusted Execution Technology で提供"
"されるモード。Ymir では使わないため SMX の外でも VMXON できる必要がある"

#: src/vmm/vmx_root.md:71
msgid ""
"VMX Operation に入る前にこれらの条件が満たされているかを順に確認していきま"
"す。 以降、VMX に関連する操作は `ymir/vmx.zig` をルートとして実装していきま"
"す:"
msgstr ""
"VMX Operation に入る前にこれらの条件が満たされているかを順に確認していきま"
"す。 以降、VMX に関連する操作は `ymir/vmx.zig` をルートとして実装していきま"
"す:"

#: src/vmm/vmx_root.md:101
msgid ""
"VMX 関連の操作に入る前に、まずは [CPUID](https://www.felixcloutier.com/x86/"
"cpuid) をする関数を実装します。 CPUID はプロセッサの機能を取得するための命令"
"であり、ベンダや世代やモデルに固有な情報を得るために使用します。"
msgstr ""
"VMX 関連の操作に入る前に、まずは [CPUID](https://www.felixcloutier.com/x86/"
"cpuid) をする関数を実装します。 CPUID はプロセッサの機能を取得するための命令"
"であり、ベンダや世代やモデルに固有な情報を得るために使用します。"

#: src/vmm/vmx_root.md:104
msgid ""
"EAX で取得したい情報を指定します。一部の場合は追加で ECX も使って取得する情報"
"を指定します。 このとき、EAX のことを **Leaf**, ECX のことを **Subleaf** と呼"
"びます。 本シリーズでは、Leaf が `N` で Subleaf が `M` の CPUID を `CPUID[N:"
"M]` と表記します。 返り値には EAX, EBX, ECX, EDX の4つのレジスタが使われま"
"す。 どのレジスタにどのような情報が入るかは、指定した Leaf/Subleaf に依存しま"
"す。 CPUID の Leaf/Subleaf 一覧については _[SDM Vol.2A](https://cdrdv2-"
"public.intel.com/812383/253666-sdm-vol-2a.pdf) Chapter 3.3 Table 3-8_ を参照"
"してください。"
msgstr ""
"EAX で取得したい情報を指定します。一部の場合は追加で ECX も使って取得する情報"
"を指定します。 このとき、EAX のことを **Leaf**, ECX のことを **Subleaf** と呼"
"びます。 本シリーズでは、Leaf が `N` で Subleaf が `M` の CPUID を `CPUID[N:"
"M]` と表記します。 返り値には EAX, EBX, ECX, EDX の4つのレジスタが使われま"
"す。 どのレジスタにどのような情報が入るかは、指定した Leaf/Subleaf に依存しま"
"す。 CPUID の Leaf/Subleaf 一覧については _[SDM Vol.2A](https://cdrdv2-"
"public.intel.com/812383/253666-sdm-vol-2a.pdf) Chapter 3.3 Table 3-8_ を参照"
"してください。"

#: src/vmm/vmx_root.md:149
msgid ""
"`Leaf` enum は、すべての Leaf を列挙しているわけではありません。 というか、"
"CPUID は無限に拡張されていくためすべてを列挙するのは不可能ですし意味がありま"
"せん。 ここでは使う分だけを列挙し、残りは `_` として無視しています。 このよう"
"な `_` を持つ `enum` は [Non-exhaustive Enum](https://ziglang.org/"
"documentation/master/#Non-exhaustive-enum) と呼びます。 Non-exhaustive Enum "
"への `switch` は必ず non-exhaustive switch になります。"
msgstr ""
"`Leaf` enum は、すべての Leaf を列挙しているわけではありません。 というか、"
"CPUID は無限に拡張されていくためすべてを列挙するのは不可能ですし意味がありま"
"せん。 ここでは使う分だけを列挙し、残りは `_` として無視しています。 このよう"
"な `_` を持つ `enum` は [Non-exhaustive Enum](https://ziglang.org/"
"documentation/master/#Non-exhaustive-enum) と呼びます。 Non-exhaustive Enum "
"への `switch` は必ず non-exhaustive switch になります。"

#: src/vmm/vmx_root.md:155
msgid "`Leaf` は以下のように使います:"
msgstr "`Leaf` は以下のように使います:"

#: src/vmm/vmx_root.md:164
msgid ""
"もしも Subleaf を指定する必要があれば `query()` の引数として渡します。 "
"Subleaf が不要な場合は `null` を渡すことができます。"
msgstr ""
"もしも Subleaf を指定する必要があれば `query()` の引数として渡します。 "
"Subleaf が不要な場合は `null` を渡すことができます。"

#: src/vmm/vmx_root.md:169
#, fuzzy
#| msgid ""
#| "\\[!TIP\\] Zig のメソッド Zig における static ではない構造体のメソッドは、"
#| "`fn hoge(self: Self)` のように定義します。 これを呼び出す際には、以下の2通"
#| "りの方法があります:"
msgid ""
"Zig における static ではない構造体のメソッドは、`fn hoge(self: Self)` のよう"
"に定義します。 これを呼び出す際には、以下の2通りの方法があります:"
msgstr ""
"\\[!TIP\\] Zig のメソッド Zig における static ではない構造体のメソッドは、"
"`fn hoge(self: Self)` のように定義します。 これを呼び出す際には、以下の2通り"
"の方法があります:"

#: src/vmm/vmx_root.md:177
msgid ""
"前者は単なる後者のシンタックスシュガーです。 C++ の `this` と同じですね。"
msgstr ""
"前者は単なる後者のシンタックスシュガーです。 C++ の `this` と同じですね。"

#: src/vmm/vmx_root.md:180
msgid ""
"`cpuid()` は CPUID 命令の実体となるアセンブリ関数です。 この関数は外部には直"
"接露出せず、`Leaf` を介して利用させます:"
msgstr ""
"`cpuid()` は CPUID 命令の実体となるアセンブリ関数です。 この関数は外部には直"
"接露出せず、`Leaf` を介して利用させます:"

#: src/vmm/vmx_root.md:219
msgid ""
"CPUID と同様にアーキテクチャの機能を取得および操作するために使用するのが "
"**MSR: Model Specific Register** です。 MSR は通常のレジスタとは異なり、アク"
"セスには特権が必要となります[^msr]。 MSR も CPUID と同様にどんどん追加され続"
"けるため、すべてを列挙することはしません。 必要なものだけを列挙して定義しま"
"す。 以下で定義しているものは Ymir で利用する MSR の全てではありません。 必要"
"になった時に新たに追加していきます:"
msgstr ""
"CPUID と同様にアーキテクチャの機能を取得および操作するために使用するのが "
"**MSR: Model Specific Register** です。 MSR は通常のレジスタとは異なり、アク"
"セスには特権が必要となります[^msr]。 MSR も CPUID と同様にどんどん追加され続"
"けるため、すべてを列挙することはしません。 必要なものだけを列挙して定義しま"
"す。 以下で定義しているものは Ymir で利用する MSR の全てではありません。 必要"
"になった時に新たに追加していきます:"

#: src/vmm/vmx_root.md:250
msgid ""
"MSR へのアクセスには [RDMSR](https://www.felixcloutier.com/x86/rdmsr) と "
"[WRMSR](https://www.felixcloutier.com/x86/wrmsr) 命令を使います。 MSR の指定"
"には ECX を使います。 返り値は EDX と EAX をこの順に連結した値となります:"
msgstr ""
"MSR へのアクセスには [RDMSR](https://www.felixcloutier.com/x86/rdmsr) と "
"[WRMSR](https://www.felixcloutier.com/x86/wrmsr) 命令を使います。 MSR の指定"
"には ECX を使います。 返り値は EDX と EAX をこの順に連結した値となります:"

#: src/vmm/vmx_root.md:280
msgid "Vendor ID の確認"
msgstr "Vendor ID の確認"

#: src/vmm/vmx_root.md:282
msgid ""
"手順1の Vendor ID String は `CPUID[0]` (`.maximum_input`) で取得できます:"
msgstr ""
"手順1の Vendor ID String は `CPUID[0]` (`.maximum_input`) で取得できます:"

#: src/vmm/vmx_root.md:300
msgid ""
"`Vm.new()` で Vendor ID を取得し、`GenuineIntel` であることを確認します:"
msgstr ""
"`Vm.new()` で Vendor ID を取得し、`GenuineIntel` であることを確認します:"

#: src/vmm/vmx_root.md:311
msgid "VMX サポートを確認"
msgstr "VMX サポートを確認"

#: src/vmm/vmx_root.md:313
msgid ""
"手順 2/3 は同じ関数内 `isVmxSupported()` で確認します。 まず手順2の VMX がサ"
"ポートされているかどうかは `CPUID[1]` で確認します。 手順3では VMXON が SMX "
"Operation の外でも実行可能かを確認します。 これは MSR の "
"`IA32_FEATURE_CONTROL` の値をチェックすることで確かめられます:"
msgstr ""
"手順 2/3 は同じ関数内 `isVmxSupported()` で確認します。 まず手順2の VMX がサ"
"ポートされているかどうかは `CPUID[1]` で確認します。 手順3では VMXON が SMX "
"Operation の外でも実行可能かを確認します。 これは MSR の "
"`IA32_FEATURE_CONTROL` の値をチェックすることで確かめられます:"

#: src/vmm/vmx_root.md:342
msgid ""
"_VMXON Outside SMX_ が無効化されていた場合、MSR を操作して有効化します。 この"
"とき、`IA32_FEATURE_CONTROL[0]` の **Lock Bit** がクリアされていることを確認"
"します。 Lock Bit がセットされている場合、この MSR には一切の書き込みができま"
"せん。 Lock Bit はシステムがリセットされるまでクリアされることがないため、も"
"しもこのビットがセットされている場合には諦めるしかありません。 逆に、Lock "
"Bit がクリアされたままだと VMXON が失敗するため、必要の値の変更後、この関数内"
"でロックしておきます。"
msgstr ""
"_VMXON Outside SMX_ が無効化されていた場合、MSR を操作して有効化します。 この"
"とき、`IA32_FEATURE_CONTROL[0]` の **Lock Bit** がクリアされていることを確認"
"します。 Lock Bit がセットされている場合、この MSR には一切の書き込みができま"
"せん。 Lock Bit はシステムがリセットされるまでクリアされることがないため、も"
"しもこのビットがセットされている場合には諦めるしかありません。 逆に、Lock "
"Bit がクリアされたままだと VMXON が失敗するため、必要の値の変更後、この関数内"
"でロックしておきます。"

#: src/vmm/vmx_root.md:348
msgid ""
"そもそも Lock Bit は BIOS がシステムでサポートする機能を設定・固定化するため"
"のものです。 一度 BIOS から設定されたあとは OS 側で変更できない場合がほとんど"
"です。 もしも VMX Outside SMX が無効化されていた場合には、お使いのホストBIOS"
"の設定を見直してみてください。"
msgstr ""
"そもそも Lock Bit は BIOS がシステムでサポートする機能を設定・固定化するため"
"のものです。 一度 BIOS から設定されたあとは OS 側で変更できない場合がほとんど"
"です。 もしも VMX Outside SMX が無効化されていた場合には、お使いのホストBIOS"
"の設定を見直してみてください。"

#: src/vmm/vmx_root.md:352
msgid "`Vm.new()` の中でこれらの関数を呼び出します:"
msgstr "`Vm.new()` の中でこれらの関数を呼び出します:"

#: src/vmm/vmx_root.md:362
msgid ""
"以上で VMX がサポートされているかどうかを確認する処理が完成しました。 "
"`kernelMain()` から呼び出して、VMX がサポートされていることを確認しましょう:"
msgstr ""
"以上で VMX がサポートされているかどうかを確認する処理が完成しました。 "
"`kernelMain()` から呼び出して、VMX がサポートされていることを確認しましょう:"

#: src/vmm/vmx_root.md:371
msgid "vCPU"
msgstr "vCPU"

#: src/vmm/vmx_root.md:373
msgid ""
"VMX Operation に入るということは、現在の CPU の状態を変更することであり、各"
"CPUに対して行う操作です。 本シリーズの Ymir では1コアのみをサポートするためと"
"りわけ意識する必要があることではないのですが、 それでも CPU に固有ということ"
"を意識するためにも `Vcpu` という構造体を作っておきます:"
msgstr ""
"VMX Operation に入るということは、現在の CPU の状態を変更することであり、各"
"CPUに対して行う操作です。 本シリーズの Ymir では1コアのみをサポートするためと"
"りわけ意識する必要があることではないのですが、 それでも CPU に固有ということ"
"を意識するためにも `Vcpu` という構造体を作っておきます:"

#: src/vmm/vmx_root.md:393
msgid ""
"**VPID: Virtual-Processor Identifier** は vCPU に対するユニークなID(16bit)で"
"す。 PCID のように、TLB のエントリを識別する等に使われます。 `id` は論理コア"
"のIDです[^core]。 本シリーズの Ymir は1コアのみをサポートするため `id` は "
"`0` で固定していますが、SMP をサポートするようにする場合にはこの値をコアごと"
"に変更します。"
msgstr ""
"**VPID: Virtual-Processor Identifier** は vCPU に対するユニークなID(16bit)で"
"す。 PCID のように、TLB のエントリを識別する等に使われます。 `id` は論理コア"
"のIDです[^core]。 本シリーズの Ymir は1コアのみをサポートするため `id` は "
"`0` で固定していますが、SMP をサポートするようにする場合にはこの値をコアごと"
"に変更します。"

#: src/vmm/vmx_root.md:398
msgid ""
"`Vm` 構造体には `Vcpu` をもたせておきましょう。 ここでも、CPU に強く依存する "
"VMX コードは `arch/x86/vmx` 以下に配置することにします。 もしも AMD-V をサ"
"ポートしたくなったような場合には `switch` で分岐することができます:"
msgstr ""
"`Vm` 構造体には `Vcpu` をもたせておきましょう。 ここでも、CPU に強く依存する "
"VMX コードは `arch/x86/vmx` 以下に配置することにします。 もしも AMD-V をサ"
"ポートしたくなったような場合には `switch` で分岐することができます:"

#: src/vmm/vmx_root.md:422
msgid "VMX Operation への遷移"
msgstr "VMX Operation への遷移"

#: src/vmm/vmx_root.md:424
msgid ""
"VMX がサポートされていることが確認できたため、VMX Operation へ遷移しましょ"
"う。 VMX Operation に移行するためには、CR レジスタの設定と VMXON 命令の実行が"
"必要になります。"
msgstr ""
"VMX がサポートされていることが確認できたため、VMX Operation へ遷移しましょ"
"う。 VMX Operation に移行するためには、CR レジスタの設定と VMXON 命令の実行が"
"必要になります。"

#: src/vmm/vmx_root.md:427
msgid "CR レジスタの設定"
msgstr "CR レジスタの設定"

#: src/vmm/vmx_root.md:429
msgid ""
"VMX Operation に入るためには CR0, CR4 レジスタを適切に設定する必要がありま"
"す。 また、一度 VMX Operation に入ると CR0, CR4 の一部の値は固定化され、値を"
"変更しようとすると `#GP: General Protection Fault` になります。"
msgstr ""
"VMX Operation に入るためには CR0, CR4 レジスタを適切に設定する必要がありま"
"す。 また、一度 VMX Operation に入ると CR0, CR4 の一部の値は固定化され、値を"
"変更しようとすると `#GP: General Protection Fault` になります。"

#: src/vmm/vmx_root.md:432
msgid ""
"CR0 の値は `IA32_VMX_CR0_FIXED0` と `IA32_VMX_CR0_FIXED1` の2つの MSR で規定"
"されます。 前者の N-th bit が `1` の場合、`CR0[N]` は `1` である必要がありま"
"す。 後者の N-th bit が `0` の場合、`CR0[N]` は `0` である必要があります。 "
"CR4 も同様で `IA32_VMX_CR4_FIXED0` と `IA32_VMX_CR4_FIXED1` の2つの MSR をも"
"とに値を指定します。 各 MSR のインデックスは以下のとおりです:"
msgstr ""
"CR0 の値は `IA32_VMX_CR0_FIXED0` と `IA32_VMX_CR0_FIXED1` の2つの MSR で規定"
"されます。 前者の N-th bit が `1` の場合、`CR0[N]` は `1` である必要がありま"
"す。 後者の N-th bit が `0` の場合、`CR0[N]` は `0` である必要があります。 "
"CR4 も同様で `IA32_VMX_CR4_FIXED0` と `IA32_VMX_CR4_FIXED1` の2つの MSR をも"
"とに値を指定します。 各 MSR のインデックスは以下のとおりです:"

#: src/vmm/vmx_root.md:438
msgid "Address"
msgstr "Address"

#: src/vmm/vmx_root.md:440 src/vmm/vmx_root.md:471
msgid "IA32_VMX_CR0_FIXED0"
msgstr "IA32_VMX_CR0_FIXED0"

#: src/vmm/vmx_root.md:440
msgid "0x486"
msgstr "0x486"

#: src/vmm/vmx_root.md:441 src/vmm/vmx_root.md:472
msgid "IA32_VMX_CR0_FIXED1"
msgstr "IA32_VMX_CR0_FIXED1"

#: src/vmm/vmx_root.md:441
msgid "0x487"
msgstr "0x487"

#: src/vmm/vmx_root.md:442 src/vmm/vmx_root.md:473
msgid "IA32_VMX_CR4_FIXED0"
msgstr "IA32_VMX_CR4_FIXED0"

#: src/vmm/vmx_root.md:442
msgid "0x488"
msgstr "0x488"

#: src/vmm/vmx_root.md:443 src/vmm/vmx_root.md:474
msgid "IA32_VMX_CR4_FIXED1"
msgstr "IA32_VMX_CR4_FIXED1"

#: src/vmm/vmx_root.md:443
msgid "0x489"
msgstr "0x489"

#: src/vmm/vmx_root.md:445
msgid "なお、各レジスタは下位 32bit のみが有効です。上位 32bit は無視します:"
msgstr "なお、各レジスタは下位 32bit のみが有効です。上位 32bit は無視します:"

#: src/vmm/vmx_root.md:467
msgid ""
"一応どのビットが強制的に 0/1 になるかを検証してみたところ、筆者の環境では以下"
"のようになりました:"
msgstr ""
"一応どのビットが強制的に 0/1 になるかを検証してみたところ、筆者の環境では以下"
"のようになりました:"

#: src/vmm/vmx_root.md:469
msgid "Bits"
msgstr "Bits"

#: src/vmm/vmx_root.md:471
msgid "`10000000000000000000000000100001`"
msgstr "`10000000000000000000000000100001`"

#: src/vmm/vmx_root.md:471
msgid "PE, NE, PG"
msgstr "PE, NE, PG"

#: src/vmm/vmx_root.md:472
msgid "`11111111111111111111111111111111`"
msgstr "`11111111111111111111111111111111`"

#: src/vmm/vmx_root.md:472
msgid "(None)"
msgstr "(None)"

#: src/vmm/vmx_root.md:473
msgid "`00000000000000000010000000000000`"
msgstr "`00000000000000000010000000000000`"

#: src/vmm/vmx_root.md:473
msgid "VMX"
msgstr "VMX"

#: src/vmm/vmx_root.md:474
msgid "`00000000011101110010111111111111`"
msgstr "`00000000011101110010111111111111`"

#: src/vmm/vmx_root.md:474
msgid "LA57, SMXE, Reserved, PKS"
msgstr "LA57, SMXE, Reserved, PKS"

#: src/vmm/vmx_root.md:476
msgid ""
"強制的に有効化されるのはページング関係 + VMX だけでした。 強制的に無効化され"
"るのは SMX や PKS など Ymir では使わない拡張機能だけでした。 よって、このマス"
"クを適用することに問題はありません。"
msgstr ""
"強制的に有効化されるのはページング関係 + VMX だけでした。 強制的に無効化され"
"るのは SMX や PKS など Ymir では使わない拡張機能だけでした。 よって、このマス"
"クを適用することに問題はありません。"

#: src/vmm/vmx_root.md:480
msgid "`readCr4()`/`loadCr4()` の定義を以下に示しておきます:"
msgstr "`readCr4()`/`loadCr4()` の定義を以下に示しておきます:"

#: src/vmm/vmx_root.md:511
msgid "VMXON"
msgstr "VMXON"

#: src/vmm/vmx_root.md:513
msgid ""
"VMX Operation に遷移するには [VMXON](https://www.felixcloutier.com/x86/"
"vmxon) 命令を使います。 この命令は引数に **VMXON Region** と呼ばれる領域の物"
"理アドレスをとります。 VMXON Region は CPU が VMX Operation 中に使う(かもしれ"
"ない)領域です。 一部を除いた内部構造やその使われ方は実装依存であり、システム"
"開発者が気にする必要はありません。 もしかしたら使われてすらいないのかもしれま"
"せんが、それすら気にする必要はありません。"
msgstr ""
"VMX Operation に遷移するには [VMXON](https://www.felixcloutier.com/x86/"
"vmxon) 命令を使います。 この命令は引数に **VMXON Region** と呼ばれる領域の物"
"理アドレスをとります。 VMXON Region は CPU が VMX Operation 中に使う(かもしれ"
"ない)領域です。 一部を除いた内部構造やその使われ方は実装依存であり、システム"
"開発者が気にする必要はありません。 もしかしたら使われてすらいないのかもしれま"
"せんが、それすら気にする必要はありません。"

#: src/vmm/vmx_root.md:519
msgid ""
"VMXON Region はページアラインされている必要があります。 必要なサイズは実装依"
"存であり、`IA32_VMX_BASIC` MSR (`0x0480`) を調べることで取得できます:"
msgstr ""
"VMXON Region はページアラインされている必要があります。 必要なサイズは実装依"
"存であり、`IA32_VMX_BASIC` MSR (`0x0480`) を調べることで取得できます:"

#: src/vmm/vmx_root.md:539
msgid ""
"VMXON Region を確保する際には取得したサイズを用いてページアラインされた領域を"
"確保します。 この領域は 4KiB アラインされていることが要求されます:"
msgstr ""
"VMXON Region を確保する際には取得したサイズを用いてページアラインされた領域を"
"確保します。 この領域は 4KiB アラインされていることが要求されます:"

#: src/vmm/vmx_root.md:560
msgid ""
"VMXON Region で唯一設定する必要のあるフィールドが **VMCS Revision "
"Identifier** です。 **VMCS** というのは ゲスト/VMM の状態を設定する構造であ"
"り VMX における最も重要なものではありますが、 ここで説明するには紙面が足りな"
"さすぎるので [次のチャプター](./vmcs.md) に回します。 ここでは、VMCS という構"
"造体のバージョン番号を VMXON Region にも設定する必要があると考えれば十分で"
"す。 この ID は、VMXON Region のサイズと同様に `IA32_VMX_BASIC` から取得しま"
"す[^vmx_basic]:"
msgstr ""
"VMXON Region で唯一設定する必要のあるフィールドが **VMCS Revision "
"Identifier** です。 **VMCS** というのは ゲスト/VMM の状態を設定する構造であ"
"り VMX における最も重要なものではありますが、 ここで説明するには紙面が足りな"
"さすぎるので [次のチャプター](./vmcs.md) に回します。 ここでは、VMCS という構"
"造体のバージョン番号を VMXON Region にも設定する必要があると考えれば十分で"
"す。 この ID は、VMXON Region のサイズと同様に `IA32_VMX_BASIC` から取得しま"
"す[^vmx_basic]:"

#: src/vmm/vmx_root.md:573
msgid ""
"それでは VMXON を実行する関数を定義します。 VMXON Region を確保したあと、"
"VMCS Revision ID を取得しセットします。 VMXON 命令に渡すのは物理アドレスであ"
"るため、VMXON Region の仮想アドレスを変換してから `am.vmxon()` に渡します:"
msgstr ""
"それでは VMXON を実行する関数を定義します。 VMXON Region を確保したあと、"
"VMCS Revision ID を取得しセットします。 VMXON 命令に渡すのは物理アドレスであ"
"るため、VMXON Region の仮想アドレスを変換してから `am.vmxon()` に渡します:"

#: src/vmm/vmx_root.md:590
msgid "`am.vmxon()` はアセンブリ関数です:"
msgstr "`am.vmxon()` はアセンブリ関数です:"

#: src/vmm/vmx_root.md:611 src/vmm/vmcs.md:531
msgid "VMX Instruction Error"
msgstr "VMX Instruction Error"

#: src/vmm/vmx_root.md:613
msgid ""
"VMXON を含む VMX 拡張命令は、特殊な calling convention を持っています。 返り"
"値は RFLAGS レジスタに格納されます。 `CF` と `ZF` がどちらも `0` であるとき、"
"VMX 拡張命令の成功を表します。 失敗した場合には、エラー番号が利用可能かどうか"
"に応じて `CF` か `ZF` がセットされます。"
msgstr ""
"VMXON を含む VMX 拡張命令は、特殊な calling convention を持っています。 返り"
"値は RFLAGS レジスタに格納されます。 `CF` と `ZF` がどちらも `0` であるとき、"
"VMX 拡張命令の成功を表します。 失敗した場合には、エラー番号が利用可能かどうか"
"に応じて `CF` か `ZF` がセットされます。"

#: src/vmm/vmx_root.md:618
msgid ""
"エラー番号が有効な場合の失敗は **VMfailValid** と呼ばれ、`ZF` が `1` になりま"
"す。 エラー番号の一覧については _SDM Vol.3C 31.4 VM INSTRUCTION ERROR "
"NUMBERS_ を参照してください。 VMfailValid は、現在の論理コアが有効な VMCS を"
"持っている場合にしか発生しません。 現在はまだ VMCS を設定していないため、この"
"エラーは発生しません。"
msgstr ""
"エラー番号が有効な場合の失敗は **VMfailValid** と呼ばれ、`ZF` が `1` になりま"
"す。 エラー番号の一覧については _SDM Vol.3C 31.4 VM INSTRUCTION ERROR "
"NUMBERS_ を参照してください。 VMfailValid は、現在の論理コアが有効な VMCS を"
"持っている場合にしか発生しません。 現在はまだ VMCS を設定していないため、この"
"エラーは発生しません。"

#: src/vmm/vmx_root.md:623
msgid ""
"エラー番号が利用不可能な失敗は **VMfailInvalid** と呼ばれ、`CF` が `1` になり"
"ます。 有効な VMCS を設定する前にエラーが発生した場合にはこちらのエラーが発生"
"します。"
msgstr ""
"エラー番号が利用不可能な失敗は **VMfailInvalid** と呼ばれ、`CF` が `1` になり"
"ます。 有効な VMCS を設定する前にエラーが発生した場合にはこちらのエラーが発生"
"します。"

#: src/vmm/vmx_root.md:626
msgid "VMX 拡張命令のエラーを処理するための関数を定義します:"
msgstr "VMX 拡張命令のエラーを処理するための関数を定義します:"

#: src/vmm/vmx_root.md:644
msgid ""
"この関数を使うと先ほどの `am.vmxon()` のように、VMX 拡張命令を呼び出す関数の"
"末尾で `try vmxtry()` とすることでエラー処理ができます。"
msgstr ""
"この関数を使うと先ほどの `am.vmxon()` のように、VMX 拡張命令を呼び出す関数の"
"末尾で `try vmxtry()` とすることでエラー処理ができます。"

#: src/vmm/vmx_root.md:646
msgid "EFLAGS レジスタは次のように定義されます:"
msgstr "EFLAGS レジスタは次のように定義されます:"

#: src/vmm/vmx_root.md:670
msgid "VMX Root Operation に遷移できたことの確認"
msgstr "VMX Root Operation に遷移できたことの確認"

#: src/vmm/vmx_root.md:672
msgid ""
"最後に、VMX 自体を有効化します。 VMX の有効化は `CR4[13]` に `1` をセットする"
"ことで行います。 VMX を有効化したら、VMXON で VMX Root Operation に遷移しま"
"す:"
msgstr ""
"最後に、VMX 自体を有効化します。 VMX の有効化は `CR4[13]` に `1` をセットする"
"ことで行います。 VMX を有効化したら、VMXON で VMX Root Operation に遷移しま"
"す:"

#: src/vmm/vmx_root.md:694
msgid "`Vm` からこの関数を呼び出します:"
msgstr "`Vm` からこの関数を呼び出します:"

#: src/vmm/vmx_root.md:706
msgid ""
"実行して最後まで処理が確認できたことを確認してみてください。 とはいっても、"
"**VMX Root Operation に遷移したということを直接的に確認する方法はありません"
"**。 とりわけ、VMX Non-root Operation にいる間に自身が VMX Operation にいると"
"いうことを知る方法はありまえん。 これはセキュリティ的にゲストが自分が仮想化さ"
"れていることを知ることがよろしくないためです。"
msgstr ""
"実行して最後まで処理が確認できたことを確認してみてください。 とはいっても、"
"**VMX Root Operation に遷移したということを直接的に確認する方法はありません"
"**。 とりわけ、VMX Non-root Operation にいる間に自身が VMX Operation にいると"
"いうことを知る方法はありまえん。 これはセキュリティ的にゲストが自分が仮想化さ"
"れていることを知ることがよろしくないためです。"

#: src/vmm/vmx_root.md:711
msgid ""
"しかしながら、VMX Root Operation にいる間は間接的に確認する方法があります。 "
"VMX 拡張命令の一部には、VMX Operation にいるときにしか実行できないものがあり"
"ます。 VMX Non-root Operation に遷移するための [VMLAUNCH](https://www."
"felixcloutier.com/x86/vmlaunch:vmresume) がその一例です。 VMX Root Operation "
"以外で VMLAUNCH を実行すると `#UD: Invalid Opcode` 例外が発生します。 よっ"
"て、この命令を実行して例外が発生しなければ VMX Root Operation に遷移できてい"
"るということがわかります[^vmlaunch]:"
msgstr ""
"しかしながら、VMX Root Operation にいる間は間接的に確認する方法があります。 "
"VMX 拡張命令の一部には、VMX Operation にいるときにしか実行できないものがあり"
"ます。 VMX Non-root Operation に遷移するための [VMLAUNCH](https://www."
"felixcloutier.com/x86/vmlaunch:vmresume) がその一例です。 VMX Root Operation "
"以外で VMLAUNCH を実行すると `#UD: Invalid Opcode` 例外が発生します。 よっ"
"て、この命令を実行して例外が発生しなければ VMX Root Operation に遷移できてい"
"るということがわかります[^vmlaunch]:"

#: src/vmm/vmx_root.md:722
msgid ""
"実行して、例外が発生しないことを確認してください。 また、`vm.init()` を呼び出"
"す前にこの命令を実行して例外が発生することも確認してください。"
msgstr ""
"実行して、例外が発生しないことを確認してください。 また、`vm.init()` を呼び出"
"す前にこの命令を実行して例外が発生することも確認してください。"

#: src/vmm/vmx_root.md:727
msgid ""
"本チャプターでは VMX Root Operation に遷移しました。 今のところ、変わったこと"
"といえば VMX 拡張命令が使えるようになったことくらいです。 しかしながら、CPU "
"の状態が切り替わったことには変わりありません。 わくわくしますね。 次回は、"
"VMX の最も重要な設定項目であり、VMX の全てであると言っても過言ではない "
"**VMCS** を扱います。"
msgstr ""
"本チャプターでは VMX Root Operation に遷移しました。 今のところ、変わったこと"
"といえば VMX 拡張命令が使えるようになったことくらいです。 しかしながら、CPU "
"の状態が切り替わったことには変わりありません。 わくわくしますね。 次回は、"
"VMX の最も重要な設定項目であり、VMX の全てであると言っても過言ではない "
"**VMCS** を扱います。"

#: src/vmm/vmx_root.md:733
msgid ""
"VM Exit が発生する要因についてはのちのチャプターで詳しく扱います。 例として、"
"例外の発生・特定のメモリへのアクセス・あらかじめ VMM が設定した時間の経過等が"
"あります。"
msgstr ""
"VM Exit が発生する要因についてはのちのチャプターで詳しく扱います。 例として、"
"例外の発生・特定のメモリへのアクセス・あらかじめ VMM が設定した時間の経過等が"
"あります。"

#: src/vmm/vmx_root.md:735
msgid ""
"ごくごく僅かな個体は `GenuineIotel` という Vendor ID を返すことが[あるらしい]"
"(https://x.com/InstLatX64/status/1101230794364862464)です。 製造ミスでしょう"
"か？"
msgstr ""
"ごくごく僅かな個体は `GenuineIotel` という Vendor ID を返すことが[あるらしい]"
"(https://x.com/InstLatX64/status/1101230794364862464)です。 製造ミスでしょう"
"か？"

#: src/vmm/vmx_root.md:737
msgid "Ring-0 以外でアクセスした場合には `#GP(0)` が発生します。"
msgstr "Ring-0 以外でアクセスした場合には `#GP(0)` が発生します。"

#: src/vmm/vmx_root.md:738
msgid ""
"本シリーズでは仮想コアを **vCPU**、通常のCPUコアを **論理コア** または単純に"
"CPUコアと呼びます。"
msgstr ""
"本シリーズでは仮想コアを **vCPU**、通常のCPUコアを **論理コア** または単純に"
"CPUコアと呼びます。"

#: src/vmm/vmx_root.md:739
msgid ""
"`IA32_VMX_BASIC` に入っている値は VMXON Region のサイズというよりも、VMCS の"
"サイズです。"
msgstr ""
"`IA32_VMX_BASIC` に入っている値は VMXON Region のサイズというよりも、VMCS の"
"サイズです。"

#: src/vmm/vmx_root.md:740
msgid ""
"VMLAUNCH 命令自体は VMXON に成功した今の段階でも実は失敗しています。 しかしな"
"がら、例外を投げるのではなく前述した VMX Instruction Error という形でエラーを"
"返しています。 今回は VMLAUNCH に対するエラーハンドリングをしていないため、例"
"外さえ投げられなければ最後まで処理が実行されます。"
msgstr ""
"VMLAUNCH 命令自体は VMXON に成功した今の段階でも実は失敗しています。 しかしな"
"がら、例外を投げるのではなく前述した VMX Instruction Error という形でエラーを"
"返しています。 今回は VMLAUNCH に対するエラーハンドリングをしていないため、例"
"外さえ投げられなければ最後まで処理が実行されます。"

#: src/vmm/vmcs.md:1
msgid "VMCS の基礎"
msgstr "VMCS の基礎"

#: src/vmm/vmcs.md:3
msgid ""
"本チャプターでは、VMX における最も重要なデータ構造である VMCS について概観し"
"ます。 なお、VMCS が制御する項目は膨大であるため、本チャプターおよび本シリー"
"ズではすべての項目を扱うわけではありません。 Ymir が Linux をブートするために"
"必要な項目についてのみ触れることとします。"
msgstr ""
"本チャプターでは、VMX における最も重要なデータ構造である VMCS について概観し"
"ます。 なお、VMCS が制御する項目は膨大であるため、本チャプターおよび本シリー"
"ズではすべての項目を扱うわけではありません。 Ymir が Linux をブートするために"
"必要な項目についてのみ触れることとします。"

#: src/vmm/vmcs.md:9
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-vmcs`](https://"
#| "github.com/smallkirby/ymir/tree/whiz-vmm-vmcs) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-vmm-vmcs`](https://github.com/smallkirby/"
"ymir/tree/whiz-vmm-vmcs) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-vmcs`](https://github."
"com/smallkirby/ymir/tree/whiz-vmm-vmcs) ブランチにあります。"

#: src/vmm/vmcs.md:13
msgid "[VMCS 概略](#vmcs-概略)"
msgstr "[VMCS 概略](#vmcs-概略)"

#: src/vmm/vmcs.md:14 src/vmm/vmlaunch.md:22
msgid "[Guest-State](#guest-state)"
msgstr "[Guest-State](#guest-state)"

#: src/vmm/vmcs.md:15 src/vmm/vmlaunch.md:17
msgid "[Host-State](#host-state)"
msgstr "[Host-State](#host-state)"

#: src/vmm/vmcs.md:16 src/vmm/vmlaunch.md:14
msgid "[VM-Execution Control](#vm-execution-control)"
msgstr "[VM-Execution Control](#vm-execution-control)"

#: src/vmm/vmcs.md:17 src/vmm/vmlaunch.md:27
msgid "[VM-Exit Control](#vm-exit-control)"
msgstr "[VM-Exit Control](#vm-exit-control)"

#: src/vmm/vmcs.md:18 src/vmm/vmlaunch.md:26
msgid "[VM-Entry Control](#vm-entry-control)"
msgstr "[VM-Entry Control](#vm-entry-control)"

#: src/vmm/vmcs.md:19
msgid "[VM-Exit Information](#vm-exit-information)"
msgstr "[VM-Exit Information](#vm-exit-information)"

#: src/vmm/vmcs.md:20
msgid "[VMCS Region](#vmcs-region)"
msgstr "[VMCS Region](#vmcs-region)"

#: src/vmm/vmcs.md:21
msgid "[フィールドアクセス](#フィールドアクセス)"
msgstr "[フィールドアクセス](#フィールドアクセス)"

#: src/vmm/vmcs.md:22
msgid "[VMCS-field Encoding](#vmcs-field-encoding)"
msgstr "[VMCS-field Encoding](#vmcs-field-encoding)"

#: src/vmm/vmcs.md:23
msgid "[VMREAD / VMWRITE](#vmread--vmwrite)"
msgstr "[VMREAD / VMWRITE](#vmread--vmwrite)"

#: src/vmm/vmcs.md:27
msgid "VMCS 概略"
msgstr "VMCS 概略"

#: src/vmm/vmcs.md:29
msgid ""
"**VMCS: Virtual-Machine Control Data Structures** は VMX Non-root Operation "
"における vCPU の挙動や VM Exit と VM Entry 時の挙動に関する設定を司るデータ構"
"造です。"
msgstr ""
"**VMCS: Virtual-Machine Control Data Structures** は VMX Non-root Operation "
"における vCPU の挙動や VM Exit と VM Entry 時の挙動に関する設定を司るデータ構"
"造です。"

#: src/vmm/vmcs.md:31
msgid "VMCS は以下の6つのカテゴリに分類されます:"
msgstr "VMCS は以下の6つのカテゴリに分類されます:"

#: src/vmm/vmcs.md:33
msgid "Category"
msgstr "Category"

#: src/vmm/vmcs.md:35
msgid "**Guest-State**"
msgstr "**Guest-State**"

#: src/vmm/vmcs.md:35
msgid ""
"ゲストのプロセッサの状態を保持する。VM Entry でロードされ VM Exit で保存され"
"る。"
msgstr ""
"ゲストのプロセッサの状態を保持する。VM Entry でロードされ VM Exit で保存され"
"る。"

#: src/vmm/vmcs.md:36
msgid "**Host-State**"
msgstr "**Host-State**"

#: src/vmm/vmcs.md:36
msgid "ホストのプロセッサの状態を保持する。VM Exit でロードされる。"
msgstr "ホストのプロセッサの状態を保持する。VM Exit でロードされる。"

#: src/vmm/vmcs.md:37
msgid "**VM-Execution Control**"
msgstr "**VM-Execution Control**"

#: src/vmm/vmcs.md:37
msgid "VMX Non-root Operation の挙動を制御する。"
msgstr "VMX Non-root Operation の挙動を制御する。"

#: src/vmm/vmcs.md:38
msgid "**VM-Exit Control**"
msgstr "**VM-Exit Control**"

#: src/vmm/vmcs.md:38
msgid "VM Exit 時の挙動を制御する。"
msgstr "VM Exit 時の挙動を制御する。"

#: src/vmm/vmcs.md:39
msgid "**VM-Entry Control**"
msgstr "**VM-Entry Control**"

#: src/vmm/vmcs.md:39
msgid "VM Entry 時の挙動を制御する。"
msgstr "VM Entry 時の挙動を制御する。"

#: src/vmm/vmcs.md:40
msgid "**VM-Exit Information**"
msgstr "**VM-Exit Information**"

#: src/vmm/vmcs.md:40
msgid "VM Exit 時の情報を保持する。"
msgstr "VM Exit 時の情報を保持する。"

#: src/vmm/vmcs.md:42 src/vmm/vmlaunch.md:648 src/vmm/msr.md:72
#: src/vmm/msr.md:78 src/vmm/msr.md:79 src/vmm/msr.md:80 src/vmm/msr.md:81
#: src/vmm/msr.md:82 src/vmm/msr.md:83 src/vmm/msr.md:84 src/vmm/msr.md:85
#: src/vmm/msr.md:86 src/vmm/msr.md:111
msgid "Guest-State"
msgstr "Guest-State"

#: src/vmm/vmcs.md:44
msgid ""
"このカテゴリはゲストのプロセッサの状態を保持します。 VM Entry 時にこれらの状"
"態が自動的にロードされることで、ゲストは VM Exit の直前の状態から実行を再開す"
"ることができます。 保存・復帰されるプロセッサの状態には以下が含まれます:"
msgstr ""
"このカテゴリはゲストのプロセッサの状態を保持します。 VM Entry 時にこれらの状"
"態が自動的にロードされることで、ゲストは VM Exit の直前の状態から実行を再開す"
"ることができます。 保存・復帰されるプロセッサの状態には以下が含まれます:"

#: src/vmm/vmcs.md:49
msgid "RSP, RIP, RFLAGS"
msgstr "RSP, RIP, RFLAGS"

#: src/vmm/vmcs.md:50
msgid "Segment Registers の一部フィールド"
msgstr "Segment Registers の一部フィールド"

#: src/vmm/vmcs.md:51 src/vmm/vmcs.md:70
msgid "一部の MSR"
msgstr "一部の MSR"

#: src/vmm/vmcs.md:53
msgid ""
"なお、RAX, RBX, ... 等の汎用レジスタは VMCS には保存されません。 これらのレジ"
"スタは VMM がソフトウェア的に保存およびロードしてあげる必要があります。"
msgstr ""
"なお、RAX, RBX, ... 等の汎用レジスタは VMCS には保存されません。 これらのレジ"
"スタは VMM がソフトウェア的に保存およびロードしてあげる必要があります。"

#: src/vmm/vmcs.md:56
msgid ""
"また、保存される MSR もごく一部です。 MSR へアクセスする [RDMSR](https://www."
"felixcloutier.com/x86/rdmsr) / [WRMSR](https://www.felixcloutier.com/x86/"
"wrmsr) 命令は、特権命令として指定することができます。 この場合、ゲストが "
"RDMSR/WRMSR すると VM Exit が発生し、VMM が実際に読み込み・書き込みする値を制"
"御することができます。"
msgstr ""
"また、保存される MSR もごく一部です。 MSR へアクセスする [RDMSR](https://www."
"felixcloutier.com/x86/rdmsr) / [WRMSR](https://www.felixcloutier.com/x86/"
"wrmsr) 命令は、特権命令として指定することができます。 この場合、ゲストが "
"RDMSR/WRMSR すると VM Exit が発生し、VMM が実際に読み込み・書き込みする値を制"
"御することができます。"

#: src/vmm/vmcs.md:60 src/vmm/vmlaunch.md:306 src/vmm/msr.md:98
#: src/vmm/msr.md:99 src/vmm/msr.md:100 src/vmm/msr.md:103 src/vmm/msr.md:104
#: src/vmm/msr.md:105 src/vmm/msr.md:112 src/vmm/msr.md:113 src/vmm/msr.md:114
#: src/vmm/msr.md:115 src/vmm/msr.md:116 src/vmm/msr.md:117 src/vmm/msr.md:118
#: src/vmm/msr.md:119 src/vmm/msr.md:120
msgid "Host-State"
msgstr "Host-State"

#: src/vmm/vmcs.md:62
msgid ""
"このカテゴリは VMM のプロセッサの状態を保持します。 これらの値は VM Exit 時に"
"ロードされ、VMM は VM Entry する直前の状態から実行を再開することができます。 "
"復帰されるプロセッサの状態には以下が含まれます:"
msgstr ""
"このカテゴリは VMM のプロセッサの状態を保持します。 これらの値は VM Exit 時に"
"ロードされ、VMM は VM Entry する直前の状態から実行を再開することができます。 "
"復帰されるプロセッサの状態には以下が含まれます:"

#: src/vmm/vmcs.md:67
msgid "RSP, RIP"
msgstr "RSP, RIP"

#: src/vmm/vmcs.md:68
msgid "Segment Selector"
msgstr "Segment Selector"

#: src/vmm/vmcs.md:69
msgid "FS / GS / TR / GDTR / IDTR の Base"
msgstr "FS / GS / TR / GDTR / IDTR の Base"

#: src/vmm/vmcs.md:72
msgid ""
"**Host-State は Guest-State の場合と異なり、VM Entry の際に自動的に保存される"
"ことがありません**。 そのため、VM Entry する前に VMM はソフトウェア的にこれら"
"の値を適切に設定する必要があります。 VM-Exit 時には、これらの値が自動的にロー"
"ドされます。"
msgstr ""
"**Host-State は Guest-State の場合と異なり、VM Entry の際に自動的に保存される"
"ことがありません**。 そのため、VM Entry する前に VMM はソフトウェア的にこれら"
"の値を適切に設定する必要があります。 VM-Exit 時には、これらの値が自動的にロー"
"ドされます。"

#: src/vmm/vmcs.md:76 src/vmm/vmlaunch.md:59
msgid "VM-Execution Control"
msgstr "VM-Execution Control"

#: src/vmm/vmcs.md:78
msgid ""
"このカテゴリは VMX Non-root Operation におけるプロセッサの挙動を制御します。 "
"設定項目は6カテゴリの中でおそらく最も多いです。 そのため、ここでは代表的な"
"フィールドのみを概観し、必要になった際に都度説明することにします。 このカテゴ"
"リは以下のフィールドを含みます:"
msgstr ""
"このカテゴリは VMX Non-root Operation におけるプロセッサの挙動を制御します。 "
"設定項目は6カテゴリの中でおそらく最も多いです。 そのため、ここでは代表的な"
"フィールドのみを概観し、必要になった際に都度説明することにします。 このカテゴ"
"リは以下のフィールドを含みます:"

#: src/vmm/vmcs.md:83
msgid ""
"**Pin-Based VM-Execution Controls**: 割り込み・例外等の非同期イベントを制御す"
"る"
msgstr ""
"**Pin-Based VM-Execution Controls**: 割り込み・例外等の非同期イベントを制御す"
"る"

#: src/vmm/vmcs.md:84
msgid ""
"**Processor-Based VM-Execution Controls**: 主に特定の命令で発生するイベントを"
"制御する"
msgstr ""
"**Processor-Based VM-Execution Controls**: 主に特定の命令で発生するイベントを"
"制御する"

#: src/vmm/vmcs.md:85
msgid ""
"\"特別な命令\" とは [RDTSCP](https://www.felixcloutier.com/x86/rdtscp), [HLT]"
"(https://www.felixcloutier.com/x86/hlt), [INVLPG](https://www.felixcloutier."
"com/x86/invlpg), MOV to CR などのこと"
msgstr ""
"\"特別な命令\" とは [RDTSCP](https://www.felixcloutier.com/x86/rdtscp), [HLT]"
"(https://www.felixcloutier.com/x86/hlt), [INVLPG](https://www.felixcloutier."
"com/x86/invlpg), MOV to CR などのこと"

#: src/vmm/vmcs.md:86
msgid "**Exception Bitmap**: どの例外で VM Exit するかを制御する"
msgstr "**Exception Bitmap**: どの例外で VM Exit するかを制御する"

#: src/vmm/vmcs.md:87
msgid "**I/O-Bitmap**: どの I/O ポートアクセスで VM Exit するかを制御する"
msgstr "**I/O-Bitmap**: どの I/O ポートアクセスで VM Exit するかを制御する"

#: src/vmm/vmcs.md:88
msgid "**MSR-Bitmap**: どの MSR アクセスで VM Exit するかを制御する"
msgstr "**MSR-Bitmap**: どの MSR アクセスで VM Exit するかを制御する"

#: src/vmm/vmcs.md:89
msgid ""
"**EPTP: Extended-Page-Table Pointer**: EPT の Lv4 テーブルを指すポインタ。"
"EPT については別のチャプターで詳しく扱う"
msgstr ""
"**EPTP: Extended-Page-Table Pointer**: EPT の Lv4 テーブルを指すポインタ。"
"EPT については別のチャプターで詳しく扱う"

#: src/vmm/vmcs.md:91 src/vmm/vmlaunch.md:899
msgid "VM-Exit Control"
msgstr "VM-Exit Control"

#: src/vmm/vmcs.md:93
msgid ""
"このカテゴリは VM Exit 時の挙動を制御します。 制御する項目は以下を含みます:"
msgstr ""
"このカテゴリは VM Exit 時の挙動を制御します。 制御する項目は以下を含みます:"

#: src/vmm/vmcs.md:96 src/vmm/vmcs.md:108
msgid "Debug Rgister を保存するかどうか"
msgstr "Debug Rgister を保存するかどうか"

#: src/vmm/vmcs.md:97
msgid "VM Exit 直後のプロセッサのモードが 64bit モードかどうか"
msgstr "VM Exit 直後のプロセッサのモードが 64bit モードかどうか"

#: src/vmm/vmcs.md:98
msgid "**MSR Area**: VM Exit 時にロードするホストの MSR 一覧"
msgstr "**MSR Area**: VM Exit 時にロードするホストの MSR 一覧"

#: src/vmm/vmcs.md:100
msgid ""
"他のカテゴリに比べて項目数が少なく、Ymir でもそこまで使う機能は多くないで"
"す。 VMCS における癒やし枠です。"
msgstr ""
"他のカテゴリに比べて項目数が少なく、Ymir でもそこまで使う機能は多くないで"
"す。 VMCS における癒やし枠です。"

#: src/vmm/vmcs.md:103 src/vmm/vmlaunch.md:838
msgid "VM-Entry Control"
msgstr "VM-Entry Control"

#: src/vmm/vmcs.md:105
msgid ""
"このカテゴリは VM Entry 時の挙動を制御します。 制御する項目は以下を含みます:"
msgstr ""
"このカテゴリは VM Entry 時の挙動を制御します。 制御する項目は以下を含みます:"

#: src/vmm/vmcs.md:109
msgid "VM Entry 直後のプロセッサのモードが IA-32e モードかどうか"
msgstr "VM Entry 直後のプロセッサのモードが IA-32e モードかどうか"

#: src/vmm/vmcs.md:110
msgid "**MSR Area**: VM Entry 時にロードするホストの MSR 一覧"
msgstr "**MSR Area**: VM Entry 時にロードするホストの MSR 一覧"

#: src/vmm/vmcs.md:111
msgid ""
"**Event Injection**: VM Entry 時に任意の割り込みをゲストに対して注入できる"
msgstr ""
"**Event Injection**: VM Entry 時に任意の割り込みをゲストに対して注入できる"

#: src/vmm/vmcs.md:113
msgid "こちらも VM-Exit Control と同様に癒やし枠です。"
msgstr "こちらも VM-Exit Control と同様に癒やし枠です。"

#: src/vmm/vmcs.md:115
msgid "VM-Exit Information"
msgstr "VM-Exit Information"

#: src/vmm/vmcs.md:117
msgid ""
"このカテゴリは VM Exit 時の情報を保持します。 このカテゴリは唯一 read-only で"
"す。 保持する情報には以下が含まれます:"
msgstr ""
"このカテゴリは VM Exit 時の情報を保持します。 このカテゴリは唯一 read-only で"
"す。 保持する情報には以下が含まれます:"

#: src/vmm/vmcs.md:121
msgid "**Basic VM-Exit Information**: VM Exit の原因"
msgstr "**Basic VM-Exit Information**: VM Exit の原因"

#: src/vmm/vmcs.md:122
msgid ""
"I/O アクセス / CPUID / MSR アクセス / EPT Violation などの大まかな理由が分か"
"る"
msgstr ""
"I/O アクセス / CPUID / MSR アクセス / EPT Violation などの大まかな理由が分か"
"る"

#: src/vmm/vmcs.md:123
msgid ""
"**VM-Instruction Error Field**: VMX 拡張命令でエラーコードが利用できる場合"
"に、ここにエラーコードが入る"
msgstr ""
"**VM-Instruction Error Field**: VMX 拡張命令でエラーコードが利用できる場合"
"に、ここにエラーコードが入る"

#: src/vmm/vmcs.md:124
msgid "**VM Exit は全く関係ない**"
msgstr "**VM Exit は全く関係ない**"

#: src/vmm/vmcs.md:126
msgid ""
"Read-only であることからも分かるように、このカテゴリは特に VMM が設定する必要"
"はありません。"
msgstr ""
"Read-only であることからも分かるように、このカテゴリは特に VMM が設定する必要"
"はありません。"

#: src/vmm/vmcs.md:128
msgid "VMCS Region"
msgstr "VMCS Region"

#: src/vmm/vmcs.md:130
msgid "VMCS を設定するための雛形を `Vcpu` に追加しておきます:"
msgstr "VMCS を設定するための雛形を `Vcpu` に追加しておきます:"

#: src/vmm/vmcs.md:158
msgid ""
"VMCS は **VMCS Region** と呼ばれる領域に設定します。 これは [VMXON Region](./"
"vmx_root.md#vmxon) と似たような構造を持っています:"
msgstr ""
"VMCS は **VMCS Region** と呼ばれる領域に設定します。 これは [VMXON Region](./"
"vmx_root.md#vmxon) と似たような構造を持っています:"

#: src/vmm/vmcs.md:161
msgid ""
"![Format of the VMCS Region](../assets/sdm/vmcs_region.png) _Format of the "
"VMCS Region. SDM Vol.3C 25.2 Table 25-1._"
msgstr ""
"![Format of the VMCS Region](../assets/sdm/vmcs_region.png) _Format of the "
"VMCS Region. SDM Vol.3C 25.2 Table 25-1._"

#: src/vmm/vmcs.md:164
msgid ""
"**VMCS Revision Identifier** は VMXON Region に設定した値と同じであり、 VMCS "
"のバージョン番号を表します。 この値は `IA32_VMX_BASIC` MSR から取得することが"
"できます。 VMX-Abort Indicator は本シリーズでは使いません。 その後からは "
"VMCS の設定項目が続きます。 各フィールドのレイアウトについては完全に実装依存"
"であり、VMM側で知る必要/知る方法はありません。 「レイアウトが分からないデータ"
"構造にどのように書き込むのか」については、のちほど説明します。"
msgstr ""
"**VMCS Revision Identifier** は VMXON Region に設定した値と同じであり、 VMCS "
"のバージョン番号を表します。 この値は `IA32_VMX_BASIC` MSR から取得することが"
"できます。 VMX-Abort Indicator は本シリーズでは使いません。 その後からは "
"VMCS の設定項目が続きます。 各フィールドのレイアウトについては完全に実装依存"
"であり、VMM側で知る必要/知る方法はありません。 「レイアウトが分からないデータ"
"構造にどのように書き込むのか」については、のちほど説明します。"

#: src/vmm/vmcs.md:172
msgid "VMCS Region を定義します:"
msgstr "VMCS Region を定義します:"

#: src/vmm/vmcs.md:193
msgid ""
"続いて確保した VMCS Region をセットしていきます。 VMCS は以下の遷移図で表され"
"る状態を持っています:"
msgstr ""
"続いて確保した VMCS Region をセットしていきます。 VMCS は以下の遷移図で表され"
"る状態を持っています:"

#: src/vmm/vmcs.md:196 src/vmm/vmentry_vmexit.md:84
msgid ""
"![State of VMCS X](../assets/sdm/vmcs_state.png) _State of VMCS X. SDM "
"Vol.3C 25.1 Figure 25-1._"
msgstr ""
"![State of VMCS X](../assets/sdm/vmcs_state.png) _State of VMCS X. SDM "
"Vol.3C 25.1 Figure 25-1._"

#: src/vmm/vmcs.md:199
msgid ""
"_Active_ / _Inactive_ は VMCS の状態を表します。 Active な VMCS の内、論理コ"
"アは最大で1つの **Current** VMCS を持つことができます。 Current VMCS が設定さ"
"れている場合、論理コアはその VMCS を参照して挙動が決定されます。 _Clear_ / "
"_Launched_ はその VMCS が利用されたかどうかを表します。 その VMCS を Current "
"とするコアが [VMLAUNCH](https://www.felixcloutier.com/x86/vmlaunch:vmresume) "
"命令で VM Entry すると、VMCS は Launched 状態になります。 一度 Launched に"
"なった VMCS は再度 Clear することができません。 Launched 状態の VMCS を使っ"
"て VM Entry するためには [VMRESUME](https://www.felixcloutier.com/x86/"
"vmlaunch:vmresume) 命令を使います。 VMCS が Clear と Launched のどちらなのか"
"を直接的に知る方法はありません[^launched]。 そのため、この状態はソフトウェア"
"的に記憶する必要があります。"
msgstr ""
"_Active_ / _Inactive_ は VMCS の状態を表します。 Active な VMCS の内、論理コ"
"アは最大で1つの **Current** VMCS を持つことができます。 Current VMCS が設定さ"
"れている場合、論理コアはその VMCS を参照して挙動が決定されます。 _Clear_ / "
"_Launched_ はその VMCS が利用されたかどうかを表します。 その VMCS を Current "
"とするコアが [VMLAUNCH](https://www.felixcloutier.com/x86/vmlaunch:vmresume) "
"命令で VM Entry すると、VMCS は Launched 状態になります。 一度 Launched に"
"なった VMCS は再度 Clear することができません。 Launched 状態の VMCS を使っ"
"て VM Entry するためには [VMRESUME](https://www.felixcloutier.com/x86/"
"vmlaunch:vmresume) 命令を使います。 VMCS が Clear と Launched のどちらなのか"
"を直接的に知る方法はありません[^launched]。 そのため、この状態はソフトウェア"
"的に記憶する必要があります。"

#: src/vmm/vmcs.md:209
msgid ""
"VMCS Region を設定するというのは、VMCS の状態を _Active + Current + Clear_ に"
"することを意味します。 これには以下の2命令を使います:"
msgstr ""
"VMCS Region を設定するというのは、VMCS の状態を _Active + Current + Clear_ に"
"することを意味します。 これには以下の2命令を使います:"

#: src/vmm/vmcs.md:212
msgid ""
"[VMCLEAR](https://www.felixcloutier.com/x86/vmclear) 命令: 状態を _Inactive "
"+ Not Current + Clear_ にする"
msgstr ""
"[VMCLEAR](https://www.felixcloutier.com/x86/vmclear) 命令: 状態を _Inactive "
"+ Not Current + Clear_ にする"

#: src/vmm/vmcs.md:213
msgid ""
"[VMPTRLD](https://www.felixcloutier.com/x86/vmptrld) 命令: 状態を _Active + "
"Current + Clear_ にする"
msgstr ""
"[VMPTRLD](https://www.felixcloutier.com/x86/vmptrld) 命令: 状態を _Active + "
"Current + Clear_ にする"

#: src/vmm/vmcs.md:252
msgid ""
"どちらも、引数として VMCS Region の物理アドレスをとります。 `vmxerr()` は前"
"チャプターで実装した VMX 拡張命令のエラーハンドリングをする関数です。"
msgstr ""
"どちらも、引数として VMCS Region の物理アドレスをとります。 `vmxerr()` は前"
"チャプターで実装した VMX 拡張命令のエラーハンドリングをする関数です。"

#: src/vmm/vmcs.md:255
msgid "以上を踏まえて、VMCS Region の確保・初期化は以下のようになります:"
msgstr "以上を踏まえて、VMCS Region の確保・初期化は以下のようになります:"

#: src/vmm/vmcs.md:268
msgid "`Vm.init()` から `setupVmcs()` を呼び出すようにしておきます:"
msgstr "`Vm.init()` から `setupVmcs()` を呼び出すようにしておきます:"

#: src/vmm/vmcs.md:278
msgid "フィールドアクセス"
msgstr "フィールドアクセス"

#: src/vmm/vmcs.md:280
msgid "VMCS-field Encoding"
msgstr "VMCS-field Encoding"

#: src/vmm/vmcs.md:282
msgid ""
"VMCS のフィールドレイアウトは実装依存です。 もしかしたら即値が入っているので"
"はなく圧縮・暗号化された値が入っている可能性すらあります。 それすらも VMM は"
"意識する必要がなく、知る方法もありません。"
msgstr ""
"VMCS のフィールドレイアウトは実装依存です。 もしかしたら即値が入っているので"
"はなく圧縮・暗号化された値が入っている可能性すらあります。 それすらも VMM は"
"意識する必要がなく、知る方法もありません。"

#: src/vmm/vmcs.md:286
msgid ""
"レイアウトの分からない VMCS フィールドに対する読み込みや書き込みには、VMX 拡"
"張命令である [VMREAD](https://www.felixcloutier.com/x86/vmread) / [VMWRITE]"
"(https://www.felixcloutier.com/x86/vmwrite) を使います。 これらの命令は読み書"
"き対象の VMCS のフィールドを **VMCS-field Encoding** というエンコードされた "
"32bit の値で指定します。"
msgstr ""
"レイアウトの分からない VMCS フィールドに対する読み込みや書き込みには、VMX 拡"
"張命令である [VMREAD](https://www.felixcloutier.com/x86/vmread) / [VMWRITE]"
"(https://www.felixcloutier.com/x86/vmwrite) を使います。 これらの命令は読み書"
"き対象の VMCS のフィールドを **VMCS-field Encoding** というエンコードされた "
"32bit の値で指定します。"

#: src/vmm/vmcs.md:289
msgid ""
"というわけで、VMCS のフィールドにアクセスするためには各フィールドに対する "
"encoding を定義してあげる必要があります。 32bit の encoding は以下の構成をし"
"ています:"
msgstr ""
"というわけで、VMCS のフィールドにアクセスするためには各フィールドに対する "
"encoding を定義してあげる必要があります。 32bit の encoding は以下の構成をし"
"ています:"

#: src/vmm/vmcs.md:292
msgid ""
"![Structure of VMCS Component Encoding](../assets/sdm/vmcs_encoding.png) "
"_Structure of VMCS Component Encoding. SDM Vol.3C 25.11.2 Table 25-21._"
msgstr ""
"![Structure of VMCS Component Encoding](../assets/sdm/vmcs_encoding.png) "
"_Structure of VMCS Component Encoding. SDM Vol.3C 25.11.2 Table 25-21._"

#: src/vmm/vmcs.md:295
msgid ""
"**Width** は VMCS フィールドのサイズです。 各 VMCS フィールドは _16-bit_ / "
"_32-bit_ / _64-bit_ / _Natural Width_ という4つのサイズを持ちます。"
msgstr ""
"**Width** は VMCS フィールドのサイズです。 各 VMCS フィールドは _16-bit_ / "
"_32-bit_ / _64-bit_ / _Natural Width_ という4つのサイズを持ちます。"

#: src/vmm/vmcs.md:298
msgid ""
"**Access Type** はフィールドに対するアクセス幅です。 4つあるフィールドの "
"_Width_ のうち、64-bit フィールドに限って 32bit アクセスすることができます。 "
"この場合には Access Type に `1:high` を指定します。 それ以外の場合には `0:"
"full` を指定します。"
msgstr ""
"**Access Type** はフィールドに対するアクセス幅です。 4つあるフィールドの "
"_Width_ のうち、64-bit フィールドに限って 32bit アクセスすることができます。 "
"この場合には Access Type に `1:high` を指定します。 それ以外の場合には `0:"
"full` を指定します。"

#: src/vmm/vmcs.md:303
msgid ""
"**Index** は各フィールドに割り当てられた番号です。 この値は _Access Type_ / "
"_Type_ / _Width_ が同じフィールドの中でユニークに割り振られています。 逆に言"
"うと、異なる _Type_ 等を持つフィールドは同じ _Index_ を持っている場合がありま"
"す。"
msgstr ""
"**Index** は各フィールドに割り当てられた番号です。 この値は _Access Type_ / "
"_Type_ / _Width_ が同じフィールドの中でユニークに割り振られています。 逆に言"
"うと、異なる _Type_ 等を持つフィールドは同じ _Index_ を持っている場合がありま"
"す。"

#: src/vmm/vmcs.md:307
msgid ""
"**Type** はフィールドのカテゴリです。 6つあるカテゴリの内、VM-Execution "
"Control / VM-Entry Control / VM-Entry Control はまとめて _control_ というタイ"
"プになっています。"
msgstr ""
"**Type** はフィールドのカテゴリです。 6つあるカテゴリの内、VM-Execution "
"Control / VM-Entry Control / VM-Entry Control はまとめて _control_ というタイ"
"プになっています。"

#: src/vmm/vmcs.md:310
msgid ""
"各フィールドに対する Encoding の内容は _SDM Appendix B FIELD ENCODING IN "
"VMCS_ に記載されています。 そのリストをもとに各フィールドの encoding を計算す"
"るヘルパー関数を定義します[^encoding]:"
msgstr ""
"各フィールドに対する Encoding の内容は _SDM Appendix B FIELD ENCODING IN "
"VMCS_ に記載されています。 そのリストをもとに各フィールドの encoding を計算す"
"るヘルパー関数を定義します[^encoding]:"

#: src/vmm/vmcs.md:380
msgid ""
"`eg()` / `eh()` / `ec()` / `er()` はそれぞれの _Type_ に対する encoding を計"
"算する関数です。 これらのヘルパー関数を使うと、フィールドの encoding を定義す"
"ることができます。 しかし、フィールドの数はとても多いです。 200 個ほどありま"
"す。 そのため、ここで定義部分のスニペットを載せることはしないでおきます。 全"
"フィールドの encoding 定義は [Ymir のリポジトリを参照](https://github.com/"
"smallkirby/ymir/blob/master/ymir/arch/x86/vmx/vmcs.zig) してください。"
msgstr ""
"`eg()` / `eh()` / `ec()` / `er()` はそれぞれの _Type_ に対する encoding を計"
"算する関数です。 これらのヘルパー関数を使うと、フィールドの encoding を定義す"
"ることができます。 しかし、フィールドの数はとても多いです。 200 個ほどありま"
"す。 そのため、ここで定義部分のスニペットを載せることはしないでおきます。 全"
"フィールドの encoding 定義は [Ymir のリポジトリを参照](https://github.com/"
"smallkirby/ymir/blob/master/ymir/arch/x86/vmx/vmcs.zig) してください。"

#: src/vmm/vmcs.md:470
msgid "地獄コードですね。"
msgstr "地獄コードですね。"

#: src/vmm/vmcs.md:474
msgid "VMREAD / VMWRITE"
msgstr "VMREAD / VMWRITE"

#: src/vmm/vmcs.md:476
msgid ""
"VMCS encoding が定義できたため、VMCS フィールドにアクセスするための関数を定義"
"します。 まずは [VMREAD](https://www.felixcloutier.com/x86/vmread) です。 引"
"数として encoding を受取り、読み取ったフィールドの値を返します。 本来であれば"
"フィールドの _Width_ に応じて適切な型を返すべきですが、面倒なので全て一律 "
"64bit としています。 また、VMREAD 自体が VMX 拡張命令であるため RFLAGS を使っ"
"たエラーハンドリングをしています:"
msgstr ""
"VMCS encoding が定義できたため、VMCS フィールドにアクセスするための関数を定義"
"します。 まずは [VMREAD](https://www.felixcloutier.com/x86/vmread) です。 引"
"数として encoding を受取り、読み取ったフィールドの値を返します。 本来であれば"
"フィールドの _Width_ に応じて適切な型を返すべきですが、面倒なので全て一律 "
"64bit としています。 また、VMREAD 自体が VMX 拡張命令であるため RFLAGS を使っ"
"たエラーハンドリングをしています:"

#: src/vmm/vmcs.md:499
msgid ""
"続いて [VMWRITE](https://www.felixcloutier.com/x86/vmwrite) です。 VMWRITE は"
"引数として encoding と書き込む値を受け取りますが、書き込む値は `anytype` とし"
"ています。 これは、VMWRITE に対して `packed struct (u64)` のような Packed "
"Struct を渡したい場面が多く、その都度 `@bitCast()` を呼ぶ手間を省くためです:"
msgstr ""
"続いて [VMWRITE](https://www.felixcloutier.com/x86/vmwrite) です。 VMWRITE は"
"引数として encoding と書き込む値を受け取りますが、書き込む値は `anytype` とし"
"ています。 これは、VMWRITE に対して `packed struct (u64)` のような Packed "
"Struct を渡したい場面が多く、その都度 `@bitCast()` を呼ぶ手間を省くためです:"

#: src/vmm/vmcs.md:533
msgid ""
"さて、VMCS encoding を定義したり、VMCS をセットすることはできましたが、その中"
"身はまだ空っぽです。 でも VMCS をセットすることができたのは嬉しいです。 こう"
"いう小さいことで喜んでいないと、世の中やっていけないですよね。 小さな幸せでと"
"りあえず大騒ぎするのはおすすめです。 [嬉しい！楽しい！](https://www.uta-net."
"com/song/838/) というわけで、**嬉しいので一旦このまま VMLAUNCH してしまいま"
"しょう**。 どうせ失敗するだろうけど、こちとら VMCS をセットしたので。 どんな"
"文句を言われるのか見てやりましょう:"
msgstr ""
"さて、VMCS encoding を定義したり、VMCS をセットすることはできましたが、その中"
"身はまだ空っぽです。 でも VMCS をセットすることができたのは嬉しいです。 こう"
"いう小さいことで喜んでいないと、世の中やっていけないですよね。 小さな幸せでと"
"りあえず大騒ぎするのはおすすめです。 [嬉しい！楽しい！](https://www.uta-net."
"com/song/838/) というわけで、**嬉しいので一旦このまま VMLAUNCH してしまいま"
"しょう**。 どうせ失敗するだろうけど、こちとら VMCS をセットしたので。 どんな"
"文句を言われるのか見てやりましょう:"

#: src/vmm/vmcs.md:551
msgid "このまま実行すると...。 何も言われません。"
msgstr "このまま実行すると...。 何も言われません。"

#: src/vmm/vmcs.md:554
msgid ""
"これは [前チャプター](./vmx_root.md#vmx-instruction-error) で扱ったように、 "
"**VMX 拡張命令である VMLAUNCH は失敗した場合に例外ではなく独自の方法でエラー"
"を返す**ためです。 単に VMLAUNCH を呼ぶのではなく、このエラーをチェックしてあ"
"げましょう:"
msgstr ""
"これは [前チャプター](./vmx_root.md#vmx-instruction-error) で扱ったように、 "
"**VMX 拡張命令である VMLAUNCH は失敗した場合に例外ではなく独自の方法でエラー"
"を返す**ためです。 単に VMLAUNCH を呼ぶのではなく、このエラーをチェックしてあ"
"げましょう:"

#: src/vmm/vmcs.md:578
msgid ""
"これは `RFLAGS.ZF` がセットされており、**エラーコードを利用可能であることを示"
"しています**。 エラーコードは VMCS の **VM-Exit Information** 内の **VM-"
"Instruction Error Field** に格納されています。 エラーコードに対応する `enum` "
"と、VM-Instruction Error Field からエラーコードを取得するヘルパー関数を作りま"
"す。 エラー番号の一覧と説明は _SDM Vol.3C 31.4 VM INSTRUCTION ERROR NUMBERS_ "
"を参照してください:"
msgstr ""
"これは `RFLAGS.ZF` がセットされており、**エラーコードを利用可能であることを示"
"しています**。 エラーコードは VMCS の **VM-Exit Information** 内の **VM-"
"Instruction Error Field** に格納されています。 エラーコードに対応する `enum` "
"と、VM-Instruction Error Field からエラーコードを取得するヘルパー関数を作りま"
"す。 エラー番号の一覧と説明は _SDM Vol.3C 31.4 VM INSTRUCTION ERROR NUMBERS_ "
"を参照してください:"

#: src/vmm/vmcs.md:620
msgid ""
"`load()` が VMCS からエラーコードを取得する関数です。 VMREAD の初めての出番で"
"すね。かわいい。"
msgstr ""
"`load()` が VMCS からエラーコードを取得する関数です。 VMREAD の初めての出番で"
"すね。かわいい。"

#: src/vmm/vmcs.md:652
msgid "さて、VMLAUNCH 後にエラーコードを取得してみましょう:"
msgstr "さて、VMLAUNCH 後にエラーコードを取得してみましょう:"

#: src/vmm/vmcs.md:670
msgid ""
"**エラー番号7番 VM entry with invalid control fields**　です。 このエラーは開"
"発中に少なく見積もっても8000億回は見ることでしょう。 これは、VMCS の VM-"
"Entry Control に不正な値が設定されていることを示しています。 VMLAUNCH や "
"VMRESUME は、VM Entry する前に VMCS の各カテゴリの中身がしっかり設定されてい"
"るかをチェックします。 もしも1つでも不正な値が設定されている場合には VM "
"Entry に失敗します[^vmentry]。 しかも**具体的にどこがおかしいのかは一切教えて"
"くれません**。 検査項目自体は100以上ある[^check]ため、どこがおかしいのかを特"
"定するのは非常に大変です。 筆者は[チェック項目を1つずつコードに書き起こし]"
"(https://github.com/smallkirby/ymir/blob/master/ymir/arch/x86/vmx/dbg.zig)、"
"デバッグビルドのときだけ実行するようにしました。 皆さんはそもそもエラーが発生"
"しないようにコーディングしてあげてください。 まぁそれでもこのエラーは出ると思"
"いますが。 そのときには、ちゃんと苦しんでください。"
msgstr ""
"**エラー番号7番 VM entry with invalid control fields**　です。 このエラーは開"
"発中に少なく見積もっても8000億回は見ることでしょう。 これは、VMCS の VM-"
"Entry Control に不正な値が設定されていることを示しています。 VMLAUNCH や "
"VMRESUME は、VM Entry する前に VMCS の各カテゴリの中身がしっかり設定されてい"
"るかをチェックします。 もしも1つでも不正な値が設定されている場合には VM "
"Entry に失敗します[^vmentry]。 しかも**具体的にどこがおかしいのかは一切教えて"
"くれません**。 検査項目自体は100以上ある[^check]ため、どこがおかしいのかを特"
"定するのは非常に大変です。 筆者は[チェック項目を1つずつコードに書き起こし]"
"(https://github.com/smallkirby/ymir/blob/master/ymir/arch/x86/vmx/dbg.zig)、"
"デバッグビルドのときだけ実行するようにしました。 皆さんはそもそもエラーが発生"
"しないようにコーディングしてあげてください。 まぁそれでもこのエラーは出ると思"
"いますが。 そのときには、ちゃんと苦しんでください。"

#: src/vmm/vmcs.md:684
msgid ""
"本チャプターでは VMCS の6つのカテゴリについてそれぞれの役割を大まかに説明しま"
"した。 VMCS のレイアウトは実装依存であり、フィールドにアクセスするためには "
"encoding を指定する必要があることを確認し、 encoding の定義と VMREAD/VMWIRE "
"のヘルパー関数を定義しました。 また、VMCS が持つ状態について確認し、VMCS を現"
"在の論理コアにセットしました。 まだ VMCS はまっさらな状態ですが、試しに "
"VMLAUNCH してみてエラーが発生することを確認しました。 その過程で実際に VMCS "
"からフィールドを読み出すことにも成功しました。"
msgstr ""
"本チャプターでは VMCS の6つのカテゴリについてそれぞれの役割を大まかに説明しま"
"した。 VMCS のレイアウトは実装依存であり、フィールドにアクセスするためには "
"encoding を指定する必要があることを確認し、 encoding の定義と VMREAD/VMWIRE "
"のヘルパー関数を定義しました。 また、VMCS が持つ状態について確認し、VMCS を現"
"在の論理コアにセットしました。 まだ VMCS はまっさらな状態ですが、試しに "
"VMLAUNCH してみてエラーが発生することを確認しました。 その過程で実際に VMCS "
"からフィールドを読み出すことにも成功しました。"

#: src/vmm/vmcs.md:691
msgid ""
"最後にはエラーについて不穏な説明をしましたが、次チャプター以降は実際に VMCS "
"に値をセットしていきます。 ひとまずは VMX Non-root Operation に遷移し、適当な"
"1命令を実行できるようにすることを目的にしましょう。"
msgstr ""
"最後にはエラーについて不穏な説明をしましたが、次チャプター以降は実際に VMCS "
"に値をセットしていきます。 ひとまずは VMX Non-root Operation に遷移し、適当な"
"1命令を実行できるようにすることを目的にしましょう。"

#: src/vmm/vmcs.md:694
msgid ""
"VMLAUNCH 命令を実行してみてエラーが発生したら Launched であると判断することは"
"できます。"
msgstr ""
"VMLAUNCH 命令を実行してみてエラーが発生したら Launched であると判断することは"
"できます。"

#: src/vmm/vmcs.md:695
msgid ""
"これらの関数呼び出しは全て `comptime` です。ランタイムオーバーヘッドはありま"
"せん。"
msgstr ""
"これらの関数呼び出しは全て `comptime` です。ランタイムオーバーヘッドはありま"
"せん。"

#: src/vmm/vmcs.md:696
msgid ""
"この理由で VM Entry が失敗する場合、VM Entry 自体が実行されないため VM Exit "
"ではなく単なる命令の失敗として扱われます。"
msgstr ""
"この理由で VM Entry が失敗する場合、VM Entry 自体が実行されないため VM Exit "
"ではなく単なる命令の失敗として扱われます。"

#: src/vmm/vmcs.md:697
msgid "_SDM Vol.3C CHAPTER 27. VMENTRIES_"
msgstr "_SDM Vol.3C CHAPTER 27. VMENTRIES_"

#: src/vmm/vmlaunch.md:1
msgid "VMLAUNCH: Restricted Guest の実行"
msgstr "VMLAUNCH: Restricted Guest の実行"

#: src/vmm/vmlaunch.md:3
msgid ""
"前チャプターでは VMCS を現在のコアにセットし、中身は未設定のまま VMLAUNCH を"
"してエラーが発生することを確認しました。 本チャプターでは VMCS を適切に設定し"
"て VMLAUNCH を実行します。 それにより VMX Non-root Operation でゲストが実行で"
"きることを目標とします。"
msgstr ""
"前チャプターでは VMCS を現在のコアにセットし、中身は未設定のまま VMLAUNCH を"
"してエラーが発生することを確認しました。 本チャプターでは VMCS を適切に設定し"
"て VMLAUNCH を実行します。 それにより VMX Non-root Operation でゲストが実行で"
"きることを目標とします。"

#: src/vmm/vmlaunch.md:9
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-vmlaunch`](https://"
#| "github.com/smallkirby/ymir/tree/whiz-vmm-vmlaunch) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-vmm-vmlaunch`](https://github.com/"
"smallkirby/ymir/tree/whiz-vmm-vmlaunch) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-vmlaunch`](https://"
"github.com/smallkirby/ymir/tree/whiz-vmm-vmlaunch) ブランチにあります。"

#: src/vmm/vmlaunch.md:13
msgid "[本チャプターの概要](#本チャプターの概要)"
msgstr "[本チャプターの概要](#本チャプターの概要)"

#: src/vmm/vmlaunch.md:15
msgid "[Pin-Based Controls](#pin-based-controls)"
msgstr "[Pin-Based Controls](#pin-based-controls)"

#: src/vmm/vmlaunch.md:16
msgid "[Primary Processor-Based Controls](#primary-processor-based-controls)"
msgstr "[Primary Processor-Based Controls](#primary-processor-based-controls)"

#: src/vmm/vmlaunch.md:18
msgid "[Control Registers](#control-registers)"
msgstr "[Control Registers](#control-registers)"

#: src/vmm/vmlaunch.md:19
msgid "[RIP / RSP](#rip--rsp)"
msgstr "[RIP / RSP](#rip--rsp)"

#: src/vmm/vmlaunch.md:20
msgid "[セグメントレジスタ](#セグメントレジスタ)"
msgstr "[セグメントレジスタ](#セグメントレジスタ)"

#: src/vmm/vmlaunch.md:23
msgid "[Control Registers](#control-registers-1)"
msgstr "[Control Registers](#control-registers-1)"

#: src/vmm/vmlaunch.md:24
msgid "[セグメントレジスタ](#セグメントレジスタ-1)"
msgstr "[セグメントレジスタ](#セグメントレジスタ-1)"

#: src/vmm/vmlaunch.md:25
msgid "[RIP / RSP / MSR / RFLAGS など](#rip--rsp--msr--rflags-など)"
msgstr "[RIP / RSP / MSR / RFLAGS など](#rip--rsp--msr--rflags-など)"

#: src/vmm/vmlaunch.md:28
msgid "[VMLAUNCH](#vmlaunch)"
msgstr "[VMLAUNCH](#vmlaunch)"

#: src/vmm/vmlaunch.md:31
msgid "本チャプターの概要"
msgstr "本チャプターの概要"

#: src/vmm/vmlaunch.md:33
msgid ""
"本シリーズの最終的な目標は Linux をブートし、シェルを動かすことです。 しか"
"し、いきなり Linux が動くように設定することは難しいため、本チャプターではとり"
"あえずゲストに遷移することを目標にします。 ゲストに遷移するためには VMCS の6"
"カテゴリの内、read-only な VM-Exit Information カテゴリを除く5カテゴリを適切"
"に設定する必要があります。"
msgstr ""
"本シリーズの最終的な目標は Linux をブートし、シェルを動かすことです。 しか"
"し、いきなり Linux が動くように設定することは難しいため、本チャプターではとり"
"あえずゲストに遷移することを目標にします。 ゲストに遷移するためには VMCS の6"
"カテゴリの内、read-only な VM-Exit Information カテゴリを除く5カテゴリを適切"
"に設定する必要があります。"

#: src/vmm/vmlaunch.md:37
msgid "まずは本チャプターにおいてゲストとして実行する関数を定義します:"
msgstr "まずは本チャプターにおいてゲストとして実行する関数を定義します:"

#: src/vmm/vmlaunch.md:46
msgid ""
"Calling Convention は `.Naked` にしています。 本チャプターではゲストに有効な "
"RSP を設定しないため、関数のプロローグで RSP への PUSH 等が行われるとフォルト"
"が発生してしまうためです。 この関数はただひたすらに HLT ループをします。 面白"
"みのない関数ですが、これで VMX Non-root Operation に遷移できるかどうかを確か"
"めていきます。"
msgstr ""
"Calling Convention は `.Naked` にしています。 本チャプターではゲストに有効な "
"RSP を設定しないため、関数のプロローグで RSP への PUSH 等が行われるとフォルト"
"が発生してしまうためです。 この関数はただひたすらに HLT ループをします。 面白"
"みのない関数ですが、これで VMX Non-root Operation に遷移できるかどうかを確か"
"めていきます。"

#: src/vmm/vmlaunch.md:51
msgid ""
"ページングやセグメンテーションに関して、本チャプターで扱うゲストでは以下の設"
"定で動作させます。 感覚としてはゲストを動かすと言うよりも **Ymir をそのまま "
"VMX Non-root Operation に遷移させるような感じ**です:"
msgstr ""
"ページングやセグメンテーションに関して、本チャプターで扱うゲストでは以下の設"
"定で動作させます。 感覚としてはゲストを動かすと言うよりも **Ymir をそのまま "
"VMX Non-root Operation に遷移させるような感じ**です:"

#: src/vmm/vmlaunch.md:54
msgid "**Restricted Guest**: ページングをすることが強制されるモード"
msgstr "**Restricted Guest**: ページングをすることが強制されるモード"

#: src/vmm/vmlaunch.md:55
msgid "IA-32e 64bit mode (Long Mode)"
msgstr "IA-32e 64bit mode (Long Mode)"

#: src/vmm/vmlaunch.md:56
msgid "GDT / ページテーブル はホストと共有する"
msgstr "GDT / ページテーブル はホストと共有する"

#: src/vmm/vmlaunch.md:57
msgid "その他の重要なレジスタ等についてもホストと共有する"
msgstr "その他の重要なレジスタ等についてもホストと共有する"

#: src/vmm/vmlaunch.md:61
msgid ""
"まずは VM-Execution Control カテゴリを設定します。 これは VMX Non-root "
"Operation におけるプロセッサの挙動を制御するフィールドです。 本チャプターで"
"は Execution Control における2つのフィールドを設定します。"
msgstr ""
"まずは VM-Execution Control カテゴリを設定します。 これは VMX Non-root "
"Operation におけるプロセッサの挙動を制御するフィールドです。 本チャプターで"
"は Execution Control における2つのフィールドを設定します。"

#: src/vmm/vmlaunch.md:65
msgid "Pin-Based Controls"
msgstr "Pin-Based Controls"

#: src/vmm/vmlaunch.md:67
msgid ""
"**Pin-Based VM-Execution Controls**[^pbec] (以下 _Pin-Based Controls_) は例外"
"などの非同期イベントを制御する 32bit のデータ構造です:"
msgstr ""
"**Pin-Based VM-Execution Controls**[^pbec] (以下 _Pin-Based Controls_) は例外"
"などの非同期イベントを制御する 32bit のデータ構造です:"

#: src/vmm/vmlaunch.md:99
msgid ""
"各フィールドの意味は実際にそのフィールドを使うときが来たら説明します。 この構"
"造体には、VMCS から値を取得またはセットするためのメソッド `load()` / "
"`store()` を定義しています。 `ctrl` 列挙型は [Github](https://github.com/"
"smallkirby/ymir/blob/whiz-vmm-vmlaunch/ymir/arch/x86/vmx/vmcs.zig) を参照して"
"ください。"
msgstr ""
"各フィールドの意味は実際にそのフィールドを使うときが来たら説明します。 この構"
"造体には、VMCS から値を取得またはセットするためのメソッド `load()` / "
"`store()` を定義しています。 `ctrl` 列挙型は [Github](https://github.com/"
"smallkirby/ymir/blob/whiz-vmm-vmlaunch/ymir/arch/x86/vmx/vmcs.zig) を参照して"
"ください。"

#: src/vmm/vmlaunch.md:187
msgid ""
"Execution Control を設定する関数において Pin-Based Controls を設定します:"
msgstr ""
"Execution Control を設定する関数において Pin-Based Controls を設定します:"

#: src/vmm/vmlaunch.md:204
msgid ""
"本チャプターではまだ非同期イベントを扱わないため、Pin-Based Controls はデフォ"
"ルトの値を使用します。"
msgstr ""
"本チャプターではまだ非同期イベントを扱わないため、Pin-Based Controls はデフォ"
"ルトの値を使用します。"

#: src/vmm/vmlaunch.md:206
msgid ""
"VMCS に書き込む値には **Reserved Bits** が多くあります。 Reserved Bits は単に"
"ゼロクリアすれば良いわけではありません。 **フィールドごとに適切な MSR を参照"
"し、その値をもとにして Reserved Bits を設定する必要**があります。 Pin-Based "
"Controls では、`IA32_VMX_BASIC` MSR の 55-th bit (`.true_control`) の値に応じ"
"て `IA32_VMX_PINBASED_CTRLS`(address: `0x0482`) または "
"`IA32_VMX_TRUE_PINBASED_CTRLS` (address: `0x048E`) の値を使用します。 これら"
"の MSR は Pin-Based Controls に対して以下のような制約を課します:"
msgstr ""
"VMCS に書き込む値には **Reserved Bits** が多くあります。 Reserved Bits は単に"
"ゼロクリアすれば良いわけではありません。 **フィールドごとに適切な MSR を参照"
"し、その値をもとにして Reserved Bits を設定する必要**があります。 Pin-Based "
"Controls では、`IA32_VMX_BASIC` MSR の 55-th bit (`.true_control`) の値に応じ"
"て `IA32_VMX_PINBASED_CTRLS`(address: `0x0482`) または "
"`IA32_VMX_TRUE_PINBASED_CTRLS` (address: `0x048E`) の値を使用します。 これら"
"の MSR は Pin-Based Controls に対して以下のような制約を課します:"

#: src/vmm/vmlaunch.md:213
msgid ""
"**\\[31:0\\]: Allowed 0-settings**: MSR のビットが `1` である場合、VMCS "
"フィールドの該当ビットは `1` でなければならない (_Manadatory 1_)"
msgstr ""
"**\\[31:0\\]: Allowed 0-settings**: MSR のビットが `1` である場合、VMCS "
"フィールドの該当ビットは `1` でなければならない (_Manadatory 1_)"

#: src/vmm/vmlaunch.md:214
msgid ""
"**\\[63:32\\]: Allowed 1-settings**: MSR のビットが `0` である場合、VMCS "
"フィールドの該当ビットは `0` でなければならない (_Manadatory 0_)"
msgstr ""
"**\\[63:32\\]: Allowed 1-settings**: MSR のビットが `0` である場合、VMCS "
"フィールドの該当ビットは `0` でなければならない (_Manadatory 0_)"

#: src/vmm/vmlaunch.md:216
msgid ""
"今後も _Allowed 0/1-settings_ は頻繁に登場するため、VMCS フィールドに対してこ"
"れらの settings を適用するヘルパー関数を用意します:"
msgstr ""
"今後も _Allowed 0/1-settings_ は頻繁に登場するため、VMCS フィールドに対してこ"
"れらの settings を適用するヘルパー関数を用意します:"

#: src/vmm/vmlaunch.md:228
msgid ""
"`setupExecCtrls()` ではこのヘルパー関数を使い、`IA32_VMX_PINBASED_CTRLS` また"
"は `IA32_VMX_TRUE_PINBASED_CTRLS` が課す制約を Pin-Based Controls に適用して"
"います。"
msgstr ""
"`setupExecCtrls()` ではこのヘルパー関数を使い、`IA32_VMX_PINBASED_CTRLS` また"
"は `IA32_VMX_TRUE_PINBASED_CTRLS` が課す制約を Pin-Based Controls に適用して"
"います。"

#: src/vmm/vmlaunch.md:230
msgid "Primary Processor-Based Controls"
msgstr "Primary Processor-Based Controls"

#: src/vmm/vmlaunch.md:232
msgid ""
"**Processor-Based VM-Execution Controls**[^pp] (以下 _Processor-Based "
"Controls_) は同期イベント(特定の命令の実行など) を制御するデータ構造です。 "
"**Primary Processor-Based Controls** (32bits) と **Secondary Processor-Based "
"Controls** (64bits) の2つがあります。 本チャプターでは Primary の方だけを設定"
"します:"
msgstr ""
"**Processor-Based VM-Execution Controls**[^pp] (以下 _Processor-Based "
"Controls_) は同期イベント(特定の命令の実行など) を制御するデータ構造です。 "
"**Primary Processor-Based Controls** (32bits) と **Secondary Processor-Based "
"Controls** (64bits) の2つがあります。 本チャプターでは Primary の方だけを設定"
"します:"

#: src/vmm/vmlaunch.md:282
msgid ""
"同様に `setupExecCtrls()` で Primary Processor-Based Controls を設定します:"
msgstr ""
"同様に `setupExecCtrls()` で Primary Processor-Based Controls を設定します:"

#: src/vmm/vmlaunch.md:298
msgid ""
"`.hlt` は [HLT](https://www.felixcloutier.com/x86/hlt) 命令時に VMExit するか"
"どうかを設定します。 今回は `blobGuest()` で HLT ループをしたいため、`false` "
"に設定します。 `.activate_secondary_controls` は Secondary Processor-Based "
"Controls を有効にするかどうかを設定します。 今回は Primary Processor-Based "
"Controls のみを使いたいため、`false` に設定します。"
msgstr ""
"`.hlt` は [HLT](https://www.felixcloutier.com/x86/hlt) 命令時に VMExit するか"
"どうかを設定します。 今回は `blobGuest()` で HLT ループをしたいため、`false` "
"に設定します。 `.activate_secondary_controls` は Secondary Processor-Based "
"Controls を有効にするかどうかを設定します。 今回は Primary Processor-Based "
"Controls のみを使いたいため、`false` に設定します。"

#: src/vmm/vmlaunch.md:303
msgid ""
"Pin-Based Controls と同様に、Reserved Bits は MSR を参照して設定する必要があ"
"ります。 利用する MSR は `IA32_VMX_PROCBASED_CTRLS` (address: `0x0482`) また"
"は `IA32_VMX_TRUE_PROCBASED_CTRLS` (address: `0x048E`) のどちらかです。"
msgstr ""
"Pin-Based Controls と同様に、Reserved Bits は MSR を参照して設定する必要があ"
"ります。 利用する MSR は `IA32_VMX_PROCBASED_CTRLS` (address: `0x0482`) また"
"は `IA32_VMX_TRUE_PROCBASED_CTRLS` (address: `0x048E`) のどちらかです。"

#: src/vmm/vmlaunch.md:308
msgid ""
"続いて Host-State カテゴリを設定します。 このカテゴリは VM Exit した際のホス"
"トの状態を制御します。"
msgstr ""
"続いて Host-State カテゴリを設定します。 このカテゴリは VM Exit した際のホス"
"トの状態を制御します。"

#: src/vmm/vmlaunch.md:313
msgid ""
"Control Registers は VM Exit した際の CR0, CR3, CR4 の値を制御します。 本シ"
"リーズでは VM Exit 後のホストの状態は VMLAUNCH 直前の状態と同じにしたいため、"
"現在のホストの状態をそのまま設定します:"
msgstr ""
"Control Registers は VM Exit した際の CR0, CR3, CR4 の値を制御します。 本シ"
"リーズでは VM Exit 後のホストの状態は VMLAUNCH 直前の状態と同じにしたいため、"
"現在のホストの状態をそのまま設定します:"

#: src/vmm/vmlaunch.md:327
msgid "RIP / RSP"
msgstr "RIP / RSP"

#: src/vmm/vmlaunch.md:329
msgid ""
"この2つのフィールドは VM Exit 直後に VMM のレジスタにセットされ、実行コンテキ"
"ストを復元します。 今はとりあえずゲストを動かすことが目標であるため、一時的な"
"値をセットします:"
msgstr ""
"この2つのフィールドは VM Exit 直後に VMM のレジスタにセットされ、実行コンテキ"
"ストを復元します。 今はとりあえずゲストを動かすことが目標であるため、一時的な"
"値をセットします:"

#: src/vmm/vmlaunch.md:339
msgid ""
"`vmexitBootstrapHandler()` は簡易的な VM Exit ハンドラです。 とりあえずログ出"
"力と **VM Exit Reason** だけを出力して HLT ループに入ります。 VMM はまだレジ"
"スタの復元をしていないことに注意してください。 この関数が呼び出された時点で "
"RBP やその他の汎用レジスタは一切セットされていません。 そのため、この関数は関"
"数のプロローグを消すために `.Naked` calling convention を使っています:"
msgstr ""
"`vmexitBootstrapHandler()` は簡易的な VM Exit ハンドラです。 とりあえずログ出"
"力と **VM Exit Reason** だけを出力して HLT ループに入ります。 VMM はまだレジ"
"スタの復元をしていないことに注意してください。 この関数が呼び出された時点で "
"RBP やその他の汎用レジスタは一切セットされていません。 そのため、この関数は関"
"数のプロローグを消すために `.Naked` calling convention を使っています:"

#: src/vmm/vmlaunch.md:364
msgid ""
"`ExitInfo` は VM Exit Reason を表す `enum` です。 VM Exit が発生すると、その"
"原因は VMCS VM-Exit Information カテゴリの Basic VM-Exit Information フィール"
"ドに格納されます。 この値を確認することで、VM Exit の大まかな原因が特定できま"
"す。 `load()` はこのフィールドから値を取得します。 実装が気になる人は以下を展"
"開して確認してください:"
msgstr ""
"`ExitInfo` は VM Exit Reason を表す `enum` です。 VM Exit が発生すると、その"
"原因は VMCS VM-Exit Information カテゴリの Basic VM-Exit Information フィール"
"ドに格納されます。 この値を確認することで、VM Exit の大まかな原因が特定できま"
"す。 `load()` はこのフィールドから値を取得します。 実装が気になる人は以下を展"
"開して確認してください:"

#: src/vmm/vmlaunch.md:504 src/vmm/vmlaunch.md:669
msgid "セグメントレジスタ"
msgstr "セグメントレジスタ"

#: src/vmm/vmlaunch.md:506
msgid "セグメントレジスタは以下の2つの種類を設定します:"
msgstr "セグメントレジスタは以下の2つの種類を設定します:"

#: src/vmm/vmlaunch.md:508
msgid "CS / SS / DS / ES / FS / GS / TR のセグメントセレクタ"
msgstr "CS / SS / DS / ES / FS / GS / TR のセグメントセレクタ"

#: src/vmm/vmlaunch.md:509
msgid "FS / GS / TR / GDTR / IDTR の Base (LDTRの設定は無い)"
msgstr "FS / GS / TR / GDTR / IDTR の Base (LDTRの設定は無い)"

#: src/vmm/vmlaunch.md:511
msgid ""
"一部のセグメントレジスタはセレクタのみを指定し、それ以外は Base も含めて設定"
"することに注意してください。 [GDTのチャプター](../kernel/gdt.md) で説明したよ"
"うにアドレス変換に使われることのないセグメントレジスタ(前者)ではセレクタのみ"
"を設定し、 実際にアドレス変換に使われる場合には Base まで指定するという区別で"
"あると推測されます。 GDTR / IDTR はそもそも Base しか持たないため、セレクタは"
"指定できません:"
msgstr ""
"一部のセグメントレジスタはセレクタのみを指定し、それ以外は Base も含めて設定"
"することに注意してください。 [GDTのチャプター](../kernel/gdt.md) で説明したよ"
"うにアドレス変換に使われることのないセグメントレジスタ(前者)ではセレクタのみ"
"を設定し、 実際にアドレス変換に使われる場合には Base まで指定するという区別で"
"あると推測されます。 GDTR / IDTR はそもそも Base しか持たないため、セレクタは"
"指定できません:"

#: src/vmm/vmlaunch.md:538
msgid "セグメントレジスタのセレクタは以下のアセンブリ関数で取得します:"
msgstr "セグメントレジスタのセレクタは以下のアセンブリ関数で取得します:"

#: src/vmm/vmlaunch.md:583
msgid ""
"TR と LDTR 以外は全て MOV 命令で直接取得できます[^seg-sel]。 TR と LDTR はそ"
"れぞれ専用の命令である [STR](https://www.felixcloutier.com/x86/str) と [SLDT]"
"(https://www.felixcloutier.com/x86/sldt) を使用して取得します。"
msgstr ""
"TR と LDTR 以外は全て MOV 命令で直接取得できます[^seg-sel]。 TR と LDTR はそ"
"れぞれ専用の命令である [STR](https://www.felixcloutier.com/x86/str) と [SLDT]"
"(https://www.felixcloutier.com/x86/sldt) を使用して取得します。"

#: src/vmm/vmlaunch.md:586
msgid ""
"FS と GS の Base はハードウェア的に `IA32_FS_BASE` と `IA32_GS_BASE` という "
"MSR にマップされています。 そのため、これらの Base は MSR から値を読むことで"
"取得できます。 GDTR と IDTR の Base はそれぞれ [SGDT](https://www."
"felixcloutier.com/x86/sgdt) と [SIDT](https://www.felixcloutier.com/x86/"
"sidt) 命令で取得できます。"
msgstr ""
"FS と GS の Base はハードウェア的に `IA32_FS_BASE` と `IA32_GS_BASE` という "
"MSR にマップされています。 そのため、これらの Base は MSR から値を読むことで"
"取得できます。 GDTR と IDTR の Base はそれぞれ [SGDT](https://www."
"felixcloutier.com/x86/sgdt) と [SIDT](https://www.felixcloutier.com/x86/"
"sidt) 命令で取得できます。"

#: src/vmm/vmlaunch.md:628
msgid ""
"一部の MSR は VM Exit の際にハードウェア的にセットすることができます。 この "
"MSR は以下を含みます (全てではありません):"
msgstr ""
"一部の MSR は VM Exit の際にハードウェア的にセットすることができます。 この "
"MSR は以下を含みます (全てではありません):"

#: src/vmm/vmlaunch.md:631
msgid "`IA32_SYSENTER_CS` / `IA32_SYSENTER_ESP` / `IA32_SYSENTER_EIP`"
msgstr "`IA32_SYSENTER_CS` / `IA32_SYSENTER_ESP` / `IA32_SYSENTER_EIP`"

#: src/vmm/vmlaunch.md:632 src/vmm/msr.md:80 src/vmm/msr.md:100
#: src/vmm/msr.md:113 src/vmm/msr.md:129
msgid "`IA32_EFER`"
msgstr "`IA32_EFER`"

#: src/vmm/vmlaunch.md:633 src/vmm/msr.md:79 src/vmm/msr.md:99
#: src/vmm/msr.md:112 src/vmm/msr.md:128
msgid "`IA32_PAT`"
msgstr "`IA32_PAT`"

#: src/vmm/vmlaunch.md:635
msgid ""
"本シリーズではシステムコールを実装しないため、`SYSENTER` 系のMSRは復元する必"
"要がありません。 `IA32_PAT` はページのキャッシュ属性を定義することができる "
"MSR ですがやはり本シリーズでは使いません。 `IA32_EFER` (address: "
"`0xC0000080`) は 64bit モードの有効化等に必須の MSR であるため、この MSR だけ"
"設定します:"
msgstr ""
"本シリーズではシステムコールを実装しないため、`SYSENTER` 系のMSRは復元する必"
"要がありません。 `IA32_PAT` はページのキャッシュ属性を定義することができる "
"MSR ですがやはり本シリーズでは使いません。 `IA32_EFER` (address: "
"`0xC0000080`) は 64bit モードの有効化等に必須の MSR であるため、この MSR だけ"
"設定します:"

#: src/vmm/vmlaunch.md:650
msgid ""
"続いて Guest-State カテゴリを設定します。 このカテゴリは VM Entry した際のゲ"
"ストの状態を制御します。"
msgstr ""
"続いて Guest-State カテゴリを設定します。 このカテゴリは VM Entry した際のゲ"
"ストの状態を制御します。"

#: src/vmm/vmlaunch.md:655
msgid ""
"Control Registers は VM Entry した際のゲストの CR0, CR3, CR4 の値を制御しま"
"す。 本チャプターではこれらの値はホストと共有することにします:"
msgstr ""
"Control Registers は VM Entry した際のゲストの CR0, CR3, CR4 の値を制御しま"
"す。 本チャプターではこれらの値はホストと共有することにします:"

#: src/vmm/vmlaunch.md:671
msgid ""
"ゲスト用のセグメントレジスタでは、セレクタ / Base / Limit / Access Rights を"
"それぞれ設定する必要があります。 かなりめんどくさいです。"
msgstr ""
"ゲスト用のセグメントレジスタでは、セレクタ / Base / Limit / Access Rights を"
"それぞれ設定する必要があります。 かなりめんどくさいです。"

#: src/vmm/vmlaunch.md:674
msgid ""
"まずは Base を設定します。 Base はどのセグメントでも利用しないため、適当に "
"`0` を入れておきます。 LDTR だけは `0xDEAD00` を入れておきます。 これは実際に"
"使うことはありませんが、**現在動いているのが VMM なのかゲストなのかを区別する"
"ためのマーカーとして使います**:"
msgstr ""
"まずは Base を設定します。 Base はどのセグメントでも利用しないため、適当に "
"`0` を入れておきます。 LDTR だけは `0xDEAD00` を入れておきます。 これは実際に"
"使うことはありませんが、**現在動いているのが VMM なのかゲストなのかを区別する"
"ためのマーカーとして使います**:"

#: src/vmm/vmlaunch.md:693
msgid "Limit に関しても使わないので、とりあえずとり得る最大値を入れておきます:"
msgstr ""
"Limit に関しても使わないので、とりあえずとり得る最大値を入れておきます:"

#: src/vmm/vmlaunch.md:709
msgid ""
"続いてセレクタを設定します。 本チャプターで使うゲストである `blobGuest()` は"
"関数のプロローグを持たないため、データセグメントは使いません。 利用するセグメ"
"ントは CS だけです。 そのため、CS にだけホストと同じセレクタを入れておきます:"
msgstr ""
"続いてセレクタを設定します。 本チャプターで使うゲストである `blobGuest()` は"
"関数のプロローグを持たないため、データセグメントは使いません。 利用するセグメ"
"ントは CS だけです。 そのため、CS にだけホストと同じセレクタを入れておきます:"

#: src/vmm/vmlaunch.md:726
msgid ""
"最後に Access Rights を設定します。 これは [GDTのチャプター](../kernel/gdt."
"md) で扱った GDT のエントリとほぼ同じ情報を持ちます。 しかしフォーマットが微"
"妙に異なるので改めて VMCS 用に定義します。 各フィールドの意味については [GDT"
"のチャプター](../kernel/gdt.md) のものと同じであるためそちらを参照してくださ"
"い:"
msgstr ""
"最後に Access Rights を設定します。 これは [GDTのチャプター](../kernel/gdt."
"md) で扱った GDT のエントリとほぼ同じ情報を持ちます。 しかしフォーマットが微"
"妙に異なるので改めて VMCS 用に定義します。 各フィールドの意味については [GDT"
"のチャプター](../kernel/gdt.md) のものと同じであるためそちらを参照してくださ"
"い:"

#: src/vmm/vmlaunch.md:753
msgid ""
"正直今回は CS だけ正しく設定できていればよいのですが、せっかくなので他のセグ"
"メントも一緒に設定してしまいます。"
msgstr ""
"正直今回は CS だけ正しく設定できていればよいのですが、せっかくなので他のセグ"
"メントも一緒に設定してしまいます。"

#: src/vmm/vmlaunch.md:809
msgid ""
"CS と DS についてはホストに設定しているものと同じ値にしています。 TR と LDTR "
"は Ymir では全く利用していませんが、これらを設定しないと VM Entry 時のチェッ"
"クでエラーになってしまうため嫌々設定しています。 とはいってもこの2つに設定す"
"るべき値はほぼ固定値なので、そういうもんとして受け入れてください。"
msgstr ""
"CS と DS についてはホストに設定しているものと同じ値にしています。 TR と LDTR "
"は Ymir では全く利用していませんが、これらを設定しないと VM Entry 時のチェッ"
"クでエラーになってしまうため嫌々設定しています。 とはいってもこの2つに設定す"
"るべき値はほぼ固定値なので、そういうもんとして受け入れてください。"

#: src/vmm/vmlaunch.md:813
msgid "RIP / RSP / MSR / RFLAGS など"
msgstr "RIP / RSP / MSR / RFLAGS など"

#: src/vmm/vmlaunch.md:815
msgid ""
"今回のゲストである `blobGuest()` は RSP を使わないため RSP は設定する必要があ"
"りません。 RIP は `blobGuest()` のアドレスを指定しておきます。 RFLAGS も初期"
"化する必要があります。 また、一部の MSR は VMCS のフィールドを使って設定する"
"ことができます。 その中でも今回は `IA32_EFER` だけを設定します。 この MSR は "
"64bit モードを有効化するために必須です:"
msgstr ""
"今回のゲストである `blobGuest()` は RSP を使わないため RSP は設定する必要があ"
"りません。 RIP は `blobGuest()` のアドレスを指定しておきます。 RFLAGS も初期"
"化する必要があります。 また、一部の MSR は VMCS のフィールドを使って設定する"
"ことができます。 その中でも今回は `IA32_EFER` だけを設定します。 この MSR は "
"64bit モードを有効化するために必須です:"

#: src/vmm/vmlaunch.md:829
msgid ""
"最後に、**VMCS Link Pointer** を設定します。 このフィールドは VMCS shadowing "
"をする場合に利用されます。 利用しない場合には `0xFFFF_FFFF_FFFF_FFFF` を入れ"
"ておく決まりがあるため、従います:"
msgstr ""
"最後に、**VMCS Link Pointer** を設定します。 このフィールドは VMCS shadowing "
"をする場合に利用されます。 利用しない場合には `0xFFFF_FFFF_FFFF_FFFF` を入れ"
"ておく決まりがあるため、従います:"

#: src/vmm/vmlaunch.md:840
msgid ""
"このカテゴリは VM Entry におけるプロセッサの挙動を制御します[^entryctrl]。 設"
"定する項目が少ない癒やし枠です:"
msgstr ""
"このカテゴリは VM Entry におけるプロセッサの挙動を制御します[^entryctrl]。 設"
"定する項目が少ない癒やし枠です:"

#: src/vmm/vmlaunch.md:879
msgid ""
"この内、_IA-32e Mode Guest_ (`.ia32e_mode_guest`) を設定します。 このフィール"
"ドは VM Entry 後にゲストが IA-32e モードで動作することを示します。 これが有効"
"になっている場合、VM Entry 後に `IA32_EFER.LMA` (Long Mode Activate) ビットが"
"セットされ、64bit モードとして動作することができます:"
msgstr ""
"この内、_IA-32e Mode Guest_ (`.ia32e_mode_guest`) を設定します。 このフィール"
"ドは VM Entry 後にゲストが IA-32e モードで動作することを示します。 これが有効"
"になっている場合、VM Entry 後に `IA32_EFER.LMA` (Long Mode Activate) ビットが"
"セットされ、64bit モードとして動作することができます:"

#: src/vmm/vmlaunch.md:897
msgid ""
"ここでも Reserved Bits は `IA32_VMX_ENTRY_CTRLS` (address: `0x0484`) または "
"`IA32_VMX_TRUE_ENTRY_CTRLS` (address: `0x0490`) の値を参照して設定します。"
msgstr ""
"ここでも Reserved Bits は `IA32_VMX_ENTRY_CTRLS` (address: `0x0484`) または "
"`IA32_VMX_TRUE_ENTRY_CTRLS` (address: `0x0490`) の値を参照して設定します。"

#: src/vmm/vmlaunch.md:901
msgid ""
"このカテゴリは VM Exit におけるプロセッサの挙動を制御します[^exitctrl]。 一"
"応 Primary と Secondary の2つがあります。 しかし、Secondary は設定項目が1つし"
"かない上に本シリーズでは Primary しか使いません。 こいつも設定する項目が少な"
"い癒やし枠その2です:"
msgstr ""
"このカテゴリは VM Exit におけるプロセッサの挙動を制御します[^exitctrl]。 一"
"応 Primary と Secondary の2つがあります。 しかし、Secondary は設定項目が1つし"
"かない上に本シリーズでは Primary しか使いません。 こいつも設定する項目が少な"
"い癒やし枠その2です:"

#: src/vmm/vmlaunch.md:947
msgid ""
"ここでは Host Address-Space Size (`.host_addr_space_size`) を設定します。 こ"
"のフィールドは VM Exit 後にホストが 64bit モードで動作することを示します。 こ"
"れが有効になっている場合、VM Exit 後に `IA32_EFER.LME` (Long Mode Enable) と "
"`IA32_EFER.LMA` (Long Mode Activate) ビットがセットされ、64bit モードとして動"
"作することができます:"
msgstr ""
"ここでは Host Address-Space Size (`.host_addr_space_size`) を設定します。 こ"
"のフィールドは VM Exit 後にホストが 64bit モードで動作することを示します。 こ"
"れが有効になっている場合、VM Exit 後に `IA32_EFER.LME` (Long Mode Enable) と "
"`IA32_EFER.LMA` (Long Mode Activate) ビットがセットされ、64bit モードとして動"
"作することができます:"

#: src/vmm/vmlaunch.md:966
msgid ""
"ここでも Reserved Bits は `IA32_VMX_EXIT_CTRLS` (address: `0x0483`) または "
"`IA32_VMX_TRUE_EXIT_CTRLS` (address: `0x048F`) の値を参照して設定します。"
msgstr ""
"ここでも Reserved Bits は `IA32_VMX_EXIT_CTRLS` (address: `0x0483`) または "
"`IA32_VMX_TRUE_EXIT_CTRLS` (address: `0x048F`) の値を参照して設定します。"

#: src/vmm/vmlaunch.md:970
msgid ""
"以上で VMCS の設定ができました。 最後に VMLAUNCH 命令を実行して VMX Non-root "
"Operation に遷移します:"
msgstr ""
"以上で VMCS の設定ができました。 最後に VMLAUNCH 命令を実行して VMX Non-root "
"Operation に遷移します:"

#: src/vmm/vmlaunch.md:989
msgid ""
"この関数はまず最初に [VMLAUNCH](https://www.felixcloutier.com/x86/vmlaunch:"
"vmresume) 命令を実行します。 VM Entry は2通りの失敗をする可能性があります:"
msgstr ""
"この関数はまず最初に [VMLAUNCH](https://www.felixcloutier.com/x86/vmlaunch:"
"vmresume) 命令を実行します。 VM Entry は2通りの失敗をする可能性があります:"

#: src/vmm/vmlaunch.md:992
msgid "**VMLAUNCH 自体が失敗する**"
msgstr "**VMLAUNCH 自体が失敗する**"

#: src/vmm/vmlaunch.md:993 src/vmm/vmentry_vmexit.md:113
msgid ""
"他の VMX 拡張命令が失敗した場合と同様に VMX Instruction Error を返します。"
msgstr ""
"他の VMX 拡張命令が失敗した場合と同様に VMX Instruction Error を返します。"

#: src/vmm/vmlaunch.md:994
msgid "`loop()` 関数内の `VMLAUNCH` 命令の直後から実行が再開されます。"
msgstr "`loop()` 関数内の `VMLAUNCH` 命令の直後から実行が再開されます。"

#: src/vmm/vmlaunch.md:995
msgid "**VMLAUNCH 自体は成功するが、すぐに VMEXIT する**"
msgstr "**VMLAUNCH 自体は成功するが、すぐに VMEXIT する**"

#: src/vmm/vmlaunch.md:996
msgid "VMLAUNCH 自体が成功したが VM Entry に失敗するケースです。"
msgstr "VMLAUNCH 自体が成功したが VM Entry に失敗するケースです。"

#: src/vmm/vmlaunch.md:997
msgid ""
"VM Exit が発生し、VMCS Host-State に設定した RIP に実行が移ります。今回は "
"`vmexitBootstrapHandler()` が呼ばれます。"
msgstr ""
"VM Exit が発生し、VMCS Host-State に設定した RIP に実行が移ります。今回は "
"`vmexitBootstrapHandler()` が呼ばれます。"

#: src/vmm/vmlaunch.md:999
msgid ""
"`Vmx` に `Vcpu.loop()` を呼び出す関数を追加します。 のちのチャプターで扱いま"
"すが、Ymir は一度 VM を動かし始めると原則としてホスト側での割り込みを禁止する"
"ようにします:"
msgstr ""
"`Vmx` に `Vcpu.loop()` を呼び出す関数を追加します。 のちのチャプターで扱いま"
"すが、Ymir は一度 VM を動かし始めると原則としてホスト側での割り込みを禁止する"
"ようにします:"

#: src/vmm/vmlaunch.md:1010
msgid "これを `kernelMain()` から呼び出します:"
msgstr "これを `kernelMain()` から呼び出します:"

#: src/vmm/vmlaunch.md:1027
msgid ""
"無限 HLT ループで止まっているようです。 この状態で QEMU monitor でレジスタの"
"状態を確認してみましょう:"
msgstr ""
"無限 HLT ループで止まっているようです。 この状態で QEMU monitor でレジスタの"
"状態を確認してみましょう:"

#: src/vmm/vmlaunch.md:1058
msgid ""
"VMX Root Operation と VMX Non-root Operation のどちらの状態にいるのかを直接的"
"に知る方法はありません。 注目するべきは LDT の Base です。 VMCS Guest-State "
"でこの値はマーカーとして `0xDEAD00` に設定していました。 現在の LDT の Base "
"が `0xDEAD00` であることから、**VMX Non-root Operation に遷移できていることが"
"わかります**。"
msgstr ""
"VMX Root Operation と VMX Non-root Operation のどちらの状態にいるのかを直接的"
"に知る方法はありません。 注目するべきは LDT の Base です。 VMCS Guest-State "
"でこの値はマーカーとして `0xDEAD00` に設定していました。 現在の LDT の Base "
"が `0xDEAD00` であることから、**VMX Non-root Operation に遷移できていることが"
"わかります**。"

#: src/vmm/vmlaunch.md:1063
msgid ""
"また、RIP の値 `0xFFFFFFFF8010A6B1` について `addr2line` でコードのどの部分に"
"該当するかを確認してみます:"
msgstr ""
"また、RIP の値 `0xFFFFFFFF8010A6B1` について `addr2line` でコードのどの部分に"
"該当するかを確認してみます:"

#: src/vmm/vmlaunch.md:1076
msgid ""
"確かに HLT ループで止まっているということが確認できますね。 というわけで、無"
"事に VMX Non-root Operation に遷移してゲストを実行することができました。"
msgstr ""
"確かに HLT ループで止まっているということが確認できますね。 というわけで、無"
"事に VMX Non-root Operation に遷移してゲストを実行することができました。"

#: src/vmm/vmlaunch.md:1079
msgid ""
"もう1つ実験として、Execution Control カテゴリの Primary Processor-Based "
"Controls において、`.hlt` フィールドを `true` に設定してみましょう。 これに"
"よってゲストが HLT を実行すると VM Exit するようになります:"
msgstr ""
"もう1つ実験として、Execution Control カテゴリの Primary Processor-Based "
"Controls において、`.hlt` フィールドを `true` に設定してみましょう。 これに"
"よってゲストが HLT を実行すると VM Exit するようになります:"

#: src/vmm/vmlaunch.md:1099
msgid ""
"ゲストが HLT を実行すると VM Exit が発生し、Host-State に設定した RIP に処理"
"が移ります。 RIP には `vmexitBootstrapHandler()` が設定されており、そこで VM "
"Exit Reason を取得・表示しています。 今回の Reason は意図したとおり `hlt` で"
"あることが分かります。 これで VM Exit ハンドラが正しく呼ばれることも確認でき"
"ました。"
msgstr ""
"ゲストが HLT を実行すると VM Exit が発生し、Host-State に設定した RIP に処理"
"が移ります。 RIP には `vmexitBootstrapHandler()` が設定されており、そこで VM "
"Exit Reason を取得・表示しています。 今回の Reason は意図したとおり `hlt` で"
"あることが分かります。 これで VM Exit ハンドラが正しく呼ばれることも確認でき"
"ました。"

#: src/vmm/vmlaunch.md:1106
msgid ""
"本チャプターでは VMCS の設定をして、VMX Non-root Operation に遷移しました。 "
"ゲストとして HLT ループを行うだけの関数を実行し、IDTR に仕込んだマーカーから "
"VM Entry が成功していることを確認しました。 また、VM Exit ハンドラを設定し、"
"VM Exit Reason が取得できることも確認しました。"
msgstr ""
"本チャプターでは VMCS の設定をして、VMX Non-root Operation に遷移しました。 "
"ゲストとして HLT ループを行うだけの関数を実行し、IDTR に仕込んだマーカーから "
"VM Entry が成功していることを確認しました。 また、VM Exit ハンドラを設定し、"
"VM Exit Reason が取得できることも確認しました。"

#: src/vmm/vmlaunch.md:1110
msgid ""
"これでついにゲストを動かすことができました。 どんなに小さなゲストでも、仮想化"
"されていることには変わりありません。 もはやこの状態の Ymir でも "
"_\"hypervisor\"_ を名乗ることができるのではないでしょうか。 無理か。"
msgstr ""
"これでついにゲストを動かすことができました。 どんなに小さなゲストでも、仮想化"
"されていることには変わりありません。 もはやこの状態の Ymir でも "
"_\"hypervisor\"_ を名乗ることができるのではないでしょうか。 無理か。"

#: src/vmm/vmlaunch.md:1115
msgid ""
"今のところゲストはホストのレジスタの状態をほぼ全て受け継いだ状態で動いていま"
"す。 逆に、ホストも VM Exit 発生時のレジスタの状態をそのまま受け継いでいま"
"す。 次のチャプターでは VM Entry / VM Exit 時にレジスタを含むゲスト・ホストの"
"状態を適切に保存する部分を実装していきます。"
msgstr ""
"今のところゲストはホストのレジスタの状態をほぼ全て受け継いだ状態で動いていま"
"す。 逆に、ホストも VM Exit 発生時のレジスタの状態をそのまま受け継いでいま"
"す。 次のチャプターでは VM Entry / VM Exit 時にレジスタを含むゲスト・ホストの"
"状態を適切に保存する部分を実装していきます。"

#: src/vmm/vmlaunch.md:1119
msgid "_SDM Vol.3C 25.6.1 Pin-Based VM-Execution Controls_"
msgstr "_SDM Vol.3C 25.6.1 Pin-Based VM-Execution Controls_"

#: src/vmm/vmlaunch.md:1120
msgid "_SDM Vol.3C 25.6.2 Processor-Based VM-Execution Controls_"
msgstr "_SDM Vol.3C 25.6.2 Processor-Based VM-Execution Controls_"

#: src/vmm/vmlaunch.md:1121
msgid ""
"MOV 命令を使って直接セグメントレジスタにアクセスした場合、レジスタの Hidden "
"Part はゼロクリアされて取得されます。"
msgstr ""
"MOV 命令を使って直接セグメントレジスタにアクセスした場合、レジスタの Hidden "
"Part はゼロクリアされて取得されます。"

#: src/vmm/vmlaunch.md:1122
msgid "_SDM Vol.3C 25.8.1 VM-Entry Control Fields_"
msgstr "_SDM Vol.3C 25.8.1 VM-Entry Control Fields_"

#: src/vmm/vmlaunch.md:1123
msgid "_SDM Vol.3C 25.7.1 VM-Exit Control Fields_"
msgstr "_SDM Vol.3C 25.7.1 VM-Exit Control Fields_"

#: src/vmm/vmentry_vmexit.md:1
msgid "VM Entry / VM Exit ハンドラ"
msgstr "VM Entry / VM Exit ハンドラ"

#: src/vmm/vmentry_vmexit.md:3
msgid ""
"前チャプターでは VMCS を設定し VMLAUNCH でゲストを実行することに成功しまし"
"た。 しかし、VM Entry 前や VM Exit 後の状態の保存・復元処理はほとんどしていま"
"せんでした。 これは、ゲストとホストがレジスタなどの状態を共有してしまっている"
"ことを意味します。 本チャプターでは VM Entry と VM Exit の処理を実装し、適切"
"に状態の保存・復元と VM Exit のハンドリングをするようにします。"
msgstr ""
"前チャプターでは VMCS を設定し VMLAUNCH でゲストを実行することに成功しまし"
"た。 しかし、VM Entry 前や VM Exit 後の状態の保存・復元処理はほとんどしていま"
"せんでした。 これは、ゲストとホストがレジスタなどの状態を共有してしまっている"
"ことを意味します。 本チャプターでは VM Entry と VM Exit の処理を実装し、適切"
"に状態の保存・復元と VM Exit のハンドリングをするようにします。"

#: src/vmm/vmentry_vmexit.md:10
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-vmentry_vmexit`]"
#| "(https://github.com/smallkirby/ymir/tree/whiz-vmm-vmentry_vmexit) ブランチ"
#| "にあります。"
msgid ""
"本チャプターの最終コードは [`whiz-vmm-vmentry_vmexit`](https://github.com/"
"smallkirby/ymir/tree/whiz-vmm-vmentry_vmexit) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-vmentry_vmexit`]"
"(https://github.com/smallkirby/ymir/tree/whiz-vmm-vmentry_vmexit) ブランチに"
"あります。"

#: src/vmm/vmentry_vmexit.md:14
msgid "[ゲストの状態保持](#ゲストの状態保持)"
msgstr "[ゲストの状態保持](#ゲストの状態保持)"

#: src/vmm/vmentry_vmexit.md:15
msgid "[VMLAUNCH と VMRESUME](#vmlaunch-と-vmresume)"
msgstr "[VMLAUNCH と VMRESUME](#vmlaunch-と-vmresume)"

#: src/vmm/vmentry_vmexit.md:16
msgid "[エラーハンドリング](#エラーハンドリング)"
msgstr "[エラーハンドリング](#エラーハンドリング)"

#: src/vmm/vmentry_vmexit.md:17
msgid "[VM Entry](#vm-entry)"
msgstr "[VM Entry](#vm-entry)"

#: src/vmm/vmentry_vmexit.md:18
msgid "[呼び出し部分](#呼び出し部分)"
msgstr "[呼び出し部分](#呼び出し部分)"

#: src/vmm/vmentry_vmexit.md:19
msgid "[ホストの状態保存](#ホストの状態保存)"
msgstr "[ホストの状態保存](#ホストの状態保存)"

#: src/vmm/vmentry_vmexit.md:20
msgid "[ゲストの状態復元](#ゲストの状態復元)"
msgstr "[ゲストの状態復元](#ゲストの状態復元)"

#: src/vmm/vmentry_vmexit.md:21
msgid "[VM Exit](#vm-exit)"
msgstr "[VM Exit](#vm-exit)"

#: src/vmm/vmentry_vmexit.md:22
msgid "[Exit Handler](#exit-handler)"
msgstr "[Exit Handler](#exit-handler)"

#: src/vmm/vmentry_vmexit.md:26
msgid "ゲストの状態保持"
msgstr "ゲストの状態保持"

#: src/vmm/vmentry_vmexit.md:28
msgid ""
"ゲストの状態は `Vcpu` が保持します。 ひとまずここではゲストの汎用レジスタを記"
"憶することにしましょう。 保持するべき汎用レジスタの一覧を定義します:"
msgstr ""
"ゲストの状態は `Vcpu` が保持します。 ひとまずここではゲストの汎用レジスタを記"
"憶することにしましょう。 保持するべき汎用レジスタの一覧を定義します:"

#: src/vmm/vmentry_vmexit.md:62
msgid ""
"整数型の汎用レジスタと8つの XMM レジスタを保持します。 本来であれば浮動小数点"
"レジスタは AVX や AVX-512 などシステムがサポートするレジスタ全てを保存するべ"
"きです。 しかしながら、それらの保存には [XSAVE](https://www.felixcloutier."
"com/x86/xsave) 命令を適切に使う必要があります。 めんどうなので、Ymir ではゲス"
"トに対して SSE2 よりもモダンな浮動小数点レジスタをサポートしないことにしてい"
"ます[^avx]。"
msgstr ""
"整数型の汎用レジスタと8つの XMM レジスタを保持します。 本来であれば浮動小数点"
"レジスタは AVX や AVX-512 などシステムがサポートするレジスタ全てを保存するべ"
"きです。 しかしながら、それらの保存には [XSAVE](https://www.felixcloutier."
"com/x86/xsave) 命令を適切に使う必要があります。 めんどうなので、Ymir ではゲス"
"トに対して SSE2 よりもモダンな浮動小数点レジスタをサポートしないことにしてい"
"ます[^avx]。"

#: src/vmm/vmentry_vmexit.md:67
msgid "`Vcpu` 構造体にゲストの情報を保持する変数を持たせます:"
msgstr "`Vcpu` 構造体にゲストの情報を保持する変数を持たせます:"

#: src/vmm/vmentry_vmexit.md:78
msgid "VMLAUNCH と VMRESUME"
msgstr "VMLAUNCH と VMRESUME"

#: src/vmm/vmentry_vmexit.md:80
msgid ""
"VM Entry を実行する命令には [VMLAUNCH](https://www.felixcloutier.com/x86/"
"vmlaunch:vmresume) と [VMRESUME](https://www.felixcloutier.com/x86/vmlaunch:"
"vmresume) の2つがあります。 この2つは現在の VMCS の状態に応じて使い分けま"
"す。 [VMCSの基礎 のチャプター](./vmcs.md) で述べたように、VMCS は以下に示す状"
"態遷移図のような状態を持ちます:"
msgstr ""
"VM Entry を実行する命令には [VMLAUNCH](https://www.felixcloutier.com/x86/"
"vmlaunch:vmresume) と [VMRESUME](https://www.felixcloutier.com/x86/vmlaunch:"
"vmresume) の2つがあります。 この2つは現在の VMCS の状態に応じて使い分けま"
"す。 [VMCSの基礎 のチャプター](./vmcs.md) で述べたように、VMCS は以下に示す状"
"態遷移図のような状態を持ちます:"

#: src/vmm/vmentry_vmexit.md:87
msgid ""
"今回注目するのは _Clear_ / _Launched_ の状態です。 VMCS はいずれかの CPU の "
"_Current_ VMCS に設定された状態で VMLAUNCH が実行されると、状態が _Launched_ "
"になります。 _Launched_ になった VMCS を使って再度 VM Entry をするには "
"VMRESUME を使います。 言い換えると、**一度目の VM Entry には VMLAUNCH を使"
"い、2回目以降は VMRESUME を使います**。 VMLAUNCH と VMRESUME を使い間違える"
"と、VMX Instruction Error が発生します。"
msgstr ""
"今回注目するのは _Clear_ / _Launched_ の状態です。 VMCS はいずれかの CPU の "
"_Current_ VMCS に設定された状態で VMLAUNCH が実行されると、状態が _Launched_ "
"になります。 _Launched_ になった VMCS を使って再度 VM Entry をするには "
"VMRESUME を使います。 言い換えると、**一度目の VM Entry には VMLAUNCH を使"
"い、2回目以降は VMRESUME を使います**。 VMLAUNCH と VMRESUME を使い間違える"
"と、VMX Instruction Error が発生します。"

#: src/vmm/vmentry_vmexit.md:93
msgid ""
"VMCS の状態を取得する方法はありません。 そのため、VMM 側でこれらの状態を記録"
"しておく必要があります。 `Vcpu` に VMCS の状態を保持する変数を追加します:"
msgstr ""
"VMCS の状態を取得する方法はありません。 そのため、VMM 側でこれらの状態を記録"
"しておく必要があります。 `Vcpu` に VMCS の状態を保持する変数を追加します:"

#: src/vmm/vmentry_vmexit.md:107
msgid "エラーハンドリング"
msgstr "エラーハンドリング"

#: src/vmm/vmentry_vmexit.md:109
msgid ""
"まずは VM Entry の非アセンブリ部分を実装します。 VM Entry には、以下の2種類の"
"失敗があります:"
msgstr ""
"まずは VM Entry の非アセンブリ部分を実装します。 VM Entry には、以下の2種類の"
"失敗があります:"

#: src/vmm/vmentry_vmexit.md:112
msgid "**VM Entry 自体が失敗する** (VMX Instruction Error)"
msgstr "**VM Entry 自体が失敗する** (VMX Instruction Error)"

#: src/vmm/vmentry_vmexit.md:114
msgid ""
"`loop()` 関数内の `VMLAUNCH`/`VMRESUME` 命令の直後から実行が再開されます。"
msgstr ""
"`loop()` 関数内の `VMLAUNCH`/`VMRESUME` 命令の直後から実行が再開されます。"

#: src/vmm/vmentry_vmexit.md:115
msgid "**VM Entry 自体は成功するが、すぐに VMEXIT する**"
msgstr "**VM Entry 自体は成功するが、すぐに VMEXIT する**"

#: src/vmm/vmentry_vmexit.md:116
msgid "`VMLAUNCH`/`VMRESUME` 自体は成功したが VM Entry に失敗するケースです。"
msgstr "`VMLAUNCH`/`VMRESUME` 自体は成功したが VM Entry に失敗するケースです。"

#: src/vmm/vmentry_vmexit.md:117
msgid "VM Exit が発生し、VMCS Host-State に設定した RIP に実行が移ります。"
msgstr "VM Exit が発生し、VMCS Host-State に設定した RIP に実行が移ります。"

#: src/vmm/vmentry_vmexit.md:119
msgid "まず扱うのは前者のケースです:"
msgstr "まず扱うのは前者のケースです:"

#: src/vmm/vmentry_vmexit.md:139
msgid ""
"`self.vmentry()` は後述するアセンブリの `VMENTRY` を実行する関数です。 返り値"
"として `VmxError!void` を返すため、もしもエラーを返した場合には `catch` で補"
"足します。 VMX 拡張命令にはさらに2通りのエラーが存在します:"
msgstr ""
"`self.vmentry()` は後述するアセンブリの `VMENTRY` を実行する関数です。 返り値"
"として `VmxError!void` を返すため、もしもエラーを返した場合には `catch` で補"
"足します。 VMX 拡張命令にはさらに2通りのエラーが存在します:"

#: src/vmm/vmentry_vmexit.md:143
msgid "`VmxStatusUnavailable`: エラーコードがないエラー"
msgstr "`VmxStatusUnavailable`: エラーコードがないエラー"

#: src/vmm/vmentry_vmexit.md:144
msgid "`VmxStatusAvailable`: エラーコードがあるエラー"
msgstr "`VmxStatusAvailable`: エラーコードがあるエラー"

#: src/vmm/vmentry_vmexit.md:146
msgid ""
"エラーコードが利用できる場合には、VMCS から VMX Instruction Error を取得し表"
"示します。 VMCS の設定が適切にされていれば VMX 拡張命令は失敗することがありま"
"せん。 そのため、Ymir では VM Entry 時のエラーは復帰不可能とみなし、`self."
"abort()` でアボートします:"
msgstr ""
"エラーコードが利用できる場合には、VMCS から VMX Instruction Error を取得し表"
"示します。 VMCS の設定が適切にされていれば VMX 拡張命令は失敗することがありま"
"せん。 そのため、Ymir では VM Entry 時のエラーは復帰不可能とみなし、`self."
"abort()` でアボートします:"

#: src/vmm/vmentry_vmexit.md:197
msgid ""
"`dump()` と `abort()` はそれぞれ別々に呼び出したいときがあるため、分けて実装"
"しています (デバッグ用にゲストの状態をダンプして処理は継続したい場合など)。 "
"アボート時はゲストの状態を出力し、無限 HLT ループに入ります。"
msgstr ""
"`dump()` と `abort()` はそれぞれ別々に呼び出したいときがあるため、分けて実装"
"しています (デバッグ用にゲストの状態をダンプして処理は継続したい場合など)。 "
"アボート時はゲストの状態を出力し、無限 HLT ループに入ります。"

#: src/vmm/vmentry_vmexit.md:201
msgid "VM Entry"
msgstr "VM Entry"

#: src/vmm/vmentry_vmexit.md:203
msgid "呼び出し部分"
msgstr "呼び出し部分"

#: src/vmm/vmentry_vmexit.md:205
msgid ""
"さきほど出てきた `vmentry()` はアセンブリの VMLAUNCH / VMRESUME をラップする"
"関数です:"
msgstr ""
"さきほど出てきた `vmentry()` はアセンブリの VMLAUNCH / VMRESUME をラップする"
"関数です:"

#: src/vmm/vmentry_vmexit.md:229
msgid ""
"純粋なアセンブリ部分はさらに `asmVmEntry()` に分離しています。 この関数は引数"
"として `*Vcpu` をとります。 `asmVmEntry()` の詳細は後述しますが、この引数はホ"
"ストの状態の保存・ゲストの状態の復元などに使われます。"
msgstr ""
"純粋なアセンブリ部分はさらに `asmVmEntry()` に分離しています。 この関数は引数"
"として `*Vcpu` をとります。 `asmVmEntry()` の詳細は後述しますが、この引数はホ"
"ストの状態の保存・ゲストの状態の復元などに使われます。"

#: src/vmm/vmentry_vmexit.md:233
msgid ""
"VM Entry / Exit の実装方法にはいくつかの方法があります。 単純に考えると一度 "
"VM Entry してしまえば、次に VMM に処理が移る際には VM Exit ハンドラに飛ぶこと"
"になります。 VM Entry を呼び出した関数 (`vmentry()`) に戻ってくることはありま"
"せん。 しかし、**Ymir ではコントロールフローが分かりやすくなるように「VM "
"Entry があたかも通常の関数呼び出しであるかのように」実装します**。 処理の流れ"
"としては、 `vmentry()` → Guest → VM Exit Handler → `vmentry()` となります。 "
"実現方法については VM Entry / VM Exit ハンドラの実装の際に説明します。"
msgstr ""
"VM Entry / Exit の実装方法にはいくつかの方法があります。 単純に考えると一度 "
"VM Entry してしまえば、次に VMM に処理が移る際には VM Exit ハンドラに飛ぶこと"
"になります。 VM Entry を呼び出した関数 (`vmentry()`) に戻ってくることはありま"
"せん。 しかし、**Ymir ではコントロールフローが分かりやすくなるように「VM "
"Entry があたかも通常の関数呼び出しであるかのように」実装します**。 処理の流れ"
"としては、 `vmentry()` → Guest → VM Exit Handler → `vmentry()` となります。 "
"実現方法については VM Entry / VM Exit ハンドラの実装の際に説明します。"

#: src/vmm/vmentry_vmexit.md:240
msgid ""
"さて、VM Entry (`asmVmEntry()`) が通常の関数呼び出しのように帰ってくることが"
"分かりました。 この関数は VM Entry に成功した場合は `0` を、失敗した場合は "
"`1` を返します。 VM Entry に成功し、それが初めての VM Entry である場合には "
"`launch_done` を `true` にします。 これによって、2回目以降は `asmVmEntry()` "
"で VMRESUME を実行するように分岐します。 VM Entry に失敗した場合には、VMX "
"Instruction Error があるかどうかを確認し、適切なエラーを返します。"
msgstr ""
"さて、VM Entry (`asmVmEntry()`) が通常の関数呼び出しのように帰ってくることが"
"分かりました。 この関数は VM Entry に成功した場合は `0` を、失敗した場合は "
"`1` を返します。 VM Entry に成功し、それが初めての VM Entry である場合には "
"`launch_done` を `true` にします。 これによって、2回目以降は `asmVmEntry()` "
"で VMRESUME を実行するように分岐します。 VM Entry に失敗した場合には、VMX "
"Instruction Error があるかどうかを確認し、適切なエラーを返します。"

#: src/vmm/vmentry_vmexit.md:246
msgid "ホストの状態保存"
msgstr "ホストの状態保存"

#: src/vmm/vmentry_vmexit.md:248
msgid ""
"`vmentry()` から呼び出される `asmVmEntry()` を実装していきましょう。 "
"`vmentry()` が Zig 関数 (Error Union を返すことができる / calling convention "
"はZigコンパイラ依存) であったのに対し、 この関数は完全に生のアセンブリとして"
"書きたいため `.Naked` calling convention を使います。"
msgstr ""
"`vmentry()` から呼び出される `asmVmEntry()` を実装していきましょう。 "
"`vmentry()` が Zig 関数 (Error Union を返すことができる / calling convention "
"はZigコンパイラ依存) であったのに対し、 この関数は完全に生のアセンブリとして"
"書きたいため `.Naked` calling convention を使います。"

#: src/vmm/vmentry_vmexit.md:252
msgid ""
"まずは x64 における callee-saved レジスタたちを保存します[^callee-saved]。 本"
"当は RSP も callee-saved ですが、RSP はのちほど別の方法で保存します:"
msgstr ""
"まずは x64 における callee-saved レジスタたちを保存します[^callee-saved]。 本"
"当は RSP も callee-saved ですが、RSP はのちほど別の方法で保存します:"

#: src/vmm/vmentry_vmexit.md:271
msgid ""
"続いて、引数としてとった `*Vcpu` のうち、`.guest_regs` フィールドのアドレス"
"を RBX 経由でスタックに積みます。 `asmVmEntry()` は `.Naked` calling "
"convention であり引数を取ることができないため、 `vmentry()` では CALL 前に明"
"示的に RDI に引数を入れていました。 `Vcpu` 内の `.guest_regs` のオフセットは "
"`@offsetOf()` と `std.fmt.comptimePrint()` を使って計算します。 "
"`comptimePrint()` はコンパイル時に評価される文字列を生成できるため、`asm "
"volatile()` の引数として指定することができます。 このようにオフセットを計算す"
"ることで、**`.guest_regs` のオフセットが変わったとしてもコードを修正する必要"
"がなくなります**:"
msgstr ""
"続いて、引数としてとった `*Vcpu` のうち、`.guest_regs` フィールドのアドレス"
"を RBX 経由でスタックに積みます。 `asmVmEntry()` は `.Naked` calling "
"convention であり引数を取ることができないため、 `vmentry()` では CALL 前に明"
"示的に RDI に引数を入れていました。 `Vcpu` 内の `.guest_regs` のオフセットは "
"`@offsetOf()` と `std.fmt.comptimePrint()` を使って計算します。 "
"`comptimePrint()` はコンパイル時に評価される文字列を生成できるため、`asm "
"volatile()` の引数として指定することができます。 このようにオフセットを計算す"
"ることで、**`.guest_regs` のオフセットが変わったとしてもコードを修正する必要"
"がなくなります**:"

#: src/vmm/vmentry_vmexit.md:289
msgid ""
"次に、残る callee-saved レジスタである RSP を保存します。 RSP は VMCS Host-"
"State に保存する必要があるという意味で特別です。 VMWRITE をアセンブリから呼び"
"出すのは面倒なため、ここでは C calling convention の関数を実装します:"
msgstr ""
"次に、残る callee-saved レジスタである RSP を保存します。 RSP は VMCS Host-"
"State に保存する必要があるという意味で特別です。 VMWRITE をアセンブリから呼び"
"出すのは面倒なため、ここでは C calling convention の関数を実装します:"

#: src/vmm/vmentry_vmexit.md:300
msgid "これを `asmVmEntry()` から CALL します:"
msgstr "これを `asmVmEntry()` から CALL します:"

#: src/vmm/vmentry_vmexit.md:313
msgid ""
"`setHostStack()` を呼び出す直前のスタックの状態は下図のようになっています。 "
"**VM Exit は、図の黄色の部分をスタックに持つ状態でスタートさせます**。 よっ"
"て、VMCS Host-State に保存する RSP も黄色の部分を指すようにします。 RSP は直"
"接 MOV することができないため、[PUSH](https://www.felixcloutier.com/x86/"
"push) と [LEA](https://www.felixcloutier.com/x86/lea) で間接的に設定します。 "
"PUSH を挟むため、`setHostStack()` に渡す引数には `+8(RSP)` を指定しています。"
msgstr ""
"`setHostStack()` を呼び出す直前のスタックの状態は下図のようになっています。 "
"**VM Exit は、図の黄色の部分をスタックに持つ状態でスタートさせます**。 よっ"
"て、VMCS Host-State に保存する RSP も黄色の部分を指すようにします。 RSP は直"
"接 MOV することができないため、[PUSH](https://www.felixcloutier.com/x86/"
"push) と [LEA](https://www.felixcloutier.com/x86/lea) で間接的に設定します。 "
"PUSH を挟むため、`setHostStack()` に渡す引数には `+8(RSP)` を指定しています。"

#: src/vmm/vmentry_vmexit.md:319
msgid ""
"![Stack layout Before VM Entry & After VM Exit](../assets/drawio/"
"vmentry_stack.drawio.png) _Stack Layout Before VM Entry & After VM Exit_"
msgstr ""
"![Stack layout Before VM Entry & After VM Exit](../assets/drawio/"
"vmentry_stack.drawio.png) _Stack Layout Before VM Entry & After VM Exit_"

#: src/vmm/vmentry_vmexit.md:322
msgid ""
"スタックを VMCS にセットしたら、PUSH しておいた RDI を POP して戻します。 こ"
"の時点で RDI は依然として `*Vcpu` を持っています。 引数 `*Vcpu` の中でもう1つ"
"使いたいフィールドが `.launch_done` です。 この値によって VMLAUNCH と "
"VMRESUME のどちらを使うかを決定します。 今のうちにこの値を取得しておきましょ"
"う。 結果は RDI に入れます。 `.launch_done` が `true` であれば `RFLAGS.ZF` "
"が `1` になります:"
msgstr ""
"スタックを VMCS にセットしたら、PUSH しておいた RDI を POP して戻します。 こ"
"の時点で RDI は依然として `*Vcpu` を持っています。 引数 `*Vcpu` の中でもう1つ"
"使いたいフィールドが `.launch_done` です。 この値によって VMLAUNCH と "
"VMRESUME のどちらを使うかを決定します。 今のうちにこの値を取得しておきましょ"
"う。 結果は RDI に入れます。 `.launch_done` が `true` であれば `RFLAGS.ZF` "
"が `1` になります:"

#: src/vmm/vmentry_vmexit.md:340
msgid "ゲストの状態復元"
msgstr "ゲストの状態復元"

#: src/vmm/vmentry_vmexit.md:342
msgid ""
"以上でホストの状態をスタックに保存することができました。 残すはゲストの状態の"
"復元です。 `.guest_regs` からゲストのレジスタを取り出し順にセットしていきま"
"す。 RAX に `&.guest_regs` を入れるため、RAX だけは最後にセットします:"
msgstr ""
"以上でホストの状態をスタックに保存することができました。 残すはゲストの状態の"
"復元です。 `.guest_regs` からゲストのレジスタを取り出し順にセットしていきま"
"す。 RAX に `&.guest_regs` を入れるため、RAX だけは最後にセットします:"

#: src/vmm/vmentry_vmexit.md:402
msgid ""
"ホストの保存とゲストの復元ができたため、いよいよ VM Entry を実行します。 この"
"時点で `RFLAGS.ZF` には VMLAUNCH と VMRESUME のどちらを実行するべきかが格納さ"
"れています。 その値に応じて適切な方を呼び出しましょう:"
msgstr ""
"ホストの保存とゲストの復元ができたため、いよいよ VM Entry を実行します。 この"
"時点で `RFLAGS.ZF` には VMLAUNCH と VMRESUME のどちらを実行するべきかが格納さ"
"れています。 その値に応じて適切な方を呼び出しましょう:"

#: src/vmm/vmentry_vmexit.md:417
msgid ""
"VM Entry が成功すれば処理はゲストに移るため、このあとの命令が実行されることは"
"ありません。 VMX 拡張命令が失敗した場合には続く命令が実行されます。 そのた"
"め、続けてエラーハンドリングを書きます:"
msgstr ""
"VM Entry が成功すれば処理はゲストに移るため、このあとの命令が実行されることは"
"ありません。 VMX 拡張命令が失敗した場合には続く命令が実行されます。 そのた"
"め、続けてエラーハンドリングを書きます:"

#: src/vmm/vmentry_vmexit.md:443
msgid ""
"`asmVmEntry()` は成功時に`0`・失敗時に`1`を返すというオレオレ calling "
"convention にしているため、ここでは`1`をセットします。 先ほどの図で示したとお"
"り、この時点でスタックには　`&.guest_regs` と callee-saved レジスタが積まれて"
"います。 前者は単に POP して捨てて、後者はレジスタに復元してあげます。"
msgstr ""
"`asmVmEntry()` は成功時に`0`・失敗時に`1`を返すというオレオレ calling "
"convention にしているため、ここでは`1`をセットします。 先ほどの図で示したとお"
"り、この時点でスタックには　`&.guest_regs` と callee-saved レジスタが積まれて"
"います。 前者は単に POP して捨てて、後者はレジスタに復元してあげます。"

#: src/vmm/vmentry_vmexit.md:447
msgid "VM Exit"
msgstr "VM Exit"

#: src/vmm/vmentry_vmexit.md:449
msgid ""
"ゲストが何らかの要因で VM Exit すると、VMCS Host-State に設定した RIP に処理"
"が移ります。 Ymir では `asmVmExit()` をセットするため、この関数にホストへの復"
"帰処理を実装します。 VM Exit した時点ではスタックは先ほどの図の黄色部分のよう"
"になっています。 最も上には `&.guest_regs` が積んであります。 ゲストの状態を"
"保存するために使うため、まずはこれを取り出しましょう:"
msgstr ""
"ゲストが何らかの要因で VM Exit すると、VMCS Host-State に設定した RIP に処理"
"が移ります。 Ymir では `asmVmExit()` をセットするため、この関数にホストへの復"
"帰処理を実装します。 VM Exit した時点ではスタックは先ほどの図の黄色部分のよう"
"になっています。 最も上には `&.guest_regs` が積んであります。 ゲストの状態を"
"保存するために使うため、まずはこれを取り出しましょう:"

#: src/vmm/vmentry_vmexit.md:471
msgid ""
"RAX はスクラッチレジスタとして使います。 ゲストの RAX を失うわけにはいかない"
"ため、`&.guest_regs` を取り出す前に RAX をスタックに PUSH しています。"
msgstr ""
"RAX はスクラッチレジスタとして使います。 ゲストの RAX を失うわけにはいかない"
"ため、`&.guest_regs` を取り出す前に RAX をスタックに PUSH しています。"

#: src/vmm/vmentry_vmexit.md:474
msgid "続いてゲストのレジスタを `guest_regs` に保存します:"
msgstr "続いてゲストのレジスタを `guest_regs` に保存します:"

#: src/vmm/vmentry_vmexit.md:537
msgid ""
"ゲストの状態を保存したら、スタックに積んでいたゲストの callee-saved レジスタ"
"を復元します。"
msgstr ""
"ゲストの状態を保存したら、スタックに積んでいたゲストの callee-saved レジスタ"
"を復元します。"

#: src/vmm/vmentry_vmexit.md:552
msgid ""
"この時点でスタックの最も上には `vmentry()` が CALL の際に積んだ RIP がありま"
"す。 よって、ここで RET すると `vmentry()` に復帰することができます。 呼び出"
"し側は、**あたかも `asmVmEntry()` を関数呼び出ししたかのように処理を続行する"
"ことができます**:"
msgstr ""
"この時点でスタックの最も上には `vmentry()` が CALL の際に積んだ RIP がありま"
"す。 よって、ここで RET すると `vmentry()` に復帰することができます。 呼び出"
"し側は、**あたかも `asmVmEntry()` を関数呼び出ししたかのように処理を続行する"
"ことができます**:"

#: src/vmm/vmentry_vmexit.md:565
msgid "Exit Handler"
msgstr "Exit Handler"

#: src/vmm/vmentry_vmexit.md:567
msgid ""
"以上で VM Entry / VM Exit を経て `vmentry()` → `loop()` に復帰することができ"
"ました。 このあとは、VM Exit した要因に応じて適切な処理をしてあげます。 VM "
"Exit のハンドラ関数を定義します:"
msgstr ""
"以上で VM Entry / VM Exit を経て `vmentry()` → `loop()` に復帰することができ"
"ました。 このあとは、VM Exit した要因に応じて適切な処理をしてあげます。 VM "
"Exit のハンドラ関数を定義します:"

#: src/vmm/vmentry_vmexit.md:592
msgid ""
"引数には `ExitInfo` 構造体を受け取ります。 この中には VM Exit した大まかな要"
"因が記録されているため、この要因に応じて `switch` します。 現在はとりあえず "
"HLT による VM Exit 用の処理だけを用意し、HLT が起こったことだけをログ出力する"
"だけにしておきます。"
msgstr ""
"引数には `ExitInfo` 構造体を受け取ります。 この中には VM Exit した大まかな要"
"因が記録されているため、この要因に応じて `switch` します。 現在はとりあえず "
"HLT による VM Exit 用の処理だけを用意し、HLT が起こったことだけをログ出力する"
"だけにしておきます。"

#: src/vmm/vmentry_vmexit.md:596
msgid ""
"`ExitInfo` は VMCS **VM-Exit Information** カテゴリの **Basic VM-Exit "
"Information** フィールドから取得することができます:"
msgstr ""
"`ExitInfo` は VMCS **VM-Exit Information** カテゴリの **Basic VM-Exit "
"Information** フィールドから取得することができます:"

#: src/vmm/vmentry_vmexit.md:608
msgid ""
"Exit ハンドラを呼び出したあとは、`while` ループの先頭に戻り再び VM Entry をし"
"ます。 ひたすらにこの繰り返しです。"
msgstr ""
"Exit ハンドラを呼び出したあとは、`while` ループの先頭に戻り再び VM Entry をし"
"ます。 ひたすらにこの繰り返しです。"

#: src/vmm/vmentry_vmexit.md:611
msgid ""
"最後に、`setupHostState()` で `vmwrite()` を使って VM Exit 時のエントリポイン"
"トを設定しておきます:"
msgstr ""
"最後に、`setupHostState()` で `vmwrite()` を使って VM Exit 時のエントリポイン"
"トを設定しておきます:"

#: src/vmm/vmentry_vmexit.md:626
msgid ""
"それでは、実装した VM Entry / VM Exit を用いてゲストを実行してみましょう。 "
"VMCS Execution Controls の Primary Processor-based Controls における `.hlt` "
"は `true` に設定して、HLT 命令で VM Exit するようにしておいてください。 この"
"状態でゲストを実行すると、以下のような出力になります:"
msgstr ""
"それでは、実装した VM Entry / VM Exit を用いてゲストを実行してみましょう。 "
"VMCS Execution Controls の Primary Processor-based Controls における `.hlt` "
"は `true` に設定して、HLT 命令で VM Exit するようにしておいてください。 この"
"状態でゲストを実行すると、以下のような出力になります:"

#: src/vmm/vmentry_vmexit.md:644
msgid ""
"ひたすらに `HLT` が出力されます。 これは VM Entry / VM Exit ループが正常に動"
"作していることを示しています。 また、ホストが VM Exit ハンドラにおいて出力を"
"したり再度 VM Entry をするためには、ホストの状態が正しく保存・復元されている"
"ことが必要です。 つまり、今回はそれらも意図したとおりに動いているということが"
"分かります。"
msgstr ""
"ひたすらに `HLT` が出力されます。 これは VM Entry / VM Exit ループが正常に動"
"作していることを示しています。 また、ホストが VM Exit ハンドラにおいて出力を"
"したり再度 VM Entry をするためには、ホストの状態が正しく保存・復元されている"
"ことが必要です。 つまり、今回はそれらも意図したとおりに動いているということが"
"分かります。"

#: src/vmm/vmentry_vmexit.md:649
msgid ""
"ゲストの状態が正しく保存・復元されているかどうかが気になる人は、`loop()` の "
"`while` に入る前に `guest_regs.rax = 0xDEADBEEF` のようにゲストレジスタの値を"
"いじってみてください。 HLT で VM Exit しないように設定しゲストを実行すると、"
"ゲストが HLT ループで止まってくれます。 その状態で QEMU monitor でレジスタの"
"状態を確認すると、RAX が `0xDEADBEEF` になっているはずです。"
msgstr ""
"ゲストの状態が正しく保存・復元されているかどうかが気になる人は、`loop()` の "
"`while` に入る前に `guest_regs.rax = 0xDEADBEEF` のようにゲストレジスタの値を"
"いじってみてください。 HLT で VM Exit しないように設定しゲストを実行すると、"
"ゲストが HLT ループで止まってくれます。 その状態で QEMU monitor でレジスタの"
"状態を確認すると、RAX が `0xDEADBEEF` になっているはずです。"

#: src/vmm/vmentry_vmexit.md:653
msgid ""
"本チャプターでは VM Entry / VM Exit の処理を適切に実装することで、何回も VM "
"Entry を繰り返すことができるようになりました。 前チャプターでは単発の "
"VMLAUNCH をして終わりだったことを考えると、大きな進歩と言えるでしょう。 アセ"
"ンブリを直書きすることが多いチャプターでしたが、これ以降はほとんどアセンブリ"
"は出てきません。 その点については安心してください。"
msgstr ""
"本チャプターでは VM Entry / VM Exit の処理を適切に実装することで、何回も VM "
"Entry を繰り返すことができるようになりました。 前チャプターでは単発の "
"VMLAUNCH をして終わりだったことを考えると、大きな進歩と言えるでしょう。 アセ"
"ンブリを直書きすることが多いチャプターでしたが、これ以降はほとんどアセンブリ"
"は出てきません。 その点については安心してください。"

#: src/vmm/vmentry_vmexit.md:660
msgid ""
"[https://zenn.dev/tanakmura/articles/80391e3284c6bb](https://zenn.dev/"
"tanakmura/articles/80391e3284c6bb)"
msgstr ""
"[https://zenn.dev/tanakmura/articles/80391e3284c6bb](https://zenn.dev/"
"tanakmura/articles/80391e3284c6bb)"

#: src/vmm/vmentry_vmexit.md:662
msgid ""
"「サポートしない」というのは利用した場合に未定義動作になるという意味ではな"
"く、システムとしてこれらの機能を利用できなくするという意味です。 これらの機能"
"が利用可能かどうかは CPUID 命令や XCR0 レジスタで確認するのですが、Ymir はゲ"
"ストに対するこれらの値を任意に操作できます。"
msgstr ""
"「サポートしない」というのは利用した場合に未定義動作になるという意味ではな"
"く、システムとしてこれらの機能を利用できなくするという意味です。 これらの機能"
"が利用可能かどうかは CPUID 命令や XCR0 レジスタで確認するのですが、Ymir はゲ"
"ストに対するこれらの値を任意に操作できます。"

#: src/vmm/vmentry_vmexit.md:664
msgid ""
"Callee-saved なレジスタを保存しているのに `vmentry()` 内で caller-saved なレ"
"ジスタ達を [clobber](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm."
"html#Clobbers-and-Scratch-Registers) していることを不審に思ったかもしれませ"
"ん。 インラインアセンブリで CALL しても、コンパイラはその前後で caller-saved "
"なレジスタを保存・復元するようなコードを出力してくれません。 そのため、CALL "
"の前後で手動で caller-saved なレジスタを保存・復元するアセンブリを書くか、今"
"回のように clobber してしまう必要があります。"
msgstr ""
"Callee-saved なレジスタを保存しているのに `vmentry()` 内で caller-saved なレ"
"ジスタ達を [clobber](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm."
"html#Clobbers-and-Scratch-Registers) していることを不審に思ったかもしれませ"
"ん。 インラインアセンブリで CALL しても、コンパイラはその前後で caller-saved "
"なレジスタを保存・復元するようなコードを出力してくれません。 そのため、CALL "
"の前後で手動で caller-saved なレジスタを保存・復元するアセンブリを書くか、今"
"回のように clobber してしまう必要があります。"

#: src/vmm/ept.md:1
msgid "EPT: Extended Page Table"
msgstr "EPT: Extended Page Table"

#: src/vmm/ept.md:3
msgid ""
"本チャプターではゲスト物理アドレスとホスト物理アドレスを変換するための仕組み"
"である EPT を扱います。 EPT を適切に設定することで、ゲストに対してホストと分"
"離された物理アドレス空間を提供しつつ、物理アドレスへのアクセス全てをホストの"
"管理下に置くことができるようになります。"
msgstr ""
"本チャプターではゲスト物理アドレスとホスト物理アドレスを変換するための仕組み"
"である EPT を扱います。 EPT を適切に設定することで、ゲストに対してホストと分"
"離された物理アドレス空間を提供しつつ、物理アドレスへのアクセス全てをホストの"
"管理下に置くことができるようになります。"

#: src/vmm/ept.md:8
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-ept`](https://"
#| "github.com/smallkirby/ymir/tree/whiz-vmm-ept) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-vmm-ept`](https://github.com/smallkirby/"
"ymir/tree/whiz-vmm-ept) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-ept`](https://github."
"com/smallkirby/ymir/tree/whiz-vmm-ept) ブランチにあります。"

#: src/vmm/ept.md:12
msgid "[EPT 概観](#ept-概観)"
msgstr "[EPT 概観](#ept-概観)"

#: src/vmm/ept.md:13
msgid "[EPT の構造](#ept-の構造)"
msgstr "[EPT の構造](#ept-の構造)"

#: src/vmm/ept.md:14
msgid "[マップの作成](#マップの作成)"
msgstr "[マップの作成](#マップの作成)"

#: src/vmm/ept.md:15
msgid "[EPTP](#eptp)"
msgstr "[EPTP](#eptp)"

#: src/vmm/ept.md:16
msgid "[ゲスト物理アドレスのマップ](#ゲスト物理アドレスのマップ)"
msgstr "[ゲスト物理アドレスのマップ](#ゲスト物理アドレスのマップ)"

#: src/vmm/ept.md:17
msgid "[EPT の有効化](#ept-の有効化)"
msgstr "[EPT の有効化](#ept-の有効化)"

#: src/vmm/ept.md:18
msgid "[Unrestricted Guest](#unrestricted-guest)"
msgstr "[Unrestricted Guest](#unrestricted-guest)"

#: src/vmm/ept.md:19
msgid "[VPID](#vpid)"
msgstr "[VPID](#vpid)"

#: src/vmm/ept.md:20
msgid "[キャッシュされる情報](#キャッシュされる情報)"
msgstr "[キャッシュされる情報](#キャッシュされる情報)"

#: src/vmm/ept.md:21
msgid "[VPID の有効化](#vpid-の有効化)"
msgstr "[VPID の有効化](#vpid-の有効化)"

#: src/vmm/ept.md:25
msgid "EPT 概観"
msgstr "EPT 概観"

#: src/vmm/ept.md:27
msgid ""
"前チャプターまでのゲストはホストと物理アドレス空間を共有していました。 ゲスト"
"はホストが使うメモリも含めて任意の物理アドレスにアクセスすることができます。 "
"ゲストが悪意あるソフトウェアであった場合、ホストのメモリから任意のデータを読"
"み取ったり、ホストのデータを書き換えることで仮想化環境を破壊することさえでき"
"ます。 これではセキュリティ的によろしくありません。 ゲストが触れる物理アドレ"
"ス空間はホストから分離されているべきであり、分離した空間も VMM が管理できるよ"
"うにするべきです。"
msgstr ""
"前チャプターまでのゲストはホストと物理アドレス空間を共有していました。 ゲスト"
"はホストが使うメモリも含めて任意の物理アドレスにアクセスすることができます。 "
"ゲストが悪意あるソフトウェアであった場合、ホストのメモリから任意のデータを読"
"み取ったり、ホストのデータを書き換えることで仮想化環境を破壊することさえでき"
"ます。 これではセキュリティ的によろしくありません。 ゲストが触れる物理アドレ"
"ス空間はホストから分離されているべきであり、分離した空間も VMM が管理できるよ"
"うにするべきです。"

#: src/vmm/ept.md:33
msgid ""
"以降は、ゲストの仮想アドレスを **GVA**・ゲストの物理アドレスを **GPA**・ホス"
"トの物理アドレスを **HPA** と表記します。"
msgstr ""
"以降は、ゲストの仮想アドレスを **GVA**・ゲストの物理アドレスを **GPA**・ホス"
"トの物理アドレスを **HPA** と表記します。"

#: src/vmm/ept.md:35
msgid ""
"**EPT: Extended Page Table** は物理メモリの仮想化を支援する VT-x の機構で"
"す。 **EPT は通常の Page Table が HVA to HPA 変換をするのと同様に、GPA to "
"HPA 変換をします**。 ゲストが GVA を使ってメモリアクセスをする際には、Page "
"Table を使って GVA to GPA 変換をしたあと、 さらに GPA to HPA 変換をすることに"
"なります。"
msgstr ""
"**EPT: Extended Page Table** は物理メモリの仮想化を支援する VT-x の機構で"
"す。 **EPT は通常の Page Table が HVA to HPA 変換をするのと同様に、GPA to "
"HPA 変換をします**。 ゲストが GVA を使ってメモリアクセスをする際には、Page "
"Table を使って GVA to GPA 変換をしたあと、 さらに GPA to HPA 変換をすることに"
"なります。"

#: src/vmm/ept.md:40
msgid ""
"![Address Translation Using EPT](../assets/drawio/ept.drawio.png) _Address "
"Translation Using EPT_"
msgstr ""
"![Address Translation Using EPT](../assets/drawio/ept.drawio.png) _Address "
"Translation Using EPT_"

#: src/vmm/ept.md:43
msgid ""
"ここで注意したいのが、ゲストが GVA to GPA 変換を行う際のページテーブルへのア"
"クセスでも GPA to HPA 変換をする必要があるという点です。 ゲストの CR3 にはゲ"
"ストの GVA to GPA 変換に必要な Lv4 Page Table の GPA が入っていますが、 この"
"テーブルにアクセスする前にそのアドレスを HPA に変換する必要があります。 図に"
"おいて、上段 (Guest) の赤色の参照がそれぞれアドレス解決のために、下段 (VMM) "
"の4回分の参照をする必要があるというイメージです。 よって、ページテーブルを1段"
"参照するためには4回の Host Page Table (Lv4~Lv1) へのアクセスが必要になりま"
"す。 つまり **仮想化なしでは通常4回の参照でアクセスできるところ、EPT を使った"
"場合には16回の参照が必要になります**。"
msgstr ""
"ここで注意したいのが、ゲストが GVA to GPA 変換を行う際のページテーブルへのア"
"クセスでも GPA to HPA 変換をする必要があるという点です。 ゲストの CR3 にはゲ"
"ストの GVA to GPA 変換に必要な Lv4 Page Table の GPA が入っていますが、 この"
"テーブルにアクセスする前にそのアドレスを HPA に変換する必要があります。 図に"
"おいて、上段 (Guest) の赤色の参照がそれぞれアドレス解決のために、下段 (VMM) "
"の4回分の参照をする必要があるというイメージです。 よって、ページテーブルを1段"
"参照するためには4回の Host Page Table (Lv4~Lv1) へのアクセスが必要になりま"
"す。 つまり **仮想化なしでは通常4回の参照でアクセスできるところ、EPT を使った"
"場合には16回の参照が必要になります**。"

#: src/vmm/ept.md:50
msgid ""
"もちろん実際には TLB のおかげでここまで多くの回数の参照が発生することはそんな"
"に多くありません。 TLB は GVA to GPA 変換・GPA to HPA 変換の [それぞれの結果"
"をキャッシュしています](#キャッシュされる情報)。 もしも GVA to GPA 変換と "
"GPA to HPA 変換の結果が TLB にキャッシュされていれば、1度もメモリアクセスする"
"こと無くアドレス変換ができるというのは非仮想化環境と同じです。 (厳密には、後"
"述するように TLB には GVA to HPA 変換の結果も入っています。)"
msgstr ""
"もちろん実際には TLB のおかげでここまで多くの回数の参照が発生することはそんな"
"に多くありません。 TLB は GVA to GPA 変換・GPA to HPA 変換の [それぞれの結果"
"をキャッシュしています](#キャッシュされる情報)。 もしも GVA to GPA 変換と "
"GPA to HPA 変換の結果が TLB にキャッシュされていれば、1度もメモリアクセスする"
"こと無くアドレス変換ができるというのは非仮想化環境と同じです。 (厳密には、後"
"述するように TLB には GVA to HPA 変換の結果も入っています。)"

#: src/vmm/ept.md:55
msgid "EPT の構造"
msgstr "EPT の構造"

#: src/vmm/ept.md:57
msgid ""
"EPT による GPA to HPA 変換は、通常のページテーブルと同様に4段階か5段階を選択"
"することができます。 本シリーズでは、ページテーブルと同様に4段階の EPT を採用"
"します。"
msgstr ""
"EPT による GPA to HPA 変換は、通常のページテーブルと同様に4段階か5段階を選択"
"することができます。 本シリーズでは、ページテーブルと同様に4段階の EPT を採用"
"します。"

#: src/vmm/ept.md:60
msgid ""
"EPT の構造も通常のページテーブルエントリと同様(もしくは少し単純)になっていま"
"す。 以下に EPT エントリを表す構造を示します。 ほとんど [ページテーブルのチャ"
"プター](../kernel/paging.md) で扱ったものと同じです:"
msgstr ""
"EPT の構造も通常のページテーブルエントリと同様(もしくは少し単純)になっていま"
"す。 以下に EPT エントリを表す構造を示します。 ほとんど [ページテーブルのチャ"
"プター](../kernel/paging.md) で扱ったものと同じです:"

#: src/vmm/ept.md:156
msgid ""
"Lv4 ~ Lv1 のエントリはおおよそ同じ構造になっているため、本シリーズでは共通化"
"した `struct` を利用します。 これもページテーブルの時と同様です。"
msgstr ""
"Lv4 ~ Lv1 のエントリはおおよそ同じ構造になっているため、本シリーズでは共通化"
"した `struct` を利用します。 これもページテーブルの時と同様です。"

#: src/vmm/ept.md:159
msgid ""
"ページテーブルとの違いとして、`present` ビットがなくなりました。 代わりに、"
"RWX を表すビット3つのビット全てが `0` である場合に、そのエントリは present で"
"はないとみなされます。"
msgstr ""
"ページテーブルとの違いとして、`present` ビットがなくなりました。 代わりに、"
"RWX を表すビット3つのビット全てが `0` である場合に、そのエントリは present で"
"はないとみなされます。"

#: src/vmm/ept.md:162
msgid "マップの作成"
msgstr "マップの作成"

#: src/vmm/ept.md:164
msgid ""
"前述したように、EPT を有効化したアドレス変換はテーブルの参照回数が大きく増え"
"るため非常に効率が悪くなります。 最も愚直な対策は、できるだけ大きい EPT ペー"
"ジを利用することです。 **Ymir では 2MiB ページの EPT だけを利用することにしま"
"す**。 2MiB ページに属するアドレスの GPA to HPA 変換は、Lv2 エントリまでの参"
"照で完了します。 GPA to HPA 変換が3回のメモリアクセスで完了することから、4段"
"全て使った変換に比べてアクセス回数が 3/4 になります[^2mib]。"
msgstr ""
"前述したように、EPT を有効化したアドレス変換はテーブルの参照回数が大きく増え"
"るため非常に効率が悪くなります。 最も愚直な対策は、できるだけ大きい EPT ペー"
"ジを利用することです。 **Ymir では 2MiB ページの EPT だけを利用することにしま"
"す**。 2MiB ページに属するアドレスの GPA to HPA 変換は、Lv2 エントリまでの参"
"照で完了します。 GPA to HPA 変換が3回のメモリアクセスで完了することから、4段"
"全て使った変換に比べてアクセス回数が 3/4 になります[^2mib]。"

#: src/vmm/ept.md:170
msgid ""
"2MiB ページをマップする関数が以下です。 何回も言いますが、ページテーブルと本"
"当に同じですね[^pg-ept]:"
msgstr ""
"2MiB ページをマップする関数が以下です。 何回も言いますが、ページテーブルと本"
"当に同じですね[^pg-ept]:"

#: src/vmm/ept.md:199
msgid ""
"`initTable()` は `Allocator` からページを確保し、512個分のエントリを non-"
"present の状態で初期化します:"
msgstr ""
"`initTable()` は `Allocator` からページを確保し、512個分のエントリを non-"
"present の状態で初期化します:"

#: src/vmm/ept.md:216
msgid ""
"`lv4_shift` のような定数や `getLv3Entry` のような関数は、`ymir/arch/x86/page."
"zig` で定義されるホストページテーブルのものと同じです。 詳細は [Github リポジ"
"トリ](https://github.com/smallkirby/ymir/"
"blob/5486787bce98ec0613ee81f5fa9c73b6a58ea8ac/ymir/arch/x86/vmx/ept.zig#L13-"
"L33) を参照してください。"
msgstr ""
"`lv4_shift` のような定数や `getLv3Entry` のような関数は、`ymir/arch/x86/page."
"zig` で定義されるホストページテーブルのものと同じです。 詳細は [Github リポジ"
"トリ](https://github.com/smallkirby/ymir/"
"blob/5486787bce98ec0613ee81f5fa9c73b6a58ea8ac/ymir/arch/x86/vmx/ept.zig#L13-"
"L33) を参照してください。"

#: src/vmm/ept.md:219
msgid "EPTP"
msgstr "EPTP"

#: src/vmm/ept.md:221
msgid ""
"ページングでは **CR3** レジスタが Lv4 テーブルのアドレス (+αの情報) を保持し"
"ていました。 同様に、Lv4 EPT テーブルのアドレスは **EPTP: Extended Page "
"Table Pointer** が保持します。 EPTP は以下のフォーマットを持っています。 つい"
"でに各レベルの EPT のフォーマットも載せておきます:"
msgstr ""
"ページングでは **CR3** レジスタが Lv4 テーブルのアドレス (+αの情報) を保持し"
"ていました。 同様に、Lv4 EPT テーブルのアドレスは **EPTP: Extended Page "
"Table Pointer** が保持します。 EPTP は以下のフォーマットを持っています。 つい"
"でに各レベルの EPT のフォーマットも載せておきます:"

#: src/vmm/ept.md:226
msgid ""
"![Formats of EPTP and EPT Paging Structure Entries](../assets/sdm/ept_format."
"png) _Formats of EPTP and EPT Paging Structure Entries. SDM Vol.3C 29.3.3 "
"Figure 29-1._"
msgstr ""
"![Formats of EPTP and EPT Paging Structure Entries](../assets/sdm/ept_format."
"png) _Formats of EPTP and EPT Paging Structure Entries. SDM Vol.3C 29.3.3 "
"Figure 29-1._"

#: src/vmm/ept.md:229
msgid ""
"フォーマットに従って `Eptp` を定義します。 この構造体は `new()` で Lv4 テーブ"
"ルのアドレスを受け取ります。 EPTP に格納する Lv4 テーブルのアドレスは、CR3 と"
"同様に物理アドレス(HPA)であることに注意してください:"
msgstr ""
"フォーマットに従って `Eptp` を定義します。 この構造体は `new()` で Lv4 テーブ"
"ルのアドレスを受け取ります。 EPTP に格納する Lv4 テーブルのアドレスは、CR3 と"
"同様に物理アドレス(HPA)であることに注意してください:"

#: src/vmm/ept.md:268
msgid "ゲスト物理アドレスのマップ"
msgstr "ゲスト物理アドレスのマップ"

#: src/vmm/ept.md:270
msgid "それでは EPT を使ってゲストに物理アドレスをマップしていきます。"
msgstr "それでは EPT を使ってゲストに物理アドレスをマップしていきます。"

#: src/vmm/ept.md:272
msgid ""
"EPT の運用には様々な方法があります。 よくある方法は、ページテーブルと同様に最"
"初は必要なページだけをマップしておき、それ以外のページでフォルトが発生したら"
"実際に物理メモリを割り当てるという方法です。 ゲストがマップされていない GPA "
"にアクセスしようとすると、VM Exit が発生します。 これを契機にして VMM は必要"
"な分だけ on-demand で物理メモリを割り当てることができます。 この方法のメリッ"
"トは、ゲストが必要とする分だけ物理メモリを割り当てれば良いことです。 ゲストが"
"本当にメモリをアクセスしない限りは、使用されていないメモリは他ゲストやホスト"
"が使うことができます。"
msgstr ""
"EPT の運用には様々な方法があります。 よくある方法は、ページテーブルと同様に最"
"初は必要なページだけをマップしておき、それ以外のページでフォルトが発生したら"
"実際に物理メモリを割り当てるという方法です。 ゲストがマップされていない GPA "
"にアクセスしようとすると、VM Exit が発生します。 これを契機にして VMM は必要"
"な分だけ on-demand で物理メモリを割り当てることができます。 この方法のメリッ"
"トは、ゲストが必要とする分だけ物理メモリを割り当てれば良いことです。 ゲストが"
"本当にメモリをアクセスしない限りは、使用されていないメモリは他ゲストやホスト"
"が使うことができます。"

#: src/vmm/ept.md:279
msgid ""
"本シリーズでは別のアプローチを採用します。 [ページテーブルのチャプター](../"
"kernel/paging.md) では、ページテーブルを初期化する際に全ての利用可能な仮想ア"
"ドレスを物理ページにマップしていました。 それによって、Ymir ではページフォル"
"トが発生することがありません。 発生した場合にはすなわちバグを意味し、回復不可"
"能とみなしてアボートします。 これは Linux カーネルでも同様です。 これになら"
"い Ymir では、**ゲストが利用できる物理アドレスをゲストの起動前に全てマップし"
"てしまいます**。 よって、EPT Violation が発生することはありません。 一度 EPT "
"を初期化したらあとは二度と触らないという方針です。"
msgstr ""
"本シリーズでは別のアプローチを採用します。 [ページテーブルのチャプター](../"
"kernel/paging.md) では、ページテーブルを初期化する際に全ての利用可能な仮想ア"
"ドレスを物理ページにマップしていました。 それによって、Ymir ではページフォル"
"トが発生することがありません。 発生した場合にはすなわちバグを意味し、回復不可"
"能とみなしてアボートします。 これは Linux カーネルでも同様です。 これになら"
"い Ymir では、**ゲストが利用できる物理アドレスをゲストの起動前に全てマップし"
"てしまいます**。 よって、EPT Violation が発生することはありません。 一度 EPT "
"を初期化したらあとは二度と触らないという方針です。"

#: src/vmm/ept.md:288
msgid ""
"本シリーズでは 100MiB を固定でゲストに割り当てることにします。 Ymir 自体は "
"512MiB のメモリを割り当てるように QEMU の起動オプションで設定していました。 "
"ゲストに渡す 100MiB を差し引いても、Ymir は 412MiB のメモリを利用できます。 "
"十分すぎるくらいです[^memsize]。"
msgstr ""
"本シリーズでは 100MiB を固定でゲストに割り当てることにします。 Ymir 自体は "
"512MiB のメモリを割り当てるように QEMU の起動オプションで設定していました。 "
"ゲストに渡す 100MiB を差し引いても、Ymir は 412MiB のメモリを利用できます。 "
"十分すぎるくらいです[^memsize]。"

#: src/vmm/ept.md:293
msgid ""
"`Vm` 構造体にゲストのメモリを保持するためのメンバ `guest_mem` を追加し、ゲス"
"トメモリを初期化する関数を追加します:"
msgstr ""
"`Vm` 構造体にゲストのメモリを保持するためのメンバ `guest_mem` を追加し、ゲス"
"トメモリを初期化する関数を追加します:"

#: src/vmm/ept.md:321
msgid ""
"メモリは**連続した 100MiB 領域を確保します**。 別に連続させる必然性はないので"
"すが、EPT テーブルの設定が楽になるためこうしています。 また、2MiB ページだけ"
"を利用できるようにするため、確保する領域は 2MiB アラインされている必要があり"
"ます。 1ページサイズ以上のアラインを要求するメモリ確保は `Allocator` インタ"
"フェースには実装されていません。 そのため、仕方がなく `PageAllocator` インス"
"タンスを直接引数として受け取るようにしています。"
msgstr ""
"メモリは**連続した 100MiB 領域を確保します**。 別に連続させる必然性はないので"
"すが、EPT テーブルの設定が楽になるためこうしています。 また、2MiB ページだけ"
"を利用できるようにするため、確保する領域は 2MiB アラインされている必要があり"
"ます。 1ページサイズ以上のアラインを要求するメモリ確保は `Allocator` インタ"
"フェースには実装されていません。 そのため、仕方がなく `PageAllocator` インス"
"タンスを直接引数として受け取るようにしています。"

#: src/vmm/ept.md:327
msgid ""
"メモリを確保したら、確保した領域の情報をもとに EPT を初期化するため `arch."
"vmx.mapGuest()` を呼び出します。 この関数は `arch.vmx.ept` を Ymir 全体に露出"
"させないための単なるラッパー関数です:"
msgstr ""
"メモリを確保したら、確保した領域の情報をもとに EPT を初期化するため `arch."
"vmx.mapGuest()` を呼び出します。 この関数は `arch.vmx.ept` を Ymir 全体に露出"
"させないための単なるラッパー関数です:"

#: src/vmm/ept.md:342
msgid "実体は `ept.initEpt()` です:"
msgstr "実体は `ept.initEpt()` です:"

#: src/vmm/ept.md:372
msgid ""
"ゲストのメモリサイズから必要な 2MiB ページの個数を計算し、その回数だけ先ほど"
"実装した `map2m()` を呼び出します。"
msgstr ""
"ゲストのメモリサイズから必要な 2MiB ページの個数を計算し、その回数だけ先ほど"
"実装した `map2m()` を呼び出します。"

#: src/vmm/ept.md:374
msgid ""
"これらの関数は、VMX Root Operation に入った後 VM を起動する前に "
"`kernelMail()` から呼び出します:"
msgstr ""
"これらの関数は、VMX Root Operation に入った後 VM を起動する前に "
"`kernelMail()` から呼び出します:"

#: src/vmm/ept.md:386
msgid ""
"これでゲスト物理メモリのマップが完成しました。 Lv4 EPT テーブルを指す EPTP を"
"得られたので、これを VMCS Execution Control に設定します。 EPTP は vCPU ごと"
"に保持するものであるため、ゲストメモリに関する情報もついでに `Vcpu` に持たせ"
"ておきましょう:"
msgstr ""
"これでゲスト物理メモリのマップが完成しました。 Lv4 EPT テーブルを指す EPTP を"
"得られたので、これを VMCS Execution Control に設定します。 EPTP は vCPU ごと"
"に保持するものであるため、ゲストメモリに関する情報もついでに `Vcpu` に持たせ"
"ておきましょう:"

#: src/vmm/ept.md:405
msgid "EPT の有効化"
msgstr "EPT の有効化"

#: src/vmm/ept.md:407
msgid ""
"EPTP はセットしただけでは有効になりません。 VMCS Execution Control カテゴリ"
"の **Secondary Processor-Based VM-Execution Control** のビットを立ててあげる"
"必要があります。 このフィールドは Primary Processor-Based VM-Execution "
"Control と同様に主に同期的イベントに関する vCPU の挙動を制御します。 まだこの"
"フィールドは使ったことがなかったため、構造体を定義しておきます:"
msgstr ""
"EPTP はセットしただけでは有効になりません。 VMCS Execution Control カテゴリ"
"の **Secondary Processor-Based VM-Execution Control** のビットを立ててあげる"
"必要があります。 このフィールドは Primary Processor-Based VM-Execution "
"Control と同様に主に同期的イベントに関する vCPU の挙動を制御します。 まだこの"
"フィールドは使ったことがなかったため、構造体を定義しておきます:"

#: src/vmm/ept.md:461
msgid ""
"EPT を有効化するには `.ept` ビットをセットします。 他の Execution Control "
"フィールドと同様に、Reserved Bits を `0` にするか `1` にするかは MSR に問い合"
"わせる必要があります。 Secondary Processor-Based Control の場合は、"
"`IA32_VMX_PROCBASED_CTLS2` MSR (address `0x048B`) に問い合わせます:"
msgstr ""
"EPT を有効化するには `.ept` ビットをセットします。 他の Execution Control "
"フィールドと同様に、Reserved Bits を `0` にするか `1` にするかは MSR に問い合"
"わせる必要があります。 Secondary Processor-Based Control の場合は、"
"`IA32_VMX_PROCBASED_CTLS2` MSR (address `0x048B`) に問い合わせます:"

#: src/vmm/ept.md:480
msgid "Unrestricted Guest"
msgstr "Unrestricted Guest"

#: src/vmm/ept.md:482
msgid ""
"EPT が有効化できたことを確かめていきます。 このチャプターまでは、ゲストはホス"
"トとアドレス空間を共有したまま `blobGuest()` を実行していました。 EPT を有効"
"化すると、ゲストとホストのアドレス空間が分離されるため、**ゲストはホストのア"
"ドレス空間に配置された `blobGuest()` を実行することができなくなります**。 今"
"までどおりゲストの `blobGuest()` を実行しようとした場合、VMCS RIP に登録した"
"アドレスは _GVA_ として解釈されます。 これはゲストの CR3 に格納されたページ"
"テーブルによって _GPA_ に変換され、さらに EPT によって _HPA_ に変換されま"
"す。 この結果、RIP が指すのはもはや `blobGuest()` の HPA ではなくなってしまい"
"ます。"
msgstr ""
"EPT が有効化できたことを確かめていきます。 このチャプターまでは、ゲストはホス"
"トとアドレス空間を共有したまま `blobGuest()` を実行していました。 EPT を有効"
"化すると、ゲストとホストのアドレス空間が分離されるため、**ゲストはホストのア"
"ドレス空間に配置された `blobGuest()` を実行することができなくなります**。 今"
"までどおりゲストの `blobGuest()` を実行しようとした場合、VMCS RIP に登録した"
"アドレスは _GVA_ として解釈されます。 これはゲストの CR3 に格納されたページ"
"テーブルによって _GPA_ に変換され、さらに EPT によって _HPA_ に変換されま"
"す。 この結果、RIP が指すのはもはや `blobGuest()` の HPA ではなくなってしまい"
"ます。"

#: src/vmm/ept.md:489
msgid ""
"厳密に言うと、CR3に格納された物理アドレス自体が GPA として解釈され EPT による"
"さらなる変換を受けるため、 もはやページテーブルにアクセスすることができず、"
"RIP を GVA to GPA 変換することすらできません。 これは、いかなるアドレスにもア"
"クセスすることができないということを意味します。 1命令でも実行しようものなら"
"ページフォルトが発生し、そのハンドラも実行できないのですぐさま Triple Fault "
"であの世行きです。 これではゲストのプログラムを実行することができません。"
msgstr ""
"厳密に言うと、CR3に格納された物理アドレス自体が GPA として解釈され EPT による"
"さらなる変換を受けるため、 もはやページテーブルにアクセスすることができず、"
"RIP を GVA to GPA 変換することすらできません。 これは、いかなるアドレスにもア"
"クセスすることができないということを意味します。 1命令でも実行しようものなら"
"ページフォルトが発生し、そのハンドラも実行できないのですぐさま Triple Fault "
"であの世行きです。 これではゲストのプログラムを実行することができません。"

#: src/vmm/ept.md:495
msgid ""
"そこで、本チャプターからはゲストを **Unrestricted Guest** として実行します。 "
"今まで実行していたゲストは **Restricted Guest** でした。 **Restricted Guest "
"は、ページングを無効化したり、リアルモードで動作することができません**。 対し"
"て、Unrestricted Guest はページングを無効化したりリアルモードで動作することが"
"できます。 Unrestricted Guest にした上でページングを無効化することで、ゲスト"
"の GVA to GPA 変換を無効化し、少なくともメモリアクセスはできるようにします。"
msgstr ""
"そこで、本チャプターからはゲストを **Unrestricted Guest** として実行します。 "
"今まで実行していたゲストは **Restricted Guest** でした。 **Restricted Guest "
"は、ページングを無効化したり、リアルモードで動作することができません**。 対し"
"て、Unrestricted Guest はページングを無効化したりリアルモードで動作することが"
"できます。 Unrestricted Guest にした上でページングを無効化することで、ゲスト"
"の GVA to GPA 変換を無効化し、少なくともメモリアクセスはできるようにします。"

#: src/vmm/ept.md:501
msgid ""
"大まかな方針として、ゲストを実行する前に、ホストからゲストのアドレスに直接 "
"`blobGuest()` をコピーしておきます。 分かりやすく **ゲストメモリの先頭に "
"`blobGuest()` をコピーした場合、VMCS RIP に `0` を設定することでゲストは "
"`blobGuest()` を実行できる** ようになります。"
msgstr ""
"大まかな方針として、ゲストを実行する前に、ホストからゲストのアドレスに直接 "
"`blobGuest()` をコピーしておきます。 分かりやすく **ゲストメモリの先頭に "
"`blobGuest()` をコピーした場合、VMCS RIP に `0` を設定することでゲストは "
"`blobGuest()` を実行できる** ようになります。"

#: src/vmm/ept.md:504
msgid "まずは Unrestricted Guest を有効化します:"
msgstr "まずは Unrestricted Guest を有効化します:"

#: src/vmm/ept.md:515
msgid "また、VM Entry 時に IA-32e モードを無効化します:"
msgstr "また、VM Entry 時に IA-32e モードを無効化します:"

#: src/vmm/ept.md:526
msgid "続いて、Guest State の CR0 を操作してページングを無効化します:"
msgstr "続いて、Guest State の CR0 を操作してページングを無効化します:"

#: src/vmm/ept.md:584
msgid ""
"これでゲストが Unrestricted Guest + ページング無効になりました。 最後に、ゲス"
"トメモリに `blobGuest()` をコピーして VMCS RIP に `0` を設定します:"
msgstr ""
"これでゲストが Unrestricted Guest + ページング無効になりました。 最後に、ゲス"
"トメモリに `blobGuest()` をコピーして VMCS RIP に `0` を設定します:"

#: src/vmm/ept.md:598
msgid ""
"コピーするサイズの `0x20` は適当です。 現在 `blobGuest()` は HLT ループをする"
"だけであるため、`hlt` + `jmp` の2命令だけで構成されているはずであり、こんなに"
"バイト数は必要ありません。 まぁ[こんなんなんぼあってもいいですからね]"
"(https://youtu.be/3bAwLydEsZo)。"
msgstr ""
"コピーするサイズの `0x20` は適当です。 現在 `blobGuest()` は HLT ループをする"
"だけであるため、`hlt` + `jmp` の2命令だけで構成されているはずであり、こんなに"
"バイト数は必要ありません。 まぁ[こんなんなんぼあってもいいですからね]"
"(https://youtu.be/3bAwLydEsZo)。"

#: src/vmm/ept.md:610
msgid "さて、ゲストを実行してみましょう。 出力は以下のようになります:"
msgstr "さて、ゲストを実行してみましょう。 出力は以下のようになります:"

#: src/vmm/ept.md:622
msgid ""
"特にクラッシュもせず、VMX Exit も発生しません。 無事に HLT ループに入っている"
"ようです。 QEMU monitor で `info registers` を実行すると以下のようになります:"
msgstr ""
"特にクラッシュもせず、VMX Exit も発生しません。 無事に HLT ループに入っている"
"ようです。 QEMU monitor で `info registers` を実行すると以下のようになります:"

#: src/vmm/ept.md:644
msgid ""
"RIP が `0x3` になっています。 これは先ほどの `objdump` の結果によると JMP 命"
"令です。 やはりちゃんと HLT ループに入ってますね。 おまけに、ゲストのマーカー"
"として設定していた `0xDEAD00` が LDT に設定されていることが分かります。 これ"
"で、EPT が有効化され GPA が HPA に変換されていることが確認できました。"
msgstr ""
"RIP が `0x3` になっています。 これは先ほどの `objdump` の結果によると JMP 命"
"令です。 やはりちゃんと HLT ループに入ってますね。 おまけに、ゲストのマーカー"
"として設定していた `0xDEAD00` が LDT に設定されていることが分かります。 これ"
"で、EPT が有効化され GPA が HPA に変換されていることが確認できました。"

#: src/vmm/ept.md:650
msgid "VPID"
msgstr "VPID"

#: src/vmm/ept.md:652
msgid "最後に EPT を使う上で重要な機能である VPID について軽く触れておきます。"
msgstr ""
"最後に EPT を使う上で重要な機能である VPID について軽く触れておきます。"

#: src/vmm/ept.md:654
msgid ""
"EPT を使う上で問題になるのが TLB のフラッシュタイミングです。 EPT を利用する"
"ということはホストの仮想アドレス空間に加えてゲストの仮想アドレス空間も TLB に"
"キャッシュされるということです。 一昔前のアーキテクチャでは TLB のキャッシュ"
"エントリがホストとゲストのどちらのアドレス空間に属しているかを区別することが"
"できませんでした。 このまま TLB を利用してしまうと、ホストにいるのにゲストの"
"アドレス空間に属する TLB エントリを利用してしまう可能性があります。 その場合"
"誤ったアドレス変換が発生し、プログラムがぶっ壊れてしまいます。 これを防ぐた"
"め、当時は VMX Non-root Operation と VMX Root Operation を遷移する際に全ての "
"TLB エントリがフラッシュされました。"
msgstr ""
"EPT を使う上で問題になるのが TLB のフラッシュタイミングです。 EPT を利用する"
"ということはホストの仮想アドレス空間に加えてゲストの仮想アドレス空間も TLB に"
"キャッシュされるということです。 一昔前のアーキテクチャでは TLB のキャッシュ"
"エントリがホストとゲストのどちらのアドレス空間に属しているかを区別することが"
"できませんでした。 このまま TLB を利用してしまうと、ホストにいるのにゲストの"
"アドレス空間に属する TLB エントリを利用してしまう可能性があります。 その場合"
"誤ったアドレス変換が発生し、プログラムがぶっ壊れてしまいます。 これを防ぐた"
"め、当時は VMX Non-root Operation と VMX Root Operation を遷移する際に全ての "
"TLB エントリがフラッシュされました。"

#: src/vmm/ept.md:661
msgid ""
"無駄な TLB フラッシュを避けるため、以降の CPU には **VPID: Virtual Processor "
"Identifier** という機構が導入されました。 VPID は各 vCPU (及び論理コア) に割"
"り当てられる 16bit の固有なIDで、VM間(+ホスト) の TLB における名前空間を分離"
"します。 VPID を有効化することで VM 間またはVM-ホスト間で、誤ってキャッシュさ"
"れた別のアドレス変換を利用することがなくなります。 これにより、**VMX Non-"
"root Operation と VMX Root Operation 間で TLB をフラッシュする必要がなくなり"
"ました**。"
msgstr ""
"無駄な TLB フラッシュを避けるため、以降の CPU には **VPID: Virtual Processor "
"Identifier** という機構が導入されました。 VPID は各 vCPU (及び論理コア) に割"
"り当てられる 16bit の固有なIDで、VM間(+ホスト) の TLB における名前空間を分離"
"します。 VPID を有効化することで VM 間またはVM-ホスト間で、誤ってキャッシュさ"
"れた別のアドレス変換を利用することがなくなります。 これにより、**VMX Non-"
"root Operation と VMX Root Operation 間で TLB をフラッシュする必要がなくなり"
"ました**。"

#: src/vmm/ept.md:666
msgid ""
"ホストは自動的に VPID の `0` を割り当てられます。 各 vCPU には `1` 以上のユ"
"ニークな VPID を明示的に割り当てる必要があります。 誤ってゲストの VPID とし"
"て `0` を割り当てると、VM Entry が失敗します。 逆に異なるゲストに意図せず同"
"じ VPID を割り当てると、それらのゲスト間で同じ TLB エントリが利用されるように"
"なってしまいバグります。"
msgstr ""
"ホストは自動的に VPID の `0` を割り当てられます。 各 vCPU には `1` 以上のユ"
"ニークな VPID を明示的に割り当てる必要があります。 誤ってゲストの VPID とし"
"て `0` を割り当てると、VM Entry が失敗します。 逆に異なるゲストに意図せず同"
"じ VPID を割り当てると、それらのゲスト間で同じ TLB エントリが利用されるように"
"なってしまいバグります。"

#: src/vmm/ept.md:671
msgid "キャッシュされる情報"
msgstr "キャッシュされる情報"

#: src/vmm/ept.md:673
msgid ""
"EPT と VPID を有効化したとき、 TLB にキャッシュされる情報には以下の3種類があ"
"ります[^mappings]:"
msgstr ""
"EPT と VPID を有効化したとき、 TLB にキャッシュされる情報には以下の3種類があ"
"ります[^mappings]:"

#: src/vmm/ept.md:675 src/vmm/cr.md:476
msgid ""
"**Linear Mappings**: GVA to GPA(=HPA) の変換結果。およびそれらの変換に利用さ"
"れるページテーブルエントリ。"
msgstr ""
"**Linear Mappings**: GVA to GPA(=HPA) の変換結果。およびそれらの変換に利用さ"
"れるページテーブルエントリ。"

#: src/vmm/ept.md:676 src/vmm/cr.md:477
msgid ""
"**Guest-Physical Mappings**: GPA to HPA の変換結果。およびそれらの変換に利用"
"される EPT エントリ。"
msgstr ""
"**Guest-Physical Mappings**: GPA to HPA の変換結果。およびそれらの変換に利用"
"される EPT エントリ。"

#: src/vmm/ept.md:677 src/vmm/cr.md:478
msgid ""
"**Combined Mappings**: GVA to HPA の変換結果。およびそれらの変換に利用される"
"ページテーブルと EPT エントリ。"
msgstr ""
"**Combined Mappings**: GVA to HPA の変換結果。およびそれらの変換に利用される"
"ページテーブルと EPT エントリ。"

#: src/vmm/ept.md:679
msgid ""
"各 mappings のキャッシュには、アドレスの変換結果の他にメモリタイプやアクセス"
"権限といった情報も含まれます。 Combined Mappings の場合には、ページテーブル"
"と EPT の両方を総合したメモリタイプ・アクセス権限がキャッシュされます。"
msgstr ""
"各 mappings のキャッシュには、アドレスの変換結果の他にメモリタイプやアクセス"
"権限といった情報も含まれます。 Combined Mappings の場合には、ページテーブル"
"と EPT の両方を総合したメモリタイプ・アクセス権限がキャッシュされます。"

#: src/vmm/ept.md:682
msgid ""
"ゲストがメモリアクセスをする場合、各 mappings は以下のように利用されます:"
msgstr ""
"ゲストがメモリアクセスをする場合、各 mappings は以下のように利用されます:"

#: src/vmm/ept.md:684
msgid ""
"EPT が無効なとき: VPID と PCID でタグ付けされた Linear Mappings が利用され"
"る。"
msgstr ""
"EPT が無効なとき: VPID と PCID でタグ付けされた Linear Mappings が利用され"
"る。"

#: src/vmm/ept.md:685
msgid "EPT が有効なとき:"
msgstr "EPT が有効なとき:"

#: src/vmm/ept.md:686
msgid ""
"仮想アドレスアクセス: VPID と PCID と EPTRTA[^eptrta] でタグ付けされた "
"Combined Mappings が利用される。"
msgstr ""
"仮想アドレスアクセス: VPID と PCID と EPTRTA[^eptrta] でタグ付けされた "
"Combined Mappings が利用される。"

#: src/vmm/ept.md:687 src/vmm/cr.md:483
msgid ""
"物理アドレスアクセス: EPTRTA でタグ付けされた Guest-Physical Mappings が利用"
"される。"
msgstr ""
"物理アドレスアクセス: EPTRTA でタグ付けされた Guest-Physical Mappings が利用"
"される。"

#: src/vmm/ept.md:689
msgid ""
"これらのキャッシュを無効化する方法と無効化される mappings は以下のとおりです:"
msgstr ""
"これらのキャッシュを無効化する方法と無効化される mappings は以下のとおりです:"

#: src/vmm/ept.md:691
msgid ""
"VMX Operations に関係なく TLB をフラッシュする操作: Linear + Combined (tag: "
"VPID)"
msgstr ""
"VMX Operations に関係なく TLB をフラッシュする操作: Linear + Combined (tag: "
"VPID)"

#: src/vmm/ept.md:692
msgid ""
"[INVLPG](https://www.felixcloutier.com/x86/invlpg) や [INVPCID](https://www."
"felixcloutier.com/x86/invpcid) や CR3 のリロード(63-th bit がセットされていな"
"い場合) など"
msgstr ""
"[INVLPG](https://www.felixcloutier.com/x86/invlpg) や [INVPCID](https://www."
"felixcloutier.com/x86/invpcid) や CR3 のリロード(63-th bit がセットされていな"
"い場合) など"

#: src/vmm/ept.md:693
msgid ""
"EPT Violation: アドレス変換に使われた Guest-Physical (tag: EPTRTA) + "
"Combined (tag: PCID + VPID + EPTRTA)"
msgstr ""
"EPT Violation: アドレス変換に使われた Guest-Physical (tag: EPTRTA) + "
"Combined (tag: PCID + VPID + EPTRTA)"

#: src/vmm/ept.md:694
msgid ""
"VM Entry/Exit (VPIDが無効な場合): Linear(tag: VPID=0) + Combined (tag: "
"VPID=0)"
msgstr ""
"VM Entry/Exit (VPIDが無効な場合): Linear(tag: VPID=0) + Combined (tag: "
"VPID=0)"

#: src/vmm/ept.md:695
msgid ""
"[INVVPID](https://www.felixcloutier.com/x86/invvpid) / [INVEPT:](https://www."
"felixcloutier.com/x86/invept) 指定したキャッシュ"
msgstr ""
"[INVVPID](https://www.felixcloutier.com/x86/invvpid) / [INVEPT:](https://www."
"felixcloutier.com/x86/invept) 指定したキャッシュ"

#: src/vmm/ept.md:697
msgid "VPID の有効化"
msgstr "VPID の有効化"

#: src/vmm/ept.md:699
msgid ""
"Ymir では VMX Transition の度に TLB をフラッシュしなくても良いように、VPID を"
"有効化します。 まずは VPID がサポートされているかを調べる必要があります。 こ"
"れは `IA32_VMX_EPT_VPID_CAP_MSR`(`0x048C`) を調べることで分かります:"
msgstr ""
"Ymir では VMX Transition の度に TLB をフラッシュしなくても良いように、VPID を"
"有効化します。 まずは VPID がサポートされているかを調べる必要があります。 こ"
"れは `IA32_VMX_EPT_VPID_CAP_MSR`(`0x048C`) を調べることで分かります:"

#: src/vmm/ept.md:742
msgid ""
"Ymir では、[INVVPID](https://www.felixcloutier.com/x86/invvpid) 命令の全ての"
"オプションがサポートされている場合に VPID がサポートされていると判断します:"
msgstr ""
"Ymir では、[INVVPID](https://www.felixcloutier.com/x86/invvpid) 命令の全ての"
"オプションがサポートされている場合に VPID がサポートされていると判断します:"

#: src/vmm/ept.md:752
msgid ""
"VPID を有効化するには **Secondary Processor-Based VM-Execution Control** の "
"`vpid` をセットします。 また、その vCPU の VPID は VMCS Execution Control の"
"専用フィールドに設定してあげます:"
msgstr ""
"VPID を有効化するには **Secondary Processor-Based VM-Execution Control** の "
"`vpid` をセットします。 また、その vCPU の VPID は VMCS Execution Control の"
"専用フィールドに設定してあげます:"

#: src/vmm/ept.md:767
msgid ""
"本シリーズでは1コアしか扱わないため、`Vcpu` の `vpid` は固定で `1` に設定しま"
"す。 複数の vCPU を扱う場合には、各 vCPU にユニークな VPID を割り当てる必要が"
"あります。"
msgstr ""
"本シリーズでは1コアしか扱わないため、`Vcpu` の `vpid` は固定で `1` に設定しま"
"す。 複数の vCPU を扱う場合には、各 vCPU にユニークな VPID を割り当てる必要が"
"あります。"

#: src/vmm/ept.md:772
msgid ""
"本チャプターでは、EPT を有効化することでホストとゲストのアドレス空間を分離し"
"ました。 Ymir ではゲストの起動前にゲストのメモリを全て 2MiB ページでマップす"
"る方針を採用しました。 また、VPID を有効化することで VMX Transition における "
"TLB フラッシュが発生しないようにしました。 実際にゲストを分離されたアドレス空"
"間で実行し、HLT ループに入っていることを確認することができました。"
msgstr ""
"本チャプターでは、EPT を有効化することでホストとゲストのアドレス空間を分離し"
"ました。 Ymir ではゲストの起動前にゲストのメモリを全て 2MiB ページでマップす"
"る方針を採用しました。 また、VPID を有効化することで VMX Transition における "
"TLB フラッシュが発生しないようにしました。 実際にゲストを分離されたアドレス空"
"間で実行し、HLT ループに入っていることを確認することができました。"

#: src/vmm/ept.md:777
msgid ""
"次のチャプターでは用意したゲストメモリに Linux カーネルをロードし、Linux を起"
"動するための準備をします。"
msgstr ""
"次のチャプターでは用意したゲストメモリに Linux カーネルをロードし、Linux を起"
"動するための準備をします。"

#: src/vmm/ept.md:781
msgid ""
"[MMU Virtualization via Intel EPT: Technical Details - Reverse Entineering]"
"(https://revers.engineering/mmu-ept-technical-details/)"
msgstr ""
"[MMU Virtualization via Intel EPT: Technical Details - Reverse Entineering]"
"(https://revers.engineering/mmu-ept-technical-details/)"

#: src/vmm/ept.md:782
msgid ""
"[Hypervisor From Scratch – Part 8: How To Do Magic With Hypervisor! - "
"Rayanfam Blog](https://rayanfam.com/topics/hypervisor-from-scratch-part-8/)"
msgstr ""
"[Hypervisor From Scratch – Part 8: How To Do Magic With Hypervisor! - "
"Rayanfam Blog](https://rayanfam.com/topics/hypervisor-from-scratch-part-8/)"

#: src/vmm/ept.md:783
msgid ""
"[ちょっと詳しいEPT - おしぼり / Zenn](https://zenn.dev/oshibori/articles/"
"e2e3693fe072ac)"
msgstr ""
"[ちょっと詳しいEPT - おしぼり / Zenn](https://zenn.dev/oshibori/articles/"
"e2e3693fe072ac)"

#: src/vmm/ept.md:785
msgid ""
"というのは建前で、本当は EPT の実装が簡単になるというのが理由だったりします。"
msgstr ""
"というのは建前で、本当は EPT の実装が簡単になるというのが理由だったりします。"

#: src/vmm/ept.md:786
msgid ""
"EPT とページテーブルの実装がかなり似通ったものになっているため、本当はある程"
"度実装を共通化したほうが良いのかもしれません。"
msgstr ""
"EPT とページテーブルの実装がかなり似通ったものになっているため、本当はある程"
"度実装を共通化したほうが良いのかもしれません。"

#: src/vmm/ept.md:787
msgid ""
"ほとんど何もしない Ymir が 412MiB を持っているというのは十分すぎるを通り越し"
"て無駄なので、もっと多くをゲストに割り当てても大丈夫です。"
msgstr ""
"ほとんど何もしない Ymir が 412MiB を持っているというのは十分すぎるを通り越し"
"て無駄なので、もっと多くをゲストに割り当てても大丈夫です。"

#: src/vmm/ept.md:788
msgid "_SDM Vol.3C 29.4.1 Information That May Be Cached_"
msgstr "_SDM Vol.3C 29.4.1 Information That May Be Cached_"

#: src/vmm/ept.md:789
msgid "**EPT Root Table Address**. EPT の Lv4 テーブルのアドレスのこと。"
msgstr "**EPT Root Table Address**. EPT の Lv4 テーブルのアドレスのこと。"

#: src/vmm/linux_boot.md:3
msgid ""
"EPT を有効化しゲストを Unrestricted Guest にしたことで、ゲストをホストと異な"
"るメモリ空間で実行することができるようになりました。 これで本シリーズの目標で"
"ある Linux カーネルを起動する準備ができたことになります。 もちろんまだ Exit "
"Handler を実装していないなど足りない部分は多々ありますが、それらは実際に "
"Linux を動かそうとして発生したエラー・不具合をもとに随時追加していくことにし"
"ましょう。 本チャプターでは、Linux の x86 におけるブートプロトコルに従って "
"Linux をロードし、処理をカーネルに渡すまでの流れを追っていきます。"
msgstr ""
"EPT を有効化しゲストを Unrestricted Guest にしたことで、ゲストをホストと異な"
"るメモリ空間で実行することができるようになりました。 これで本シリーズの目標で"
"ある Linux カーネルを起動する準備ができたことになります。 もちろんまだ Exit "
"Handler を実装していないなど足りない部分は多々ありますが、それらは実際に "
"Linux を動かそうとして発生したエラー・不具合をもとに随時追加していくことにし"
"ましょう。 本チャプターでは、Linux の x86 におけるブートプロトコルに従って "
"Linux をロードし、処理をカーネルに渡すまでの流れを追っていきます。"

#: src/vmm/linux_boot.md:10
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-linux_boot`]"
#| "(https://github.com/smallkirby/ymir/tree/whiz-vmm-linux_boot) ブランチにあ"
#| "ります。"
msgid ""
"本チャプターの最終コードは [`whiz-vmm-linux_boot`](https://github.com/"
"smallkirby/ymir/tree/whiz-vmm-linux_boot) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-linux_boot`](https://"
"github.com/smallkirby/ymir/tree/whiz-vmm-linux_boot) ブランチにあります。"

#: src/vmm/linux_boot.md:14
msgid "[Boot Process](#boot-process)"
msgstr "[Boot Process](#boot-process)"

#: src/vmm/linux_boot.md:15
msgid "[1. ブートローダへの遷移](#1-ブートローダへの遷移)"
msgstr "[1. ブートローダへの遷移](#1-ブートローダへの遷移)"

#: src/vmm/linux_boot.md:16
msgid "[2. カーネルのロード](#2-カーネルのロード)"
msgstr "[2. カーネルのロード](#2-カーネルのロード)"

#: src/vmm/linux_boot.md:17
msgid "[3. カーネルの起動処理](#3-カーネルの起動処理)"
msgstr "[3. カーネルの起動処理](#3-カーネルの起動処理)"

#: src/vmm/linux_boot.md:18
msgid "[Linux Kernel のビルド](#linux-kernel-のビルド)"
msgstr "[Linux Kernel のビルド](#linux-kernel-のビルド)"

#: src/vmm/linux_boot.md:19
msgid "[`bzImage` の読み込み](#bzimage-の読み込み)"
msgstr "[`bzImage` の読み込み](#bzimage-の読み込み)"

#: src/vmm/linux_boot.md:20
msgid "[Boot Parameters](#boot-parameters)"
msgstr "[Boot Parameters](#boot-parameters)"

#: src/vmm/linux_boot.md:21
msgid "[構造体の定義](#構造体の定義)"
msgstr "[構造体の定義](#構造体の定義)"

#: src/vmm/linux_boot.md:22
msgid "[E820 Map](#e820-map)"
msgstr "[E820 Map](#e820-map)"

#: src/vmm/linux_boot.md:23
msgid "[メモリレイアウト](#メモリレイアウト)"
msgstr "[メモリレイアウト](#メモリレイアウト)"

#: src/vmm/linux_boot.md:24
msgid "[カーネルのロード](#カーネルのロード)"
msgstr "[カーネルのロード](#カーネルのロード)"

#: src/vmm/linux_boot.md:25
msgid "[VMCS の設定](#vmcs-の設定)"
msgstr "[VMCS の設定](#vmcs-の設定)"

#: src/vmm/linux_boot.md:29
msgid "Boot Process"
msgstr "Boot Process"

#: src/vmm/linux_boot.md:31
msgid "Linux カーネルを起動する場合、通常は以下の手順を踏みます:"
msgstr "Linux カーネルを起動する場合、通常は以下の手順を踏みます:"

#: src/vmm/linux_boot.md:33
msgid "1. ブートローダへの遷移"
msgstr "1. ブートローダへの遷移"

#: src/vmm/linux_boot.md:35
msgid ""
"Legacy BIOS がシステムの初期化をしたあと、[MBR: Master Boot Record](https://"
"en.wikipedia.org/wiki/Master_boot_record) からブートローダをロードして制御を"
"渡します[^mbr]。 UEFI の場合はブートローダが UEFI アプリとして起動されます。"
msgstr ""
"Legacy BIOS がシステムの初期化をしたあと、[MBR: Master Boot Record](https://"
"en.wikipedia.org/wiki/Master_boot_record) からブートローダをロードして制御を"
"渡します[^mbr]。 UEFI の場合はブートローダが UEFI アプリとして起動されます。"

#: src/vmm/linux_boot.md:38
msgid ""
"BIOS/UEFI から直接実行されるブートローダとして有名なものには [GRUB2](https://"
"docs.fedoraproject.org/en-US/quick-docs/grub2-bootloader/) や [coreboot]"
"(https://www.coreboot.org/) などがあります。 本シリーズではゲストにとっての"
"ブートローダの役割を Ymir が担うことにします。 そのため、ブートローダ自体を"
"ロードするという手順はスキップすることができます。"
msgstr ""
"BIOS/UEFI から直接実行されるブートローダとして有名なものには [GRUB2](https://"
"docs.fedoraproject.org/en-US/quick-docs/grub2-bootloader/) や [coreboot]"
"(https://www.coreboot.org/) などがあります。 本シリーズではゲストにとっての"
"ブートローダの役割を Ymir が担うことにします。 そのため、ブートローダ自体を"
"ロードするという手順はスキップすることができます。"

#: src/vmm/linux_boot.md:42
msgid "2. カーネルのロード"
msgstr "2. カーネルのロード"

#: src/vmm/linux_boot.md:44
msgid ""
"BIOS/UEFI からロードされたブートローダは、Linux が定義するブートプロトコルに"
"従ってカーネルをロードします。 このプロトコルはアーキテクチャごとに定められて"
"います。 Ymir は x64 だけをサポートしているため、[x86 Boot Protocol](https://"
"www.kernel.org/doc/html/v5.6/x86/boot.html) に従います。 x86 Boot Protocol "
"v2.02 以降は以下のようなメモリレイアウトになります:"
msgstr ""
"BIOS/UEFI からロードされたブートローダは、Linux が定義するブートプロトコルに"
"従ってカーネルをロードします。 このプロトコルはアーキテクチャごとに定められて"
"います。 Ymir は x64 だけをサポートしているため、[x86 Boot Protocol](https://"
"www.kernel.org/doc/html/v5.6/x86/boot.html) に従います。 x86 Boot Protocol "
"v2.02 以降は以下のようなメモリレイアウトになります:"

#: src/vmm/linux_boot.md:49
msgid ""
"![x86 Linux Kernel Memory Layout](../assets/linux/memory_layout.png) _x86 "
"Linux Kernel Memory Layout. https://www.kernel.org/doc/html/v5.6/x86/boot."
"html_"
msgstr ""
"![x86 Linux Kernel Memory Layout](../assets/linux/memory_layout.png) _x86 "
"Linux Kernel Memory Layout. https://www.kernel.org/doc/html/v5.6/x86/boot."
"html_"

#: src/vmm/linux_boot.md:52
msgid ""
"x86 Boot Protocol において重要なデータ構造が **struct boot_params** です。 ま"
"たの名を [Zero Page](https://docs.kernel.org/arch/x86/zero-page.html) とも呼"
"びます。 この構造体は **bzImage** の先頭に配置されていて、BIOS/UEFI がシステ"
"ムの情報および Linux のロードに必要な情報を渡すのに使われます。 ブートローダ"
"はこの構造体を適切な情報で埋めて、カーネルはこの構造体を使って初期化処理をす"
"ることになります。 厳密には、カーネルは `boot_params` の中の **Setup "
"Headers** と呼ばれる構造体を使います。 これらの構造に関してはのちほど詳しく見"
"ていくことにします。"
msgstr ""
"x86 Boot Protocol において重要なデータ構造が **struct boot_params** です。 ま"
"たの名を [Zero Page](https://docs.kernel.org/arch/x86/zero-page.html) とも呼"
"びます。 この構造体は **bzImage** の先頭に配置されていて、BIOS/UEFI がシステ"
"ムの情報および Linux のロードに必要な情報を渡すのに使われます。 ブートローダ"
"はこの構造体を適切な情報で埋めて、カーネルはこの構造体を使って初期化処理をす"
"ることになります。 厳密には、カーネルは `boot_params` の中の **Setup "
"Headers** と呼ばれる構造体を使います。 これらの構造に関してはのちほど詳しく見"
"ていくことにします。"

#: src/vmm/linux_boot.md:59
msgid "3. カーネルの起動処理"
msgstr "3. カーネルの起動処理"

#: src/vmm/linux_boot.md:61
msgid ""
"ブートローダはカーネルをメモリにロードしたあと、カーネルのエントリポイントに"
"制御を渡します。 x64 の場合にはエントリポイントは [startup_32()](https://"
"github.com/torvalds/linux/blob/de2f378f2b771b39594c04695feee86476743a69/arch/"
"x86/boot/compressed/head_64.S#L83) です。 ここに遷移する時点では、"
"**Protected Mode + ページング無効の状態** にします。 `startup_32()` ではまず"
"ページングを有効化し、Long Mode への遷移が行われます。 その後、[startup_64()]"
"(https://github.com/torvalds/linux/blob/"
"de2f378f2b771b39594c04695feee86476743a69/arch/x86/boot/compressed/head_64."
"S#L286) では圧縮されたカーネルイメージの展開処理が行われます。 展開が終わる"
"と、カーネルのエントリポイントである [startup_64()](https://github.com/"
"torvalds/linux/blob/de2f378f2b771b39594c04695feee86476743a69/arch/x86/kernel/"
"head_64.S#L38) に遷移します。 関数名が同じですが、前者は `kernel/compressed/"
"head_64.S` のもので、後者は `kernel/head_64.S` のものです。 最終的には C の関"
"数である [start_kernel()](https://github.com/torvalds/linux/blob/"
"de2f378f2b771b39594c04695feee86476743a69/init/main.c#L903) に到達します。"
msgstr ""
"ブートローダはカーネルをメモリにロードしたあと、カーネルのエントリポイントに"
"制御を渡します。 x64 の場合にはエントリポイントは [startup_32()](https://"
"github.com/torvalds/linux/blob/de2f378f2b771b39594c04695feee86476743a69/arch/"
"x86/boot/compressed/head_64.S#L83) です。 ここに遷移する時点では、"
"**Protected Mode + ページング無効の状態** にします。 `startup_32()` ではまず"
"ページングを有効化し、Long Mode への遷移が行われます。 その後、[startup_64()]"
"(https://github.com/torvalds/linux/blob/"
"de2f378f2b771b39594c04695feee86476743a69/arch/x86/boot/compressed/head_64."
"S#L286) では圧縮されたカーネルイメージの展開処理が行われます。 展開が終わる"
"と、カーネルのエントリポイントである [startup_64()](https://github.com/"
"torvalds/linux/blob/de2f378f2b771b39594c04695feee86476743a69/arch/x86/kernel/"
"head_64.S#L38) に遷移します。 関数名が同じですが、前者は `kernel/compressed/"
"head_64.S` のもので、後者は `kernel/head_64.S` のものです。 最終的には C の関"
"数である [start_kernel()](https://github.com/torvalds/linux/blob/"
"de2f378f2b771b39594c04695feee86476743a69/init/main.c#L903) に到達します。"

#: src/vmm/linux_boot.md:70
msgid ""
"本来であればこれらの処理はゲストの問題であり VMM が細かい流れを意識する必要は"
"ありません。 しかしながら、Ymir の開発中には問題の原因を特定するために Linux "
"の処理の流れを辿りたい場合が多く出てくると思うため、 起動シーケンスを軽くでも"
"抑えておくことはのちのち役立つかもしれません。"
msgstr ""
"本来であればこれらの処理はゲストの問題であり VMM が細かい流れを意識する必要は"
"ありません。 しかしながら、Ymir の開発中には問題の原因を特定するために Linux "
"の処理の流れを辿りたい場合が多く出てくると思うため、 起動シーケンスを軽くでも"
"抑えておくことはのちのち役立つかもしれません。"

#: src/vmm/linux_boot.md:74
msgid "Linux Kernel のビルド"
msgstr "Linux Kernel のビルド"

#: src/vmm/linux_boot.md:78
#, fuzzy
#| msgid ""
#| "\\[!TIP\\] ショートカット 自分でカーネルをビルドするのがめんどうな人用に、"
#| "以下の手順でビルドしたカーネルイメージを [こちら](https://r2.hv."
#| "smallkirby.com/bzImage) からダウンロードすることができます。"
msgid ""
"自分でカーネルをビルドするのがめんどうな人用に、以下の手順でビルドしたカーネ"
"ルイメージを [こちら](https://r2.hv.smallkirby.com/bzImage) からダウンロード"
"することができます。"
msgstr ""
"\\[!TIP\\] ショートカット 自分でカーネルをビルドするのがめんどうな人用に、以"
"下の手順でビルドしたカーネルイメージを [こちら](https://r2.hv.smallkirby.com/"
"bzImage) からダウンロードすることができます。"

#: src/vmm/linux_boot.md:80
msgid ""
"Linux をロード・ブートするにはカーネルイメージがないと話になりません。 まず"
"は Linux カーネルをビルドしましょう。 Linux のソースコードは [git://git."
"kernel.org](git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git) "
"からクローンすることができます。 以下のコマンドでリポジトリをクローンしてきて"
"ください:"
msgstr ""
"Linux をロード・ブートするにはカーネルイメージがないと話になりません。 まず"
"は Linux カーネルをビルドしましょう。 Linux のソースコードは [git://git."
"kernel.org](git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git) "
"からクローンすることができます。 以下のコマンドでリポジトリをクローンしてきて"
"ください:"

#: src/vmm/linux_boot.md:91
msgid ""
"カーネルのコンフィグは `make menuconfig` で interactive に設定することができ"
"ます。 デバッグ用に調整するには、不必要な機能を無効化し、できるだけサイズが小"
"さくなるように設定することが本来は望ましいです。 ただし、本シリーズでは汎用性"
"を考慮してデフォルトの設定でビルドすることにします。 このへんは好みに合わせて"
"設定してください:"
msgstr ""
"カーネルのコンフィグは `make menuconfig` で interactive に設定することができ"
"ます。 デバッグ用に調整するには、不必要な機能を無効化し、できるだけサイズが小"
"さくなるように設定することが本来は望ましいです。 ただし、本シリーズでは汎用性"
"を考慮してデフォルトの設定でビルドすることにします。 このへんは好みに合わせて"
"設定してください:"

#: src/vmm/linux_boot.md:102
msgid ""
"ビルドが終わると `/vmlinux` と `/arch/x86/boot/bzImage` というファイルが生成"
"されます。 `vmxlinux` はカーネル本体を含む実行可能な ELF ファイルであり、"
"`bzImage` は `vmlinux` を [zlib](https://www.zlib.net/) や [LZMA](https://en."
"wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm) を使っ"
"て圧縮したものです[^compress]。 実際にカーネルイメージとして利用するのは "
"`bzImage` の方ですが、GDB に読み込ませてデバッグする場合には圧縮されておらず"
"シンボル情報もついている `vmlinux` を使います。"
msgstr ""
"ビルドが終わると `/vmlinux` と `/arch/x86/boot/bzImage` というファイルが生成"
"されます。 `vmxlinux` はカーネル本体を含む実行可能な ELF ファイルであり、"
"`bzImage` は `vmlinux` を [zlib](https://www.zlib.net/) や [LZMA](https://en."
"wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm) を使っ"
"て圧縮したものです[^compress]。 実際にカーネルイメージとして利用するのは "
"`bzImage` の方ですが、GDB に読み込ませてデバッグする場合には圧縮されておらず"
"シンボル情報もついている `vmlinux` を使います。"

#: src/vmm/linux_boot.md:106
msgid ""
"Ymir の開発中は Linux の方にログを仕込んでデバッグしたい場合が多々出てきま"
"す。 その際には `compile_commands.json` があるとコードエディタの機能が使いや"
"すくなるため、以下のコマンドで生成しておきます。 `compile_commands.json` のエ"
"ディタへの読み込ませ方は、お使いのエディタのドキュメントを参照してください"
"[^compile_commands]:"
msgstr ""
"Ymir の開発中は Linux の方にログを仕込んでデバッグしたい場合が多々出てきま"
"す。 その際には `compile_commands.json` があるとコードエディタの機能が使いや"
"すくなるため、以下のコマンドで生成しておきます。 `compile_commands.json` のエ"
"ディタへの読み込ませ方は、お使いのエディタのドキュメントを参照してください"
"[^compile_commands]:"

#: src/vmm/linux_boot.md:115
msgid ""
"最後に、ビルドしたカーネルイメージを Ymir のディレクトリにコピーします。 "
"`bzImage` は Ymir カーネルと同様に FAT ファイルシステムのルートディレクトリに"
"配置することにします:"
msgstr ""
"最後に、ビルドしたカーネルイメージを Ymir のディレクトリにコピーします。 "
"`bzImage` は Ymir カーネルと同様に FAT ファイルシステムのルートディレクトリに"
"配置することにします:"

#: src/vmm/linux_boot.md:123
msgid "`bzImage` の読み込み"
msgstr "`bzImage` の読み込み"

#: src/vmm/linux_boot.md:125
msgid ""
"まずは `bzImage` を FAT ファイルシステムからメモリ上に読み込みます。 単なる"
"ファイルとして読み込むだけなので、特にレイアウト等を意識する必要はありませ"
"ん。 FAT ファイルシステムを利用するには UEFI Boot Services の [Simple File "
"System Protocol](https://uefi.org/specs/UEFI/2.10/13_Protocols_Media_Access."
"html#simple-file-system-protocol) を使います。"
msgstr ""
"まずは `bzImage` を FAT ファイルシステムからメモリ上に読み込みます。 単なる"
"ファイルとして読み込むだけなので、特にレイアウト等を意識する必要はありませ"
"ん。 FAT ファイルシステムを利用するには UEFI Boot Services の [Simple File "
"System Protocol](https://uefi.org/specs/UEFI/2.10/13_Protocols_Media_Access."
"html#simple-file-system-protocol) を使います。"

#: src/vmm/linux_boot.md:129
msgid ""
"Boot Services は一旦 Ymir が起動してしまうと利用できなくなるため、これらの処"
"理は Surtr の中で行います。 ちょうど [カーネルのパース](../bootloader/"
"parse_kernel.md) でしたのと同様に、まずはファイルを開いてファイルサイズを取得"
"します:"
msgstr ""
"Boot Services は一旦 Ymir が起動してしまうと利用できなくなるため、これらの処"
"理は Surtr の中で行います。 ちょうど [カーネルのパース](../bootloader/"
"parse_kernel.md) でしたのと同様に、まずはファイルを開いてファイルサイズを取得"
"します:"

#: src/vmm/linux_boot.md:145
msgid ""
"続いて必要なファイルサイズ分だけページを確保します。 この際、メモリタイプに"
"は `.LoaderData` を指定します。 [Page Allocator](../kernel/page_allocator."
"md) で実装したように、Ymir のページアロケータは UEFI から渡されたメモリマップ"
"の内、 `.ConventionalMemory` / `.BootServiceCode` タイプのメモリを Ymir が利"
"用可能なメモリとして扱います。 今読み込もうとしているファイルデータは、ページ"
"アロケータの初期化後もゲストメモリにロードするまでは破棄したくないため、 ペー"
"ジアロケータが利用しない `.LoaderData` に配置することにします:"
msgstr ""
"続いて必要なファイルサイズ分だけページを確保します。 この際、メモリタイプに"
"は `.LoaderData` を指定します。 [Page Allocator](../kernel/page_allocator."
"md) で実装したように、Ymir のページアロケータは UEFI から渡されたメモリマップ"
"の内、 `.ConventionalMemory` / `.BootServiceCode` タイプのメモリを Ymir が利"
"用可能なメモリとして扱います。 今読み込もうとしているファイルデータは、ページ"
"アロケータの初期化後もゲストメモリにロードするまでは破棄したくないため、 ペー"
"ジアロケータが利用しない `.LoaderData` に配置することにします:"

#: src/vmm/linux_boot.md:161
msgid "最後に、確保したページに `bzImage` を読み込みます:"
msgstr "最後に、確保したページに `bzImage` を読み込みます:"

#: src/vmm/linux_boot.md:170
msgid ""
"これで `bzImage` をメモリ上に読み込むことができました。 カーネルイメージをど"
"こにロードしたのかを Ymir に伝えるために、Surtr と Ymir の間で共有されるデー"
"タである `BootInfo` に情報を追加します:"
msgstr ""
"これで `bzImage` をメモリ上に読み込むことができました。 カーネルイメージをど"
"こにロードしたのかを Ymir に伝えるために、Surtr と Ymir の間で共有されるデー"
"タである `BootInfo` に情報を追加します:"

#: src/vmm/linux_boot.md:188
msgid "Ymir に渡す引数に、`GuestInfo` を追加します:"
msgstr "Ymir に渡す引数に、`GuestInfo` を追加します:"

#: src/vmm/linux_boot.md:201
msgid ""
"以上で `bzImage` をメモリに読み込んで Ymir に渡すことができました。 なお、"
"`BootInfo.guest_image` が指す `bzImage` のアドレスは物理アドレスであることに"
"注意してください。 Ymir がメモリマップを再構築したあとはこのアドレスを使って"
"直接アクセスすることができなくなります。 `ymir.mem.phys2virt()` を使って仮想"
"アドレスに変換してからアクセスするようにしてください。"
msgstr ""
"以上で `bzImage` をメモリに読み込んで Ymir に渡すことができました。 なお、"
"`BootInfo.guest_image` が指す `bzImage` のアドレスは物理アドレスであることに"
"注意してください。 Ymir がメモリマップを再構築したあとはこのアドレスを使って"
"直接アクセスすることができなくなります。 `ymir.mem.phys2virt()` を使って仮想"
"アドレスに変換してからアクセスするようにしてください。"

#: src/vmm/linux_boot.md:206
msgid "Boot Parameters"
msgstr "Boot Parameters"

#: src/vmm/linux_boot.md:208
msgid "構造体の定義"
msgstr "構造体の定義"

#: src/vmm/linux_boot.md:210
msgid ""
"Linux に渡す `struct boot_params` を `BootParams` として定義します。 全ての"
"フィールドを使うわけではないため、使わないフィールドは `_` で始まる名前をつけ"
"て無視しています:"
msgstr ""
"Linux に渡す `struct boot_params` を `BootParams` として定義します。 全ての"
"フィールドを使うわけではないため、使わないフィールドは `_` で始まる名前をつけ"
"て無視しています:"

#: src/vmm/linux_boot.md:258
msgid ""
"重要なフィールドは Setup Headers である `.hdr` と E820 マップである `."
"e820_map` です。 E820 マップについては [のちほど扱います](#e820-map)。 "
"`BootParams` は `bzImage` の先頭に圧縮されていない状態で配置されています。 "
"`from()` メソッドは `bzImage` のバイナリデータから `BootParams` を取り出しま"
"す。"
msgstr ""
"重要なフィールドは Setup Headers である `.hdr` と E820 マップである `."
"e820_map` です。 E820 マップについては [のちほど扱います](#e820-map)。 "
"`BootParams` は `bzImage` の先頭に圧縮されていない状態で配置されています。 "
"`from()` メソッドは `bzImage` のバイナリデータから `BootParams` を取り出しま"
"す。"

#: src/vmm/linux_boot.md:263
msgid ""
"`BootParams` のうち、ブートローダ(Ymir)が設定してあげる必要のある主なフィール"
"ドが **Setup Headers** です。 Setup Headers を以下に定義します:"
msgstr ""
"`BootParams` のうち、ブートローダ(Ymir)が設定してあげる必要のある主なフィール"
"ドが **Setup Headers** です。 Setup Headers を以下に定義します:"

#: src/vmm/linux_boot.md:367
msgid ""
"これまたたくさんフィールドがありますが、Ymir で使うのはごく一部です。 全ての"
"フィールドの意味については [ドキュメント](https://www.kernel.org/doc/html/"
"v5.6/x86/boot.html#the-real-mode-kernel-header) を参照してください。 "
"`from()` は `bzImage` のバイナリイメージから `SetupHeader` を取り出します。 "
"Setup Headers は `bzImage` の先頭から `0x1F1` バイトのオフセットに固定で配置"
"されています。"
msgstr ""
"これまたたくさんフィールドがありますが、Ymir で使うのはごく一部です。 全ての"
"フィールドの意味については [ドキュメント](https://www.kernel.org/doc/html/"
"v5.6/x86/boot.html#the-real-mode-kernel-header) を参照してください。 "
"`from()` は `bzImage` のバイナリイメージから `SetupHeader` を取り出します。 "
"Setup Headers は `bzImage` の先頭から `0x1F1` バイトのオフセットに固定で配置"
"されています。"

#: src/vmm/linux_boot.md:372
msgid ""
"`.setup_sects` は Setup Code のサイズを 512byte セクタ単位で表しています。 こ"
"の値が例えば `4` であれば、Setup Code のサイズは \\\\( 4 \\times 512 = 2048 "
"\\\\) byte となります。 なお、この値が `0` の場合には実際の値が `4` であるも"
"のとして扱うという仕様になっています。"
msgstr ""
"`.setup_sects` は Setup Code のサイズを 512byte セクタ単位で表しています。 こ"
"の値が例えば `4` であれば、Setup Code のサイズは \\\\( 4 \\times 512 = 2048 "
"\\\\) byte となります。 なお、この値が `0` の場合には実際の値が `4` であるも"
"のとして扱うという仕様になっています。"

#: src/vmm/linux_boot.md:376
msgid ""
"`getProtectedCodeOffset()` はカーネルの Protected Mode Code が配置されている"
"オフセットを返します。 カーネルの Realmode Code はブートセクタ (1セクタ) と "
"Setup Code (`setup_sects` セクタ) から成ります。 Protected Mode のコードは "
"Realmode Code の直後に配置されるため、`bzImage` の先頭から `1 + setup_sects` "
"セクタの位置に配置されていることになります。 このオフセットは後でカーネルを"
"ロードする際に使います。"
msgstr ""
"`getProtectedCodeOffset()` はカーネルの Protected Mode Code が配置されている"
"オフセットを返します。 カーネルの Realmode Code はブートセクタ (1セクタ) と "
"Setup Code (`setup_sects` セクタ) から成ります。 Protected Mode のコードは "
"Realmode Code の直後に配置されるため、`bzImage` の先頭から `1 + setup_sects` "
"セクタの位置に配置されていることになります。 このオフセットは後でカーネルを"
"ロードする際に使います。"

#: src/vmm/linux_boot.md:381
msgid "E820 Map"
msgstr "E820 Map"

#: src/vmm/linux_boot.md:383
msgid ""
"**E820** は BIOS が提供するメモリマップです。 `BootParams` に渡すことでカーネ"
"ルがメモリのレイアウトを伝えることができます。 その名前は Real Mode で AX レ"
"ジスタに `0xE820` をセットした状態で `INT 15h` 命令を実行して得られることに由"
"来します。 `BootParams` は最大で128個の E820 を持つことができます。 ブート"
"ローダは有効な E820 エントリの数を `.e820_entries` にセットして渡します。"
msgstr ""
"**E820** は BIOS が提供するメモリマップです。 `BootParams` に渡すことでカーネ"
"ルがメモリのレイアウトを伝えることができます。 その名前は Real Mode で AX レ"
"ジスタに `0xE820` をセットした状態で `INT 15h` 命令を実行して得られることに由"
"来します。 `BootParams` は最大で128個の E820 を持つことができます。 ブート"
"ローダは有効な E820 エントリの数を `.e820_entries` にセットして渡します。"

#: src/vmm/linux_boot.md:389
msgid ""
"E820 エントリは以下のように定義します。 `addr` / `size` で指定されるメモリ領"
"域に対して、`type` でその種類を示しています:"
msgstr ""
"E820 エントリは以下のように定義します。 `addr` / `size` で指定されるメモリ領"
"域に対して、`type` でその種類を示しています:"

#: src/vmm/linux_boot.md:414
msgid "`BootParams` に E820 エントリを追加するためのメソッドを用意します:"
msgstr "`BootParams` に E820 エントリを追加するためのメソッドを用意します:"

#: src/vmm/linux_boot.md:431
msgid "メモリレイアウト"
msgstr "メモリレイアウト"

#: src/vmm/linux_boot.md:433
msgid "Ymir では以下の物理メモリレイアウトでカーネルをロードします:"
msgstr "Ymir では以下の物理メモリレイアウトでカーネルをロードします:"

#: src/vmm/linux_boot.md:435
msgid ""
"![Memory Layout for Guest Linux](../assets/drawio/linux_layout.drawio.png) "
"_Memory Layout for Guest Linux_"
msgstr ""
"![Memory Layout for Guest Linux](../assets/drawio/linux_layout.drawio.png) "
"_Memory Layout for Guest Linux_"

#: src/vmm/linux_boot.md:438
msgid ""
"`initrd` は本チャプターでは扱いませんが、カーネルに渡すファイルシステムのイ"
"メージを配置します。 `cmdline` にはカーネルに渡すコマンドラインオプションを配"
"置します。 `BootParams` には先ほど定義した `BootParams` 構造体を配置します。 "
"カーネルはこの構造体を使って初期化処理をします。"
msgstr ""
"`initrd` は本チャプターでは扱いませんが、カーネルに渡すファイルシステムのイ"
"メージを配置します。 `cmdline` にはカーネルに渡すコマンドラインオプションを配"
"置します。 `BootParams` には先ほど定義した `BootParams` 構造体を配置します。 "
"カーネルはこの構造体を使って初期化処理をします。"

#: src/vmm/linux_boot.md:443
msgid ""
"`initrd` と `cmdline` のアドレスは `BootParams` 内のフィールドで指定します。 "
"`Protected Mode Kernel` のアドレスは VMCS RIP に設定します。 `BootParams` の"
"アドレスはゲストに処理を渡す際に RSI レジスタに設定すると仕様で決まっていま"
"す。"
msgstr ""
"`initrd` と `cmdline` のアドレスは `BootParams` 内のフィールドで指定します。 "
"`Protected Mode Kernel` のアドレスは VMCS RIP に設定します。 `BootParams` の"
"アドレスはゲストに処理を渡す際に RSI レジスタに設定すると仕様で決まっていま"
"す。"

#: src/vmm/linux_boot.md:447
msgid "`linux.zig` にメモリレイアウトを定義します:"
msgstr "`linux.zig` にメモリレイアウトを定義します:"

#: src/vmm/linux_boot.md:466
msgid "以上の情報を適切に設定する関数を `Vm` に追加します:"
msgstr "以上の情報を適切に設定する関数を `Vm` に追加します:"

#: src/vmm/linux_boot.md:497
msgid ""
"この関数は Surtr がメモリに読み込んだ `bzImage` のデータを受け取ります。 最初"
"に設定している Setup Headers のフィールドは以下の意味を持ちます:"
msgstr ""
"この関数は Surtr がメモリに読み込んだ `bzImage` のデータを受け取ります。 最初"
"に設定している Setup Headers のフィールドは以下の意味を持ちます:"

#: src/vmm/linux_boot.md:502
msgid "`type_of_loader`"
msgstr "`type_of_loader`"

#: src/vmm/linux_boot.md:502
msgid ""
"ブートローダの種類。Ymir には当然割り振られていないため `0xFF`(undefined) を"
"指定する。"
msgstr ""
"ブートローダの種類。Ymir には当然割り振られていないため `0xFF`(undefined) を"
"指定する。"

#: src/vmm/linux_boot.md:503
msgid "`ext_loader_ver`"
msgstr "`ext_loader_ver`"

#: src/vmm/linux_boot.md:503
msgid "ブートローダのバージョン。未使用。"
msgstr "ブートローダのバージョン。未使用。"

#: src/vmm/linux_boot.md:504
msgid "`loaded_high`"
msgstr "`loaded_high`"

#: src/vmm/linux_boot.md:504
msgid ""
"Protected Mode Code を `0x100000` に配置する。`false` なら `0x10000` にロー"
"ド。"
msgstr ""
"Protected Mode Code を `0x100000` に配置する。`false` なら `0x10000` にロー"
"ド。"

#: src/vmm/linux_boot.md:505
msgid "`can_use_heap`"
msgstr "`can_use_heap`"

#: src/vmm/linux_boot.md:505
msgid ""
"`heap_end_ptr` で指定するヒープが利用できることを示す。`false` ならいくつかの"
"機能が無効化される。"
msgstr ""
"`heap_end_ptr` で指定するヒープが利用できることを示す。`false` ならいくつかの"
"機能が無効化される。"

#: src/vmm/linux_boot.md:506
msgid "`heap_end_ptr`"
msgstr "`heap_end_ptr`"

#: src/vmm/linux_boot.md:506
msgid ""
"Real-mode のヒープ・スタックの終端アドレス (の Real-mode Code からのオフセッ"
"ト)。`-0x200` することが決められている。おそらく使われない。"
msgstr ""
"Real-mode のヒープ・スタックの終端アドレス (の Real-mode Code からのオフセッ"
"ト)。`-0x200` することが決められている。おそらく使われない。"

#: src/vmm/linux_boot.md:507
msgid "`keep_segments`"
msgstr "`keep_segments`"

#: src/vmm/linux_boot.md:507
msgid ""
"32bit エントリポイントでセグメントレジスタをリロードするかどうか。`false` な"
"らリロードされる。"
msgstr ""
"32bit エントリポイントでセグメントレジスタをリロードするかどうか。`false` な"
"らリロードされる。"

#: src/vmm/linux_boot.md:508
msgid "`cmd_line_ptr`"
msgstr "`cmd_line_ptr`"

#: src/vmm/linux_boot.md:508
msgid "カーネルコマンドラインのアドレス。"
msgstr "カーネルコマンドラインのアドレス。"

#: src/vmm/linux_boot.md:509
msgid "`vid_mode`"
msgstr "`vid_mode`"

#: src/vmm/linux_boot.md:509
msgid "ビデオモード。`0xFFFF` は VGA(normal) を意味する。"
msgstr "ビデオモード。`0xFFFF` は VGA(normal) を意味する。"

#: src/vmm/linux_boot.md:511
msgid ""
"続いて、E820 マップを設定します。 今回は Protected Mode Kernel までとそれ以降"
"の2つのメモリ領域だけを設定しています。 2つの領域は隣接しているため1つにまと"
"めて指定してもおそらく問題ありませんが、ここでは E820 マップが適切に渡せてい"
"ることを検証しやすいようになんとなく分けています。"
msgstr ""
"続いて、E820 マップを設定します。 今回は Protected Mode Kernel までとそれ以降"
"の2つのメモリ領域だけを設定しています。 2つの領域は隣接しているため1つにまと"
"めて指定してもおそらく問題ありませんが、ここでは E820 マップが適切に渡せてい"
"ることを検証しやすいようになんとなく分けています。"

#: src/vmm/linux_boot.md:515
msgid ""
"続いてコマンドラインを設定します。 コマンドラインは Setup Headers の "
"`cmd_line_ptr` で指定されたアドレスに配置します。 Ymir ではデバッグしやすいよ"
"うに `console=ttyS0 earlyprintk=serial nokaslr` というコマンドラインを設定し"
"ます。 これにより、KASLR が無効化され、ログはシリアルに対して出力されるように"
"なります。 シリアル出力は QEMU によって `stdout` にリダイレクトされるため、"
"QEMU の標準出力に Linux のログが出力されるようになります:"
msgstr ""
"続いてコマンドラインを設定します。 コマンドラインは Setup Headers の "
"`cmd_line_ptr` で指定されたアドレスに配置します。 Ymir ではデバッグしやすいよ"
"うに `console=ttyS0 earlyprintk=serial nokaslr` というコマンドラインを設定し"
"ます。 これにより、KASLR が無効化され、ログはシリアルに対して出力されるように"
"なります。 シリアル出力は QEMU によって `stdout` にリダイレクトされるため、"
"QEMU の標準出力に Linux のログが出力されるようになります:"

#: src/vmm/linux_boot.md:530
msgid ""
"続いて、設定した `BootParams` やカーネルの Protected-Mode Code をゲストメモリ"
"にロードします。 ゲストメモリにデータを配置するヘルパー関数を用意します:"
msgstr ""
"続いて、設定した `BootParams` やカーネルの Protected-Mode Code をゲストメモリ"
"にロードします。 ゲストメモリにデータを配置するヘルパー関数を用意します:"

#: src/vmm/linux_boot.md:543
msgid "これを利用して、`BootParams` をロードします:"
msgstr "これを利用して、`BootParams` をロードします:"

#: src/vmm/linux_boot.md:550
msgid ""
"最後にカーネルをロードします。 `bzImage` におけるカーネルコードのオフセット"
"は、先ほど実装した `SetupHeader.getProtectedCodeOffset()` で取得できます。 "
"ロードするコードのサイズは `bzImage` 全体のサイズから Real-Mode Code のオフ"
"セットを引いたものです:"
msgstr ""
"最後にカーネルをロードします。 `bzImage` におけるカーネルコードのオフセット"
"は、先ほど実装した `SetupHeader.getProtectedCodeOffset()` で取得できます。 "
"ロードするコードのサイズは `bzImage` 全体のサイズから Real-Mode Code のオフ"
"セットを引いたものです:"

#: src/vmm/linux_boot.md:565
msgid ""
"以上で `BootParams` の設定およびカーネルイメージのロードは完了です。 これらの"
"関数を `Vm.setupGuestMemory()` から呼び出すように変更しましょう:"
msgstr ""
"以上で `BootParams` の設定およびカーネルイメージのロードは完了です。 これらの"
"関数を `Vm.setupGuestMemory()` から呼び出すように変更しましょう:"

#: src/vmm/linux_boot.md:579
msgid ""
"また、`kernelMain()` で Surtr から渡されたカーネルイメージを "
"`setupGuestMemory()` に渡すように変更します。 Surtr から渡されるカーネルイ"
"メージのアドレスは物理アドレスであるため、仮想アドレスに変換する必要があるこ"
"とに注意してください:"
msgstr ""
"また、`kernelMain()` で Surtr から渡されたカーネルイメージを "
"`setupGuestMemory()` に渡すように変更します。 Surtr から渡されるカーネルイ"
"メージのアドレスは物理アドレスであるため、仮想アドレスに変換する必要があるこ"
"とに注意してください:"

#: src/vmm/linux_boot.md:601
msgid "VMCS の設定"
msgstr "VMCS の設定"

#: src/vmm/linux_boot.md:603
msgid ""
"Linux カーネルをゲストにロードすることができたため、VMCS を設定して Linux に"
"制御を渡せるようにします。 まずはブートプロトコルに従って RIP と RSI を設定し"
"ます。 RIP は Protected Mode Kernel のエントリポイントである `0x100000` に設"
"定します。 RSI には `BootParams` のアドレスを設定します:"
msgstr ""
"Linux カーネルをゲストにロードすることができたため、VMCS を設定して Linux に"
"制御を渡せるようにします。 まずはブートプロトコルに従って RIP と RSI を設定し"
"ます。 RIP は Protected Mode Kernel のエントリポイントである `0x100000` に設"
"定します。 RSI には `BootParams` のアドレスを設定します:"

#: src/vmm/linux_boot.md:617
msgid ""
"続いて、ゲストの CS を少し修正します。 カーネルに処理を渡した段階で、カーネル"
"は Protected Mode であることが要求されます。 よって、CS は 64bit Code ではな"
"く 32bit Code に設定する必要があります。 また、`BootParams.hdr.loadflags."
"keep_segments` を `true` に設定したため全てのセグメントセレクタを `0` に設定"
"する必要があります:"
msgstr ""
"続いて、ゲストの CS を少し修正します。 カーネルに処理を渡した段階で、カーネル"
"は Protected Mode であることが要求されます。 よって、CS は 64bit Code ではな"
"く 32bit Code に設定する必要があります。 また、`BootParams.hdr.loadflags."
"keep_segments` を `true` に設定したため全てのセグメントセレクタを `0` に設定"
"する必要があります:"

#: src/vmm/linux_boot.md:642
msgid ""
"続いて EFER を設定します。 EFER には Long Mode に関する設定フィールドがありま"
"す。 Long Mode は無効化しておきたいため、全て `0` に設定します:"
msgstr ""
"続いて EFER を設定します。 EFER には Long Mode に関する設定フィールドがありま"
"す。 Long Mode は無効化しておきたいため、全て `0` に設定します:"

#: src/vmm/linux_boot.md:655
msgid ""
"以上で VMCS の設定は完了です。 前チャプターまで使っていた `blobGuest()` はも"
"う使うことがないため削除してしまって問題ありません。"
msgstr ""
"以上で VMCS の設定は完了です。 前チャプターまで使っていた `blobGuest()` はも"
"う使うことがないため削除してしまって問題ありません。"

#: src/vmm/linux_boot.md:658
msgid "さあ、いよいよゲストとして Linux を起動してみましょう:"
msgstr "さあ、いよいよゲストとして Linux を起動してみましょう:"

#: src/vmm/linux_boot.md:672
msgid ""
"CPUID が原因で VM Exit すれば成功です。 これは `startup_32()` から呼ばれる "
"[verify_cpu()](https://github.com/torvalds/linux/blob/"
"de2f378f2b771b39594c04695feee86476743a69/arch/x86/kernel/verify_cpu.S#L34) "
"で [CPUID](https://www.felixcloutier.com/x86/cpuid) が実行されるためです。 ま"
"だ CPUID のための Exit ハンドラを書いていないため、このエラーが出ています。 "
"なにはともあれカーネルに処理が渡り、CPUID が実行されるまではゲストが実行され"
"たことが分かります。 **ゲストとして Linux を動かし始めることができました**。"
msgstr ""
"CPUID が原因で VM Exit すれば成功です。 これは `startup_32()` から呼ばれる "
"[verify_cpu()](https://github.com/torvalds/linux/blob/"
"de2f378f2b771b39594c04695feee86476743a69/arch/x86/kernel/verify_cpu.S#L34) "
"で [CPUID](https://www.felixcloutier.com/x86/cpuid) が実行されるためです。 ま"
"だ CPUID のための Exit ハンドラを書いていないため、このエラーが出ています。 "
"なにはともあれカーネルに処理が渡り、CPUID が実行されるまではゲストが実行され"
"たことが分かります。 **ゲストとして Linux を動かし始めることができました**。"

#: src/vmm/linux_boot.md:678
msgid ""
"なお、GDB でゲストが動いていることを確認することもできます。 Ymir の起動後ゲ"
"ストが起動するまでに、GDB から `target remote :1234` で接続してください。 そ"
"の後、hardware breakpoint を `0x100000` に設定してください (例: `hbreak "
"*0x100000`)。 そのまま `continue` すると breakpoint で止まるはずです:"
msgstr ""
"なお、GDB でゲストが動いていることを確認することもできます。 Ymir の起動後ゲ"
"ストが起動するまでに、GDB から `target remote :1234` で接続してください。 そ"
"の後、hardware breakpoint を `0x100000` に設定してください (例: `hbreak "
"*0x100000`)。 そのまま `continue` すると breakpoint で止まるはずです:"

#: src/vmm/linux_boot.md:722
msgid ""
"なお、表示されている命令は間違っていることに注意してください。 これは GDB が"
"命令を Long Mode 用として解釈しているからだと思われます。 実際には 32bit "
"Protected Mode で動作しているため、このような表示になっています。 この状態で "
"`si` を実行すると、RIP は `0x10000a` ではなく `0x100001` に進みます (最初の命"
"令が実際は1byteの [CLD](https://www.felixcloutier.com/x86/cld) のため)。 仮想"
"化されたゲストを GDB デバッグする際には、この他にも色々と誤った表示や不便があ"
"るため、注意が必要です。"
msgstr ""
"なお、表示されている命令は間違っていることに注意してください。 これは GDB が"
"命令を Long Mode 用として解釈しているからだと思われます。 実際には 32bit "
"Protected Mode で動作しているため、このような表示になっています。 この状態で "
"`si` を実行すると、RIP は `0x10000a` ではなく `0x100001` に進みます (最初の命"
"令が実際は1byteの [CLD](https://www.felixcloutier.com/x86/cld) のため)。 仮想"
"化されたゲストを GDB デバッグする際には、この他にも色々と誤った表示や不便があ"
"るため、注意が必要です。"

#: src/vmm/linux_boot.md:730
msgid ""
"本チャプターでは、Surtr と Ymir が協力して Linux カーネルイメージである "
"`bzImage` を読み込みました。 読み込んだデータは EPT でゲストにマップされたメ"
"モリ上にロードしました。 また、x86 Boot Protocol で要求されたとおりに "
"`BootParams` を設定し、コマンドラインも設定しました。 最後に VMCS を設定し、"
"Unrestricted Guest モードで Linux の起動処理を開始することに成功しました。"
msgstr ""
"本チャプターでは、Surtr と Ymir が協力して Linux カーネルイメージである "
"`bzImage` を読み込みました。 読み込んだデータは EPT でゲストにマップされたメ"
"モリ上にロードしました。 また、x86 Boot Protocol で要求されたとおりに "
"`BootParams` を設定し、コマンドラインも設定しました。 最後に VMCS を設定し、"
"Unrestricted Guest モードで Linux の起動処理を開始することに成功しました。"

#: src/vmm/linux_boot.md:735
msgid ""
"起動処理を開始したカーネルは CPUID で停止しました。 CPUID 命令は CPU がサポー"
"トする機能を調べるための命令であり、ゲストの vCPU がサポートする機能はホスト"
"が自由に設定することができます。 見せたいものだけ見せるようにできるということ"
"です。 次のチャプターでは CPUID を原因とする VM Exit をハンドリングして、"
"Linux の起動シーケンスがさらに進むようにします。"
msgstr ""
"起動処理を開始したカーネルは CPUID で停止しました。 CPUID 命令は CPU がサポー"
"トする機能を調べるための命令であり、ゲストの vCPU がサポートする機能はホスト"
"が自由に設定することができます。 見せたいものだけ見せるようにできるということ"
"です。 次のチャプターでは CPUID を原因とする VM Exit をハンドリングして、"
"Linux の起動シーケンスがさらに進むようにします。"

#: src/vmm/linux_boot.md:742
msgid ""
"[The Linux/x86 Boot Protocol - The Linux Kernel](https://www.kernel.org/doc/"
"html/v5.6/x86/boot.html)"
msgstr ""
"[The Linux/x86 Boot Protocol - The Linux Kernel](https://www.kernel.org/doc/"
"html/v5.6/x86/boot.html)"

#: src/vmm/linux_boot.md:743
msgid ""
"[Booting process of Linux - Wikipedia](https://en.wikipedia.org/wiki/"
"Booting_process_of_Linux)"
msgstr ""
"[Booting process of Linux - Wikipedia](https://en.wikipedia.org/wiki/"
"Booting_process_of_Linux)"

#: src/vmm/linux_boot.md:745
msgid ""
"MBR は 512 バイトしかないため、通常 MBR からロードされた最初のブートローダは"
"よりサイズの大きいブートローダをロードするためだけに使われます。 このとき、"
"MBR に入っているブートローダを _First Stage Bootloader_ と呼び、続いてロード"
"されるブートローダを _Second Stage Bootloader_ と呼んだりします。 UEFI の場合"
"にはサイズ制限がないため、直接ブートローダ全体をロードすることができます。"
msgstr ""
"MBR は 512 バイトしかないため、通常 MBR からロードされた最初のブートローダは"
"よりサイズの大きいブートローダをロードするためだけに使われます。 このとき、"
"MBR に入っているブートローダを _First Stage Bootloader_ と呼び、続いてロード"
"されるブートローダを _Second Stage Bootloader_ と呼んだりします。 UEFI の場合"
"にはサイズ制限がないため、直接ブートローダ全体をロードすることができます。"

#: src/vmm/linux_boot.md:748
msgid "`bzImage` の圧縮アルゴリズムは config で変更可能です。"
msgstr "`bzImage` の圧縮アルゴリズムは config で変更可能です。"

#: src/vmm/linux_boot.md:749
msgid ""
"[Frequently asked questions - Visual Studio Code](https://code.visualstudio."
"com/docs/cpp/faq-cpp#_how-do-i-get-intellisense-to-work-correctly)"
msgstr ""
"[Frequently asked questions - Visual Studio Code](https://code.visualstudio."
"com/docs/cpp/faq-cpp#_how-do-i-get-intellisense-to-work-correctly)"

#: src/vmm/cpuid.md:1
msgid "CPUID の仮想化"
msgstr "CPUID の仮想化"

#: src/vmm/cpuid.md:3
msgid ""
"前チャプターではゲスト Linux の起動処理を開始することに成功し、CPUID が原因"
"で VM Exit するところまで確認しました。 本チャプターでは、ゲストの CPUID 命令"
"に対して適切な値を見せることで CPUID を仮想化します。"
msgstr ""
"前チャプターではゲスト Linux の起動処理を開始することに成功し、CPUID が原因"
"で VM Exit するところまで確認しました。 本チャプターでは、ゲストの CPUID 命令"
"に対して適切な値を見せることで CPUID を仮想化します。"

#: src/vmm/cpuid.md:8
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-cpuid`](https://"
#| "github.com/smallkirby/ymir/tree/whiz-vmm-cpuid) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-vmm-cpuid`](https://github.com/smallkirby/"
"ymir/tree/whiz-vmm-cpuid) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-cpuid`](https://"
"github.com/smallkirby/ymir/tree/whiz-vmm-cpuid) ブランチにあります。"

#: src/vmm/cpuid.md:12 src/vmm/msr.md:13
msgid "[VM Exit ハンドラ](#vm-exit-ハンドラ)"
msgstr "[VM Exit ハンドラ](#vm-exit-ハンドラ)"

#: src/vmm/cpuid.md:13
msgid "[CPUID ハンドラ](#cpuid-ハンドラ)"
msgstr "[CPUID ハンドラ](#cpuid-ハンドラ)"

#: src/vmm/cpuid.md:14
msgid "[Leaf ごとの対応](#leaf-ごとの対応)"
msgstr "[Leaf ごとの対応](#leaf-ごとの対応)"

#: src/vmm/cpuid.md:15
msgid "[0x0: Basic CPUID Information](#0x0-basic-cpuid-information)"
msgstr "[0x0: Basic CPUID Information](#0x0-basic-cpuid-information)"

#: src/vmm/cpuid.md:16
msgid "[0x1: Feature Information](#0x1-feature-information)"
msgstr "[0x1: Feature Information](#0x1-feature-information)"

#: src/vmm/cpuid.md:17
msgid "[0x6: Thermal and Power Management](#0x6-thermal-and-power-management)"
msgstr "[0x6: Thermal and Power Management](#0x6-thermal-and-power-management)"

#: src/vmm/cpuid.md:18
msgid ""
"[0x7: Extended Feature Flags Enumeration](#0x7-extended-feature-flags-"
"enumeration)"
msgstr ""
"[0x7: Extended Feature Flags Enumeration](#0x7-extended-feature-flags-"
"enumeration)"

#: src/vmm/cpuid.md:19
msgid ""
"[0xD: Processor Extended State Enumeration](#0xd-processor-extended-state-"
"enumeration)"
msgstr ""
"[0xD: Processor Extended State Enumeration](#0xd-processor-extended-state-"
"enumeration)"

#: src/vmm/cpuid.md:20
msgid ""
"[0x8000_0000: Extended Function Maximum Input](#0x8000_0000-extended-"
"function-maximum-input)"
msgstr ""
"[0x8000_0000: Extended Function Maximum Input](#0x8000_0000-extended-"
"function-maximum-input)"

#: src/vmm/cpuid.md:21
msgid "[0x8000_0001: Extended Function](#0x8000_0001-extended-function)"
msgstr "[0x8000_0001: Extended Function](#0x8000_0001-extended-function)"

#: src/vmm/cpuid.md:24 src/vmm/msr.md:21
msgid "VM Exit ハンドラ"
msgstr "VM Exit ハンドラ"

#: src/vmm/cpuid.md:26
msgid ""
"ゲストが [CPUID](https://www.felixcloutier.com/x86/cpuid) 命令を実行しようと"
"すると、無条件で VM Exit が発生します。 この際、VMCS **Basic VM-Exit "
"Information** カテゴリの **Basic Reason** フィールドに `0x0A`(`.cpuid`) が設"
"定されます。 VM Exit ハンドラである `handleExit()` において、CPUID を原因とす"
"る VM Exit に対してハンドラを呼び出すようにします:"
msgstr ""
"ゲストが [CPUID](https://www.felixcloutier.com/x86/cpuid) 命令を実行しようと"
"すると、無条件で VM Exit が発生します。 この際、VMCS **Basic VM-Exit "
"Information** カテゴリの **Basic Reason** フィールドに `0x0A`(`.cpuid`) が設"
"定されます。 VM Exit ハンドラである `handleExit()` において、CPUID を原因とす"
"る VM Exit に対してハンドラを呼び出すようにします:"

#: src/vmm/cpuid.md:46
msgid ""
"`cpuid.handleCpuidExit()` は CPUID 命令に対する専用のハンドラであり、要求され"
"た CPUID Leaf に応じて適切な値をゲストレジスタに設定します。"
msgstr ""
"`cpuid.handleCpuidExit()` は CPUID 命令に対する専用のハンドラであり、要求され"
"た CPUID Leaf に応じて適切な値をゲストレジスタに設定します。"

#: src/vmm/cpuid.md:48
msgid ""
"`Vcpu.stepNextInst()` はゲストの RIP をインクリメントし、次の命令を指すように"
"します。 x64 は [CISC](https://en.wikipedia.org/wiki/"
"Complex_instruction_set_computer) であり、命令の長さが固定ではなく可変になっ"
"ています。 そのため、RIP をインクリメントするには現在 RIP が指している命令の"
"長さを知る必要があります。 幸いなことに、VMCS VM-Exit Information には "
"**Exit Instruction Length** フィールドが存在し、 VM Exit を発生させた命令の長"
"さを取得することができます。 わざわざ自分で x64 命令セットのデコーダを書く必"
"要がないのは非常に助かります。 `stepNextInst()` ではこのフィールドの値を読み"
"取って、RIP に加算することで次の命令を指すようにします:"
msgstr ""
"`Vcpu.stepNextInst()` はゲストの RIP をインクリメントし、次の命令を指すように"
"します。 x64 は [CISC](https://en.wikipedia.org/wiki/"
"Complex_instruction_set_computer) であり、命令の長さが固定ではなく可変になっ"
"ています。 そのため、RIP をインクリメントするには現在 RIP が指している命令の"
"長さを知る必要があります。 幸いなことに、VMCS VM-Exit Information には "
"**Exit Instruction Length** フィールドが存在し、 VM Exit を発生させた命令の長"
"さを取得することができます。 わざわざ自分で x64 命令セットのデコーダを書く必"
"要がないのは非常に助かります。 `stepNextInst()` ではこのフィールドの値を読み"
"取って、RIP に加算することで次の命令を指すようにします:"

#: src/vmm/cpuid.md:64
msgid "CPUID ハンドラ"
msgstr "CPUID ハンドラ"

#: src/vmm/cpuid.md:66
msgid ""
"`cpuid.handleCpuidExit()` は CPUID 命令に対するハンドラです。 その雛形は以下"
"のようになります:"
msgstr ""
"`cpuid.handleCpuidExit()` は CPUID 命令に対するハンドラです。 その雛形は以下"
"のようになります:"

#: src/vmm/cpuid.md:82
msgid ""
"CPUID は RAX レジスタで **Leaf** を指定することができます。 Leaf によっては "
"RCX レジスタで **Subleaf** を指定することができるものもあります。 Leaf と "
"Subleaf の組み合わせによって取得したい情報を指定します。 `Leaf` enum は [VMX "
"Root Operation のチャプター](./vmx_root.md#cpuid) で定義した `enum` であり、"
"CPUID の Laaf と関連する操作を提供します。 `handleCpuidExit()` では、ゲストの"
"レジスタから要求される CPUID Leaf を取得し、それに応じた処理を `switch` で行"
"います。"
msgstr ""
"CPUID は RAX レジスタで **Leaf** を指定することができます。 Leaf によっては "
"RCX レジスタで **Subleaf** を指定することができるものもあります。 Leaf と "
"Subleaf の組み合わせによって取得したい情報を指定します。 `Leaf` enum は [VMX "
"Root Operation のチャプター](./vmx_root.md#cpuid) で定義した `enum` であり、"
"CPUID の Laaf と関連する操作を提供します。 `handleCpuidExit()` では、ゲストの"
"レジスタから要求される CPUID Leaf を取得し、それに応じた処理を `switch` で行"
"います。"

#: src/vmm/cpuid.md:88
msgid ""
"CPUID の Leaf の数は非常に多いです。 また、CPU 世代によってサポートされる "
"Leaf が異なり、今後も増えていきます。 よって、この `switch` で全ての Leaf を"
"サポートすることはできません。 Ymir では、明示的にサポートする CPUID Leaf 以"
"外は未サポートとということにします。 未サポートの Leaf に対する CPUID 命令"
"は、RAX/RBX/RCX/RDX レジスタの全てに `0` をセットするという仕様になっていま"
"す:"
msgstr ""
"CPUID の Leaf の数は非常に多いです。 また、CPU 世代によってサポートされる "
"Leaf が異なり、今後も増えていきます。 よって、この `switch` で全ての Leaf を"
"サポートすることはできません。 Ymir では、明示的にサポートする CPUID Leaf 以"
"外は未サポートとということにします。 未サポートの Leaf に対する CPUID 命令"
"は、RAX/RBX/RCX/RDX レジスタの全てに `0` をセットするという仕様になっていま"
"す:"

#: src/vmm/cpuid.md:109
msgid ""
"`Leaf` enum はそもそも全 Leaf を定義してるわけではなく、_Non-Exhaustive "
"Enum_ として定義されていました:"
msgstr ""
"`Leaf` enum はそもそも全 Leaf を定義してるわけではなく、_Non-Exhaustive "
"Enum_ として定義されていました:"

#: src/vmm/cpuid.md:120
msgid ""
"Non-Exhaustive Enum は、`switch` において定義されていないフィールド(`_`)全て"
"を `_ =>` で捕捉することができます[^non-exhaustive]。 ひとまず個別の `Leaf` "
"の対応を書く前に、全てのフィールドに対して `invalid()` を呼び出すようにしま"
"す:"
msgstr ""
"Non-Exhaustive Enum は、`switch` において定義されていないフィールド(`_`)全て"
"を `_ =>` で捕捉することができます[^non-exhaustive]。 ひとまず個別の `Leaf` "
"の対応を書く前に、全てのフィールドに対して `invalid()` を呼び出すようにしま"
"す:"

#: src/vmm/cpuid.md:133
msgid "Leaf ごとの対応"
msgstr "Leaf ごとの対応"

#: src/vmm/cpuid.md:135
msgid ""
"Leaf ごとにゲストに見せたい値を定義していきます。 Ymir では必要最低限の Leaf "
"のみをサポートします。 CPU がサポートする全ての Leaf の説明については、_SDM "
"Vol.2A 3.3 CPUID - CPU Identification_ を参照してください。"
msgstr ""
"Leaf ごとにゲストに見せたい値を定義していきます。 Ymir では必要最低限の Leaf "
"のみをサポートします。 CPU がサポートする全ての Leaf の説明については、_SDM "
"Vol.2A 3.3 CPUID - CPU Identification_ を参照してください。"

#: src/vmm/cpuid.md:139
msgid "0x0: Basic CPUID Information"
msgstr "0x0: Basic CPUID Information"

#: src/vmm/cpuid.md:141
msgid ""
"![Information Returned by CPUID Instruction: Leaf 0x0](../assets/sdm/cpuid_0."
"png) _Information Returned by CPUID Instruction: Leaf 0x0. SDM Vol.2A Table "
"3-17._"
msgstr ""
"![Information Returned by CPUID Instruction: Leaf 0x0](../assets/sdm/cpuid_0."
"png) _Information Returned by CPUID Instruction: Leaf 0x0. SDM Vol.2A Table "
"3-17._"

#: src/vmm/cpuid.md:144
msgid ""
"Leaf `0x0` は CPU がサポートする最大の Leaf 番号と、**CPU Vendor ID** を返し"
"ます。 サポートする最大の Leaf は、おそらく `0x20` になると思います。 ただ"
"し、CPUID は Extended Function と呼ばれる `0x8000_0000` 以降の Leaf もサポー"
"トしている場合があります。 Leaf `0x0` で返される値は Extended Function を除い"
"た最大の Leaf 番号となります。"
msgstr ""
"Leaf `0x0` は CPU がサポートする最大の Leaf 番号と、**CPU Vendor ID** を返し"
"ます。 サポートする最大の Leaf は、おそらく `0x20` になると思います。 ただ"
"し、CPUID は Extended Function と呼ばれる `0x8000_0000` 以降の Leaf もサポー"
"トしている場合があります。 Leaf `0x0` で返される値は Extended Function を除い"
"た最大の Leaf 番号となります。"

#: src/vmm/cpuid.md:149
msgid ""
"CPU Vendor ID は、CPU の製造元を示す 12byte の文字列です。 Intel CPU では "
"`\"GenuineIntel\"` となっています。 Linux KVM はこの値を `\"KVMKVMKVM\"` とし"
"ています。 KVM 上で動作するゲストはこの Vendor ID から KVM 上で動作しているこ"
"とを検知し、可能であれば paravirtualization を利用することができます。 Ymir "
"では KVM にならい Vendor ID を `\"YmirYmirYmir\"` として返すことにします。 も"
"ちろん Ymir に対応したゲストOSなんてものは存在しないので、この値を見てもゲス"
"トは何もできませんけどね!:"
msgstr ""
"CPU Vendor ID は、CPU の製造元を示す 12byte の文字列です。 Intel CPU では "
"`\"GenuineIntel\"` となっています。 Linux KVM はこの値を `\"KVMKVMKVM\"` とし"
"ています。 KVM 上で動作するゲストはこの Vendor ID から KVM 上で動作しているこ"
"とを検知し、可能であれば paravirtualization を利用することができます。 Ymir "
"では KVM にならい Vendor ID を `\"YmirYmirYmir\"` として返すことにします。 も"
"ちろん Ymir に対応したゲストOSなんてものは存在しないので、この値を見てもゲス"
"トは何もできませんけどね!:"

#: src/vmm/cpuid.md:166
msgid "0x1: Feature Information"
msgstr "0x1: Feature Information"

#: src/vmm/cpuid.md:168
msgid ""
"![Information Returned by CPUID Instruction: Leaf 0x1](../assets/sdm/cpuid_1."
"png) _Information Returned by CPUID Instruction: Leaf 0x1. SDM Vol.2A Table "
"3-17._"
msgstr ""
"![Information Returned by CPUID Instruction: Leaf 0x1](../assets/sdm/cpuid_1."
"png) _Information Returned by CPUID Instruction: Leaf 0x1. SDM Vol.2A Table "
"3-17._"

#: src/vmm/cpuid.md:171
msgid ""
"Leaf `0x1` は CPU のバージョンとサポートする機能に関する情報を返します。 バー"
"ジョン情報は、Vendor ID がゲストが知らない値である以上何の意味も持ちません。 "
"ここではとりあえずホストの CPU が返すバージョン情報をそのまま返すことにしま"
"す:"
msgstr ""
"Leaf `0x1` は CPU のバージョンとサポートする機能に関する情報を返します。 バー"
"ジョン情報は、Vendor ID がゲストが知らない値である以上何の意味も持ちません。 "
"ここではとりあえずホストの CPU が返すバージョン情報をそのまま返すことにしま"
"す:"

#: src/vmm/cpuid.md:186
msgid ""
"ECX/EDX に格納される Feature Information は、CPU がサポートする機能をビット"
"フィールドで表します。 Feature Information の定義は以下のようになっています"
"が、長いので折りたたみで表示しておきます。 気になる人は展開してみてください:"
msgstr ""
"ECX/EDX に格納される Feature Information は、CPU がサポートする機能をビット"
"フィールドで表します。 Feature Information の定義は以下のようになっています"
"が、長いので折りたたみで表示しておきます。 気になる人は展開してみてください:"

#: src/vmm/cpuid.md:332
msgid ""
"x64 は [`verify_cpu()` において必須の機能がサポートされているかどうかを確認]"
"(https://github.com/torvalds/linux/blob/"
"de2f378f2b771b39594c04695feee86476743a69/arch/x86/include/asm/required-"
"features.h#L76) し、 サポートされていない場合には初期化処理を中止してしまいま"
"す:"
msgstr ""
"x64 は [`verify_cpu()` において必須の機能がサポートされているかどうかを確認]"
"(https://github.com/torvalds/linux/blob/"
"de2f378f2b771b39594c04695feee86476743a69/arch/x86/include/asm/required-"
"features.h#L76) し、 サポートされていない場合には初期化処理を中止してしまいま"
"す:"

#: src/vmm/cpuid.md:342
msgid "Ymir ではこれらの必須機能を含む以下の機能をサポートすることにします:"
msgstr "Ymir ではこれらの必須機能を含む以下の機能をサポートすることにします:"

#: src/vmm/cpuid.md:344 src/vmm/cr.md:434
msgid "PCID"
msgstr "PCID"

#: src/vmm/cpuid.md:345
msgid "FPU / SSE / SSE2"
msgstr "FPU / SSE / SSE2"

#: src/vmm/cpuid.md:346
msgid "Page Size Extension"
msgstr "Page Size Extension"

#: src/vmm/cpuid.md:347
msgid ""
"[RDMSR](https://www.felixcloutier.com/x86/rdmsr) / [WRMSR](https://www."
"felixcloutier.com/x86/wrmsr) 命令"
msgstr ""
"[RDMSR](https://www.felixcloutier.com/x86/rdmsr) / [WRMSR](https://www."
"felixcloutier.com/x86/wrmsr) 命令"

#: src/vmm/cpuid.md:348
msgid ""
"[SYSENTER](https://www.felixcloutier.com/x86/sysenter) / [SYSEXIT](https://"
"www.felixcloutier.com/x86/sysexit) 命令"
msgstr ""
"[SYSENTER](https://www.felixcloutier.com/x86/sysenter) / [SYSEXIT](https://"
"www.felixcloutier.com/x86/sysexit) 命令"

#: src/vmm/cpuid.md:349
msgid "ページテーブルにおける Global ビット"
msgstr "ページテーブルにおける Global ビット"

#: src/vmm/cpuid.md:350
msgid ""
"[FXSAVE](https://www.felixcloutier.com/x86/fxsave) / [FXRSTOR](https://www."
"felixcloutier.com/x86/fxrstor) 命令"
msgstr ""
"[FXSAVE](https://www.felixcloutier.com/x86/fxsave) / [FXRSTOR](https://www."
"felixcloutier.com/x86/fxrstor) 命令"

#: src/vmm/cpuid.md:352
msgid "逆に以下の機能は明示的に無効化します:"
msgstr "逆に以下の機能は明示的に無効化します:"

#: src/vmm/cpuid.md:354
msgid "ACPI: Ymir では一切サポートしません"
msgstr "ACPI: Ymir では一切サポートしません"

#: src/vmm/cpuid.md:380
msgid ""
"\\[!WARN\\] Linux における PCID の無効化 最近の Intel Core CPU であれば、"
"PCID はサポートされているはずです。 しかしながら、Alder Lake (12th Gen) 以降"
"の CPU では、INVLPG 命令でグローバルページがフラッシュされないというバグがあ"
"ります。 これに対処するため、Linux 6.4 移行のカーネルでは PCID を無効化する"
"パッチ[^pcid-disable]が適用されています。 お使いのカーネルおよびCPUがこれに該"
"当する場合、上記の `pcid` を `false` にしてゲストでも PCID を無効化してくださ"
"い。"
msgstr ""
"\\[!WARN\\] Linux における PCID の無効化 最近の Intel Core CPU であれば、"
"PCID はサポートされているはずです。 しかしながら、Alder Lake (12th Gen) 以降"
"の CPU では、INVLPG 命令でグローバルページがフラッシュされないというバグがあ"
"ります。 これに対処するため、Linux 6.4 移行のカーネルでは PCID を無効化する"
"パッチ[^pcid-disable]が適用されています。 お使いのカーネルおよびCPUがこれに該"
"当する場合、上記の `pcid` を `false` にしてゲストでも PCID を無効化してくださ"
"い。"

#: src/vmm/cpuid.md:386
msgid "0x6: Thermal and Power Management"
msgstr "0x6: Thermal and Power Management"

#: src/vmm/cpuid.md:388
msgid "Ymir では Thermal and Power Management には一切対応しません:"
msgstr "Ymir では Thermal and Power Management には一切対応しません:"

#: src/vmm/cpuid.md:395
msgid "0x7: Extended Feature Flags Enumeration"
msgstr "0x7: Extended Feature Flags Enumeration"

#: src/vmm/cpuid.md:397
msgid ""
"![Information Returned by CPUID Instruction: Leaf 0x7](../assets/sdm/cpuid_7."
"png) _Information Returned by CPUID Instruction: Leaf 0x7. SDM Vol.2A Table "
"3-17._"
msgstr ""
"![Information Returned by CPUID Instruction: Leaf 0x7](../assets/sdm/cpuid_7."
"png) _Information Returned by CPUID Instruction: Leaf 0x7. SDM Vol.2A Table "
"3-17._"

#: src/vmm/cpuid.md:400
msgid ""
"Leaf `0x7` も Feature Information と同様に CPU の機能に関する情報を返しま"
"す。 ただし、Leaf `0x7` には Subleaf が存在します。 サポートされる Subleaf の"
"個数は、Subleaf 0 で RAX によって返される値によって決まります。 Ymir では "
"Subleaf 0 のみをサポートしたかったのですが、サポートする Subleaf の最大値を "
"`0` として指定した場合でも Linux は Subleaf 1 以降の情報を取得しようとしま"
"す。 そのため、Subleaf 1,2 に関しては呼び出しを許容するものの、 `invalid()` "
"を返すことにします。 Subleaf 3 以降の呼び出しはエラーにします:"
msgstr ""
"Leaf `0x7` も Feature Information と同様に CPU の機能に関する情報を返しま"
"す。 ただし、Leaf `0x7` には Subleaf が存在します。 サポートされる Subleaf の"
"個数は、Subleaf 0 で RAX によって返される値によって決まります。 Ymir では "
"Subleaf 0 のみをサポートしたかったのですが、サポートする Subleaf の最大値を "
"`0` として指定した場合でも Linux は Subleaf 1 以降の情報を取得しようとしま"
"す。 そのため、Subleaf 1,2 に関しては呼び出しを許容するものの、 `invalid()` "
"を返すことにします。 Subleaf 3 以降の呼び出しはエラーにします:"

#: src/vmm/cpuid.md:427
msgid ""
"EDX に格納される Feature Feature Flags は以下のようになっています。 やはり長"
"いので折りたたみで表示しておきます:"
msgstr ""
"EDX に格納される Feature Feature Flags は以下のようになっています。 やはり長"
"いので折りたたみで表示しておきます:"

#: src/vmm/cpuid.md:473
msgid "Ymir では以下の機能をサポートします:"
msgstr "Ymir では以下の機能をサポートします:"

#: src/vmm/cpuid.md:475
msgid ""
"[RDFSBASE/RDGSBASE](https://www.felixcloutier.com/x86/rdfsbase:rdgsbase) / "
"[WRFSBASE/WRGSBASE](https://www.felixcloutier.com/x86/wrfsbase:wrgsbase) 命令"
msgstr ""
"[RDFSBASE/RDGSBASE](https://www.felixcloutier.com/x86/rdfsbase:rdgsbase) / "
"[WRFSBASE/WRGSBASE](https://www.felixcloutier.com/x86/wrfsbase:wrgsbase) 命令"

#: src/vmm/cpuid.md:476
msgid "[SMEP](https://en.wikipedia.org/wiki/Control_register#SMEP)"
msgstr "[SMEP](https://en.wikipedia.org/wiki/Control_register#SMEP)"

#: src/vmm/cpuid.md:477
msgid "[SMAP](https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention)"
msgstr ""
"[SMAP](https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention)"

#: src/vmm/cpuid.md:478
msgid "[INVPCID](https://www.felixcloutier.com/x86/invpcid)"
msgstr "[INVPCID](https://www.felixcloutier.com/x86/invpcid)"

#: src/vmm/cpuid.md:490
msgid "0xD: Processor Extended State Enumeration"
msgstr "0xD: Processor Extended State Enumeration"

#: src/vmm/cpuid.md:492
msgid ""
"Leaf `0xD` は CPU の拡張機能に関する情報を返します。 この Leaf も Subleaf を"
"持っています。 Subleaf 1 は [XSAVE](https://www.felixcloutier.com/x86/"
"xsave) / [XRSTOR](https://www.felixcloutier.com/x86/xrstor) のサポートに関す"
"る情報を返します。 Ymir では Subleaf 1 のみ呼び出しを許可(実際には未実装)し、"
"それ以外の呼び出しはエラーとします:"
msgstr ""
"Leaf `0xD` は CPU の拡張機能に関する情報を返します。 この Leaf も Subleaf を"
"持っています。 Subleaf 1 は [XSAVE](https://www.felixcloutier.com/x86/"
"xsave) / [XRSTOR](https://www.felixcloutier.com/x86/xrstor) のサポートに関す"
"る情報を返します。 Ymir では Subleaf 1 のみ呼び出しを許可(実際には未実装)し、"
"それ以外の呼び出しはエラーとします:"

#: src/vmm/cpuid.md:510
msgid "0x8000_0000: Extended Function Maximum Input"
msgstr "0x8000_0000: Extended Function Maximum Input"

#: src/vmm/cpuid.md:512
msgid ""
"![Information Returned by CPUID Instruction: Leaf 0x8000_0000](../assets/sdm/"
"cpuid_80000000.png) _Information Returned by CPUID Instruction: Leaf "
"0x8000_0000. SDM Vol.2A Table 3-17._"
msgstr ""
"![Information Returned by CPUID Instruction: Leaf 0x8000_0000](../assets/sdm/"
"cpuid_80000000.png) _Information Returned by CPUID Instruction: Leaf "
"0x8000_0000. SDM Vol.2A Table 3-17._"

#: src/vmm/cpuid.md:515
msgid ""
"Leaf `0x8000_0000` は CPU がサポートする最大の Extended Function Leaf 番号を"
"返します。 Linux は [`verify_cpu()` においてこの値を取得し `0x8000_0001` 以上"
"であることを要求する](https://github.com/torvalds/linux/blob/"
"de2f378f2b771b39594c04695feee86476743a69/arch/x86/kernel/verify_cpu.S#L109) "
"ため、 Ymir でもそこまでをサポートするようにします:"
msgstr ""
"Leaf `0x8000_0000` は CPU がサポートする最大の Extended Function Leaf 番号を"
"返します。 Linux は [`verify_cpu()` においてこの値を取得し `0x8000_0001` 以上"
"であることを要求する](https://github.com/torvalds/linux/blob/"
"de2f378f2b771b39594c04695feee86476743a69/arch/x86/kernel/verify_cpu.S#L109) "
"ため、 Ymir でもそこまでをサポートするようにします:"

#: src/vmm/cpuid.md:529
msgid "0x8000_0001: Extended Function"
msgstr "0x8000_0001: Extended Function"

#: src/vmm/cpuid.md:531
msgid ""
"Leaf `0x8000_0001` は syscall や Intel 64 などの拡張機能に関する情報を返しま"
"す。 Ymir ではこの Leaf はホストの値をパススルーします:"
msgstr ""
"Leaf `0x8000_0001` は syscall や Intel 64 などの拡張機能に関する情報を返しま"
"す。 Ymir ではこの Leaf はホストの値をパススルーします:"

#: src/vmm/cpuid.md:547
msgid ""
"以上で CPUID を原因とする VM Exit のハンドラは完成です。 結局のところ定義し"
"た CPUID Leaf はたったの7つだけです。 本シリーズでは、今後 Linux のブートが完"
"了するまでの間これ以上の CPUID Leaf に対応する必要はありません。 この7つの "
"Leaf の仮想化だけで Linux のブートをすることができます。"
msgstr ""
"以上で CPUID を原因とする VM Exit のハンドラは完成です。 結局のところ定義し"
"た CPUID Leaf はたったの7つだけです。 本シリーズでは、今後 Linux のブートが完"
"了するまでの間これ以上の CPUID Leaf に対応する必要はありません。 この7つの "
"Leaf の仮想化だけで Linux のブートをすることができます。"

#: src/vmm/cpuid.md:552
msgid "最後に、CPUID を仮想化した状態でゲストを実行してみましょう:"
msgstr "最後に、CPUID を仮想化した状態でゲストを実行してみましょう:"

#: src/vmm/cpuid.md:566
msgid ""
"前回と違って CPUID による VM Exit ではなくなりました。 代わりに [RDMSR]"
"(https://www.felixcloutier.com/x86/rdmsr) による VM Exit が発生しています。 "
"次チャプターでは RDMSR / WRMSR に対応するためのハンドラを実装します。 加え"
"て、ゲストとホストの MSR を適切に保存・退避するように VMCS の設定をしていきま"
"す。"
msgstr ""
"前回と違って CPUID による VM Exit ではなくなりました。 代わりに [RDMSR]"
"(https://www.felixcloutier.com/x86/rdmsr) による VM Exit が発生しています。 "
"次チャプターでは RDMSR / WRMSR に対応するためのハンドラを実装します。 加え"
"て、ゲストとホストの MSR を適切に保存・退避するように VMCS の設定をしていきま"
"す。"

#: src/vmm/cpuid.md:571
msgid ""
"Exhaustive Enum では `_` を使うことができない代わりに、明示的に捕捉したフィー"
"ルド以外の全てのフィールドを `else` で捕捉することができます。"
msgstr ""
"Exhaustive Enum では `_` を使うことができない代わりに、明示的に捕捉したフィー"
"ルド以外の全てのフィールドを `else` で捕捉することができます。"

#: src/vmm/cpuid.md:572
msgid ""
"[https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?h=x86/"
"urgent&id=ce0b15d11ad837fbacc5356941712218e38a0a83](https://git.kernel.org/"
"pub/scm/linux/kernel/git/tip/tip.git/commit/?h=x86/"
"urgent&id=ce0b15d11ad837fbacc5356941712218e38a0a83)"
msgstr ""
"[https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?h=x86/"
"urgent&id=ce0b15d11ad837fbacc5356941712218e38a0a83](https://git.kernel.org/"
"pub/scm/linux/kernel/git/tip/tip.git/commit/?h=x86/"
"urgent&id=ce0b15d11ad837fbacc5356941712218e38a0a83)"

#: src/vmm/msr.md:1
msgid "MSR の仮想化"
msgstr "MSR の仮想化"

#: src/vmm/msr.md:3
msgid ""
"本チャプターでは MSR を仮想化します。 ゲストに対して見せる MSR の値を任意に設"
"定し、逆にゲストが MSR に書き込もうとした値をホストが変更することもできま"
"す。 また、VM Entry と VM Exit の際に MSR の値を適切に保存・復元するようにし"
"ます。"
msgstr ""
"本チャプターでは MSR を仮想化します。 ゲストに対して見せる MSR の値を任意に設"
"定し、逆にゲストが MSR に書き込もうとした値をホストが変更することもできま"
"す。 また、VM Entry と VM Exit の際に MSR の値を適切に保存・復元するようにし"
"ます。"

#: src/vmm/msr.md:9
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-msr`](https://"
#| "github.com/smallkirby/ymir/tree/whiz-vmm-msr) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-vmm-msr`](https://github.com/smallkirby/"
"ymir/tree/whiz-vmm-msr) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-msr`](https://github."
"com/smallkirby/ymir/tree/whiz-vmm-msr) ブランチにあります。"

#: src/vmm/msr.md:14
msgid "[MSR の保存・復帰](#msr-の保存復帰)"
msgstr "[MSR の保存・復帰](#msr-の保存復帰)"

#: src/vmm/msr.md:15
msgid "[自動的に保存・復帰される MSR](#自動的に保存復帰される-msr)"
msgstr "[自動的に保存・復帰される MSR](#自動的に保存復帰される-msr)"

#: src/vmm/msr.md:16
msgid "[MSR Area](#msr-area)"
msgstr "[MSR Area](#msr-area)"

#: src/vmm/msr.md:17
msgid "[RDMSR ハンドラ](#rdmsr-ハンドラ)"
msgstr "[RDMSR ハンドラ](#rdmsr-ハンドラ)"

#: src/vmm/msr.md:18
msgid "[WRMSR ハンドラ](#wrmsr-ハンドラ)"
msgstr "[WRMSR ハンドラ](#wrmsr-ハンドラ)"

#: src/vmm/msr.md:23
msgid ""
"ゲストが [RDMSR](https://www.felixcloutier.com/x86/rdmsr) / [WRMSR](https://"
"www.felixcloutier.com/x86/wrmsr) 命令を実行しようとすると VM Exit が発生する"
"場合があります。 VM Exit が発生するかどうかは VMCS Execution Control カテゴリ"
"の **MSR Bitmaps** によって制御されます。 MSR Bitmaps は MSR のアドレスにマッ"
"プされるビットマップであり、値が `1` の MSR に対して RDMSR / WRMSR が実行され"
"ると VM Exit が発生します。 値が `0` の MSR に対する操作では VM Exit が発生し"
"ません。 また、**MSR Bitmaps を無効化すると全ての MSR に対する RDMSR/WRMSR "
"が VM Exit を発生させる** ようになります。"
msgstr ""
"ゲストが [RDMSR](https://www.felixcloutier.com/x86/rdmsr) / [WRMSR](https://"
"www.felixcloutier.com/x86/wrmsr) 命令を実行しようとすると VM Exit が発生する"
"場合があります。 VM Exit が発生するかどうかは VMCS Execution Control カテゴリ"
"の **MSR Bitmaps** によって制御されます。 MSR Bitmaps は MSR のアドレスにマッ"
"プされるビットマップであり、値が `1` の MSR に対して RDMSR / WRMSR が実行され"
"ると VM Exit が発生します。 値が `0` の MSR に対する操作では VM Exit が発生し"
"ません。 また、**MSR Bitmaps を無効化すると全ての MSR に対する RDMSR/WRMSR "
"が VM Exit を発生させる** ようになります。"

#: src/vmm/msr.md:29
msgid ""
"本シリーズでは MSR Bitmaps を無効化し、全ての MSR に対する RDMSR/WRMSR が VM "
"Exit を発生させるようにします:"
msgstr ""
"本シリーズでは MSR Bitmaps を無効化し、全ての MSR に対する RDMSR/WRMSR が VM "
"Exit を発生させるようにします:"

#: src/vmm/msr.md:40
msgid ""
"RDMSR は `31` / WRMSR は `32` 番の Exit Reason で VM Exit します。 それぞれに"
"ついて Exit ハンドラを呼び出すように変更します:"
msgstr ""
"RDMSR は `31` / WRMSR は `32` 番の Exit Reason で VM Exit します。 それぞれに"
"ついて Exit ハンドラを呼び出すように変更します:"

#: src/vmm/msr.md:61
msgid "MSR の保存・復帰"
msgstr "MSR の保存・復帰"

#: src/vmm/msr.md:63
msgid ""
"MSR アクセスに対する VM Exit ハンドラの実装の前に、VM Entry / VM Exit におい"
"て MSR の保存・復帰をするようにしましょう。 現在は、一部の MSR を除いて全て"
"の MSR はゲスト・ホスト間で共有されてしまっています。"
msgstr ""
"MSR アクセスに対する VM Exit ハンドラの実装の前に、VM Entry / VM Exit におい"
"て MSR の保存・復帰をするようにしましょう。 現在は、一部の MSR を除いて全て"
"の MSR はゲスト・ホスト間で共有されてしまっています。"

#: src/vmm/msr.md:66
msgid "自動的に保存・復帰される MSR"
msgstr "自動的に保存・復帰される MSR"

#: src/vmm/msr.md:68
msgid ""
"以下のゲストの MSR は VM Entry 時に対応する場所から自動的にロードされます:"
msgstr ""
"以下のゲストの MSR は VM Entry 時に対応する場所から自動的にロードされます:"

#: src/vmm/msr.md:70 src/vmm/msr.md:90 src/vmm/msr.md:109
msgid "条件"
msgstr "条件"

#: src/vmm/msr.md:70 src/vmm/msr.md:90
msgid "ロード元"
msgstr "ロード元"

#: src/vmm/msr.md:72 src/vmm/msr.md:92 src/vmm/msr.md:111
msgid "`IA32_DEBUGCTL`"
msgstr "`IA32_DEBUGCTL`"

#: src/vmm/msr.md:72
msgid "VMCS VM-Entry Control の `load debug controls` が有効"
msgstr "VMCS VM-Entry Control の `load debug controls` が有効"

#: src/vmm/msr.md:73 src/vmm/msr.md:93
msgid "`IA32_SYSENTER_CS`"
msgstr "`IA32_SYSENTER_CS`"

#: src/vmm/msr.md:73 src/vmm/msr.md:74 src/vmm/msr.md:75 src/vmm/msr.md:76
#: src/vmm/msr.md:77 src/vmm/msr.md:92 src/vmm/msr.md:93 src/vmm/msr.md:94
#: src/vmm/msr.md:95 src/vmm/msr.md:96 src/vmm/msr.md:97
msgid "(Unconditional)"
msgstr "(Unconditional)"

#: src/vmm/msr.md:73 src/vmm/msr.md:74 src/vmm/msr.md:75
msgid "VMCS Guest-State"
msgstr "VMCS Guest-State"

#: src/vmm/msr.md:74 src/vmm/msr.md:94
msgid "`IA32_SYSENTER_ESP`"
msgstr "`IA32_SYSENTER_ESP`"

#: src/vmm/msr.md:75 src/vmm/msr.md:95
msgid "`IA32_SYSENTER_EIP`"
msgstr "`IA32_SYSENTER_EIP`"

#: src/vmm/msr.md:76 src/vmm/msr.md:96
msgid "`IA32_FSBASE`"
msgstr "`IA32_FSBASE`"

#: src/vmm/msr.md:76
msgid "Guest-State の FS.Base"
msgstr "Guest-State の FS.Base"

#: src/vmm/msr.md:77 src/vmm/msr.md:97
msgid "`IA32_GSBASE`"
msgstr "`IA32_GSBASE`"

#: src/vmm/msr.md:77
msgid "Guest-State の GS.Base"
msgstr "Guest-State の GS.Base"

#: src/vmm/msr.md:78 src/vmm/msr.md:98 src/vmm/msr.md:120
msgid "`IA32_PERF_GLOBAL_CTRL`"
msgstr "`IA32_PERF_GLOBAL_CTRL`"

#: src/vmm/msr.md:78
msgid "VMCS VM-Entry Control の `load IA32_PERF_GLOBAL_CTRL` が有効"
msgstr "VMCS VM-Entry Control の `load IA32_PERF_GLOBAL_CTRL` が有効"

#: src/vmm/msr.md:79
msgid "VMCS VM-Entry Control の `load IA32_PAT` が有効"
msgstr "VMCS VM-Entry Control の `load IA32_PAT` が有効"

#: src/vmm/msr.md:80
msgid "VMCS VM-Entry Control の `load IA32_EFER` が有効"
msgstr "VMCS VM-Entry Control の `load IA32_EFER` が有効"

#: src/vmm/msr.md:81 src/vmm/msr.md:101 src/vmm/msr.md:114
msgid "`IA32_BNDCFGS`"
msgstr "`IA32_BNDCFGS`"

#: src/vmm/msr.md:81
msgid "VMCS VM-Entry Control の `load IA32_BNDCFGS` が有効"
msgstr "VMCS VM-Entry Control の `load IA32_BNDCFGS` が有効"

#: src/vmm/msr.md:82 src/vmm/msr.md:102 src/vmm/msr.md:115
msgid "`IA32_RTIT_CTL`"
msgstr "`IA32_RTIT_CTL`"

#: src/vmm/msr.md:82
msgid "VMCS VM-Entry Control の `load IA32_RTIT_CTL` が有効"
msgstr "VMCS VM-Entry Control の `load IA32_RTIT_CTL` が有効"

#: src/vmm/msr.md:83 src/vmm/msr.md:103 src/vmm/msr.md:116
msgid "`IA32_S_CET`"
msgstr "`IA32_S_CET`"

#: src/vmm/msr.md:83 src/vmm/msr.md:84
msgid "VMCS VM-Entry Control の `load CET` が有効"
msgstr "VMCS VM-Entry Control の `load CET` が有効"

#: src/vmm/msr.md:84 src/vmm/msr.md:104 src/vmm/msr.md:117
msgid "`IA32_INTERRUPT_SSP_TABLE_ADDR`"
msgstr "`IA32_INTERRUPT_SSP_TABLE_ADDR`"

#: src/vmm/msr.md:85 src/vmm/msr.md:118
msgid "`IA32_LBR_CTRL`"
msgstr "`IA32_LBR_CTRL`"

#: src/vmm/msr.md:85
msgid "VMCS VM-Entry Control の `load IA32_LBR_CTRL` が有効"
msgstr "VMCS VM-Entry Control の `load IA32_LBR_CTRL` が有効"

#: src/vmm/msr.md:86 src/vmm/msr.md:105 src/vmm/msr.md:119
msgid "`IA32_PKRS`"
msgstr "`IA32_PKRS`"

#: src/vmm/msr.md:86
msgid "VMCS VM-Entry Control の `load PKRS` が有効"
msgstr "VMCS VM-Entry Control の `load PKRS` が有効"

#: src/vmm/msr.md:88
msgid ""
"以下のホストの MSR は VM Exit 時に対応する場所から自動的にロードされます:"
msgstr ""
"以下のホストの MSR は VM Exit 時に対応する場所から自動的にロードされます:"

#: src/vmm/msr.md:92 src/vmm/msr.md:101 src/vmm/msr.md:102
msgid "`0` にクリアされる"
msgstr "`0` にクリアされる"

#: src/vmm/msr.md:93 src/vmm/msr.md:94 src/vmm/msr.md:95
msgid "VMCS Host-State"
msgstr "VMCS Host-State"

#: src/vmm/msr.md:96
msgid "Host-State の FS.Base"
msgstr "Host-State の FS.Base"

#: src/vmm/msr.md:97
msgid "Host-State の GS.Base"
msgstr "Host-State の GS.Base"

#: src/vmm/msr.md:98
msgid "VMCS VM-Exit Control の `load IA32_PERF_GLOBAL_CTRL` が有効"
msgstr "VMCS VM-Exit Control の `load IA32_PERF_GLOBAL_CTRL` が有効"

#: src/vmm/msr.md:99
msgid "VMCS VM-Exit Control の `load IA32_PAT` が有効"
msgstr "VMCS VM-Exit Control の `load IA32_PAT` が有効"

#: src/vmm/msr.md:100
msgid "VMCS VM-Exit Control の `load IA32_EFER` が有効"
msgstr "VMCS VM-Exit Control の `load IA32_EFER` が有効"

#: src/vmm/msr.md:101
msgid "VMCS VM-Exit Control の `clear IA32_BNDCFGS` が有効"
msgstr "VMCS VM-Exit Control の `clear IA32_BNDCFGS` が有効"

#: src/vmm/msr.md:102
msgid "VMCS VM-Exit Control の `clear IA32_RTIT_CTL` が有効"
msgstr "VMCS VM-Exit Control の `clear IA32_RTIT_CTL` が有効"

#: src/vmm/msr.md:103 src/vmm/msr.md:104 src/vmm/msr.md:116 src/vmm/msr.md:117
msgid "VMCS VM-Exit Control の `load CET` が有効"
msgstr "VMCS VM-Exit Control の `load CET` が有効"

#: src/vmm/msr.md:105 src/vmm/msr.md:119
msgid "VMCS VM-Exit Control の `load PKRS` が有効"
msgstr "VMCS VM-Exit Control の `load PKRS` が有効"

#: src/vmm/msr.md:107
msgid "以下のゲストの MSR は VM Exit 時に対応する場所に自動的にセーブされます:"
msgstr ""
"以下のゲストの MSR は VM Exit 時に対応する場所に自動的にセーブされます:"

#: src/vmm/msr.md:109
msgid "セーブ先"
msgstr "セーブ先"

#: src/vmm/msr.md:111
msgid "VMCS VM-Exit Control の `save debug controls` が有効"
msgstr "VMCS VM-Exit Control の `save debug controls` が有効"

#: src/vmm/msr.md:112
msgid "VMCS VM-Exit Control の `save IA32_PAT` が有効"
msgstr "VMCS VM-Exit Control の `save IA32_PAT` が有効"

#: src/vmm/msr.md:113
msgid "VMCS VM-Exit Control の `save IA32_EFER` が有効"
msgstr "VMCS VM-Exit Control の `save IA32_EFER` が有効"

#: src/vmm/msr.md:114
msgid "VMCS VM-Exit Control の `load IA32_BNDCFGS` が有効"
msgstr "VMCS VM-Exit Control の `load IA32_BNDCFGS` が有効"

#: src/vmm/msr.md:115
msgid "VMCS VM-Exit Control の `load IA32_RTIT_CTL` が有効"
msgstr "VMCS VM-Exit Control の `load IA32_RTIT_CTL` が有効"

#: src/vmm/msr.md:118
msgid "VMCS VM-Exit Control の `load IA32_LBR_CTRL` が有効"
msgstr "VMCS VM-Exit Control の `load IA32_LBR_CTRL` が有効"

#: src/vmm/msr.md:120
msgid "VMCS VM-Exit Control の `save IA32_PERF_GLOBAL_CTRL` が有効"
msgstr "VMCS VM-Exit Control の `save IA32_PERF_GLOBAL_CTRL` が有効"

#: src/vmm/msr.md:122
msgid ""
"これらの MSR は VM Entry / VM Exit 時に自動的にセーブ・ロードされます。 ロー"
"ドする値は VMCS に保存されているため、ホスト・ゲスト間で共有される心配があり"
"ません。 いくつかの MSR は VM-Exit/-Entry Controls において設定を有効化する必"
"要があります。 Ymir では以下の MSR についてロードを有効化します。 上記の MSR "
"の内、下記の MSR 以外は Ymir では使わないため、仮想化する必要がありません (ホ"
"ストにいる間もゲストの MSR が見えることになります):"
msgstr ""
"これらの MSR は VM Entry / VM Exit 時に自動的にセーブ・ロードされます。 ロー"
"ドする値は VMCS に保存されているため、ホスト・ゲスト間で共有される心配があり"
"ません。 いくつかの MSR は VM-Exit/-Entry Controls において設定を有効化する必"
"要があります。 Ymir では以下の MSR についてロードを有効化します。 上記の MSR "
"の内、下記の MSR 以外は Ymir では使わないため、仮想化する必要がありません (ホ"
"ストにいる間もゲストの MSR が見えることになります):"

#: src/vmm/msr.md:150
msgid "MSR Area"
msgstr "MSR Area"

#: src/vmm/msr.md:152
msgid ""
"上記の MSR 以外は明示的に設定しない限り VM Entry / VM Exit 時に保存・復帰され"
"ません。 Ymir では以下の MSR について追加で保存・復帰をすることにします:"
msgstr ""
"上記の MSR 以外は明示的に設定しない限り VM Entry / VM Exit 時に保存・復帰され"
"ません。 Ymir では以下の MSR について追加で保存・復帰をすることにします:"

#: src/vmm/msr.md:155
msgid "`IA32_TSC_AUX`"
msgstr "`IA32_TSC_AUX`"

#: src/vmm/msr.md:156
msgid "`IA32_STAR`"
msgstr "`IA32_STAR`"

#: src/vmm/msr.md:157
msgid "`IA32_LSTAR`"
msgstr "`IA32_LSTAR`"

#: src/vmm/msr.md:158
msgid "`IA32_CSTAR`"
msgstr "`IA32_CSTAR`"

#: src/vmm/msr.md:159
msgid "`IA32_FMASK`"
msgstr "`IA32_FMASK`"

#: src/vmm/msr.md:160
msgid "`IA32_KERNEL_GS_BASE`"
msgstr "`IA32_KERNEL_GS_BASE`"

#: src/vmm/msr.md:162
msgid ""
"VM Exit / Entry 時にロード・セーブする MSR は **MSR Area** と呼ばれる領域に保"
"存します。 MSR Area は **MSR Entry** と呼ばれる 128bit のエントリの配列で"
"す。 MSR Entry は以下のような構造を持ち、`index` で指定される MSR の `data` "
"を保持します:"
msgstr ""
"VM Exit / Entry 時にロード・セーブする MSR は **MSR Area** と呼ばれる領域に保"
"存します。 MSR Area は **MSR Entry** と呼ばれる 128bit のエントリの配列で"
"す。 MSR Entry は以下のような構造を持ち、`index` で指定される MSR の `data` "
"を保持します:"

#: src/vmm/msr.md:166
msgid ""
"![Format of an MSR Entry](../assets/sdm/msr_entry.png) _Format of an MSR "
"Entry. SDM Vol.3C Table 25-15._"
msgstr ""
"![Format of an MSR Entry](../assets/sdm/msr_entry.png) _Format of an MSR "
"Entry. SDM Vol.3C Table 25-15._"

#: src/vmm/msr.md:169
msgid "MSR Area には以下の3種類があります:"
msgstr "MSR Area には以下の3種類があります:"

#: src/vmm/msr.md:171
msgid ""
"**VM-Entry MSR-Load Area**: VM Entry 時にゲストの MSR をロードするためのエリ"
"ア"
msgstr ""
"**VM-Entry MSR-Load Area**: VM Entry 時にゲストの MSR をロードするためのエリ"
"ア"

#: src/vmm/msr.md:172
msgid ""
"**VM-Exit MSR-Store Area**: VM Exit 時にゲストの MSR を保存するためのエリア"
msgstr ""
"**VM-Exit MSR-Store Area**: VM Exit 時にゲストの MSR を保存するためのエリア"

#: src/vmm/msr.md:173
msgid ""
"**VM-Exit MSR-Load Area**: VM Exit 時にホストの MSR をロードするためのエリア"
msgstr ""
"**VM-Exit MSR-Load Area**: VM Exit 時にホストの MSR をロードするためのエリア"

#: src/vmm/msr.md:175
msgid ""
"VM Entry 時にホストの MSR をセーブするためのエリアは存在しません。 おそらく"
"(当然ですが)ホストは virtualization-aware であるため、VM Entry する前に手動で"
"セーブしろということでしょう。"
msgstr ""
"VM Entry 時にホストの MSR をセーブするためのエリアは存在しません。 おそらく"
"(当然ですが)ホストは virtualization-aware であるため、VM Entry する前に手動で"
"セーブしろということでしょう。"

#: src/vmm/msr.md:178
msgid "MSR Area を表現する構造体を定義します:"
msgstr "MSR Area を表現する構造体を定義します:"

#: src/vmm/msr.md:250
msgid ""
"`ShadowMsr` は MSR Entry の配列を保持し、登録する MSR を操作するための API を"
"提供します。 3つの MSR Area のうち、ホスト用(Load)とゲスト用(Store+Load)の領"
"域を表すメンバ変数を `Vm` に追加します:"
msgstr ""
"`ShadowMsr` は MSR Entry の配列を保持し、登録する MSR を操作するための API を"
"提供します。 3つの MSR Area のうち、ホスト用(Load)とゲスト用(Store+Load)の領"
"域を表すメンバ変数を `Vm` に追加します:"

#: src/vmm/msr.md:262
msgid ""
"VMCS の初期化時 (`setupVmcs()`) で、ゲストとホストの MSR Area を初期化しま"
"す。 MSR Area の物理アドレスは VM-Exit Controls / VM-Entry Controls の `MSR-"
"load address` / `MSR-store address` に設定します。 また、MSR Area に登録され"
"た MSR の個数は `MSR-load count` / `MSR-store count` に設定します。 ここに登"
"録された MSR Area の先頭から `count` 分だけ、VM Exit / VM Entry 時にロード・"
"セーブされます。 ホストの MSR は現在の MSR の値をそのまま登録することにしま"
"す。 ゲストの MSR は全て `0` に初期化します:"
msgstr ""
"VMCS の初期化時 (`setupVmcs()`) で、ゲストとホストの MSR Area を初期化しま"
"す。 MSR Area の物理アドレスは VM-Exit Controls / VM-Entry Controls の `MSR-"
"load address` / `MSR-store address` に設定します。 また、MSR Area に登録され"
"た MSR の個数は `MSR-load count` / `MSR-store count` に設定します。 ここに登"
"録された MSR Area の先頭から `count` 分だけ、VM Exit / VM Entry 時にロード・"
"セーブされます。 ホストの MSR は現在の MSR の値をそのまま登録することにしま"
"す。 ゲストの MSR は全て `0` に初期化します:"

#: src/vmm/msr.md:301
msgid ""
"VM-Exit MSR-Load Area (VM Exit 時にホストの MSR にロードされる領域) は、VM "
"Entry 前に毎回更新する必要があります。 そうしなければ、最初に設定した値が永遠"
"に使われることになってしまいます。 VM Entry ループをする `loop()` 内の "
"`while` ループの先頭で、以下の関数を呼び出します:"
msgstr ""
"VM-Exit MSR-Load Area (VM Exit 時にホストの MSR にロードされる領域) は、VM "
"Entry 前に毎回更新する必要があります。 そうしなければ、最初に設定した値が永遠"
"に使われることになってしまいます。 VM Entry ループをする `loop()` 内の "
"`while` ループの先頭で、以下の関数を呼び出します:"

#: src/vmm/msr.md:319
msgid ""
"本シリーズでは MSR Area に登録する MSR の個数が変わることはありません。 この"
"あと扱いますが、ゲストが MSR Area に登録されていない MSR に対して WRMSR をし"
"てきた場合にはアボートするようにします。 よって、実際は MSR counts を更新する"
"必要はありません。 今後 MSR Area に動的に MSR を追加で登録できるようにしたい"
"場合に備えて、このような実装にしています。"
msgstr ""
"本シリーズでは MSR Area に登録する MSR の個数が変わることはありません。 この"
"あと扱いますが、ゲストが MSR Area に登録されていない MSR に対して WRMSR をし"
"てきた場合にはアボートするようにします。 よって、実際は MSR counts を更新する"
"必要はありません。 今後 MSR Area に動的に MSR を追加で登録できるようにしたい"
"場合に備えて、このような実装にしています。"

#: src/vmm/msr.md:324
msgid ""
"以上で MSR Area に登録した MSR 及び自動的に保存・復帰される MSR の設定が完了"
"しました。 残すはゲストの RDMSR / WRMSR に応じて MSR Area に登録された MSR の"
"値を読み書きする処理を実装することです。"
msgstr ""
"以上で MSR Area に登録した MSR 及び自動的に保存・復帰される MSR の設定が完了"
"しました。 残すはゲストの RDMSR / WRMSR に応じて MSR Area に登録された MSR の"
"値を読み書きする処理を実装することです。"

#: src/vmm/msr.md:327
msgid "RDMSR ハンドラ"
msgstr "RDMSR ハンドラ"

#: src/vmm/msr.md:329
msgid ""
"RDMSR に対するハンドラを実装します。 まずは、ゲストのレジスタに RDMSR の結果"
"を格納するためのヘルパー関数を用意します。 RDMSR の結果は上位 32bit を RDX "
"に、下位 32bit を RAX に格納します。 ゲストに MSR の値を見せるには以下の2つの"
"パターンがあります:"
msgstr ""
"RDMSR に対するハンドラを実装します。 まずは、ゲストのレジスタに RDMSR の結果"
"を格納するためのヘルパー関数を用意します。 RDMSR の結果は上位 32bit を RDX "
"に、下位 32bit を RAX に格納します。 ゲストに MSR の値を見せるには以下の2つの"
"パターンがあります:"

#: src/vmm/msr.md:334
msgid "VMCS に登録された値を返す: 自動的にロード・セーブされる MSR の場合"
msgstr "VMCS に登録された値を返す: 自動的にロード・セーブされる MSR の場合"

#: src/vmm/msr.md:335
msgid "MSR Area に登録された値を返す: それ以外"
msgstr "MSR Area に登録された値を返す: それ以外"

#: src/vmm/msr.md:337
msgid ""
"前者のために `setRetVal()` を、後者のために `shadowRead()` を用意します:"
msgstr ""
"前者のために `setRetVal()` を、後者のために `shadowRead()` を用意します:"

#: src/vmm/msr.md:364
msgid "以上を踏まえて、RDMSR ハンドラを実装します:"
msgstr "以上を踏まえて、RDMSR ハンドラを実装します:"

#: src/vmm/msr.md:386
msgid ""
"対応していない MSR (`else`) に対する RDMSR はアボートします。 対応する必要の"
"ある MSR は経験則で決めています。 `else` だけをもつ `switch` でゲストを動かし"
"てみて、Linux がブートするまでに必要な MSR を追加していったらこうなりまし"
"た。 意外と少ない数の MSR で Linux が動くものですね。びっくり。 びっくりと言"
"えば、この節を書いているのは11月です。 栗が美味しい季節になりましたね。"
msgstr ""
"対応していない MSR (`else`) に対する RDMSR はアボートします。 対応する必要の"
"ある MSR は経験則で決めています。 `else` だけをもつ `switch` でゲストを動かし"
"てみて、Linux がブートするまでに必要な MSR を追加していったらこうなりまし"
"た。 意外と少ない数の MSR で Linux が動くものですね。びっくり。 びっくりと言"
"えば、この節を書いているのは11月です。 栗が美味しい季節になりましたね。"

#: src/vmm/msr.md:393
msgid "WRMSR ハンドラ"
msgstr "WRMSR ハンドラ"

#: src/vmm/msr.md:395
msgid "RDMSR と同様にヘルパー関数を用意します:"
msgstr "RDMSR と同様にヘルパー関数を用意します:"

#: src/vmm/msr.md:410
msgid "WRMSR ハンドラを実装します:"
msgstr "WRMSR ハンドラを実装します:"

#: src/vmm/msr.md:441
msgid ""
"RDMSR よりは対応する必要のある MSR が多いです。 `STAR` / `LSTAR` / `CSTAR` "
"(syscall のエントリポイント) などはセットするだけして読むことはないので、当然"
"といえば当然ですね。"
msgstr ""
"RDMSR よりは対応する必要のある MSR が多いです。 `STAR` / `LSTAR` / `CSTAR` "
"(syscall のエントリポイント) などはセットするだけして読むことはないので、当然"
"といえば当然ですね。"

#: src/vmm/msr.md:446
msgid ""
"本チャプターでは、MSR Area を設定することで VM Entry / VM Exit 時にゲスト・ホ"
"ストの MSR を適切に保存・復帰するように設定しました。 これによって、ホストと"
"ゲスト間の MSR 空間が分離されます。 また、RDMSR / WRMSR ハンドラを実装して "
"VMCS または MSR Area に登録された値を読み書きするようにしました。 これによっ"
"て MSR の仮想化ができたことになります。"
msgstr ""
"本チャプターでは、MSR Area を設定することで VM Entry / VM Exit 時にゲスト・ホ"
"ストの MSR を適切に保存・復帰するように設定しました。 これによって、ホストと"
"ゲスト間の MSR 空間が分離されます。 また、RDMSR / WRMSR ハンドラを実装して "
"VMCS または MSR Area に登録された値を読み書きするようにしました。 これによっ"
"て MSR の仮想化ができたことになります。"

#: src/vmm/msr.md:451
msgid "もはや恒例になってきましたが、最後にゲストを動かしてみましょう:"
msgstr "もはや恒例になってきましたが、最後にゲストを動かしてみましょう:"

#: src/vmm/msr.md:505
msgid ""
"なんと！ ついにゲストからのログが出力されました！ まだカーネルの本体がブート"
"する前ですが、[Linux Boot Protocol のチャプター](./linux_boot.md) でコマンド"
"ラインに `earlyprintk=serial` を出力したのでログが出力されています[^log]。 "
"`'nokaslr' on cmdline` と出力されているように、`BootParams` で指定したコマン"
"ドラインもちゃんとゲストに渡っていることが分かりますね。"
msgstr ""
"なんと！ ついにゲストからのログが出力されました！ まだカーネルの本体がブート"
"する前ですが、[Linux Boot Protocol のチャプター](./linux_boot.md) でコマンド"
"ラインに `earlyprintk=serial` を出力したのでログが出力されています[^log]。 "
"`'nokaslr' on cmdline` と出力されているように、`BootParams` で指定したコマン"
"ドラインもちゃんとゲストに渡っていることが分かりますね。"

#: src/vmm/msr.md:510
msgid ""
"`Decompressing Linux...` は [extract_kernel()](https://github.com/torvalds/"
"linux/blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/arch/x86/boot/compressed/"
"misc.c#L405) からの出力です。 この関数は `head_64.S` の [relocated()]"
"(https://github.com/torvalds/linux/"
"blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/arch/x86/boot/compressed/"
"head_64.S#L477) から呼ばれます。 圧縮されたカーネルを展開してメモリに展開し、"
"制御を移そうとする関数です。 ここで展開されたカーネルは `BootParams` で指定し"
"たアドレス (`0x10_0000`) に展開されます。 `extract_kernel()` の直後にこのアド"
"レスにジャンプし、`compress/head_64.S` ではない方の `head_64.S` の "
"[startup_64()](https://github.com/torvalds/linux/"
"blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/arch/x86/kernel/head_64.S#L38) "
"に制御が移ります。"
msgstr ""
"`Decompressing Linux...` は [extract_kernel()](https://github.com/torvalds/"
"linux/blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/arch/x86/boot/compressed/"
"misc.c#L405) からの出力です。 この関数は `head_64.S` の [relocated()]"
"(https://github.com/torvalds/linux/"
"blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/arch/x86/boot/compressed/"
"head_64.S#L477) から呼ばれます。 圧縮されたカーネルを展開してメモリに展開し、"
"制御を移そうとする関数です。 ここで展開されたカーネルは `BootParams` で指定し"
"たアドレス (`0x10_0000`) に展開されます。 `extract_kernel()` の直後にこのアド"
"レスにジャンプし、`compress/head_64.S` ではない方の `head_64.S` の "
"[startup_64()](https://github.com/torvalds/linux/"
"blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/arch/x86/kernel/head_64.S#L38) "
"に制御が移ります。"

#: src/vmm/msr.md:516
msgid ""
"最終的に発生している Triple Fault は、CR4 の PSE ビットをセットしようとしてい"
"る部分です:"
msgstr ""
"最終的に発生している Triple Fault は、CR4 の PSE ビットをセットしようとしてい"
"る部分です:"

#: src/vmm/msr.md:530
msgid ""
"この `MOV to CR4` は、`CR4.VMXE` ビットをアンセットしてしまいます。 **VM "
"Exit を引き起こさないような `MOV to CR4` が `IA32_VMX_CR4_FIXED0` または "
"`IA32_VMX_CR4_FIXED1` で規定される CR4 のルールに従っていない場合、ゲスト側"
"で `#GP` が発生します** (VM Exit ではありません)。[^cr4-gp]。 ゲストにはまだ"
"割り込みハンドラがないため、`#GP` が発生するとそのまま Triple Faults になって"
"しまうようです。 ということで、次回はゲストによる CR アクセスを適切にハンドリ"
"ングするようにしましょう。"
msgstr ""
"この `MOV to CR4` は、`CR4.VMXE` ビットをアンセットしてしまいます。 **VM "
"Exit を引き起こさないような `MOV to CR4` が `IA32_VMX_CR4_FIXED0` または "
"`IA32_VMX_CR4_FIXED1` で規定される CR4 のルールに従っていない場合、ゲスト側"
"で `#GP` が発生します** (VM Exit ではありません)。[^cr4-gp]。 ゲストにはまだ"
"割り込みハンドラがないため、`#GP` が発生するとそのまま Triple Faults になって"
"しまうようです。 ということで、次回はゲストによる CR アクセスを適切にハンドリ"
"ングするようにしましょう。"

#: src/vmm/msr.md:535
msgid ""
"まだシリアルコンソールの仮想化はしていないため、ゲストは直接シリアルを触りに"
"いっています。今はまだ許してあげることにしましょう。"
msgstr ""
"まだシリアルコンソールの仮想化はしていないため、ゲストは直接シリアルを触りに"
"いっています。今はまだ許してあげることにしましょう。"

#: src/vmm/msr.md:536
msgid ""
"_SDM Vol.3C 26.3 CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION_"
msgstr ""
"_SDM Vol.3C 26.3 CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION_"

#: src/vmm/cr.md:1
msgid "Control Registers の仮想化"
msgstr "Control Registers の仮想化"

#: src/vmm/cr.md:3
msgid ""
"本チャプターでは Control Registers へのアクセスを仮想化します。 Control "
"Registers は CPU の挙動を制御するための重要なレジスタであり、ゲストを動かす上"
"で適切に扱う必要があります。 本チャプターでは CR からの読み込みと CR への書き"
"込みの両方を仮想化し、他の VMCS フィールドとの整合性を保ちながらハンドリング"
"していきます。"
msgstr ""
"本チャプターでは Control Registers へのアクセスを仮想化します。 Control "
"Registers は CPU の挙動を制御するための重要なレジスタであり、ゲストを動かす上"
"で適切に扱う必要があります。 本チャプターでは CR からの読み込みと CR への書き"
"込みの両方を仮想化し、他の VMCS フィールドとの整合性を保ちながらハンドリング"
"していきます。"

#: src/vmm/cr.md:9
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-cr`](https://"
#| "github.com/smallkirby/ymir/tree/whiz-vmm-cr) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-vmm-cr`](https://github.com/smallkirby/"
"ymir/tree/whiz-vmm-cr) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-cr`](https://github."
"com/smallkirby/ymir/tree/whiz-vmm-cr) ブランチにあります。"

#: src/vmm/cr.md:13
msgid "[CR Read Shadows / Masks](#cr-read-shadows--masks)"
msgstr "[CR Read Shadows / Masks](#cr-read-shadows--masks)"

#: src/vmm/cr.md:14
msgid "[Exit Qualification](#exit-qualification)"
msgstr "[Exit Qualification](#exit-qualification)"

#: src/vmm/cr.md:15
msgid "[MOV from CR ハンドラ](#mov-from-cr-ハンドラ)"
msgstr "[MOV from CR ハンドラ](#mov-from-cr-ハンドラ)"

#: src/vmm/cr.md:16
msgid "[MOV from CR0 / CR4](#mov-from-cr0--cr4)"
msgstr "[MOV from CR0 / CR4](#mov-from-cr0--cr4)"

#: src/vmm/cr.md:17
msgid "[MOV from CR3](#mov-from-cr3)"
msgstr "[MOV from CR3](#mov-from-cr3)"

#: src/vmm/cr.md:18
msgid "[MOV to CR ハンドラ](#mov-to-cr-ハンドラ)"
msgstr "[MOV to CR ハンドラ](#mov-to-cr-ハンドラ)"

#: src/vmm/cr.md:19
msgid "[MOV to CR0 / CR4](#mov-to-cr0--cr4)"
msgstr "[MOV to CR0 / CR4](#mov-to-cr0--cr4)"

#: src/vmm/cr.md:20
msgid "[パススルー](#パススルー)"
msgstr "[パススルー](#パススルー)"

#: src/vmm/cr.md:21
msgid "[IA-32e Mode](#ia-32e-mode)"
msgstr "[IA-32e Mode](#ia-32e-mode)"

#: src/vmm/cr.md:22
msgid "[MOV to CR3](#mov-to-cr3)"
msgstr "[MOV to CR3](#mov-to-cr3)"

#: src/vmm/cr.md:23
msgid "[PCID](#pcid)"
msgstr "[PCID](#pcid)"

#: src/vmm/cr.md:24
msgid "[Combined Mappings](#combined-mappings)"
msgstr "[Combined Mappings](#combined-mappings)"

#: src/vmm/cr.md:25
msgid "[INVPCID の有効化](#invpcid-の有効化)"
msgstr "[INVPCID の有効化](#invpcid-の有効化)"

#: src/vmm/cr.md:28
msgid "CR Read Shadows / Masks"
msgstr "CR Read Shadows / Masks"

#: src/vmm/cr.md:30
msgid ""
"CR0 と CR4 に対するアクセスが VM Exit を発生させるかどうかは VMCS VM-"
"Execution Controls の設定に依存します。 CR の特定のビットがゲストとホストのど"
"ちらの支配下にあるかどうかを決定するのが **Guest/Host Masks** です。 Guest/"
"Host Masks は CR レジスタのサイズと同じサイズを持つビットフィールドであり、 "
"Intel 64 アーキテクチャでは 64bit です。 Guest/Host Masks のあるビットが `1` "
"であるとき、CR の対応するビットは **\"ホストが所有\"** します。 逆に Masks の"
"ビットが `0` であるとき、CR の対応するビットは **\"ゲストが所有\"** します。"
msgstr ""
"CR0 と CR4 に対するアクセスが VM Exit を発生させるかどうかは VMCS VM-"
"Execution Controls の設定に依存します。 CR の特定のビットがゲストとホストのど"
"ちらの支配下にあるかどうかを決定するのが **Guest/Host Masks** です。 Guest/"
"Host Masks は CR レジスタのサイズと同じサイズを持つビットフィールドであり、 "
"Intel 64 アーキテクチャでは 64bit です。 Guest/Host Masks のあるビットが `1` "
"であるとき、CR の対応するビットは **\"ホストが所有\"** します。 逆に Masks の"
"ビットが `0` であるとき、CR の対応するビットは **\"ゲストが所有\"** します。"

#: src/vmm/cr.md:37
msgid ""
"ゲストが CR から read をするとき、そのビットがゲストが所有する場合には CR の"
"値が直接 read されます。 同様に、ゲストが CR に write をするとき、そのビット"
"がゲストが所有する場合には CR に直接値が書き込まれます。"
msgstr ""
"ゲストが CR から read をするとき、そのビットがゲストが所有する場合には CR の"
"値が直接 read されます。 同様に、ゲストが CR に write をするとき、そのビット"
"がゲストが所有する場合には CR に直接値が書き込まれます。"

#: src/vmm/cr.md:40
msgid ""
"ホストが所有するビットへのアクセスは、**Guest/Host Read Shadows** によって制"
"御されます。 これも Intel 64 では 64bit のビットフィールドであり、CR の各ビッ"
"トに対応します。 ゲストが CR から read をするとき、そのビットがホストが所有す"
"る場合には、Read Shadows の対応するビットが read されます。 ゲストが CR に "
"write をするとき、**ホストが所有するビットに対して Read Shadows の対応する"
"ビットと異なる値を書き込もうとすると VM Exit が発生** します。"
msgstr ""
"ホストが所有するビットへのアクセスは、**Guest/Host Read Shadows** によって制"
"御されます。 これも Intel 64 では 64bit のビットフィールドであり、CR の各ビッ"
"トに対応します。 ゲストが CR から read をするとき、そのビットがホストが所有す"
"る場合には、Read Shadows の対応するビットが read されます。 ゲストが CR に "
"write をするとき、**ホストが所有するビットに対して Read Shadows の対応する"
"ビットと異なる値を書き込もうとすると VM Exit が発生** します。"

#: src/vmm/cr.md:62
msgid ""
"Ymir では Guest/Host Masks のビットを全てセットします。 CR0 と CR4 のビットは"
"全てホストが所有するということです:。"
msgstr ""
"Ymir では Guest/Host Masks のビットを全てセットします。 CR0 と CR4 のビットは"
"全てホストが所有するということです:。"

#: src/vmm/cr.md:75
msgid ""
"先ほどの図から分かるとおり、Masks がセットされているビットに対する read は "
"Read Shadows の値が返されます。 今回は Masks の全てのビットをセットしているた"
"め、CR からの read は常に Read Shadows の値を返します。 よって、**Read "
"Shadows は CR の実際の値に追従するようにする必要があります**。 追従するロジッ"
"クはのちほど VM Exit ハンドラで書くとして、とりあえず初期状態には CR0 / CR4 "
"の値をそのまま代入しておきます:"
msgstr ""
"先ほどの図から分かるとおり、Masks がセットされているビットに対する read は "
"Read Shadows の値が返されます。 今回は Masks の全てのビットをセットしているた"
"め、CR からの read は常に Read Shadows の値を返します。 よって、**Read "
"Shadows は CR の実際の値に追従するようにする必要があります**。 追従するロジッ"
"クはのちほど VM Exit ハンドラで書くとして、とりあえず初期状態には CR0 / CR4 "
"の値をそのまま代入しておきます:"

#: src/vmm/cr.md:90
msgid "Exit Qualification"
msgstr "Exit Qualification"

#: src/vmm/cr.md:92
msgid ""
"Host/Guest Masks が全てセットされているため、ゲストが Read Shadows と異なる値"
"を CR0/CR4 に書き込もうとすると VM Exit が発生します。 この際、どのレジスタに"
"対してどのような値を書き込もうとしたのかという追加情報が VMCS **Exit "
"Qualification** に格納されます。 Exit Qualification は全ての VM Exit に対して"
"提供されるわけではなく、CR Access を含む一部の VM Exit に対してのみ提供されま"
"す。 Qualification が提供される他の Exit Reasonには、I/O Access や EPT "
"Violation などがあります。"
msgstr ""
"Host/Guest Masks が全てセットされているため、ゲストが Read Shadows と異なる値"
"を CR0/CR4 に書き込もうとすると VM Exit が発生します。 この際、どのレジスタに"
"対してどのような値を書き込もうとしたのかという追加情報が VMCS **Exit "
"Qualification** に格納されます。 Exit Qualification は全ての VM Exit に対して"
"提供されるわけではなく、CR Access を含む一部の VM Exit に対してのみ提供されま"
"す。 Qualification が提供される他の Exit Reasonには、I/O Access や EPT "
"Violation などがあります。"

#: src/vmm/cr.md:97
msgid ""
"Exit Qualification は 64bit のデータであり、その意味は Exit Reason によって異"
"なります。 CR Access に対する Exit Qualification は以下のフォーマットを持ちま"
"す:"
msgstr ""
"Exit Qualification は 64bit のデータであり、その意味は Exit Reason によって異"
"なります。 CR Access に対する Exit Qualification は以下のフォーマットを持ちま"
"す:"

#: src/vmm/cr.md:100
msgid ""
"![Exit Qualification for Control-Register Accesses](../assets/sdm/qual_cr."
"png) _Exit Qualification for Control-Register Accesses. SDM Vol.3C Table "
"28-3._"
msgstr ""
"![Exit Qualification for Control-Register Accesses](../assets/sdm/qual_cr."
"png) _Exit Qualification for Control-Register Accesses. SDM Vol.3C Table "
"28-3._"

#: src/vmm/cr.md:103
msgid ""
"Exit Qualification は CR Access 以外にも今後追加していく予定のため、`qual` 空"
"間を用意してそこに追加していくことにします。 第1号として、CR Access 用の "
"Exit Qualification を追加します:"
msgstr ""
"Exit Qualification は CR Access 以外にも今後追加していく予定のため、`qual` 空"
"間を用意してそこに追加していくことにします。 第1号として、CR Access 用の "
"Exit Qualification を追加します:"

#: src/vmm/cr.md:151
msgid ""
"CR Access による VM Exit は [MOV](https://www.felixcloutier.com/x86/mov) "
"(from/to) 命令以外にも2通りの方法で発生します:"
msgstr ""
"CR Access による VM Exit は [MOV](https://www.felixcloutier.com/x86/mov) "
"(from/to) 命令以外にも2通りの方法で発生します:"

#: src/vmm/cr.md:153
msgid ""
"[CLTS](https://www.felixcloutier.com/x86/clts): CR0 の TS フラグをクリアする"
msgstr ""
"[CLTS](https://www.felixcloutier.com/x86/clts): CR0 の TS フラグをクリアする"

#: src/vmm/cr.md:154
msgid ""
"[LMSW](https://www.felixcloutier.com/x86/lmsw): CR0 の `[15:0]` にロードする"
msgstr ""
"[LMSW](https://www.felixcloutier.com/x86/lmsw): CR0 の `[15:0]` にロードする"

#: src/vmm/cr.md:156
msgid ""
"しかしながら、Linux ではブートまでにこれらの命令が使われることはありません。 "
"よって、Ymir でもこの2つの命令による VM Exit は非サポートとします。 対応自体"
"は簡単なため、興味がある人は実装してみてください。"
msgstr ""
"しかしながら、Linux ではブートまでにこれらの命令が使われることはありません。 "
"よって、Ymir でもこの2つの命令による VM Exit は非サポートとします。 対応自体"
"は簡単なため、興味がある人は実装してみてください。"

#: src/vmm/cr.md:160
msgid ""
"Exit Qualification を取得するための関数も用意しておきましょう。 Exit "
"Qualification は Exit Reason によってその中身が異なるため、どの型として取得す"
"るのかは呼び出し側で決定します:"
msgstr ""
"Exit Qualification を取得するための関数も用意しておきましょう。 Exit "
"Qualification は Exit Reason によってその中身が異なるため、どの型として取得す"
"るのかは呼び出し側で決定します:"

#: src/vmm/cr.md:170
msgid "MOV from CR ハンドラ"
msgstr "MOV from CR ハンドラ"

#: src/vmm/cr.md:172
msgid ""
"`handleExit()` に CR アクセス用のハンドラを追加します。 Exit Reason としては "
"MOV to と MOV from のどちらかによらず1つしか用意されていません。 MOV to か "
"from かは Exit Qualification を取得して判断する必要があります:"
msgstr ""
"`handleExit()` に CR アクセス用のハンドラを追加します。 Exit Reason としては "
"MOV to と MOV from のどちらかによらず1つしか用意されていません。 MOV to か "
"from かは Exit Qualification を取得して判断する必要があります:"

#: src/vmm/cr.md:190
msgid ""
"CR Access を原因とする VM Exit が発生したら、先ほどの関数を使って Exit "
"Qualification を取得し、専用のハンドラ `cr.handleAccessCr()` に渡します。 こ"
"の関数は `cr.zig` に実装していくことにします:"
msgstr ""
"CR Access を原因とする VM Exit が発生したら、先ほどの関数を使って Exit "
"Qualification を取得し、専用のハンドラ `cr.handleAccessCr()` に渡します。 こ"
"の関数は `cr.zig` に実装していくことにします:"

#: src/vmm/cr.md:207
msgid ""
"Exit Qualification の `.access_type` から MOV to なのか MOV from なのかを判断"
"し、それぞれの処理を実装していきます。 どちらでもない、つまり CLTS や LMSW に"
"よる VM Exit は非サポートとしているため、エラーログを出力してアボートします。"
msgstr ""
"Exit Qualification の `.access_type` から MOV to なのか MOV from なのかを判断"
"し、それぞれの処理を実装していきます。 どちらでもない、つまり CLTS や LMSW に"
"よる VM Exit は非サポートとしているため、エラーログを出力してアボートします。"

#: src/vmm/cr.md:210
msgid "MOV from CR0 / CR4"
msgstr "MOV from CR0 / CR4"

#: src/vmm/cr.md:212
msgid ""
"**CR0 と CR4 に対する read アクセスは、VM Exit を起こすことがありません**。 "
"Masks を全てセットしているため、CR0 と CR4 への read は常に Read Shadows の値"
"を返します。"
msgstr ""
"**CR0 と CR4 に対する read アクセスは、VM Exit を起こすことがありません**。 "
"Masks を全てセットしているため、CR0 と CR4 への read は常に Read Shadows の値"
"を返します。"

#: src/vmm/cr.md:215
msgid "MOV from CR3"
msgstr "MOV from CR3"

#: src/vmm/cr.md:217
msgid ""
"CR3 からの read は、実際の CR3 の値をそのままゲストに露出することにします。 "
"CR の値をゲストにそのままパススルーするためのヘルパー関数を用意します:"
msgstr ""
"CR3 からの read は、実際の CR3 の値をそのままゲストに露出することにします。 "
"CR の値をゲストにそのままパススルーするためのヘルパー関数を用意します:"

#: src/vmm/cr.md:231
msgid ""
"Exit Qualification の `.index` には read 対象の CR の番号が入っています。 CR "
"Read で VM Exit を発生させるのは CR3 だけであるため、`.index` が `3` の場合だ"
"けをハンドルします。 CR3 は VMCS Guest-State に入っているため、その値を "
"`setValue()` でゲストレジスタにセットすることにします。 `setValue()` は Exit "
"Qualification で指定されるゲストのレジスタに対して値をセットするヘルパー関数"
"です。 実装については以下の折りたたみを展開して確認してください:"
msgstr ""
"Exit Qualification の `.index` には read 対象の CR の番号が入っています。 CR "
"Read で VM Exit を発生させるのは CR3 だけであるため、`.index` が `3` の場合だ"
"けをハンドルします。 CR3 は VMCS Guest-State に入っているため、その値を "
"`setValue()` でゲストレジスタにセットすることにします。 `setValue()` は Exit "
"Qualification で指定されるゲストのレジスタに対して値をセットするヘルパー関数"
"です。 実装については以下の折りたたみを展開して確認してください:"

#: src/vmm/cr.md:289
msgid "`handleAccessCr()` から read 用のハンドラを呼び出します:"
msgstr "`handleAccessCr()` から read 用のハンドラを呼び出します:"

#: src/vmm/cr.md:299
msgid "MOV to CR ハンドラ"
msgstr "MOV to CR ハンドラ"

#: src/vmm/cr.md:301
msgid "MOV to CR0 / CR4"
msgstr "MOV to CR0 / CR4"

#: src/vmm/cr.md:303
msgid "パススルー"
msgstr "パススルー"

#: src/vmm/cr.md:305
msgid ""
"CR0 と CR4 に対する write は、「基本的に」そのまま CR に値を書き込みます。 "
"「基本的に」と書いたのは、**CR0 と CR4 の特定のビットは VMX Operation におい"
"て許される値が決まっている** ためです。 [VMX Root Operation のチャプター](./"
"vmx_root.md#cr-レジスタの設定) でホストの CR0/CR4 の値を設定したことを覚えて"
"いるでしょうか。 その際、`IA32_VMX_CR{0,4}_FIXED0` と `IA32_VMX_CR{0,4}"
"_FIXED1` の値を使って CR0/CR4 の値を調整しました。 FIXED0 で `1` になっている"
"ビットは、常に `1` にする必要があります。 逆に FIXED1 で `0` になっているビッ"
"トは、常に `0` にする必要があります。 これはゲストの CR においても同様です。 "
"ゲストが CR0/CR4 に書き込む際には、これらの MSR の値を確認して書き込む値を調"
"整する必要があります。 CR の値をパススルー + 調整するためのヘルパー関数を用意"
"します:"
msgstr ""
"CR0 と CR4 に対する write は、「基本的に」そのまま CR に値を書き込みます。 "
"「基本的に」と書いたのは、**CR0 と CR4 の特定のビットは VMX Operation におい"
"て許される値が決まっている** ためです。 [VMX Root Operation のチャプター](./"
"vmx_root.md#cr-レジスタの設定) でホストの CR0/CR4 の値を設定したことを覚えて"
"いるでしょうか。 その際、`IA32_VMX_CR{0,4}_FIXED0` と `IA32_VMX_CR{0,4}"
"_FIXED1` の値を使って CR0/CR4 の値を調整しました。 FIXED0 で `1` になっている"
"ビットは、常に `1` にする必要があります。 逆に FIXED1 で `0` になっているビッ"
"トは、常に `0` にする必要があります。 これはゲストの CR においても同様です。 "
"ゲストが CR0/CR4 に書き込む際には、これらの MSR の値を確認して書き込む値を調"
"整する必要があります。 CR の値をパススルー + 調整するためのヘルパー関数を用意"
"します:"

#: src/vmm/cr.md:333
msgid ""
"`adjustCr0()` と `adjustCr4()` はそれぞれ CR0 と CR4 の値を MSR の値に合わせ"
"て調整するヘルパー関数です。 実装は以前と同じなので、忘れた人は以下を展開して"
"確認してください:"
msgstr ""
"`adjustCr0()` と `adjustCr4()` はそれぞれ CR0 と CR4 の値を MSR の値に合わせ"
"て調整するヘルパー関数です。 実装は以前と同じなので、忘れた人は以下を展開して"
"確認してください:"

#: src/vmm/cr.md:366
msgid ""
"Read Shadows に値を書き込んでいるのは、Read Shadows の値は常に実際の CR の値"
"に追従して一致している必要があるためです。 Ymir では Guest/Host Masks が全て"
"セットされているため、CR からの read はすなわち Read Shadows の値と同義で"
"す。 書き込まれた値がちゃんとゲストに見えるように、Read Shadows を更新してあ"
"げる必要があります。"
msgstr ""
"Read Shadows に値を書き込んでいるのは、Read Shadows の値は常に実際の CR の値"
"に追従して一致している必要があるためです。 Ymir では Guest/Host Masks が全て"
"セットされているため、CR からの read はすなわち Read Shadows の値と同義で"
"す。 書き込まれた値がちゃんとゲストに見えるように、Read Shadows を更新してあ"
"げる必要があります。"

#: src/vmm/cr.md:370
msgid "IA-32e Mode"
msgstr "IA-32e Mode"

#: src/vmm/cr.md:372
msgid ""
"CR0/4 の更新にはもう1つ気をつけることがあります。 それは **IA-32e Mode** の有"
"効状態です。 IA-32e モードは **Long Mode** (64bit mode) と **Compatible "
"Mode** (32bit mode) の2つの状態を持ちます。 IA-32e モードは、VMX Operation "
"\"ではないとき\" 以下の条件を全て満たす場合に有効になります (実際にはこれらを"
"順におこなう必要があります)[^ia32e]:"
msgstr ""
"CR0/4 の更新にはもう1つ気をつけることがあります。 それは **IA-32e Mode** の有"
"効状態です。 IA-32e モードは **Long Mode** (64bit mode) と **Compatible "
"Mode** (32bit mode) の2つの状態を持ちます。 IA-32e モードは、VMX Operation "
"\"ではないとき\" 以下の条件を全て満たす場合に有効になります (実際にはこれらを"
"順におこなう必要があります)[^ia32e]:"

#: src/vmm/cr.md:378
msgid "`CR4.PAE` が `1`"
msgstr "`CR4.PAE` が `1`"

#: src/vmm/cr.md:379
msgid "`IA32_EFER.LME` が `1`"
msgstr "`IA32_EFER.LME` が `1`"

#: src/vmm/cr.md:380
msgid "`CR0.PG` が `1`"
msgstr "`CR0.PG` が `1`"

#: src/vmm/cr.md:381
msgid "`IA32_EFER.LMA` が `1`"
msgstr "`IA32_EFER.LMA` が `1`"

#: src/vmm/cr.md:383
msgid ""
"しかしながら、**VMX Non-Root Operation においてはゲストが IA-32e モードかどう"
"かは VM Entry 時の VM-Entry Controls の設定 (`.ia32e_mode_guest`) によって決"
"まります** (VMX Non-Root Operation の最中に変更することはできます)。 逆に言う"
"と、上に挙げたレジスタの設定は VM-Entry Controls の設定と一致している必要があ"
"ります。 **両者の間に不整合がある場合、VM Entry は `Invalid Guest` として失敗"
"してしまいます**。"
msgstr ""
"しかしながら、**VMX Non-Root Operation においてはゲストが IA-32e モードかどう"
"かは VM Entry 時の VM-Entry Controls の設定 (`.ia32e_mode_guest`) によって決"
"まります** (VMX Non-Root Operation の最中に変更することはできます)。 逆に言う"
"と、上に挙げたレジスタの設定は VM-Entry Controls の設定と一致している必要があ"
"ります。 **両者の間に不整合がある場合、VM Entry は `Invalid Guest` として失敗"
"してしまいます**。"

#: src/vmm/cr.md:388
msgid ""
"CR0/4 への write の際には、CR0/CR4 の値をもとに IA-32e モードが有効かどうかを"
"判断し、 EFER の値と VM-Entry Controls の設定を更新する必要があります:"
msgstr ""
"CR0/4 への write の際には、CR0/CR4 の値をもとに IA-32e モードが有効かどうかを"
"判断し、 EFER の値と VM-Entry Controls の設定を更新する必要があります:"

#: src/vmm/cr.md:411
msgid ""
"`handleAccessCr()` において、値のパススルーと IA-32e モードの更新をおこないま"
"す:"
msgstr ""
"`handleAccessCr()` において、値のパススルーと IA-32e モードの更新をおこないま"
"す:"

#: src/vmm/cr.md:429
msgid "MOV to CR3"
msgstr "MOV to CR3"

#: src/vmm/cr.md:431
msgid ""
"CR3 への write も、「基本的には」そのままパススルーして実際の CR3 に値を書き"
"込みます。 ここでの「基本的には」には2つの注意点があります:"
msgstr ""
"CR3 への write も、「基本的には」そのままパススルーして実際の CR3 に値を書き"
"込みます。 ここでの「基本的には」には2つの注意点があります:"

#: src/vmm/cr.md:436
msgid ""
"**PCID: Processor Context ID** は CR3 に対して ID を割り当てることで TLB のエ"
"ントリを区別する機能です。 PCID で区別された TLB エントリは、[INVPCID]"
"(https://www.felixcloutier.com/x86/invpcid) によって特定の PCID を持つエント"
"リだけをフラッシュすることができます。 Ymir では [CPUID によってゲストに見せ"
"る値](./cpuid.md#0x0-basic-cpuid-information) によってゲストに対して PCID を"
"使うことを許可しています。 PCID は `CR4.PCIDE` が `1` のときに有効になりま"
"す。"
msgstr ""
"**PCID: Processor Context ID** は CR3 に対して ID を割り当てることで TLB のエ"
"ントリを区別する機能です。 PCID で区別された TLB エントリは、[INVPCID]"
"(https://www.felixcloutier.com/x86/invpcid) によって特定の PCID を持つエント"
"リだけをフラッシュすることができます。 Ymir では [CPUID によってゲストに見せ"
"る値](./cpuid.md#0x0-basic-cpuid-information) によってゲストに対して PCID を"
"使うことを許可しています。 PCID は `CR4.PCIDE` が `1` のときに有効になりま"
"す。"

#: src/vmm/cr.md:443
msgid ""
"PCID を有効化すると、CR3 の最上位ビット (63-th bit) が特別な意味を持ちます"
"[^cr3sdm]。 PCID が無効な場合、MOV to CR3 は全ての TLB エントリをフラッシュし"
"ます。 PCID が有効な場合、`CR3[63]` が `0` の時には新しい CR3 の PCID を持つ"
"全ての TLB エントリをフラッシュします[^global]。 `CR3[63]` が `1` の場合に"
"は、いかなる TLB エントリもフラッシュしなくなります[^cr3-63]。"
msgstr ""
"PCID を有効化すると、CR3 の最上位ビット (63-th bit) が特別な意味を持ちます"
"[^cr3sdm]。 PCID が無効な場合、MOV to CR3 は全ての TLB エントリをフラッシュし"
"ます。 PCID が有効な場合、`CR3[63]` が `0` の時には新しい CR3 の PCID を持つ"
"全ての TLB エントリをフラッシュします[^global]。 `CR3[63]` が `1` の場合に"
"は、いかなる TLB エントリもフラッシュしなくなります[^cr3-63]。"

#: src/vmm/cr.md:448
msgid ""
"しかしながら、**VMX Operation ではゲストの `CR3[63]` は必ず `0` でなければい"
"けません**。 そうでない場合には VM Entry が `Invalid Guest` として失敗してし"
"まいます。 そもそも VMX Root Operation ではない場合にも、 `CR3[63]` が `1` で"
"あっても実際に CR3 に書き込まれる際は `0` として書き込まれます。 これと同様"
"に、ゲストの `CR3[63]` は必ず `0` でなければいけないというわけだと思います。 "
"というわけで、ゲストが書き込もうとした値の 63-th bit がセットされている場合に"
"はクリアしてからセットしてあげる必要があります:"
msgstr ""
"しかしながら、**VMX Operation ではゲストの `CR3[63]` は必ず `0` でなければい"
"けません**。 そうでない場合には VM Entry が `Invalid Guest` として失敗してし"
"まいます。 そもそも VMX Root Operation ではない場合にも、 `CR3[63]` が `1` で"
"あっても実際に CR3 に書き込まれる際は `0` として書き込まれます。 これと同様"
"に、ゲストの `CR3[63]` は必ず `0` でなければいけないというわけだと思います。 "
"というわけで、ゲストが書き込もうとした値の 63-th bit がセットされている場合に"
"はクリアしてからセットしてあげる必要があります:"

#: src/vmm/cr.md:471
msgid "Combined Mappings"
msgstr "Combined Mappings"

#: src/vmm/cr.md:473
msgid ""
"[EPT を導入した際](./ept.md#キャッシュされる情報) に、VMX Operation で TLB に"
"キャッシュされる情報を3つ挙げたことを覚えているでしょうか？ 念の為以下に EPT "
"を有効化した場合に TLB にキャッシュされる情報を再掲します:"
msgstr ""
"[EPT を導入した際](./ept.md#キャッシュされる情報) に、VMX Operation で TLB に"
"キャッシュされる情報を3つ挙げたことを覚えているでしょうか？ 念の為以下に EPT "
"を有効化した場合に TLB にキャッシュされる情報を再掲します:"

#: src/vmm/cr.md:480
msgid ""
"各 Mappings はゲストのメモリアクセスが物理アドレスと仮想アドレスのどちらを利"
"用しているかに応じて、以下のように利用されます:"
msgstr ""
"各 Mappings はゲストのメモリアクセスが物理アドレスと仮想アドレスのどちらを利"
"用しているかに応じて、以下のように利用されます:"

#: src/vmm/cr.md:482
msgid ""
"仮想アドレスアクセス: VPID と PCID と EPTRTA でタグ付けされた Combined "
"Mappings が利用される。"
msgstr ""
"仮想アドレスアクセス: VPID と PCID と EPTRTA でタグ付けされた Combined "
"Mappings が利用される。"

#: src/vmm/cr.md:485
msgid ""
"このうち、MOV to CR3 によって Linear Mappings はフラッシュされます。 しかしな"
"がら、**Guest-Physical Mappings と Combined Mappings はフラッシュされません"
"**。 この2つはどちらも HPA へと変換するために利用される Mappings であり、ゲス"
"トの MOV to CR3 では無効化されないという論理なのでしょうか？ 筆者も理由はよく"
"分かりませんが、まぁフラッシュされないものは仕方がありません。 このまま放って"
"おくと TLB にキャッシュされた古い Combined Mappingsを使って GVA/GPA to HPA 変"
"換が行われてしまいます。 GVA to GPA 変換の結果が MOV to CR3 によって変わって"
"しまったため、**GVA to HPA 変換に使われる Combined Mappings も無効化してあげ"
"る必要があります**[^guest-phys]。"
msgstr ""
"このうち、MOV to CR3 によって Linear Mappings はフラッシュされます。 しかしな"
"がら、**Guest-Physical Mappings と Combined Mappings はフラッシュされません"
"**。 この2つはどちらも HPA へと変換するために利用される Mappings であり、ゲス"
"トの MOV to CR3 では無効化されないという論理なのでしょうか？ 筆者も理由はよく"
"分かりませんが、まぁフラッシュされないものは仕方がありません。 このまま放って"
"おくと TLB にキャッシュされた古い Combined Mappingsを使って GVA/GPA to HPA 変"
"換が行われてしまいます。 GVA to GPA 変換の結果が MOV to CR3 によって変わって"
"しまったため、**GVA to HPA 変換に使われる Combined Mappings も無効化してあげ"
"る必要があります**[^guest-phys]。"

#: src/vmm/cr.md:492
msgid ""
"この Mappings を無効化するにはいくつかの方法があります。 1つ目が [INVEPT]"
"(https://www.felixcloutier.com/x86/invept) 命令を使う方法です。 INVEPT は指定"
"した EPTP に紐づく EPT エントリをフラッシュします。 ゲストの EPTP を指定する"
"ことで、ゲストに紐づく全ての Mappings をフラッシュすることができます。 しかし"
"ながら、フラッシュする必要のない Guest-Physical Mappings もフラッシュされてし"
"まうというデメリットがあります。 2つ目が [INVVPID](https://www.felixcloutier."
"com/x86/invvpid) 命令を使う方法です。 これは vCPU に紐づく VPID を指定するこ"
"とで、その VPID を持つ TLB エントリをフラッシュします。 INVVPID は INVEPT と"
"は異なり、Combined Mappings だけをフラッシュし、Guest-Physical Mappings はフ"
"ラッシュしません[^invvpid]。 今回は Combined Mappings だけをフラッシュしたい"
"ため、INVVPID を使うことにします。"
msgstr ""
"この Mappings を無効化するにはいくつかの方法があります。 1つ目が [INVEPT]"
"(https://www.felixcloutier.com/x86/invept) 命令を使う方法です。 INVEPT は指定"
"した EPTP に紐づく EPT エントリをフラッシュします。 ゲストの EPTP を指定する"
"ことで、ゲストに紐づく全ての Mappings をフラッシュすることができます。 しかし"
"ながら、フラッシュする必要のない Guest-Physical Mappings もフラッシュされてし"
"まうというデメリットがあります。 2つ目が [INVVPID](https://www.felixcloutier."
"com/x86/invvpid) 命令を使う方法です。 これは vCPU に紐づく VPID を指定するこ"
"とで、その VPID を持つ TLB エントリをフラッシュします。 INVVPID は INVEPT と"
"は異なり、Combined Mappings だけをフラッシュし、Guest-Physical Mappings はフ"
"ラッシュしません[^invvpid]。 今回は Combined Mappings だけをフラッシュしたい"
"ため、INVVPID を使うことにします。"

#: src/vmm/cr.md:502
msgid ""
"INVVPID 命令には4つのタイプがあり、それぞれフラッシュする対象範囲が異なりま"
"す。 今回は、指定した VPID に紐づく全ての Combined Mappings をフラッシュする "
"Single Context タイプを使います:"
msgstr ""
"INVVPID 命令には4つのタイプがあり、それぞれフラッシュする対象範囲が異なりま"
"す。 今回は、指定した VPID に紐づく全ての Combined Mappings をフラッシュする "
"Single Context タイプを使います:"

#: src/vmm/cr.md:530
msgid ""
"MOV to CR3 の最後に、INVVPID を使って Combined Mappings をフラッシュします:"
msgstr ""
"MOV to CR3 の最後に、INVVPID を使って Combined Mappings をフラッシュします:"

#: src/vmm/cr.md:546
msgid "INVPCID の有効化"
msgstr "INVPCID の有効化"

#: src/vmm/cr.md:548
msgid ""
"以上で Control Registers へのアクセスに対するハンドリングが完了しました。 さ"
"て、Linux はどこまでブートするようになったでしょうか。 ゲストを実行してみま"
"しょう:"
msgstr ""
"以上で Control Registers へのアクセスに対するハンドリングが完了しました。 さ"
"て、Linux はどこまでブートするようになったでしょうか。 ゲストを実行してみま"
"しょう:"

#: src/vmm/cr.md:606
msgid ""
"Linux がブートし始めています！ やった〜。 `Linux version...` 以降のログは、展"
"開されたカーネルのログです。 ブートログから分かることがいくつかありますね:"
msgstr ""
"Linux がブートし始めています！ やった〜。 `Linux version...` 以降のログは、展"
"開されたカーネルのログです。 ブートログから分かることがいくつかありますね:"

#: src/vmm/cr.md:611
msgid "`vendo_id` が `YmirYmirYmir` となっている。これは CPUID で指定した値。"
msgstr "`vendo_id` が `YmirYmirYmir` となっている。これは CPUID で指定した値。"

#: src/vmm/cr.md:612
msgid ""
"`Command line` に `BootParams` で指定した文字列がそのまま表示されている。"
msgstr ""
"`Command line` に `BootParams` で指定した文字列がそのまま表示されている。"

#: src/vmm/cr.md:613
msgid ""
"`BIOS-e820` が表示されている。これは `BootParams` で指定した E820 マップ。"
msgstr ""
"`BIOS-e820` が表示されている。これは `BootParams` で指定した E820 マップ。"

#: src/vmm/cr.md:614
msgid ""
"`X86/PAT: PAT not supported by the CPU.` と表示されている。これも CPUID で指"
"定したから。"
msgstr ""
"`X86/PAT: PAT not supported by the CPU.` と表示されている。これも CPUID で指"
"定したから。"

#: src/vmm/cr.md:616
msgid ""
"今までのチャプターでやってきたことが正しく反映されているというのが一気に分か"
"るログです。"
msgstr ""
"今までのチャプターでやってきたことが正しく反映されているというのが一気に分か"
"るログです。"

#: src/vmm/cr.md:618
msgid ""
"さて、最後は `PANIC: early exception 0x06` で止まってしまいました。 この例外"
"番号は `#UD: Invalid Opcode` です。 サポートされていない命令を実行した場合等"
"に発生します。 この時点でカーネルは正式な割り込みハンドラを用意していないた"
"め、単にパニックしてしまうのだと考えられます。 表示された RIP は `addr2line` "
"で確認すると、[\\_\\_invpcid()](https://github.com/torvalds/linux/"
"blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/arch/x86/include/asm/invpcid."
"h#L16) だということが分かります。"
msgstr ""
"さて、最後は `PANIC: early exception 0x06` で止まってしまいました。 この例外"
"番号は `#UD: Invalid Opcode` です。 サポートされていない命令を実行した場合等"
"に発生します。 この時点でカーネルは正式な割り込みハンドラを用意していないた"
"め、単にパニックしてしまうのだと考えられます。 表示された RIP は `addr2line` "
"で確認すると、[\\_\\_invpcid()](https://github.com/torvalds/linux/"
"blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/arch/x86/include/asm/invpcid."
"h#L16) だということが分かります。"

#: src/vmm/cr.md:624
msgid ""
"さて、VM Execution Controls カテゴリの **Secondary Processor-Based Execution "
"Controls** には、 ゲストによる INVPCID 命令を許可するかどうかを決めるフィール"
"ドがあります。 無効化されている場合には、ゲストが INVPCID を実行すると `#UD: "
"Invalid Opcode` が発生します。 このフィールドを有効化するのを、うっかり忘れて"
"いました。 `setupExecCtrls()` でこのフィールドを有効化してあげることで、この"
"例外は発生しなくなります:"
msgstr ""
"さて、VM Execution Controls カテゴリの **Secondary Processor-Based Execution "
"Controls** には、 ゲストによる INVPCID 命令を許可するかどうかを決めるフィール"
"ドがあります。 無効化されている場合には、ゲストが INVPCID を実行すると `#UD: "
"Invalid Opcode` が発生します。 このフィールドを有効化するのを、うっかり忘れて"
"いました。 `setupExecCtrls()` でこのフィールドを有効化してあげることで、この"
"例外は発生しなくなります:"

#: src/vmm/cr.md:641
msgid ""
"本チャプターでは、Control Registers へのアクセスを仮想化しました。 CR0/CR4 の"
"各ビットは Guest/Host Masks によって所有者が変わりますが、Ymir では全てホスト"
"が所有するように設定しました。 CR Access によって VM Exit が発生した場合に"
"は、実際の値を(微調整しつつ)パススルーすることでゲストに露出しました。 ただ"
"し、CR0/CR4 は IA-32e Mode について、CR3 は Combined Mappings について特別に"
"対応する必要がありました。 ついでですが、ゲストによる INVPCID 命令の実行も許"
"可しました。"
msgstr ""
"本チャプターでは、Control Registers へのアクセスを仮想化しました。 CR0/CR4 の"
"各ビットは Guest/Host Masks によって所有者が変わりますが、Ymir では全てホスト"
"が所有するように設定しました。 CR Access によって VM Exit が発生した場合に"
"は、実際の値を(微調整しつつ)パススルーすることでゲストに露出しました。 ただ"
"し、CR0/CR4 は IA-32e Mode について、CR3 は Combined Mappings について特別に"
"対応する必要がありました。 ついでですが、ゲストによる INVPCID 命令の実行も許"
"可しました。"

#: src/vmm/cr.md:647
msgid ""
"INVPCID を有効化する前よりもさらにブートが進むはずです。 実行してみましょ"
"う。 以降は、Linux のブートログの先頭部分は省略することにします (あんなに見え"
"て嬉しかったログを省略するのは心惜しいですけどね、なにせ長いので):"
msgstr ""
"INVPCID を有効化する前よりもさらにブートが進むはずです。 実行してみましょ"
"う。 以降は、Linux のブートログの先頭部分は省略することにします (あんなに見え"
"て嬉しかったログを省略するのは心惜しいですけどね、なにせ長いので):"

#: src/vmm/cr.md:700
msgid ""
"**めちゃくちゃ進みました**。 まだ仮想化していないシリアルまで勝手に触って初期"
"化しています。勝手な野郎です。"
msgstr ""
"**めちゃくちゃ進みました**。 まだ仮想化していないシリアルまで勝手に触って初期"
"化しています。勝手な野郎です。"

#: src/vmm/cr.md:703
msgid ""
"最終的には EPT Violation で VM Exit しています。 EPT のチャプターで扱いました"
"が、Ymir では EPT Violation が発生しないようにゲストが利用可能な物理メモリの"
"全てをゲストの起動前にマップしています。 それでも EPT Violation が発生してい"
"るということは、ゲストが触ってはいけないメモリに触っているということです。 こ"
"れは、I/O の仮想化をしていないためです。 というわけで、次回は I/O の仮想化を"
"していきましょう。"
msgstr ""
"最終的には EPT Violation で VM Exit しています。 EPT のチャプターで扱いました"
"が、Ymir では EPT Violation が発生しないようにゲストが利用可能な物理メモリの"
"全てをゲストの起動前にマップしています。 それでも EPT Violation が発生してい"
"るということは、ゲストが触ってはいけないメモリに触っているということです。 こ"
"れは、I/O の仮想化をしていないためです。 というわけで、次回は I/O の仮想化を"
"していきましょう。"

#: src/vmm/cr.md:709
msgid "_SDM Vol.3C 10.8.5. Initializing IA-32e Mode_"
msgstr "_SDM Vol.3C 10.8.5. Initializing IA-32e Mode_"

#: src/vmm/cr.md:710
msgid ""
"_SDM Vol.3A 4.10.4.1. Operations that Invalidate TLBs and Paging-Structure "
"Caches_"
msgstr ""
"_SDM Vol.3A 4.10.4.1. Operations that Invalidate TLBs and Paging-Structure "
"Caches_"

#: src/vmm/cr.md:711
msgid "Global Page はフラッシュしません。"
msgstr "Global Page はフラッシュしません。"

#: src/vmm/cr.md:712
msgid ""
"厳密には、いかなる TLB エントリもフラッシュ **\"しない可能性があります"
"\"** 。 MOV to CR3 だけではなく、INVEPT / INVPCID / IVVPID もフラッシュ対象は"
"必ずフラッシュしますが、 フラッシュ対象でないエントリはフラッシュされるかもし"
"れないし、されないかもしれないということが SDM に明記されています。"
msgstr ""
"厳密には、いかなる TLB エントリもフラッシュ **\"しない可能性があります"
"\"** 。 MOV to CR3 だけではなく、INVEPT / INVPCID / IVVPID もフラッシュ対象は"
"必ずフラッシュしますが、 フラッシュ対象でないエントリはフラッシュされるかもし"
"れないし、されないかもしれないということが SDM に明記されています。"

#: src/vmm/cr.md:715
msgid ""
"Guest-Physical Mappings は無効化する必要がありません。 この Mappings は物理ア"
"ドレスアクセスで使われるものであり、ゲストのページングおよびCR3の値に関係しな"
"いため、MOV to CR3 で古くならないからです。"
msgstr ""
"Guest-Physical Mappings は無効化する必要がありません。 この Mappings は物理ア"
"ドレスアクセスで使われるものであり、ゲストのページングおよびCR3の値に関係しな"
"いため、MOV to CR3 で古くならないからです。"

#: src/vmm/cr.md:717
msgid "_SDM Vol.3C 29.4.3.3. Guidelines for Use of the INVVPID Instruction_"
msgstr "_SDM Vol.3C 29.4.3.3. Guidelines for Use of the INVVPID Instruction_"

#: src/vmm/io.md:1
msgid "I/O の仮想化"
msgstr "I/O の仮想化"

#: src/vmm/io.md:3
msgid ""
"[前チャプター](./cr.md) では、ゲストが EPT Violation を起こしてしまいまし"
"た。 これは I/O Access を仮想化していないためにゲストがホストデバイスと直接や"
"り取りをしてしまい、 アクセスしてはいけないアドレスの情報をデバイスから教えら"
"れてしまったためです。 本チャプターでは、ゲストによる I/O Access を仮想化して"
"いきます。 Linux をブートさせるために仮想化するデバイスはそれほど多くなく、そ"
"の他のデバイスは単純にパススルーするか無効化することにします。"
msgstr ""
"[前チャプター](./cr.md) では、ゲストが EPT Violation を起こしてしまいまし"
"た。 これは I/O Access を仮想化していないためにゲストがホストデバイスと直接や"
"り取りをしてしまい、 アクセスしてはいけないアドレスの情報をデバイスから教えら"
"れてしまったためです。 本チャプターでは、ゲストによる I/O Access を仮想化して"
"いきます。 Linux をブートさせるために仮想化するデバイスはそれほど多くなく、そ"
"の他のデバイスは単純にパススルーするか無効化することにします。"

#: src/vmm/io.md:11
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-io`](https://"
#| "github.com/smallkirby/ymir/tree/whiz-vmm-io) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-vmm-io`](https://github.com/smallkirby/"
"ymir/tree/whiz-vmm-io) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-io`](https://github."
"com/smallkirby/ymir/tree/whiz-vmm-io) ブランチにあります。"

#: src/vmm/io.md:15
msgid "[雛形の作成](#雛形の作成)"
msgstr "[雛形の作成](#雛形の作成)"

#: src/vmm/io.md:16
msgid "[PCI (Unsupported)](#pci-unsupported)"
msgstr "[PCI (Unsupported)](#pci-unsupported)"

#: src/vmm/io.md:17
msgid "[シリアル](#シリアル)"
msgstr "[シリアル](#シリアル)"

#: src/vmm/io.md:18
msgid "[PIT](#pit)"
msgstr "[PIT](#pit)"

#: src/vmm/io.md:19
msgid "[PIC](#pic)"
msgstr "[PIC](#pic)"

#: src/vmm/io.md:20
msgid "[その他のポート](#その他のポート)"
msgstr "[その他のポート](#その他のポート)"

#: src/vmm/io.md:24
msgid "雛形の作成"
msgstr "雛形の作成"

#: src/vmm/io.md:26
msgid ""
"まずは I/O Access を起因とする VM Exit のハンドラの雛形を書いてあげます。 I/"
"O Access を起因とする VM Exit は、CR Access と同様に **Exit Qualification** "
"を提供します:"
msgstr ""
"まずは I/O Access を起因とする VM Exit のハンドラの雛形を書いてあげます。 I/"
"O Access を起因とする VM Exit は、CR Access と同様に **Exit Qualification** "
"を提供します:"

#: src/vmm/io.md:29
msgid ""
"![Exit Qualification for I/O Instructions](../assets/sdm/qual_io.png) _Exit "
"Qualification for I/O Instructions. SDM Vol.3C Table 28-5._"
msgstr ""
"![Exit Qualification for I/O Instructions](../assets/sdm/qual_io.png) _Exit "
"Qualification for I/O Instructions. SDM Vol.3C Table 28-5._"

#: src/vmm/io.md:32
msgid ""
"Qualification には、アクセス長・アクセス方向・ポート番号等の情報が格納されて"
"います。 I/O 用の Exit Qualification を表す構造体を定義します:"
msgstr ""
"Qualification には、アクセス長・アクセス方向・ポート番号等の情報が格納されて"
"います。 I/O 用の Exit Qualification を表す構造体を定義します:"

#: src/vmm/io.md:81
msgid ""
"Ymir では [OUT](https://www.felixcloutier.com/x86/out) / [IN](https://www."
"felixcloutier.com/x86/in) 命令だけをサポートすることにします。 Qualification "
"の `.string` で表現されるような [OUTS](https://www.felixcloutier.com/x86/"
"outs:outsb:outsw:outsd) / [INS](https://www.felixcloutier.com/x86/ins:insb:"
"insw:insd) はサポートしません。 ただし、これらの命令は OUT 元と IN 先がレジス"
"タではなくメモリであるということを除いてとりわけ難しいことはないため、興味が"
"ある人は実装してみてください。"
msgstr ""
"Ymir では [OUT](https://www.felixcloutier.com/x86/out) / [IN](https://www."
"felixcloutier.com/x86/in) 命令だけをサポートすることにします。 Qualification "
"の `.string` で表現されるような [OUTS](https://www.felixcloutier.com/x86/"
"outs:outsb:outsw:outsd) / [INS](https://www.felixcloutier.com/x86/ins:insb:"
"insw:insd) はサポートしません。 ただし、これらの命令は OUT 元と IN 先がレジス"
"タではなくメモリであるということを除いてとりわけ難しいことはないため、興味が"
"ある人は実装してみてください。"

#: src/vmm/io.md:85
msgid ""
"続いて、I/O Access のハンドラを定義します。 ハンドラはアクセスの方向ごとに定"
"義し、各ハンドラではアクセスされたポート番号に応じて処理をします。 今のところ"
"はどのポートに対するハンドラも定義していないため、全ポートアクセスを `else` "
"で捕捉し、アボートすることにします:"
msgstr ""
"続いて、I/O Access のハンドラを定義します。 ハンドラはアクセスの方向ごとに定"
"義し、各ハンドラではアクセスされたポート番号に応じて処理をします。 今のところ"
"はどのポートに対するハンドラも定義していないため、全ポートアクセスを `else` "
"で捕捉し、アボートすることにします:"

#: src/vmm/io.md:118
msgid ""
"VM Exit ハンドラである `Vcpu.handleExit()` では、Exit Reason が `.io` であっ"
"た場合に Exit Qualification を取得します。 取得した Qualification を先ほどの"
"ハンドラに渡せば、雛形の完成です:"
msgstr ""
"VM Exit ハンドラである `Vcpu.handleExit()` では、Exit Reason が `.io` であっ"
"た場合に Exit Qualification を取得します。 取得した Qualification を先ほどの"
"ハンドラに渡せば、雛形の完成です:"

#: src/vmm/io.md:135
msgid ""
"I/O Access が VM Exit を発生させるようにするためには、VMCS Execution "
"Controls カテゴリの **Pin-Based VM-Execution Controls** にある `."
"unconditional_io` というフィールドをセットする必要があります:"
msgstr ""
"I/O Access が VM Exit を発生させるようにするためには、VMCS Execution "
"Controls カテゴリの **Pin-Based VM-Execution Controls** にある `."
"unconditional_io` というフィールドをセットする必要があります:"

#: src/vmm/io.md:146
msgid ""
"これによって、全ての I/O Access が VM Exit を発生させるようになります。 ポー"
"ト番号ごとに VM Exit が発生するかどうかを決定させるためには **I/O Bitmap** を"
"利用することができます。 I/O Bitmap は各ビットがポート番号に対応しており、"
"`1` にセットされているポートに対する I/O Access が VM Exit を発生させるように"
"なります。 I/O Bitmap は **Primary Processor-Based VM-Execution Controls** に"
"ある `.use_io_bitmap` というフィールドで有効化することができます。 ただし、本"
"シリーズでは先ほどの Unconditional I/O Exit を利用することにし、I/O Bitmap は"
"使用しません。"
msgstr ""
"これによって、全ての I/O Access が VM Exit を発生させるようになります。 ポー"
"ト番号ごとに VM Exit が発生するかどうかを決定させるためには **I/O Bitmap** を"
"利用することができます。 I/O Bitmap は各ビットがポート番号に対応しており、"
"`1` にセットされているポートに対する I/O Access が VM Exit を発生させるように"
"なります。 I/O Bitmap は **Primary Processor-Based VM-Execution Controls** に"
"ある `.use_io_bitmap` というフィールドで有効化することができます。 ただし、本"
"シリーズでは先ほどの Unconditional I/O Exit を利用することにし、I/O Bitmap は"
"使用しません。"

#: src/vmm/io.md:152
msgid "PCI (Unsupported)"
msgstr "PCI (Unsupported)"

#: src/vmm/io.md:154
msgid ""
"Linux が起動してから最初にアクセスする I/O ポートは `0x0CF8` に位置する "
"**PCI Configuration Address** です。 [PCI](https://wiki.osdev.org/PCI) は周辺"
"デバイスとの通信に用いられる規格であり、 Configuration Address と `0x0CFC` に"
"位置する **PCI Configuration Data** にアクセスすることで各 PCI デバイスを探索"
"することができます。"
msgstr ""
"Linux が起動してから最初にアクセスする I/O ポートは `0x0CF8` に位置する "
"**PCI Configuration Address** です。 [PCI](https://wiki.osdev.org/PCI) は周辺"
"デバイスとの通信に用いられる規格であり、 Configuration Address と `0x0CFC` に"
"位置する **PCI Configuration Data** にアクセスすることで各 PCI デバイスを探索"
"することができます。"

#: src/vmm/io.md:158
msgid ""
"各デバイスはそれぞれの **BAR: Base Address Register** と呼ばれる空間を持って"
"おり、 Linux は検出されたデバイスの BAR に対してアクセスすることでデバイスの"
"情報を取得および設定します。 前回までは PCI を仮想化しておらずホストの PCI 空"
"間をそのままゲストに露出していました。 ここでゲストが教えられた BAR アドレス"
"は、EPT で設定したゲストの物理アドレス空間内に存在していません。 これにより、"
"ゲストが BAR にアクセスしようとすると EPT Violation が発生してしまいます。 "
"[前チャプターの最後](./cr.md#まとめ) で見た EPT Violation によるアボートはこ"
"れが原因だったというわけです。"
msgstr ""
"各デバイスはそれぞれの **BAR: Base Address Register** と呼ばれる空間を持って"
"おり、 Linux は検出されたデバイスの BAR に対してアクセスすることでデバイスの"
"情報を取得および設定します。 前回までは PCI を仮想化しておらずホストの PCI 空"
"間をそのままゲストに露出していました。 ここでゲストが教えられた BAR アドレス"
"は、EPT で設定したゲストの物理アドレス空間内に存在していません。 これにより、"
"ゲストが BAR にアクセスしようとすると EPT Violation が発生してしまいます。 "
"[前チャプターの最後](./cr.md#まとめ) で見た EPT Violation によるアボートはこ"
"れが原因だったというわけです。"

#: src/vmm/io.md:165
msgid ""
"残念ながら、Ymir では PCI の仮想化はサポートしません。 出力も入力もシリアルで"
"十分であり、ブートしてシェルを動かす程度のことであれば PCI は必要ありませ"
"ん。 とはいえ、PCI を有効化できると外部ストレージや外付けキーボードも NIC も"
"使えるようになり、とても楽しいです。 興味がある人はぜひ挑戦してみてください。"
msgstr ""
"残念ながら、Ymir では PCI の仮想化はサポートしません。 出力も入力もシリアルで"
"十分であり、ブートしてシェルを動かす程度のことであれば PCI は必要ありませ"
"ん。 とはいえ、PCI を有効化できると外部ストレージや外付けキーボードも NIC も"
"使えるようになり、とても楽しいです。 興味がある人はぜひ挑戦してみてください。"

#: src/vmm/io.md:170
msgid ""
"PCI の無効化は、単に RAX に `0` を返すだけで十分です。 Linux は PCI を使う前"
"に Probing という処理をするのですが、常に RAX を `0` にすることで Probing が"
"失敗するようになります。 Probing が失敗すると、以降 Linux は PCI を利用しなく"
"なります:"
msgstr ""
"PCI の無効化は、単に RAX に `0` を返すだけで十分です。 Linux は PCI を使う前"
"に Probing という処理をするのですが、常に RAX を `0` にすることで Probing が"
"失敗するようになります。 Probing が失敗すると、以降 Linux は PCI を利用しなく"
"なります:"

#: src/vmm/io.md:193
msgid "シリアル"
msgstr "シリアル"

#: src/vmm/io.md:195
msgid ""
"なにはともあれシリアル出力。 地球が生まれた46億年前から変わらない普遍の真理で"
"す。 筆者が生まれた7年前からももちろん変わりません。 まずはシリアルを仮想化し"
"ていきましょう。 これまでもゲストの Linux はシリアルを使ってログを出力してい"
"ました。 シリアルは仮想化していなかったため、ゲストはホストのシリアルに対して"
"直接アクセスをしていたということです。 正直このままでも問題はないといえばない"
"です。 割り込み周りで良くないことが発生しそうな予感がしますが、おそらく動くこ"
"とには動くと思います。 しかしながら、**せっかくなので** Ymir ではシリアルも仮"
"想化してあげることにします。"
msgstr ""
"なにはともあれシリアル出力。 地球が生まれた46億年前から変わらない普遍の真理で"
"す。 筆者が生まれた7年前からももちろん変わりません。 まずはシリアルを仮想化し"
"ていきましょう。 これまでもゲストの Linux はシリアルを使ってログを出力してい"
"ました。 シリアルは仮想化していなかったため、ゲストはホストのシリアルに対して"
"直接アクセスをしていたということです。 正直このままでも問題はないといえばない"
"です。 割り込み周りで良くないことが発生しそうな予感がしますが、おそらく動くこ"
"とには動くと思います。 しかしながら、**せっかくなので** Ymir ではシリアルも仮"
"想化してあげることにします。"

#: src/vmm/io.md:205
msgid ""
"[シリアル出力](../kernel/serial_output.md) で扱ったように、シリアルの I/O "
"ポートは以下のように割り振られています:"
msgstr ""
"[シリアル出力](../kernel/serial_output.md) で扱ったように、シリアルの I/O "
"ポートは以下のように割り振られています:"

#: src/vmm/io.md:207
msgid "Port Start"
msgstr "Port Start"

#: src/vmm/io.md:209
msgid "`0x02F8` - `0x3EF`"
msgstr "`0x02F8` - `0x3EF`"

#: src/vmm/io.md:209
msgid "COM4"
msgstr "COM4"

#: src/vmm/io.md:210
msgid "`0x02F8` - `0x2FF`"
msgstr "`0x02F8` - `0x2FF`"

#: src/vmm/io.md:210
msgid "COM2"
msgstr "COM2"

#: src/vmm/io.md:211
msgid "`0x03E8` - `0x3EF`"
msgstr "`0x03E8` - `0x3EF`"

#: src/vmm/io.md:211
msgid "COM3"
msgstr "COM3"

#: src/vmm/io.md:212
msgid "`0x03F8` - `0x3FF`"
msgstr "`0x03F8` - `0x3FF`"

#: src/vmm/io.md:212
msgid "COM1"
msgstr "COM1"

#: src/vmm/io.md:214
msgid "Ymir では COM1 ポートだけをサポートすることにします。"
msgstr "Ymir では COM1 ポートだけをサポートすることにします。"

#: src/vmm/io.md:216
msgid ""
"これまた [シリアル出力](../kernel/serial_output.md#シリアルの基本の定義) で"
"扱ったように、 シリアルは8個の I/O ポートを12個のレジスタにマップしていま"
"す。 そのうち、以下のレジスタを仮想化することにします。 なお、同列に書いてあ"
"るレジスタは同じポートにマップされているものの、DLAB の値やアクセス方向(RW)に"
"応じて異なるレジスタにマップされるものたちです:"
msgstr ""
"これまた [シリアル出力](../kernel/serial_output.md#シリアルの基本の定義) で"
"扱ったように、 シリアルは8個の I/O ポートを12個のレジスタにマップしていま"
"す。 そのうち、以下のレジスタを仮想化することにします。 なお、同列に書いてあ"
"るレジスタは同じポートにマップされているものの、DLAB の値やアクセス方向(RW)に"
"応じて異なるレジスタにマップされるものたちです:"

#: src/vmm/io.md:221
msgid "**TX / (DLL)**: RX はパススルー / TX は Ymir が代わりに書き込み"
msgstr "**TX / (DLL)**: RX はパススルー / TX は Ymir が代わりに書き込み"

#: src/vmm/io.md:222
msgid "**IER / DLH**: 値を別途保持"
msgstr "**IER / DLH**: 値を別途保持"

#: src/vmm/io.md:223
msgid "**MCR**: 値を別途保持"
msgstr "**MCR**: 値を別途保持"

#: src/vmm/io.md:224
msgid "**LCR**: 読み込みは常に `0` / 書き込みはブロック"
msgstr "**LCR**: 読み込みは常に `0` / 書き込みはブロック"

#: src/vmm/io.md:225
msgid "**SR**: 読み込みは常に `0` / 書き込みはブロック"
msgstr "**SR**: 読み込みは常に `0` / 書き込みはブロック"

#: src/vmm/io.md:226
msgid "**FCR**: 書き込みをブロック"
msgstr "**FCR**: 書き込みをブロック"

#: src/vmm/io.md:228
msgid "以下のレジスタは全てパススルーします:"
msgstr "以下のレジスタは全てパススルーします:"

#: src/vmm/io.md:230
msgid "**RX**"
msgstr "**RX**"

#: src/vmm/io.md:231
msgid "**IIR**"
msgstr "**IIR**"

#: src/vmm/io.md:232
msgid "**LSR**: Read-Only"
msgstr "**LSR**: Read-Only"

#: src/vmm/io.md:233
msgid "**MSR**: Read-Only"
msgstr "**MSR**: Read-Only"

#: src/vmm/io.md:235
msgid ""
"仮想化するレジスタの内、値を実際のシリアルレジスタとは別にソフトウェア的に別"
"途保持する必要のある3レジスタのために、 これらの値を保持する構造体を定義し、"
"`Vcpu` 構造体に持たせます:"
msgstr ""
"仮想化するレジスタの内、値を実際のシリアルレジスタとは別にソフトウェア的に別"
"途保持する必要のある3レジスタのために、 これらの値を保持する構造体を定義し、"
"`Vcpu` 構造体に持たせます:"

#: src/vmm/io.md:252
msgid ""
"まずは読み込みアクセスについて仮想化します。 読み込みで使われるレジスタは、"
"RX / DLL / IER / DLH / IIR / LCR / MCR / LSR / MSR / SR です:"
msgstr ""
"まずは読み込みアクセスについて仮想化します。 読み込みで使われるレジスタは、"
"RX / DLL / IER / DLH / IIR / LCR / MCR / LSR / MSR / SR です:"

#: src/vmm/io.md:284
msgid ""
"各レジスタに対する対応は、先ほどリストで示したとおりです。 パススルーするレジ"
"スタは、IN 命令を使って実際のシリアルのレジスタから値を読み込み、そのままゲス"
"トに渡します。 別途値を保持しているレジスタの場合は、保持している値をゲストに"
"渡します。"
msgstr ""
"各レジスタに対する対応は、先ほどリストで示したとおりです。 パススルーするレジ"
"スタは、IN 命令を使って実際のシリアルのレジスタから値を読み込み、そのままゲス"
"トに渡します。 別途値を保持しているレジスタの場合は、保持している値をゲストに"
"渡します。"

#: src/vmm/io.md:288
msgid ""
"続いて書き込みに対するハンドラを定義します。 **書き込みでは TX への書き込みを"
"除いてパススルーをしません**。 これにより、ゲストの出力がホストに影響すること"
"がなくなります。 書き込みで使われるレジスタは、TX / DLL / IER / DLH / FCR / "
"LCR / MCR / SR です。 リストに挙げたレジスタの内、LSR と MSR は読み込み専用な"
"ので書き込みが発生することはありません。 よって分岐の数は少なくなります:"
msgstr ""
"続いて書き込みに対するハンドラを定義します。 **書き込みでは TX への書き込みを"
"除いてパススルーをしません**。 これにより、ゲストの出力がホストに影響すること"
"がなくなります。 書き込みで使われるレジスタは、TX / DLL / IER / DLH / FCR / "
"LCR / MCR / SR です。 リストに挙げたレジスタの内、LSR と MSR は読み込み専用な"
"ので書き込みが発生することはありません。 よって分岐の数は少なくなります:"

#: src/vmm/io.md:322
msgid ""
"TX への書き込みは、[シリアル出力のチャプター](../kernel/serial_output.md#シリ"
"アルコンソールによるログ出力) で実装した `Serial.writeByte()` を使うことで、"
"Ymir が代わりに行います。"
msgstr ""
"TX への書き込みは、[シリアル出力のチャプター](../kernel/serial_output.md#シリ"
"アルコンソールによるログ出力) で実装した `Serial.writeByte()` を使うことで、"
"Ymir が代わりに行います。"

#: src/vmm/io.md:327
#, fuzzy
#| msgid ""
#| "\\[!TIP\\] I/O Bitmap I/O Bitmap を設定することで、ポートごとに VM Exit を"
#| "発生させるかどうかを決定させることができます。 シリアルの仮想化ではアクセ"
#| "スが起こってもパススルーするレジスタがいくつかありました。 そのようなレジ"
#| "スタのポートに対しては I/O Bitmap で VM Exit を発生させないようにすること"
#| "で、 VM Exit によるオーバーヘッドを抑えることができます。"
msgid ""
"I/O Bitmap を設定することで、ポートごとに VM Exit を発生させるかどうかを決定"
"させることができます。 シリアルの仮想化ではアクセスが起こってもパススルーする"
"レジスタがいくつかありました。 そのようなレジスタのポートに対しては I/O "
"Bitmap で VM Exit を発生させないようにすることで、 VM Exit によるオーバーヘッ"
"ドを抑えることができます。"
msgstr ""
"\\[!TIP\\] I/O Bitmap I/O Bitmap を設定することで、ポートごとに VM Exit を発"
"生させるかどうかを決定させることができます。 シリアルの仮想化ではアクセスが起"
"こってもパススルーするレジスタがいくつかありました。 そのようなレジスタのポー"
"トに対しては I/O Bitmap で VM Exit を発生させないようにすることで、 VM Exit "
"によるオーバーヘッドを抑えることができます。"

#: src/vmm/io.md:332
msgid ""
"実装したシリアルのハンドラを、先ほどの I/O ハンドラに追加します。 前述したよ"
"うに、サポートするのは COM1 ポートだけであり、それ以外の場合には単純に無視す"
"るようにしておきます:"
msgstr ""
"実装したシリアルのハンドラを、先ほどの I/O ハンドラに追加します。 前述したよ"
"うに、サポートするのは COM1 ポートだけであり、それ以外の場合には単純に無視す"
"るようにしておきます:"

#: src/vmm/io.md:359
msgid ""
"ここまででゲストを動かすと、前チャプターほどではありませんがそれなりのところ"
"まで起動が進むと思います。 そして何より、前チャプターまでと同様にシリアルログ"
"が出力されます。 **見た目は一切変わりませんが、前回までとは異なりシリアルの出"
"力が Ymir によって仮想化されています**。 ある程度進んだところで、今度は "
"`Unhandled I/O-out port: 0x43` というエラーメッセージとともにアボートすること"
"でしょう。 このポートは PIT のものです。 次はこいつを仮想化していきましょう。"
msgstr ""
"ここまででゲストを動かすと、前チャプターほどではありませんがそれなりのところ"
"まで起動が進むと思います。 そして何より、前チャプターまでと同様にシリアルログ"
"が出力されます。 **見た目は一切変わりませんが、前回までとは異なりシリアルの出"
"力が Ymir によって仮想化されています**。 ある程度進んだところで、今度は "
"`Unhandled I/O-out port: 0x43` というエラーメッセージとともにアボートすること"
"でしょう。 このポートは PIT のものです。 次はこいつを仮想化していきましょう。"

#: src/vmm/io.md:366
msgid "PIT"
msgstr "PIT"

#: src/vmm/io.md:368
msgid ""
"**PIT: Programmable Interval Timer** は周期的に割り込みを発生させるためのデバ"
"イスです。 IRQ 0 に接続されており、OS は PIT からの割り込みを受け取ることでス"
"ケジューリングに必要な時間等を計測することができます。"
msgstr ""
"**PIT: Programmable Interval Timer** は周期的に割り込みを発生させるためのデバ"
"イスです。 IRQ 0 に接続されており、OS は PIT からの割り込みを受け取ることでス"
"ケジューリングに必要な時間等を計測することができます。"

#: src/vmm/io.md:371
msgid ""
"Ymir カーネルはスケジューラを持っていません。 他にもタイマーが必要なコンポー"
"ネントはありません。 したがって、PIT を使うことがありません。 そのため、PIT "
"は仮想化せずにゲストにパススルーすることにします:"
msgstr ""
"Ymir カーネルはスケジューラを持っていません。 他にもタイマーが必要なコンポー"
"ネントはありません。 したがって、PIT を使うことがありません。 そのため、PIT "
"は仮想化せずにゲストにパススルーすることにします:"

#: src/vmm/io.md:396
msgid ""
"このへんは、前述した I/O Bitmap を使ってパススルーすることで、より簡単にかつ"
"効率的に実装することができます。 興味がある人はぜひ [本家 Ymir](https://"
"github.com/smallkirby/ymir) を参照しつつ実装してみてください。 今回は、唯一ア"
"クセスサイズによる分岐だけをおこないパススルーしています。 これらのハンドラ"
"を PIT へのアクセスで呼び出すようにします:"
msgstr ""
"このへんは、前述した I/O Bitmap を使ってパススルーすることで、より簡単にかつ"
"効率的に実装することができます。 興味がある人はぜひ [本家 Ymir](https://"
"github.com/smallkirby/ymir) を参照しつつ実装してみてください。 今回は、唯一ア"
"クセスサイズによる分岐だけをおこないパススルーしています。 これらのハンドラ"
"を PIT へのアクセスで呼び出すようにします:"

#: src/vmm/io.md:419
msgid ""
"大本命、PIC を仮想化していきます。 他の仮想化するコンポーネントと同様ですが、"
"**「とりあえず動くこと」を目標に全ての機能を完全に実装することはしません**。 "
"PIC は以下の I/O ポートを持ちます:"
msgstr ""
"大本命、PIC を仮想化していきます。 他の仮想化するコンポーネントと同様ですが、"
"**「とりあえず動くこと」を目標に全ての機能を完全に実装することはしません**。 "
"PIC は以下の I/O ポートを持ちます:"

#: src/vmm/io.md:423
msgid "Port"
msgstr "Port"

#: src/vmm/io.md:425
msgid "`0x20`"
msgstr "`0x20`"

#: src/vmm/io.md:425
msgid "Primary PIC Command"
msgstr "Primary PIC Command"

#: src/vmm/io.md:426
msgid "`0x21`"
msgstr "`0x21`"

#: src/vmm/io.md:426
msgid "Primary PIC Data"
msgstr "Primary PIC Data"

#: src/vmm/io.md:427
msgid "`0xA0`"
msgstr "`0xA0`"

#: src/vmm/io.md:427
msgid "Secondary PIC Command"
msgstr "Secondary PIC Command"

#: src/vmm/io.md:428
msgid "`0xA1`"
msgstr "`0xA1`"

#: src/vmm/io.md:428
msgid "Secondary PIC Data"
msgstr "Secondary PIC Data"

#: src/vmm/io.md:430
msgid ""
"[Ymir カーネルで PIC を初期化した際に扱った](../kernel/pic.md#command-words)"
"ように、 PIC の初期化は **ICW** と呼ばれるコマンド群によって段階的に行われま"
"す。 復習しておくと、初期化は以下の流れで行われます:"
msgstr ""
"[Ymir カーネルで PIC を初期化した際に扱った](../kernel/pic.md#command-words)"
"ように、 PIC の初期化は **ICW** と呼ばれるコマンド群によって段階的に行われま"
"す。 復習しておくと、初期化は以下の流れで行われます:"

#: src/vmm/io.md:434
msgid "**ICW1**: 初期化開始。ICW1 だけコマンドポートに送信。"
msgstr "**ICW1**: 初期化開始。ICW1 だけコマンドポートに送信。"

#: src/vmm/io.md:435
msgid "**ICW2**: 割り込みベクタのオフセット。"
msgstr "**ICW2**: 割り込みベクタのオフセット。"

#: src/vmm/io.md:436
msgid "**ICW3**: Secondary PIC の設定。"
msgstr "**ICW3**: Secondary PIC の設定。"

#: src/vmm/io.md:437
msgid "**ICW4**: モード設定"
msgstr "**ICW4**: モード設定"

#: src/vmm/io.md:439
msgid ""
"また、起動したあとは **OCW** と呼ばれるコマンド群によって割り込みの設定や "
"EOI が行われます。"
msgstr ""
"また、起動したあとは **OCW** と呼ばれるコマンド群によって割り込みの設定や "
"EOI が行われます。"

#: src/vmm/io.md:441
msgid ""
"ホスト側では以下の情報を記憶することにします。 それ以外の設定については、"
"Ymir が PIC に対して既に行っている設定をそのまま使うこととし、ゲストからの要"
"求は無視します:"
msgstr ""
"ホスト側では以下の情報を記憶することにします。 それ以外の設定については、"
"Ymir が PIC に対して既に行っている設定をそのまま使うこととし、ゲストからの要"
"求は無視します:"

#: src/vmm/io.md:444
msgid "初期化フェーズ"
msgstr "初期化フェーズ"

#: src/vmm/io.md:445
msgid "割り込みマスク"
msgstr "割り込みマスク"

#: src/vmm/io.md:446
msgid "割り込みベクタ"
msgstr "割り込みベクタ"

#: src/vmm/io.md:448
msgid ""
"それぞれの情報は Primary と Secondary のそれぞれについて記憶する必要がありま"
"す。 仮想化された PIC を表す構造体を定義し、`Vcpu` 構造体に持たせます:"
msgstr ""
"それぞれの情報は Primary と Secondary のそれぞれについて記憶する必要がありま"
"す。 仮想化された PIC を表す構造体を定義し、`Vcpu` 構造体に持たせます:"

#: src/vmm/io.md:484
msgid ""
"まずは PIC からの IN 命令に対するハンドラを定義します。 読み込みはデータポー"
"トからのみ行われると想定します。 また、読み込みは PIC の初期化前・初期化後に"
"のみ行われ、初期化の最中に行われることはないとします。 データポートから読み込"
"まれる値は本来は直前の OCW の種類によって異なるのですが、 **本シリーズでは全"
"て割り込みマスクを返すことにします**。 厳密には正しくない実装ですが、この実装"
"でも Linux はとりあえず動くので簡単のためにこのようにしています。 余力がある"
"人は直前の OCW の内容を保存し、その値をもとに適切な値を返すようにしてみてくだ"
"さい:"
msgstr ""
"まずは PIC からの IN 命令に対するハンドラを定義します。 読み込みはデータポー"
"トからのみ行われると想定します。 また、読み込みは PIC の初期化前・初期化後に"
"のみ行われ、初期化の最中に行われることはないとします。 データポートから読み込"
"まれる値は本来は直前の OCW の種類によって異なるのですが、 **本シリーズでは全"
"て割り込みマスクを返すことにします**。 厳密には正しくない実装ですが、この実装"
"でも Linux はとりあえず動くので簡単のためにこのようにしています。 余力がある"
"人は直前の OCW の内容を保存し、その値をもとに適切な値を返すようにしてみてくだ"
"さい:"

#: src/vmm/io.md:514
msgid ""
"対象のポートに応じて Primary か Secondary かを分岐します。 読み込みは初期化前"
"か初期化後にのみ行われることを想定しているため、初期化中に読み込みが行われた"
"場合はアボートします。 あとは保存していた割り込みマスクを返すだけの簡単な実装"
"です。"
msgstr ""
"対象のポートに応じて Primary か Secondary かを分岐します。 読み込みは初期化前"
"か初期化後にのみ行われることを想定しているため、初期化中に読み込みが行われた"
"場合はアボートします。 あとは保存していた割り込みマスクを返すだけの簡単な実装"
"です。"

#: src/vmm/io.md:518
msgid "続いて OUT 命令に対するハンドラを定義します。"
msgstr "続いて OUT 命令に対するハンドラを定義します。"

#: src/vmm/io.md:576
msgid ""
"まず、コマンドポートに対して書き込む値は2通りのみを想定します。 1つ目が "
"`0x11` であり、これは ICW1 です。 初期化を開始するため、仮想 PIC に `."
"phase1` をセットします。 2つ目が `0x60` から `0x67` までの8つの値であり、この"
"値は EOI を表します。 各値と `0x60` とのオフセットが EOI を送信する IRQ 番号"
"に対応しています。 [次のチャプター](./intr_injection.md) で扱いますが、**本シ"
"リーズでは PIC に対して EOI を送信するのは Ymir の責任** とします。 ゲストが "
"EOI を送信することは一切許可しません。 よって、EOI が送信された場合には単純に"
"無視します。"
msgstr ""
"まず、コマンドポートに対して書き込む値は2通りのみを想定します。 1つ目が "
"`0x11` であり、これは ICW1 です。 初期化を開始するため、仮想 PIC に `."
"phase1` をセットします。 2つ目が `0x60` から `0x67` までの8つの値であり、この"
"値は EOI を表します。 各値と `0x60` とのオフセットが EOI を送信する IRQ 番号"
"に対応しています。 [次のチャプター](./intr_injection.md) で扱いますが、**本シ"
"リーズでは PIC に対して EOI を送信するのは Ymir の責任** とします。 ゲストが "
"EOI を送信することは一切許可しません。 よって、EOI が送信された場合には単純に"
"無視します。"

#: src/vmm/io.md:585
msgid ""
"データポートへの書き込みは、初期化フェーズに応じて処理を分岐します。 初期化前"
"と初期化後の場合は全て割り込みマスク (**IMR**) への書き込みとみなし、仮想 "
"PIC の `.{primary,secondary}_mask` に書き込みます。 このマスクの値は、のちほ"
"どゲストへ割り込みを注入する際に使います。 `.phase1` での書き込みは ICW2 であ"
"り、ベクタオフセットを設定します。 `.phase2` での書き込みは ICW3 であり、"
"Secondary PIC の接続先を設定します。 Ymir では、Secondary PIC が Primary PIC "
"の IRQ2 にカスケードされている状況のみを想定します。 `.phase3` での書き込み"
"は ICW4 であり、モード設定をします。 モードは Ymir が PIC に直接設定した値を"
"そのまま使いまわすため、ゲストからの要求は無視します。"
msgstr ""
"データポートへの書き込みは、初期化フェーズに応じて処理を分岐します。 初期化前"
"と初期化後の場合は全て割り込みマスク (**IMR**) への書き込みとみなし、仮想 "
"PIC の `.{primary,secondary}_mask` に書き込みます。 このマスクの値は、のちほ"
"どゲストへ割り込みを注入する際に使います。 `.phase1` での書き込みは ICW2 であ"
"り、ベクタオフセットを設定します。 `.phase2` での書き込みは ICW3 であり、"
"Secondary PIC の接続先を設定します。 Ymir では、Secondary PIC が Primary PIC "
"の IRQ2 にカスケードされている状況のみを想定します。 `.phase3` での書き込み"
"は ICW4 であり、モード設定をします。 モードは Ymir が PIC に直接設定した値を"
"そのまま使いまわすため、ゲストからの要求は無視します。"

#: src/vmm/io.md:594
msgid "その他のポート"
msgstr "その他のポート"

#: src/vmm/io.md:596
msgid ""
"その他のポートについては、無視するかアボートするかのどちらかを選択します。 "
"Linux が起動までにアクセスするポートへの I/O は無視することにし、それ以外はア"
"ボートすることにします。 Linux がアクセスするポートは、以下のとおりです:"
msgstr ""
"その他のポートについては、無視するかアボートするかのどちらかを選択します。 "
"Linux が起動までにアクセスするポートへの I/O は無視することにし、それ以外はア"
"ボートすることにします。 Linux がアクセスするポートは、以下のとおりです:"

#: src/vmm/io.md:600
msgid "Ports"
msgstr "Ports"

#: src/vmm/io.md:602
msgid "`[0x0060, 0x0064]`"
msgstr "`[0x0060, 0x0064]`"

#: src/vmm/io.md:602
msgid "PS/2"
msgstr "PS/2"

#: src/vmm/io.md:603
msgid "`[0x0070, 0x0071]`"
msgstr "`[0x0070, 0x0071]`"

#: src/vmm/io.md:603
msgid "RTC"
msgstr "RTC"

#: src/vmm/io.md:604
msgid "`[0x0080, 0x008F]`"
msgstr "`[0x0080, 0x008F]`"

#: src/vmm/io.md:604
msgid "DMA"
msgstr "DMA"

#: src/vmm/io.md:605
msgid "`[0x03B0, 0x03DF]`"
msgstr "`[0x03B0, 0x03DF]`"

#: src/vmm/io.md:605
msgid "VGA"
msgstr "VGA"

#: src/vmm/io.md:607
msgid "最終的に、I/O Exit ハンドラは以下のようになります:"
msgstr "最終的に、I/O Exit ハンドラは以下のようになります:"

#: src/vmm/io.md:654
msgid ""
"本チャプターでは、シリアルと PIC への I/O ポートアクセスを仮想化しました。 そ"
"れ以外のポートについては、必要なもののみ無視するようにし、それ以外はアボート"
"することで対応しました。 シリアルと PIC の仮想化はとても完全といえるものでは"
"ありませんが、ひとまず Linux を動かすには十分になっています。"
msgstr ""
"本チャプターでは、シリアルと PIC への I/O ポートアクセスを仮想化しました。 そ"
"れ以外のポートについては、必要なもののみ無視するようにし、それ以外はアボート"
"することで対応しました。 シリアルと PIC の仮想化はとても完全といえるものでは"
"ありませんが、ひとまず Linux を動かすには十分になっています。"

#: src/vmm/io.md:658
msgid "それではここまでで一旦ゲストを動かしてみましょう:"
msgstr "それではここまでで一旦ゲストを動かしてみましょう:"

#: src/vmm/io.md:695
msgid ""
"前チャプターと同様にログの前半部分は省略しています。 かなり起動が進んでいます"
"ね。 途中のログ出力から、Primary と Secondary の PIC のベクタオフセットがそれ"
"ぞれ `0x30` と `0x38` に設定されていることがわかります。 Ymir と同じ値です"
"ね。 まぁ Ymir 側が Linux と同じになるように設定したので当然ですが。"
msgstr ""
"前チャプターと同様にログの前半部分は省略しています。 かなり起動が進んでいます"
"ね。 途中のログ出力から、Primary と Secondary の PIC のベクタオフセットがそれ"
"ぞれ `0x30` と `0x38` に設定されていることがわかります。 Ymir と同じ値です"
"ね。 まぁ Ymir 側が Linux と同じになるように設定したので当然ですが。"

#: src/vmm/io.md:701
msgid ""
"最後には、VM Exit するわけでもなくアボートするわけでもなく、**ゲストが停止し"
"てしまいます**。 この状態で QEMU monitor を開くか GDB をアタッチするかして "
"RIP を調べてみると、`0xFFFFFFFF81002246` になっています。 `addr2line` で該当"
"するソースコードを調べてみると、[calibrate_delay_converge()](https://github."
"com/torvalds/linux/blob/0a9b9d17f3a781dea03baca01c835deaa07f7cc3/init/"
"calibrate.c#L197) という関数であることが分かります:"
msgstr ""
"最後には、VM Exit するわけでもなくアボートするわけでもなく、**ゲストが停止し"
"てしまいます**。 この状態で QEMU monitor を開くか GDB をアタッチするかして "
"RIP を調べてみると、`0xFFFFFFFF81002246` になっています。 `addr2line` で該当"
"するソースコードを調べてみると、[calibrate_delay_converge()](https://github."
"com/torvalds/linux/blob/0a9b9d17f3a781dea03baca01c835deaa07f7cc3/init/"
"calibrate.c#L197) という関数であることが分かります:"

#: src/vmm/io.md:715
msgid ""
"この関数は `jiffies` が変化するまでひたすらに待ち続けます。 `jiffies` は "
"[vmlinux.lds.S](https://github.com/torvalds/linux/"
"blob/0a9b9d17f3a781dea03baca01c835deaa07f7cc3/arch/x86/kernel/vmlinux.lds."
"S#L44) において `jiffies_64` にエイリアスされています。 `jiffies_64` は "
"[do_timer()](https://github.com/torvalds/linux/"
"blob/0a9b9d17f3a781dea03baca01c835deaa07f7cc3/kernel/time/timekeeping."
"c#L2418-L2422) において加算されます。 この関数は [hpet_time_init()](https://"
"github.com/torvalds/linux/blob/0a9b9d17f3a781dea03baca01c835deaa07f7cc3/arch/"
"x86/kernel/time.c#L57) において IRQ 0 に対するハンドラとして登録されていま"
"す。 以上のことより、IRQ 0 が割り込みを送信したら加算されるはずの `jiffies` "
"がずっと変わらないために永遠に `while` から抜け出せずフリーズしているのだろう"
"ということが分かりますね。"
msgstr ""
"この関数は `jiffies` が変化するまでひたすらに待ち続けます。 `jiffies` は "
"[vmlinux.lds.S](https://github.com/torvalds/linux/"
"blob/0a9b9d17f3a781dea03baca01c835deaa07f7cc3/arch/x86/kernel/vmlinux.lds."
"S#L44) において `jiffies_64` にエイリアスされています。 `jiffies_64` は "
"[do_timer()](https://github.com/torvalds/linux/"
"blob/0a9b9d17f3a781dea03baca01c835deaa07f7cc3/kernel/time/timekeeping."
"c#L2418-L2422) において加算されます。 この関数は [hpet_time_init()](https://"
"github.com/torvalds/linux/blob/0a9b9d17f3a781dea03baca01c835deaa07f7cc3/arch/"
"x86/kernel/time.c#L57) において IRQ 0 に対するハンドラとして登録されていま"
"す。 以上のことより、IRQ 0 が割り込みを送信したら加算されるはずの `jiffies` "
"がずっと変わらないために永遠に `while` から抜け出せずフリーズしているのだろう"
"ということが分かりますね。"

#: src/vmm/io.md:721
msgid ""
"なぜゲストにタイマー割り込みが送信されていないのでしょうか？ まず PIT はゲス"
"トに対してパススルーしているため、PIT の設定に問題はないはずです。 それから、"
"VMCS の Primary Processor-Based VM-Execution Controls において `."
"external_interrupt` を設定していないため、 外部割り込みで VM Exit が発生する"
"ことはなくゲストにそのまま通知されています。 みなさんもなぜタイマー割り込みが"
"送信されていないのか考えてみてください。 まぁすぐに答えを言ってしまうんです"
"が。 正解は、**今回仮想化した PIC において EOI を無視しているからです**。 "
"[PIC のチャプター](../kernel/pic.md#eoi) で扱ったように、IRQ からの割り込み待"
"ち一覧は **IRR** と呼ばれるレジスタに保存されます。 CPU が IRQ 割り込みを承認"
"すると、**IRR** がクリアされる代わりに **ISR** に IRQ がセットされます。 こ"
"の ISR に値がセットされている間、PIC はそれ以上割り込み信号を CPU に送信しな"
"くなります。 ISR にセットされた IRQ は EOI を送信することでクリアされます。 "
"この EOI を無視してしまうと、タイマーに限らず (ISRにセットされた IRQ よりも優"
"先度が低い) 全ての割り込みが送信されなくなります。"
msgstr ""
"なぜゲストにタイマー割り込みが送信されていないのでしょうか？ まず PIT はゲス"
"トに対してパススルーしているため、PIT の設定に問題はないはずです。 それから、"
"VMCS の Primary Processor-Based VM-Execution Controls において `."
"external_interrupt` を設定していないため、 外部割り込みで VM Exit が発生する"
"ことはなくゲストにそのまま通知されています。 みなさんもなぜタイマー割り込みが"
"送信されていないのか考えてみてください。 まぁすぐに答えを言ってしまうんです"
"が。 正解は、**今回仮想化した PIC において EOI を無視しているからです**。 "
"[PIC のチャプター](../kernel/pic.md#eoi) で扱ったように、IRQ からの割り込み待"
"ち一覧は **IRR** と呼ばれるレジスタに保存されます。 CPU が IRQ 割り込みを承認"
"すると、**IRR** がクリアされる代わりに **ISR** に IRQ がセットされます。 こ"
"の ISR に値がセットされている間、PIC はそれ以上割り込み信号を CPU に送信しな"
"くなります。 ISR にセットされた IRQ は EOI を送信することでクリアされます。 "
"この EOI を無視してしまうと、タイマーに限らず (ISRにセットされた IRQ よりも優"
"先度が低い) 全ての割り込みが送信されなくなります。"

#: src/vmm/io.md:734
msgid ""
"以上がタイマー割り込みが発生せずに無限ループが発生する原因です。 なお、この問"
"題は意図したものです。 Ymir では EOI を送信するのは Ymir の責任であるとしま"
"す。 ゲストが直接 EOI を送信することは許しません。 これにより、ゲストだけでは"
"なく Ymir も割り込みを受け取ることが可能になります (まぁ Ymir は外部割り込み"
"を受け取って何かをすることはないんですけどね...)。 次のチャプターでは割り込み"
"を適切にホスト側で処理し、PIC への EOI の送信やゲストへの割り込みの注入をしま"
"す。"
msgstr ""
"以上がタイマー割り込みが発生せずに無限ループが発生する原因です。 なお、この問"
"題は意図したものです。 Ymir では EOI を送信するのは Ymir の責任であるとしま"
"す。 ゲストが直接 EOI を送信することは許しません。 これにより、ゲストだけでは"
"なく Ymir も割り込みを受け取ることが可能になります (まぁ Ymir は外部割り込み"
"を受け取って何かをすることはないんですけどね...)。 次のチャプターでは割り込み"
"を適切にホスト側で処理し、PIC への EOI の送信やゲストへの割り込みの注入をしま"
"す。"

#: src/vmm/io.md:745
msgid ""
"[Programmable Interval Timer - OSDev Wiki](https://wiki.osdev.org/"
"Programmable_Interval_Timer)"
msgstr ""
"[Programmable Interval Timer - OSDev Wiki](https://wiki.osdev.org/"
"Programmable_Interval_Timer)"

#: src/vmm/intr_injection.md:3
msgid ""
"前チャプターでは EOI が適切に PIC に通知されないためにタイマー割り込みが発生"
"せず、それが原因でゲストがフリーズしてしまいました。 本チャプターでは、ゲスト"
"とホストの間で適切に役割分担をして割り込みを共有する仕組みを構築します。 その"
"過程で、ホストはゲストに対して VM Entry 時に割り込みを注入することになりま"
"す。"
msgstr ""
"前チャプターでは EOI が適切に PIC に通知されないためにタイマー割り込みが発生"
"せず、それが原因でゲストがフリーズしてしまいました。 本チャプターでは、ゲスト"
"とホストの間で適切に役割分担をして割り込みを共有する仕組みを構築します。 その"
"過程で、ホストはゲストに対して VM Entry 時に割り込みを注入することになりま"
"す。"

#: src/vmm/intr_injection.md:9
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-intr_injection`]"
#| "(https://github.com/smallkirby/ymir/tree/whiz-vmm-intr_injection) ブランチ"
#| "にあります。"
msgid ""
"本チャプターの最終コードは [`whiz-vmm-intr_injection`](https://github.com/"
"smallkirby/ymir/tree/whiz-vmm-intr_injection) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-intr_injection`]"
"(https://github.com/smallkirby/ymir/tree/whiz-vmm-intr_injection) ブランチに"
"あります。"

#: src/vmm/intr_injection.md:13
msgid "[割り込みの共有](#割り込みの共有)"
msgstr "[割り込みの共有](#割り込みの共有)"

#: src/vmm/intr_injection.md:14
msgid "[割り込みによる VM Exit](#割り込みによる-vm-exit)"
msgstr "[割り込みによる VM Exit](#割り込みによる-vm-exit)"

#: src/vmm/intr_injection.md:15
msgid "[Subscriber](#subscriber)"
msgstr "[Subscriber](#subscriber)"

#: src/vmm/intr_injection.md:16
msgid "[Pending IRQs](#pending-irqs)"
msgstr "[Pending IRQs](#pending-irqs)"

#: src/vmm/intr_injection.md:17
msgid "[IRQ Injection](#irq-injection)"
msgstr "[IRQ Injection](#irq-injection)"

#: src/vmm/intr_injection.md:18
msgid "[割り込みの受け入れ](#割り込みの受け入れ)"
msgstr "[割り込みの受け入れ](#割り込みの受け入れ)"

#: src/vmm/intr_injection.md:19
msgid "[HLT](#hlt)"
msgstr "[HLT](#hlt)"

#: src/vmm/intr_injection.md:22
msgid "割り込みの共有"
msgstr "割り込みの共有"

#: src/vmm/intr_injection.md:24
msgid ""
"本チャプターで扱う内容は少し特殊です。 そのため、何がしたいのかという目的から"
"先にまとめて説明することにします。"
msgstr ""
"本チャプターで扱う内容は少し特殊です。 そのため、何がしたいのかという目的から"
"先にまとめて説明することにします。"

#: src/vmm/intr_injection.md:27
msgid ""
"本シリーズでは **Ymir とゲストの両者が割り込みを受け取ることができるようにし"
"ます**。 ゲストの実行中に割り込みが発生した場合、ゲストは VM Exit し、Ymir が"
"まず最初に割り込みを受取りハンドラを呼び出します。 Ymir の割り込みハンドラは "
"PIC がさらに割り込みを発生させることができるようにするため **EOI** を通知しま"
"す。 しかし、EOI を通知してしまうと PIC が ISR をクリアしてしまうため、ゲスト"
"が割り込みに気がつくことができなくなってしまいます。 そこで、**ゲストへの割り"
"込みの注入は Ymir が代わりに行います**。 Ymir から割り込みを受け取ったゲスト"
"は通常通り割り込みハンドラを呼び出し、PIC に EOI を通知しようとします。 ゲス"
"トが送信した EOI は [前チャプター](./io.md#pic) で仮想化した PIC が受け取りま"
"すが、 実際の PIC に通知すること無く捨てられます。 これにより余計に EOI を通"
"知することなく Ymir とゲストの両方が割り込みを受け取ることができます。 ゲスト"
"への割り込みの注入は VT-x の _VM-Exit Interruption-Information_ と _VM-Entry "
"Interruption-Information_ というフィールドを使って実現します。"
msgstr ""
"本シリーズでは **Ymir とゲストの両者が割り込みを受け取ることができるようにし"
"ます**。 ゲストの実行中に割り込みが発生した場合、ゲストは VM Exit し、Ymir が"
"まず最初に割り込みを受取りハンドラを呼び出します。 Ymir の割り込みハンドラは "
"PIC がさらに割り込みを発生させることができるようにするため **EOI** を通知しま"
"す。 しかし、EOI を通知してしまうと PIC が ISR をクリアしてしまうため、ゲスト"
"が割り込みに気がつくことができなくなってしまいます。 そこで、**ゲストへの割り"
"込みの注入は Ymir が代わりに行います**。 Ymir から割り込みを受け取ったゲスト"
"は通常通り割り込みハンドラを呼び出し、PIC に EOI を通知しようとします。 ゲス"
"トが送信した EOI は [前チャプター](./io.md#pic) で仮想化した PIC が受け取りま"
"すが、 実際の PIC に通知すること無く捨てられます。 これにより余計に EOI を通"
"知することなく Ymir とゲストの両方が割り込みを受け取ることができます。 ゲスト"
"への割り込みの注入は VT-x の _VM-Exit Interruption-Information_ と _VM-Entry "
"Interruption-Information_ というフィールドを使って実現します。"

#: src/vmm/intr_injection.md:38
msgid ""
"Ymir 自体の割り込みの仕組みは [割り込みのチャプター](../kernel/interrupt.md) "
"で既に実装しました。 タイマー割り込みを受取り、割り込みハンドラが呼び出される"
"ことも既に確認済みです。 独立性を保つためにも、Ymir では仮想化のためにこれら"
"の割り込みの仕組みに直接介入したくありません。 そこで、**任意の割り込みに対し"
"て subscribe できる仕組み** を用意します。 Ymir カーネル自体は割り込みを受取"
"り通常通りの処理をしますが、加えて別途登録した VMM 用の subscriber が呼び出さ"
"れるという仕組みです。 これにより、カーネル自体は VMM の機能を特に意識するこ"
"となく割り込みを処理することができ、 VMM 側は任意の割り込みに対して透過的に介"
"入することができるようになります。"
msgstr ""
"Ymir 自体の割り込みの仕組みは [割り込みのチャプター](../kernel/interrupt.md) "
"で既に実装しました。 タイマー割り込みを受取り、割り込みハンドラが呼び出される"
"ことも既に確認済みです。 独立性を保つためにも、Ymir では仮想化のためにこれら"
"の割り込みの仕組みに直接介入したくありません。 そこで、**任意の割り込みに対し"
"て subscribe できる仕組み** を用意します。 Ymir カーネル自体は割り込みを受取"
"り通常通りの処理をしますが、加えて別途登録した VMM 用の subscriber が呼び出さ"
"れるという仕組みです。 これにより、カーネル自体は VMM の機能を特に意識するこ"
"となく割り込みを処理することができ、 VMM 側は任意の割り込みに対して透過的に介"
"入することができるようになります。"

#: src/vmm/intr_injection.md:46
msgid ""
"![Overview of IRQ sharing betwenn Ymir and Guest OS.](../assets/drawio/"
"irq_share.drawio.png) _Overview of IRQ sharing betwenn Ymir and Guest OS._"
msgstr ""
"![Overview of IRQ sharing betwenn Ymir and Guest OS.](../assets/drawio/"
"irq_share.drawio.png) _Overview of IRQ sharing betwenn Ymir and Guest OS._"

#: src/vmm/intr_injection.md:49
msgid "割り込みによる VM Exit"
msgstr "割り込みによる VM Exit"

#: src/vmm/intr_injection.md:51
msgid ""
"外部割り込み発生時に VM Exit を発生させるかどうかは VMCS の **Pin-Based VM-"
"Execution Controls** によって制御されます。 今の所このフィールドは設定してい"
"ないため、外部割り込みで VM Exit は発生せずゲストに直接割り込みが通知されま"
"す。 まずはこのフィールドを有効化することで、外部割り込みで VM Exit が発生す"
"るようにします:"
msgstr ""
"外部割り込み発生時に VM Exit を発生させるかどうかは VMCS の **Pin-Based VM-"
"Execution Controls** によって制御されます。 今の所このフィールドは設定してい"
"ないため、外部割り込みで VM Exit は発生せずゲストに直接割り込みが通知されま"
"す。 まずはこのフィールドを有効化することで、外部割り込みで VM Exit が発生す"
"るようにします:"

#: src/vmm/intr_injection.md:65
msgid ""
"ゲストを動かすと、かなり初期の方(カーネル本体が展開される前)で割り込みが発生"
"することが分かります。 これは IRQ 0番のタイマー割り込みによるものです。 PIC "
"のタイマー割り込みマスクは Ymir が既に外しているため、ゲストの実行中に割り込"
"みが発生しています:"
msgstr ""
"ゲストを動かすと、かなり初期の方(カーネル本体が展開される前)で割り込みが発生"
"することが分かります。 これは IRQ 0番のタイマー割り込みによるものです。 PIC "
"のタイマー割り込みマスクは Ymir が既に外しているため、ゲストの実行中に割り込"
"みが発生しています:"

#: src/vmm/intr_injection.md:91
msgid ""
"なお、I/O Bitmaps などとは異なり、割り込みはベクタごとに VM Exit させるかどう"
"かを設定することはできません。"
msgstr ""
"なお、I/O Bitmaps などとは異なり、割り込みはベクタごとに VM Exit させるかどう"
"かを設定することはできません。"

#: src/vmm/intr_injection.md:93
msgid "Subscriber"
msgstr "Subscriber"

#: src/vmm/intr_injection.md:95
msgid ""
"続いて、Ymir カーネルの割り込みハンドラに対して任意の処理を挿入するための仕組"
"みを用意します。 仕組み自体はとてもシンプルで、通常の割り込みハンドラの他に追"
"加で呼び出したい関数を登録し、割り込みハンドラからそれらを呼び出すようにする"
"だけです。 割り込みに対して subscribe する主体のことを **Subscriber** と呼ぶ"
"ことにします。 Subscriber インタフェースは以下のように定義されます:"
msgstr ""
"続いて、Ymir カーネルの割り込みハンドラに対して任意の処理を挿入するための仕組"
"みを用意します。 仕組み自体はとてもシンプルで、通常の割り込みハンドラの他に追"
"加で呼び出したい関数を登録し、割り込みハンドラからそれらを呼び出すようにする"
"だけです。 割り込みに対して subscribe する主体のことを **Subscriber** と呼ぶ"
"ことにします。 Subscriber インタフェースは以下のように定義されます:"

#: src/vmm/intr_injection.md:112
msgid ""
"`Subscriber` は挿入するハンドラとして `callback` を持っています。 "
"`callback()` は通常の割り込みハンドラが受け取るコンテキスト情報を受け取りま"
"す。 このコンテキスト情報にはレジスタの情報や割り込みベクタなどが含まれていま"
"した。 また、`callback()` は Subscriber の実体である `self` を受け取ることが"
"できます。 [General Allocator](../kernel/general_allocator.md) で "
"`Allocator` インスタンスを実装した際にも、 `allocate()` 関数は `self` を受け"
"取っていたことを覚えているでしょうか。 この型を `callback()` の中で "
"`Subscriber` 自身の値に変換することで、Subscriber は自分自身のコンテキスト情"
"報を取得することができます。"
msgstr ""
"`Subscriber` は挿入するハンドラとして `callback` を持っています。 "
"`callback()` は通常の割り込みハンドラが受け取るコンテキスト情報を受け取りま"
"す。 このコンテキスト情報にはレジスタの情報や割り込みベクタなどが含まれていま"
"した。 また、`callback()` は Subscriber の実体である `self` を受け取ることが"
"できます。 [General Allocator](../kernel/general_allocator.md) で "
"`Allocator` インスタンスを実装した際にも、 `allocate()` 関数は `self` を受け"
"取っていたことを覚えているでしょうか。 この型を `callback()` の中で "
"`Subscriber` 自身の値に変換することで、Subscriber は自分自身のコンテキスト情"
"報を取得することができます。"

#: src/vmm/intr_injection.md:120
msgid ""
"Subscriber はグローバル変数で管理し、以下の関数で登録することができます:"
msgstr ""
"Subscriber はグローバル変数で管理し、以下の関数で登録することができます:"

#: src/vmm/intr_injection.md:141
msgid ""
"登録された Subscriber は割り込みハンドラから呼び出されます。 今回の目的として"
"は IRQ 割り込み (`[0x30, 0x40)`) に対してのみ呼び出しても良いところですが、 "
"本シリーズでは汎用的に全ての割り込みに対して subscriber が呼び出されるように"
"しています。 発生した割り込みが本当に興味のあるものかどうかを判断するのは、"
"Subscriber の責任とします:"
msgstr ""
"登録された Subscriber は割り込みハンドラから呼び出されます。 今回の目的として"
"は IRQ 割り込み (`[0x30, 0x40)`) に対してのみ呼び出しても良いところですが、 "
"本シリーズでは汎用的に全ての割り込みに対して subscriber が呼び出されるように"
"しています。 発生した割り込みが本当に興味のあるものかどうかを判断するのは、"
"Subscriber の責任とします:"

#: src/vmm/intr_injection.md:159
msgid ""
"以上で任意の割り込みに介入する仕組みができました。 試しに、適当な Subscriber "
"を登録してみましょう。 Subscriber として適当な型 `A` と適当なハンドラ "
"`blobSubscriber()` を用意します。 ハンドラの中では、`self` が正しく取得できて"
"いることを確認するためにログを出力してすぐに panic させます:"
msgstr ""
"以上で任意の割り込みに介入する仕組みができました。 試しに、適当な Subscriber "
"を登録してみましょう。 Subscriber として適当な型 `A` と適当なハンドラ "
"`blobSubscriber()` を用意します。 ハンドラの中では、`self` が正しく取得できて"
"いることを確認するためにログを出力してすぐに panic させます:"

#: src/vmm/intr_injection.md:177
msgid "実行すると以下のようになります。"
msgstr "実行すると以下のようになります。"

#: src/vmm/intr_injection.md:185
msgid ""
"タイマー割り込みが発生し、ちゃんと Subscriber が呼び出されていることが分かり"
"ます。 ここで使ったコードは実験用であり、以降は使わないため削除してOKです。"
msgstr ""
"タイマー割り込みが発生し、ちゃんと Subscriber が呼び出されていることが分かり"
"ます。 ここで使ったコードは実験用であり、以降は使わないため削除してOKです。"

#: src/vmm/intr_injection.md:188
msgid "Pending IRQs"
msgstr "Pending IRQs"

#: src/vmm/intr_injection.md:190
msgid ""
"ゲストの実行中に割り込みが発生した場合、VM Exit が発生しホストの割り込みハン"
"ドラが割り込みを処理します。 Subscriber は、割り込みが発生したらそれをゲスト"
"に注入するために割り込みの内容を記録しておく必要があります。 ゲストに注入され"
"るのを待っている IRQ の一覧を保持するための変数を `Vcpu` に追加します:"
msgstr ""
"ゲストの実行中に割り込みが発生した場合、VM Exit が発生しホストの割り込みハン"
"ドラが割り込みを処理します。 Subscriber は、割り込みが発生したらそれをゲスト"
"に注入するために割り込みの内容を記録しておく必要があります。 ゲストに注入され"
"るのを待っている IRQ の一覧を保持するための変数を `Vcpu` に追加します:"

#: src/vmm/intr_injection.md:203
msgid ""
"`.pending_irq` は、16 本ある IRQ に対応するビットマップです。 IRQ N が発生し"
"た場合、`.pending_irq` の対応するビットがセットされます。 また、ゲストへの注"
"入が完了したらそのビットをクリアします。"
msgstr ""
"`.pending_irq` は、16 本ある IRQ に対応するビットマップです。 IRQ N が発生し"
"た場合、`.pending_irq` の対応するビットがセットされます。 また、ゲストへの注"
"入が完了したらそのビットをクリアします。"

#: src/vmm/intr_injection.md:207
msgid ""
"ゲストへの割り込みの注入は必ずしも成功するとは限りません。 たとえばゲストが "
"`RFLAGS.IF` をクリアしていた場合、割り込みを注入することはできません。 また、"
"PIC の割り込みマスク(IMR)の対応するビットがセットされている場合にも、その "
"IRQ はゲストに通知されるべきではありません。 よって、割り込みによって VM "
"Exit が発生したとしても、 その割り込みは **直後の VM Entry でゲストに通知され"
"るわけではない** ことに注意してください。 ゲストが `RFLAGS.IF` をセットしない"
"間に発生した割り込みはどんどん `.pending_irq` に積まれていきます。 この挙動は"
"仮想化していない場合と同様です。 非仮想化環境においても、`RFLAGS.IF` がクリア"
"されている間に発生した IRQ は IRR に積まれていき、 `RFLAGS.IF` がセットされた"
"タイミングで最も優先度の高いものから ISR にセットされ CPU に通知されます。"
msgstr ""
"ゲストへの割り込みの注入は必ずしも成功するとは限りません。 たとえばゲストが "
"`RFLAGS.IF` をクリアしていた場合、割り込みを注入することはできません。 また、"
"PIC の割り込みマスク(IMR)の対応するビットがセットされている場合にも、その "
"IRQ はゲストに通知されるべきではありません。 よって、割り込みによって VM "
"Exit が発生したとしても、 その割り込みは **直後の VM Entry でゲストに通知され"
"るわけではない** ことに注意してください。 ゲストが `RFLAGS.IF` をセットしない"
"間に発生した割り込みはどんどん `.pending_irq` に積まれていきます。 この挙動は"
"仮想化していない場合と同様です。 非仮想化環境においても、`RFLAGS.IF` がクリア"
"されている間に発生した IRQ は IRR に積まれていき、 `RFLAGS.IF` がセットされた"
"タイミングで最も優先度の高いものから ISR にセットされ CPU に通知されます。"

#: src/vmm/intr_injection.md:217
msgid ""
"Subscriber は、割り込みが発生すると `.pending_irq` に対応するビットをセットし"
"ます。 Ymir では IRQ 割り込みをベクタ `0x20` から `0x2F` の間にリマップしてい"
"るため、 これらのベクタが発生した場合に限って IRQ ビットをセットしましょう:"
msgstr ""
"Subscriber は、割り込みが発生すると `.pending_irq` に対応するビットをセットし"
"ます。 Ymir では IRQ 割り込みをベクタ `0x20` から `0x2F` の間にリマップしてい"
"るため、 これらのベクタが発生した場合に限って IRQ ビットをセットしましょう:"

#: src/vmm/intr_injection.md:233
msgid ""
"この Subscriber は `loop()` の先頭で登録することにします。 一度だけ呼び出され"
"る場所であれば、他にどこで呼び出しても問題ありません:"
msgstr ""
"この Subscriber は `loop()` の先頭で登録することにします。 一度だけ呼び出され"
"る場所であれば、他にどこで呼び出しても問題ありません:"

#: src/vmm/intr_injection.md:244
msgid "IRQ Injection"
msgstr "IRQ Injection"

#: src/vmm/intr_injection.md:246
msgid ""
"IRQ をゲストに注入する関数を定義します。 前述したように、ゲストはいつでも割り"
"込みを受け付けているわけではありません (もちろん NMI は除きます)。 割り込みを"
"注入することができない条件は、以下のとおりです:"
msgstr ""
"IRQ をゲストに注入する関数を定義します。 前述したように、ゲストはいつでも割り"
"込みを受け付けているわけではありません (もちろん NMI は除きます)。 割り込みを"
"注入することができない条件は、以下のとおりです:"

#: src/vmm/intr_injection.md:250
msgid "そもそも注入する割り込みがない"
msgstr "そもそも注入する割り込みがない"

#: src/vmm/intr_injection.md:251
msgid "PIC が初期化されていない"
msgstr "PIC が初期化されていない"

#: src/vmm/intr_injection.md:252
msgid "`RFLAGS.IF` がクリアされている"
msgstr "`RFLAGS.IF` がクリアされている"

#: src/vmm/intr_injection.md:253
msgid "PIC の IMR によって IRQ がマスクされている"
msgstr "PIC の IMR によって IRQ がマスクされている"

#: src/vmm/intr_injection.md:255
msgid ""
"まずは 1 から 3 ケースについてチェックしてあげます。 `injectExtIntr()` はゲス"
"トに割り込みを注入するための VMCS フィールドを設定する関数です。 注入する割り"
"込みの設定に成功した場合は `true` を返します:"
msgstr ""
"まずは 1 から 3 ケースについてチェックしてあげます。 `injectExtIntr()` はゲス"
"トに割り込みを注入するための VMCS フィールドを設定する関数です。 注入する割り"
"込みの設定に成功した場合は `true` を返します:"

#: src/vmm/intr_injection.md:279
msgid ""
"上記のチェックに通過した場合、ゲストに割り込みを注入することができます。 ただ"
"し、一度に注入することができる割り込みはただ1つだけです。 よって、どの IRQ を"
"注入するのかを選択する必要があります。 本来この IRQ 選択ロジックは PIC が担当"
"し、IRQ の優先度が高いものから順に割り込みが通知されます。 基本的に IRQ 番号"
"が小さいほど優先度が高いのですが、PIC では IRQ の優先度を変更することができる"
"ため、それらを考慮して IRQ が選択されます。 [PIC の仮想化のチャプター](./io."
"md) で実装した仮想 PIC は優先度回転をサポートしていないため、 Ymir では IRQ "
"番号が小さいものから順に割り込みを注入することにします。"
msgstr ""
"上記のチェックに通過した場合、ゲストに割り込みを注入することができます。 ただ"
"し、一度に注入することができる割り込みはただ1つだけです。 よって、どの IRQ を"
"注入するのかを選択する必要があります。 本来この IRQ 選択ロジックは PIC が担当"
"し、IRQ の優先度が高いものから順に割り込みが通知されます。 基本的に IRQ 番号"
"が小さいほど優先度が高いのですが、PIC では IRQ の優先度を変更することができる"
"ため、それらを考慮して IRQ が選択されます。 [PIC の仮想化のチャプター](./io."
"md) で実装した仮想 PIC は優先度回転をサポートしていないため、 Ymir では IRQ "
"番号が小さいものから順に割り込みを注入することにします。"

#: src/vmm/intr_injection.md:287
msgid "IRQ 0 から 15 の順番で、注入対象かどうかを確認します:"
msgstr "IRQ 0 から 15 の順番で、注入対象かどうかを確認します:"

#: src/vmm/intr_injection.md:289
msgid "`.pending_irq` に対応するビットがセットされている"
msgstr "`.pending_irq` に対応するビットがセットされている"

#: src/vmm/intr_injection.md:290
msgid "IMR によって IRQ がマスクされていない"
msgstr "IMR によって IRQ がマスクされていない"

#: src/vmm/intr_injection.md:292
msgid ""
"なお IRQ N が Secondary PIC に属している場合には、 **IRQ 2 と IRQ N の両方が "
"IMR でマスクされていないことを確認する必要** があります。 以下で使っている "
"`bits` は [ビット演算とテスト](../kernel/bit_and_test.md) で実装したライブラ"
"リです。 `.pending_irq` のようなビットマップを扱う際に大活躍します:"
msgstr ""
"なお IRQ N が Secondary PIC に属している場合には、 **IRQ 2 と IRQ N の両方が "
"IMR でマスクされていないことを確認する必要** があります。 以下で使っている "
"`bits` は [ビット演算とテスト](../kernel/bit_and_test.md) で実装したライブラ"
"リです。 `.pending_irq` のようなビットマップを扱う際に大活躍します:"

#: src/vmm/intr_injection.md:324
msgid ""
"IRQ が注入可能である場合には、VMCS を設定して注入する割り込みを設定します。 "
"ゲストへの割り込みの注入は VMCS の **VM-Entry Interruption-Information** とい"
"う 32bit のフィールドを使います。 Interruption-Information は以下の構造を持ち"
"ます:"
msgstr ""
"IRQ が注入可能である場合には、VMCS を設定して注入する割り込みを設定します。 "
"ゲストへの割り込みの注入は VMCS の **VM-Entry Interruption-Information** とい"
"う 32bit のフィールドを使います。 Interruption-Information は以下の構造を持ち"
"ます:"

#: src/vmm/intr_injection.md:328
msgid ""
"![Format of VM-Entry Interruption-Information](../assets/sdm/"
"interruption_information.png) _Format of VM-Entry Interruption-Information. "
"SDM Vol.3C Table 25-17._"
msgstr ""
"![Format of VM-Entry Interruption-Information](../assets/sdm/"
"interruption_information.png) _Format of VM-Entry Interruption-Information. "
"SDM Vol.3C Table 25-17._"

#: src/vmm/intr_injection.md:331
msgid ""
"**Vector** はゲストに注入する割り込み・例外のベクタを表します。 **Type** は割"
"り込みの種類を表します。 **Deliver Error Code** は Error Code を提供するかど"
"うかを芦原します。 [割り込みのチャプター](../kernel/interrupt.md) で扱ったよ"
"うに、一部の例外はより詳しい情報を提供するため Error Code をスタックに積みま"
"す。 _Deliver Error Code_ がセットされている場合、VMCS **VM-Entry exception "
"Error Code** の値がゲストに提供されます。"
msgstr ""
"**Vector** はゲストに注入する割り込み・例外のベクタを表します。 **Type** は割"
"り込みの種類を表します。 **Deliver Error Code** は Error Code を提供するかど"
"うかを芦原します。 [割り込みのチャプター](../kernel/interrupt.md) で扱ったよ"
"うに、一部の例外はより詳しい情報を提供するため Error Code をスタックに積みま"
"す。 _Deliver Error Code_ がセットされている場合、VMCS **VM-Entry exception "
"Error Code** の値がゲストに提供されます。"

#: src/vmm/intr_injection.md:337
msgid "Interruption-Information を以下のように定義します:"
msgstr "Interruption-Information を以下のように定義します:"

#: src/vmm/intr_injection.md:366
msgid ""
"以下のように IRQ を注入します。 なお、注入するベクタは IRQ のリマップを考慮し"
"て計算する必要があります。 ゲストの IRQ がどのベクタにマップされているかは "
"`Vcpu.pic` に記録されているため、IRQ の番号をこれに加算して注入するベクタを計"
"算します:"
msgstr ""
"以下のように IRQ を注入します。 なお、注入するベクタは IRQ のリマップを考慮し"
"て計算する必要があります。 ゲストの IRQ がどのベクタにマップされているかは "
"`Vcpu.pic` に記録されているため、IRQ の番号をこれに加算して注入するベクタを計"
"算します:"

#: src/vmm/intr_injection.md:391
msgid ""
"割り込みの設定が完了したら、IRR に対応する `.pending_irq` はクリアしておきま"
"す。 ゲストが割り込みを処理可能であることは既に確認済みのため、VM Entry 直後"
"にゲストの割り込みハンドラが呼び出されます。"
msgstr ""
"割り込みの設定が完了したら、IRR に対応する `.pending_irq` はクリアしておきま"
"す。 ゲストが割り込みを処理可能であることは既に確認済みのため、VM Entry 直後"
"にゲストの割り込みハンドラが呼び出されます。"

#: src/vmm/intr_injection.md:394
msgid "割り込みの受け入れ"
msgstr "割り込みの受け入れ"

#: src/vmm/intr_injection.md:396
msgid ""
"割り込みによる VM Exit のためのハンドラを定義し、そこから `injectExtIntr()` "
"を呼び出します。 ここで大事なこととして、**ゲストを起動する直前から Ymir は原"
"則として割り込み禁止モードで動作しています**。 これはゲストの実行中に VM "
"Exit が発生してホストに処理が戻ってきても、このままではホストは割り込みに気が"
"つくことができないということを意味します。 割り込みに気が付かないため当然 "
"Subscriber が呼び出されることもありません。"
msgstr ""
"割り込みによる VM Exit のためのハンドラを定義し、そこから `injectExtIntr()` "
"を呼び出します。 ここで大事なこととして、**ゲストを起動する直前から Ymir は原"
"則として割り込み禁止モードで動作しています**。 これはゲストの実行中に VM "
"Exit が発生してホストに処理が戻ってきても、このままではホストは割り込みに気が"
"つくことができないということを意味します。 割り込みに気が付かないため当然 "
"Subscriber が呼び出されることもありません。"

#: src/vmm/intr_injection.md:401
msgid ""
"そこで、割り込みで VM Exit が発生した場合には **一時的に Ymir で割り込みを許"
"可して割り込みを受け入れてあげる** 必要があります。 `handleExit()` の "
"`switch` に割り込み用の処理を追加します:"
msgstr ""
"そこで、割り込みで VM Exit が発生した場合には **一時的に Ymir で割り込みを許"
"可して割り込みを受け入れてあげる** 必要があります。 `handleExit()` の "
"`switch` に割り込み用の処理を追加します:"

#: src/vmm/intr_injection.md:419
msgid ""
"[STI](https://www.felixcloutier.com/x86/sti) によって `RFLAGS.IF` をセットし"
"割り込みを許可します。 なお、**実際には STI の次の instruction boundary まで"
"割り込みは無効化されたまま** です。 割り込みが有効になるまで、1命令分の遅れが"
"存在します。 これは、割り込みを禁止する関数において、 `sti; ret;` のように関"
"数から返る直前で割り込みを許可できるようにするために設計されたようです。 この"
"遅れを考慮して、STI の直後には NOP を置いておきます。 これにより、NOP の実行"
"から次の STI の実行までの間に割り込みを受け入れることができる期間が確保されま"
"す。 この間にもし溜まっている割り込みがあれば CPU は割り込みハンドラを呼び出"
"し、Subscriber が `.pending_irq` をセットします。 割り込みを受け入れたら "
"[CLI](https://www.felixcloutier.com/x86/cli) で再び割り込みを禁止します。"
msgstr ""
"[STI](https://www.felixcloutier.com/x86/sti) によって `RFLAGS.IF` をセットし"
"割り込みを許可します。 なお、**実際には STI の次の instruction boundary まで"
"割り込みは無効化されたまま** です。 割り込みが有効になるまで、1命令分の遅れが"
"存在します。 これは、割り込みを禁止する関数において、 `sti; ret;` のように関"
"数から返る直前で割り込みを許可できるようにするために設計されたようです。 この"
"遅れを考慮して、STI の直後には NOP を置いておきます。 これにより、NOP の実行"
"から次の STI の実行までの間に割り込みを受け入れることができる期間が確保されま"
"す。 この間にもし溜まっている割り込みがあれば CPU は割り込みハンドラを呼び出"
"し、Subscriber が `.pending_irq` をセットします。 割り込みを受け入れたら "
"[CLI](https://www.felixcloutier.com/x86/cli) で再び割り込みを禁止します。"

#: src/vmm/intr_injection.md:428
msgid "HLT"
msgstr "HLT"

#: src/vmm/intr_injection.md:430
msgid ""
"おまけで HLT 命令に対する VM Exit を実装します。 [HLT](https://www."
"felixcloutier.com/x86/hlt) は割り込みが発生するまで CPU を停止します。 ゲスト"
"が HLT を実行した際に VM Exit が発生するかどうかは VMCS の **Primary "
"Processor-Based VM-Execution Controls** によって制御されます。 現在は設定して"
"いないため、HLT による VM Exit は発生しません。 しかし、これでは不都合が発生"
"する可能性があります。 `.pending_irq` に割り込みが積まれている状態でゲストが "
"HLT を実行し割り込みが来るのを期待していると仮定します。 このとき、期待されて"
"いる割り込みは実際には発生したあとであり、ホストが注入するタイミングを伺って"
"いる最中です。 現在は割り込みによる VM Exit の場合にしか割り込みを注入しない"
"ため、割り込みが発生しない限りは HLT 後に VM Exit が発生することがなく、割り"
"込みを注入することができません。"
msgstr ""
"おまけで HLT 命令に対する VM Exit を実装します。 [HLT](https://www."
"felixcloutier.com/x86/hlt) は割り込みが発生するまで CPU を停止します。 ゲスト"
"が HLT を実行した際に VM Exit が発生するかどうかは VMCS の **Primary "
"Processor-Based VM-Execution Controls** によって制御されます。 現在は設定して"
"いないため、HLT による VM Exit は発生しません。 しかし、これでは不都合が発生"
"する可能性があります。 `.pending_irq` に割り込みが積まれている状態でゲストが "
"HLT を実行し割り込みが来るのを期待していると仮定します。 このとき、期待されて"
"いる割り込みは実際には発生したあとであり、ホストが注入するタイミングを伺って"
"いる最中です。 現在は割り込みによる VM Exit の場合にしか割り込みを注入しない"
"ため、割り込みが発生しない限りは HLT 後に VM Exit が発生することがなく、割り"
"込みを注入することができません。"

#: src/vmm/intr_injection.md:439
msgid ""
"対策としてはいろいろな方法が考えられます。 1つ目は **VMX-Preemption "
"Timer**[^preemp-timer] を設定するという方法です。 この値を VMCS にセットする"
"と VMX Non-root Operation にいる間セットした値のカウントダウンがされます。 カ"
"ウントが 0 になると VM Exit が発生します。 これによって割り込みなどの有無によ"
"らず定期的に VM Exit を発生させることができます。 2つ目は、`.pending_irq` に "
"IRQ が積まれている間は 1 命令ごとに VM Exit を発生させるという方法です。 "
"**Monitor Trap Flag**[^mtf] をセットすることで、(基本的に)1命令ごとに VM "
"Exit が発生するようになります。 ステップ実行のような感じです。"
msgstr ""
"対策としてはいろいろな方法が考えられます。 1つ目は **VMX-Preemption "
"Timer**[^preemp-timer] を設定するという方法です。 この値を VMCS にセットする"
"と VMX Non-root Operation にいる間セットした値のカウントダウンがされます。 カ"
"ウントが 0 になると VM Exit が発生します。 これによって割り込みなどの有無によ"
"らず定期的に VM Exit を発生させることができます。 2つ目は、`.pending_irq` に "
"IRQ が積まれている間は 1 命令ごとに VM Exit を発生させるという方法です。 "
"**Monitor Trap Flag**[^mtf] をセットすることで、(基本的に)1命令ごとに VM "
"Exit が発生するようになります。 ステップ実行のような感じです。"

#: src/vmm/intr_injection.md:448
msgid ""
"Ymir では他の方法として、HLT 命令の際に `.pending_irq` に IRQ が積まれていれ"
"ば割り込みを注入するという方針にします。 HLT が実行されたらホスト側で代わり"
"に HLT をします。 その際、STI をして割り込み許可モードにしてから HLT を実行"
"し、Subscribers によって `.pending_irq` がセットされるまで待ちます:"
msgstr ""
"Ymir では他の方法として、HLT 命令の際に `.pending_irq` に IRQ が積まれていれ"
"ば割り込みを注入するという方針にします。 HLT が実行されたらホスト側で代わり"
"に HLT をします。 その際、STI をして割り込み許可モードにしてから HLT を実行"
"し、Subscribers によって `.pending_irq` がセットされるまで待ちます:"

#: src/vmm/intr_injection.md:470
msgid ""
"最後に Primary Processor-Based VM-Execution Controls を設定して HLT による "
"VM Exit を有効化します:"
msgstr ""
"最後に Primary Processor-Based VM-Execution Controls を設定して HLT による "
"VM Exit を有効化します:"

#: src/vmm/intr_injection.md:483
msgid ""
"本チャプターでは、Ymir とゲストの両方が割り込みを受け取るための仕組みを実装し"
"ました。 割り込みに対して Subscriber という形でゲストに注入する割り込みを記憶"
"できるようにしました。 記憶された割り込みは、ゲストが割り込みを受け取る準備が"
"できている場合に VM-Entry Interrupt-Information を設定することで注入されま"
"す。"
msgstr ""
"本チャプターでは、Ymir とゲストの両方が割り込みを受け取るための仕組みを実装し"
"ました。 割り込みに対して Subscriber という形でゲストに注入する割り込みを記憶"
"できるようにしました。 記憶された割り込みは、ゲストが割り込みを受け取る準備が"
"できている場合に VM-Entry Interrupt-Information を設定することで注入されま"
"す。"

#: src/vmm/intr_injection.md:487
msgid ""
"さて、前チャプターでは `early exception` によってあまり起動が進みませんでした"
"が、今回の実装によってどこまで進むようになったでしょうか。 ゲストを動かして確"
"かめてみましょう:"
msgstr ""
"さて、前チャプターでは `early exception` によってあまり起動が進みませんでした"
"が、今回の実装によってどこまで進むようになったでしょうか。 ゲストを動かして確"
"かめてみましょう:"

#: src/vmm/intr_injection.md:527
msgid ""
"無事に `jiffies` ループを通過したようです。 そのまま初期化は進み、最後は嬉し"
"いことに `/dev/root: Can't open blockdev` でアボートしています。 これは、ゲス"
"トがファイルシステムとして **initramfs** を読み込もうとしたものの、initramfs "
"が見つからなかったというログです。 ついに FS をロードするところまで起動が完了"
"しました。 あとは initramfs をメモリに読み込んで、FS 内のプログラムを起動し"
"て PID 1 のプロセスを起動するだけです。 いよいよ終わりが近づいてきました。 次"
"回は initramfs のロードを実装します。"
msgstr ""
"無事に `jiffies` ループを通過したようです。 そのまま初期化は進み、最後は嬉し"
"いことに `/dev/root: Can't open blockdev` でアボートしています。 これは、ゲス"
"トがファイルシステムとして **initramfs** を読み込もうとしたものの、initramfs "
"が見つからなかったというログです。 ついに FS をロードするところまで起動が完了"
"しました。 あとは initramfs をメモリに読み込んで、FS 内のプログラムを起動し"
"て PID 1 のプロセスを起動するだけです。 いよいよ終わりが近づいてきました。 次"
"回は initramfs のロードを実装します。"

#: src/vmm/intr_injection.md:535
msgid "_SDM Vol.3C 26.5.1 VMX-Preemption Timer_"
msgstr "_SDM Vol.3C 26.5.1 VMX-Preemption Timer_"

#: src/vmm/intr_injection.md:536
msgid "_SDM Vol.3C 26.5.2 Monitor Trap Flag_"
msgstr "_SDM Vol.3C 26.5.2 Monitor Trap Flag_"

#: src/vmm/initramfs.md:3
msgid ""
"前チャプターではゲストが initramfs を読み込もうとするところまでブートが進みま"
"した。 欲しいのならば、あげましょう。 本チャプターでは、Linux にロードさせる"
"ための initramfs を用意し、Surtr と Ymir が連携してゲストのメモリ空間にロード"
"します。 先にネタバレしてしまうと、このチャプターを終えることでゲスト Linux "
"が完全に起動するようになります。 ネタバレしてごめんね。"
msgstr ""
"前チャプターではゲストが initramfs を読み込もうとするところまでブートが進みま"
"した。 欲しいのならば、あげましょう。 本チャプターでは、Linux にロードさせる"
"ための initramfs を用意し、Surtr と Ymir が連携してゲストのメモリ空間にロード"
"します。 先にネタバレしてしまうと、このチャプターを終えることでゲスト Linux "
"が完全に起動するようになります。 ネタバレしてごめんね。"

#: src/vmm/initramfs.md:11
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-initramfs`]"
#| "(https://github.com/smallkirby/ymir/tree/whiz-vmm-initramfs) ブランチにあ"
#| "ります。"
msgid ""
"本チャプターの最終コードは [`whiz-vmm-initramfs`](https://github.com/"
"smallkirby/ymir/tree/whiz-vmm-initramfs) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-initramfs`](https://"
"github.com/smallkirby/ymir/tree/whiz-vmm-initramfs) ブランチにあります。"

#: src/vmm/initramfs.md:15
msgid "[initramfs の作成](#initramfs-の作成)"
msgstr "[initramfs の作成](#initramfs-の作成)"

#: src/vmm/initramfs.md:16
msgid "[Surtr による initramfs のロード](#surtr-による-initramfs-のロード)"
msgstr "[Surtr による initramfs のロード](#surtr-による-initramfs-のロード)"

#: src/vmm/initramfs.md:17
msgid "[ゲストへの initramfs の渡し方](#ゲストへの-initramfs-の渡し方)"
msgstr "[ゲストへの initramfs の渡し方](#ゲストへの-initramfs-の渡し方)"

#: src/vmm/initramfs.md:20
msgid "initramfs の作成"
msgstr "initramfs の作成"

#: src/vmm/initramfs.md:24
#, fuzzy
#| msgid ""
#| "\\[!TIP\\] ショートカット 自分で initramfs を生成するのがめんどうな人用"
#| "に、以下の手順で生成した FS イメージを [こちら](https://r2.hv.smallkirby."
#| "com/rootfs.cpio.gz) からダウンロードすることができます。"
msgid ""
"自分で initramfs を生成するのがめんどうな人用に、以下の手順で生成した FS イ"
"メージを [こちら](https://r2.hv.smallkirby.com/rootfs.cpio.gz) からダウンロー"
"ドすることができます。"
msgstr ""
"\\[!TIP\\] ショートカット 自分で initramfs を生成するのがめんどうな人用に、以"
"下の手順で生成した FS イメージを [こちら](https://r2.hv.smallkirby.com/"
"rootfs.cpio.gz) からダウンロードすることができます。"

#: src/vmm/initramfs.md:26
msgid ""
"**initramfs** はメモリ上に展開される RAM FS の一種です。 ディレクトリとファイ"
"ルが単純に [cpio](https://en.wikipedia.org/wiki/Cpio) 圧縮 (+ gzib) された簡"
"単な構造をしています。 Linux はカーネル自体が initramfs を操作するための機能"
"を持っており、他の FS をマウントしていない間の一時的な FS として利用すること"
"ができます。 この initramfs からカーネルモジュールをロードし、そのモジュール"
"を使って実際のルートファイルシステムをマウントしたりします。 Ymir では簡単の"
"ために initramfs をずっと使用し、他の FS は一切使用しません。"
msgstr ""
"**initramfs** はメモリ上に展開される RAM FS の一種です。 ディレクトリとファイ"
"ルが単純に [cpio](https://en.wikipedia.org/wiki/Cpio) 圧縮 (+ gzib) された簡"
"単な構造をしています。 Linux はカーネル自体が initramfs を操作するための機能"
"を持っており、他の FS をマウントしていない間の一時的な FS として利用すること"
"ができます。 この initramfs からカーネルモジュールをロードし、そのモジュール"
"を使って実際のルートファイルシステムをマウントしたりします。 Ymir では簡単の"
"ために initramfs をずっと使用し、他の FS は一切使用しません。"

#: src/vmm/initramfs.md:32
msgid ""
"まずはゲストがロードするための initramfs を作成します。 initramfs を作成する"
"方法は色々とありますが、ここでは [buildroot](https://buildroot.org/) を使用す"
"ることにします。 buildroot は組み込み用 Linux をビルドするためのツールチェイ"
"ンですが、ここではファイルシステムを生成するためだけに使います。 [buildroot "
"のダウンロードページ](https://buildroot.org/download.html) から適当なバージョ"
"ンをダウンロードし、解凍してください。 解凍したディレクトリで、`make "
"menuconfig` でコンフィグを設定します。 今回は Linux カーネル自体はビルドする"
"必要がないため、`BR2_LINUX_KERNEL` はオフにします。 その後、以下のオプション"
"を有効にして cpio 形式の initramfs を生成するようにします:"
msgstr ""
"まずはゲストがロードするための initramfs を作成します。 initramfs を作成する"
"方法は色々とありますが、ここでは [buildroot](https://buildroot.org/) を使用す"
"ることにします。 buildroot は組み込み用 Linux をビルドするためのツールチェイ"
"ンですが、ここではファイルシステムを生成するためだけに使います。 [buildroot "
"のダウンロードページ](https://buildroot.org/download.html) から適当なバージョ"
"ンをダウンロードし、解凍してください。 解凍したディレクトリで、`make "
"menuconfig` でコンフィグを設定します。 今回は Linux カーネル自体はビルドする"
"必要がないため、`BR2_LINUX_KERNEL` はオフにします。 その後、以下のオプション"
"を有効にして cpio 形式の initramfs を生成するようにします:"

#: src/vmm/initramfs.md:40
msgid ""
"![cpio the root filesystem (for use as an initial RAM filesystem)](../assets/"
"buildroot.png) _cpio the root filesystem (for use as an initial RAM "
"filesystem)_"
msgstr ""
"![cpio the root filesystem (for use as an initial RAM filesystem)](../assets/"
"buildroot.png) _cpio the root filesystem (for use as an initial RAM "
"filesystem)_"

#: src/vmm/initramfs.md:43
msgid ""
"`make` を実行し、ファイルシステムを生成します。 ファイルは `./output/images/"
"rootfs.cpio` に出力されます。 cpio ファイルは、以下の手順で展開および圧縮する"
"ことができます[^lysithea]:"
msgstr ""
"`make` を実行し、ファイルシステムを生成します。 ファイルは `./output/images/"
"rootfs.cpio` に出力されます。 cpio ファイルは、以下の手順で展開および圧縮する"
"ことができます[^lysithea]:"

#: src/vmm/initramfs.md:57
msgid ""
"Linux はカーネルのブート後に FS の `/init` を実行します。 `/init` は `/sbin/"
"init` を PID 1 のプロセスとして呼び出し、`/sbin/init` は `/etc/init.d/rcS` を"
"実行します。 `rcS` は `/etc/init.d/` に置いてある `S` で始まるスクリプトを順"
"番にサブプロセスで実行します。"
msgstr ""
"Linux はカーネルのブート後に FS の `/init` を実行します。 `/init` は `/sbin/"
"init` を PID 1 のプロセスとして呼び出し、`/sbin/init` は `/etc/init.d/rcS` を"
"実行します。 `rcS` は `/etc/init.d/` に置いてある `S` で始まるスクリプトを順"
"番にサブプロセスで実行します。"

#: src/vmm/initramfs.md:61
msgid ""
"出力された initramfs を展開し、中から余計な起動スクリプトを消してあげます。 "
"本シリーズではネットワークはサポートしないため、ネットワーク関連のスクリプト"
"を削除しましょう:"
msgstr ""
"出力された initramfs を展開し、中から余計な起動スクリプトを消してあげます。 "
"本シリーズではネットワークはサポートしないため、ネットワーク関連のスクリプト"
"を削除しましょう:"

#: src/vmm/initramfs.md:70
msgid "また、以下の起動スクリプトを代わりに `S999whiz` として追加します:"
msgstr "また、以下の起動スクリプトを代わりに `S999whiz` として追加します:"

#: src/vmm/initramfs.md:86
msgid "最終的には以下のようなディレクトリ構造になります:"
msgstr "最終的には以下のようなディレクトリ構造になります:"

#: src/vmm/initramfs.md:101
msgid ""
"以上の準備が終わったら、`rootfs.cpio` を gzip 圧縮して `rootfs.cpio.gz` にし"
"てあげ、 Ymir カーネルが置いてある `zig-out/img` ディレクトリにコピーしておい"
"てください:"
msgstr ""
"以上の準備が終わったら、`rootfs.cpio` を gzip 圧縮して `rootfs.cpio.gz` にし"
"てあげ、 Ymir カーネルが置いてある `zig-out/img` ディレクトリにコピーしておい"
"てください:"

#: src/vmm/initramfs.md:116
msgid "Surtr による initramfs のロード"
msgstr "Surtr による initramfs のロード"

#: src/vmm/initramfs.md:118
msgid ""
"`bzImage` をメモリにロードした際と同様に、`rootfs.cpio.gz` をメモリにロードし"
"て Ymir に渡すのは Surtr の役割です。 `boot.zig` に `rootfs.cpio.gz` 用のメモ"
"リ領域の確保とロードを行うコードを追加します:"
msgstr ""
"`bzImage` をメモリにロードした際と同様に、`rootfs.cpio.gz` をメモリにロードし"
"て Ymir に渡すのは Surtr の役割です。 `boot.zig` に `rootfs.cpio.gz` 用のメモ"
"リ領域の確保とロードを行うコードを追加します:"

#: src/vmm/initramfs.md:141
msgid ""
"また、Surtr から Ymir に渡す情報である `GuestInfo` に initramfs をロードした"
"場所に関する情報を追加します:"
msgstr ""
"また、Surtr から Ymir に渡す情報である `GuestInfo` に initramfs をロードした"
"場所に関する情報を追加します:"

#: src/vmm/initramfs.md:154
msgid "Surtr が Ymir に処理を移す際に initramfs の情報を埋めてあげます:"
msgstr "Surtr が Ymir に処理を移す際に initramfs の情報を埋めてあげます:"

#: src/vmm/initramfs.md:169
msgid ""
"以上で Surtr が initramfs をメモリにロードし、その情報を Ymir に渡すことがで"
"きました。 Ymir 側で渡された情報を見ることができるか確認してみましょう。 "
"`kernelMain()` に以下のコードを追加します。 Surtr から渡される initramfs のア"
"ドレスは物理アドレスであるため、 `phys2virt()` で仮想アドレスに変換する必要が"
"あることに注意してください:"
msgstr ""
"以上で Surtr が initramfs をメモリにロードし、その情報を Ymir に渡すことがで"
"きました。 Ymir 側で渡された情報を見ることができるか確認してみましょう。 "
"`kernelMain()` に以下のコードを追加します。 Surtr から渡される initramfs のア"
"ドレスは物理アドレスであるため、 `phys2virt()` で仮想アドレスに変換する必要が"
"あることに注意してください:"

#: src/vmm/initramfs.md:183
msgid "ゲストへの initramfs の渡し方"
msgstr "ゲストへの initramfs の渡し方"

#: src/vmm/initramfs.md:185
msgid ""
"x86 Linux のブートプロトコルで利用される `BootParams` 内の `SetupHeader` に"
"は、initramfs の物理アドレスとサイズを指定するためのフィールドがあります。 ゲ"
"ストメモリの適当なアドレスに initramfs をロードし、そのアドレスとサイズを "
"`SetupHeader` に設定することで、 Linux カーネルが initramfs を認識し、マウン"
"トすることがでるようになります。 本シリーズでは initramfs は `0x0600_0000` に"
"ロードすることにします:"
msgstr ""
"x86 Linux のブートプロトコルで利用される `BootParams` 内の `SetupHeader` に"
"は、initramfs の物理アドレスとサイズを指定するためのフィールドがあります。 ゲ"
"ストメモリの適当なアドレスに initramfs をロードし、そのアドレスとサイズを "
"`SetupHeader` に設定することで、 Linux カーネルが initramfs を認識し、マウン"
"トすることがでるようになります。 本シリーズでは initramfs は `0x0600_0000` に"
"ロードすることにします:"

#: src/vmm/initramfs.md:198
msgid "`loadKernel()` で initramfs をロードします:"
msgstr "`loadKernel()` で initramfs をロードします:"

#: src/vmm/initramfs.md:214
msgid ""
"本チャプターでは initramfs を作成し、Surtr にロードしてもらった後ゲストに渡し"
"ました。 ゲストを動かしてみましょう:"
msgstr ""
"本チャプターでは initramfs を作成し、Surtr にロードしてもらった後ゲストに渡し"
"ました。 ゲストを動かしてみましょう:"

#: src/vmm/initramfs.md:252
msgid ""
"**ついに！Linux が！起動しました！** 仮想化されたシリアルによる入力も受け付け"
"ており、自由にシェルを操作することができます！ ここまで合計30チャプター近くも"
"ある長い道のりでしたが、いよいよゲストを動かすことができました。 おもちゃレベ"
"ルではあるものの、これで \"Hypervisor\" と呼べるものができたのではないでしょ"
"うか。 次のチャプターでは、おまけとして [VMCALL](https://www.felixcloutier."
"com/x86/vmcall) を実装してゲストから VMM の機能を呼び出す仕組みを実装し、本シ"
"リーズを締めくくろうと思います。"
msgstr ""
"**ついに！Linux が！起動しました！** 仮想化されたシリアルによる入力も受け付け"
"ており、自由にシェルを操作することができます！ ここまで合計30チャプター近くも"
"ある長い道のりでしたが、いよいよゲストを動かすことができました。 おもちゃレベ"
"ルではあるものの、これで \"Hypervisor\" と呼べるものができたのではないでしょ"
"うか。 次のチャプターでは、おまけとして [VMCALL](https://www.felixcloutier."
"com/x86/vmcall) を実装してゲストから VMM の機能を呼び出す仕組みを実装し、本シ"
"リーズを締めくくろうと思います。"

#: src/vmm/initramfs.md:258
msgid ""
"このへんの操作を自動化する筆者謹製のスクリプト [smallkirby/lysithea](https://"
"github.com/smallkirby/lysithea) があるので、興味がある人は使ってみてくださ"
"い。"
msgstr ""
"このへんの操作を自動化する筆者謹製のスクリプト [smallkirby/lysithea](https://"
"github.com/smallkirby/lysithea) があるので、興味がある人は使ってみてくださ"
"い。"

#: src/vmm/vmcall.md:1
msgid "VMCALL Service"
msgstr "VMCALL Service"

#: src/vmm/vmcall.md:3
msgid ""
"本チャプターは、Writing Hypervisor in Zig におけるとりあえずの最終章です。 今"
"後も気が向いたら加筆される可能性はありますが、一旦本チャプターを持って締めく"
"くろうと思います。 本チャプターはエクストラステージとして、VMCALL を使った "
"VMCALL Service を実装します。 かなりコンパクトなチャプターです。 VMCALL "
"Service を活用することで、ゲストがホストに対して何らかの要求をしたり、逆にホ"
"ストがゲストの情報を取得することができるようになります。 本チャプターではそれ"
"らを実装するための基盤を作ります。"
msgstr ""
"本チャプターは、Writing Hypervisor in Zig におけるとりあえずの最終章です。 今"
"後も気が向いたら加筆される可能性はありますが、一旦本チャプターを持って締めく"
"くろうと思います。 本チャプターはエクストラステージとして、VMCALL を使った "
"VMCALL Service を実装します。 かなりコンパクトなチャプターです。 VMCALL "
"Service を活用することで、ゲストがホストに対して何らかの要求をしたり、逆にホ"
"ストがゲストの情報を取得することができるようになります。 本チャプターではそれ"
"らを実装するための基盤を作ります。"

#: src/vmm/vmcall.md:12
#, fuzzy
#| msgid ""
#| "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-vmcall`](https://"
#| "github.com/smallkirby/ymir/tree/whiz-vmm-vmcall) ブランチにあります。"
msgid ""
"本チャプターの最終コードは [`whiz-vmm-vmcall`](https://github.com/smallkirby/"
"ymir/tree/whiz-vmm-vmcall) ブランチにあります。"
msgstr ""
"\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-vmm-vmcall`](https://"
"github.com/smallkirby/ymir/tree/whiz-vmm-vmcall) ブランチにあります。"

#: src/vmm/vmcall.md:16
msgid "[VMCALL 概要](#vmcall-概要)"
msgstr "[VMCALL 概要](#vmcall-概要)"

#: src/vmm/vmcall.md:17
msgid "[VMCALL Service の実装](#vmcall-service-の実装)"
msgstr "[VMCALL Service の実装](#vmcall-service-の実装)"

#: src/vmm/vmcall.md:18
msgid "[ymirsh](#ymirsh)"
msgstr "[ymirsh](#ymirsh)"

#: src/vmm/vmcall.md:21
msgid "VMCALL 概要"
msgstr "VMCALL 概要"

#: src/vmm/vmcall.md:23
msgid ""
"[VMCALL](https://www.felixcloutier.com/x86/vmcall) はゲストから VMM の機能を"
"呼び出すための命令です。 VMM の機能を呼び出すとは言ったものの、**この命令は "
"VM Exit を発生させる以外には何もしません**。 VMCALL による VM Exit は、Basic "
"Reason が `VMCALL(18)` となります。 VM Exit したあとに何をするかは完全に VMM "
"の実装依存です。"
msgstr ""
"[VMCALL](https://www.felixcloutier.com/x86/vmcall) はゲストから VMM の機能を"
"呼び出すための命令です。 VMM の機能を呼び出すとは言ったものの、**この命令は "
"VM Exit を発生させる以外には何もしません**。 VMCALL による VM Exit は、Basic "
"Reason が `VMCALL(18)` となります。 VM Exit したあとに何をするかは完全に VMM "
"の実装依存です。"

#: src/vmm/vmcall.md:28
msgid ""
"Ymir ではお試しとして VMCALL サービスを1つだけ提供します。 この VMCALL が呼び"
"出されると、Ymir はロゴとメッセージをシリアル出力するようにします。"
msgstr ""
"Ymir ではお試しとして VMCALL サービスを1つだけ提供します。 この VMCALL が呼び"
"出されると、Ymir はロゴとメッセージをシリアル出力するようにします。"

#: src/vmm/vmcall.md:33
#, fuzzy
#| msgid ""
#| "\\[!NOTE\\] VMCALL と仮想化の隠蔽 VMCALL は VMX 拡張命令であり、VMX "
#| "Operation でない場合に呼び出すと `#UD: Invalid Opcode` 例外が発生します。 "
#| "セキュリティ的な理由でゲストにゲスト自身が仮想化されていることを隠したい場"
#| "合には、この挙動を真似て VMCALL の呼び出し時に `#UD` 例外を発生させる必要"
#| "があります。 例外の挿入は [割り込みの注入のチャプター](./intr_injection."
#| "md) で扱ったように VM-Entry Interruption-Information を設定することで可能"
#| "です。"
msgid ""
"VMCALL は VMX 拡張命令であり、VMX Operation でない場合に呼び出すと `#UD: "
"Invalid Opcode` 例外が発生します。 セキュリティ的な理由でゲストにゲスト自身が"
"仮想化されていることを隠したい場合には、この挙動を真似て VMCALL の呼び出し時"
"に `#UD` 例外を発生させる必要があります。 例外の挿入は [割り込みの注入のチャ"
"プター](./intr_injection.md) で扱ったように VM-Entry Interruption-"
"Information を設定することで可能です。"
msgstr ""
"\\[!NOTE\\] VMCALL と仮想化の隠蔽 VMCALL は VMX 拡張命令であり、VMX "
"Operation でない場合に呼び出すと `#UD: Invalid Opcode` 例外が発生します。 セ"
"キュリティ的な理由でゲストにゲスト自身が仮想化されていることを隠したい場合に"
"は、この挙動を真似て VMCALL の呼び出し時に `#UD` 例外を発生させる必要がありま"
"す。 例外の挿入は [割り込みの注入のチャプター](./intr_injection.md) で扱った"
"ように VM-Entry Interruption-Information を設定することで可能です。"

#: src/vmm/vmcall.md:37
msgid "VMCALL Service の実装"
msgstr "VMCALL Service の実装"

#: src/vmm/vmcall.md:39
msgid ""
"VMCALL サービスを定義していきます。 VMCALL は命令自体は引数も何も持たず、"
"calling convention を VMM 側で定義する必要があります。 Ymir では **RAX に "
"VMCALL Service の番号を入れて呼び出すという規約** にします。 VMCALL Service "
"の `0` には `hello` という名前をつけて、ロゴとメッセージを出力するようにしま"
"す:"
msgstr ""
"VMCALL サービスを定義していきます。 VMCALL は命令自体は引数も何も持たず、"
"calling convention を VMM 側で定義する必要があります。 Ymir では **RAX に "
"VMCALL Service の番号を入れて呼び出すという規約** にします。 VMCALL Service "
"の `0` には `hello` という名前をつけて、ロゴとメッセージを出力するようにしま"
"す:"

#: src/vmm/vmcall.md:63
msgid ""
"`vmcHello()` はロゴを出力するだけの簡単な関数です。 ここでは [Text to ASCII "
"Art Generator (TAAG)](https://patorjk.com/software/taag/"
"#p=display&f=Flower%20Power&t=) で生成したロゴを使います:"
msgstr ""
"`vmcHello()` はロゴを出力するだけの簡単な関数です。 ここでは [Text to ASCII "
"Art Generator (TAAG)](https://patorjk.com/software/taag/"
"#p=display&f=Flower%20Power&t=) で生成したロゴを使います:"

#: src/vmm/vmcall.md:86
msgid "ymirsh"
msgstr "ymirsh"

#: src/vmm/vmcall.md:88
msgid ""
"最後に、VMCALL を呼び出すためのユーザランドプログラムを実装します。 _Writing "
"Hypervisor in Zig_ で書く最後のプログラムがユーザランドというのはなんともまた"
"皮肉な話です。 新しく `ymirsh` というディレクトリを作成し、VMCALL をするだけ"
"のプログラムを書きます:"
msgstr ""
"最後に、VMCALL を呼び出すためのユーザランドプログラムを実装します。 _Writing "
"Hypervisor in Zig_ で書く最後のプログラムがユーザランドというのはなんともまた"
"皮肉な話です。 新しく `ymirsh` というディレクトリを作成し、VMCALL をするだけ"
"のプログラムを書きます:"

#: src/vmm/vmcall.md:109
msgid ""
"先ほど決めたように、VMCALL Service の番号は RAX に入れて呼び出します。 それ以"
"外は何もしません。"
msgstr ""
"先ほど決めたように、VMCALL Service の番号は RAX に入れて呼び出します。 それ以"
"外は何もしません。"

#: src/vmm/vmcall.md:112
msgid ""
"`build.zig` に `ymirsh` をビルドするための設定を追記します。 これまで書いてき"
"た Surtr や Ymir とは異なり、`ymirsh` はユーザランドプログラムなので `."
"os_tag = .linux` を指定します:"
msgstr ""
"`build.zig` に `ymirsh` をビルドするための設定を追記します。 これまで書いてき"
"た Surtr や Ymir とは異なり、`ymirsh` はユーザランドプログラムなので `."
"os_tag = .linux` を指定します:"

#: src/vmm/vmcall.md:132
msgid ""
"`zig build install` でビルドすると `zig-out/bin/ymirsh` が生成されます。 これ"
"を `rootfs.cpio.gz` の中の FS における `/bin` 以下に配置してあげれば準備は完"
"了です。"
msgstr ""
"`zig build install` でビルドすると `zig-out/bin/ymirsh` が生成されます。 これ"
"を `rootfs.cpio.gz` の中の FS における `/bin` 以下に配置してあげれば準備は完"
"了です。"

#: src/vmm/vmcall.md:137
msgid ""
"以上で VMCALL Service の実装は終了です。 最後にゲスト及び `ymirsh` を実行して"
"みましょう:"
msgstr ""
"以上で VMCALL Service の実装は終了です。 最後にゲスト及び `ymirsh` を実行して"
"みましょう:"

#: src/vmm/vmcall.md:164
msgid ""
"`ymirsh` が VMCALL を実行すると、サービス0番の `hello` が呼び出されてロゴと"
"メッセージが出力されました。 今まで Ymir がしてきたログ出力と見た目はなんら変"
"わりませんが、このログはゲストに明示的に要求されて出力されているという違いが"
"あります。"
msgstr ""
"`ymirsh` が VMCALL を実行すると、サービス0番の `hello` が呼び出されてロゴと"
"メッセージが出力されました。 今まで Ymir がしてきたログ出力と見た目はなんら変"
"わりませんが、このログはゲストに明示的に要求されて出力されているという違いが"
"あります。"

#: src/vmm/vmcall.md:167
msgid ""
"本チャプターでは VMCALL Service の実装をしました。 実装した機能はログ出力をす"
"るだけのほぼ意味がないものでしたが、この枠組みを利用してゲストとホストの間で"
"さまざまなやり取りをすることができます。 たとえば [BitVisor](https://www."
"bitvisor.org/) では `dbgsh` というプログラムが VMCALL を介して VMM と対話的に"
"やりとりをするシェルを提供しています。 他には、起動時に VMCALL を使って "
"Linux カーネルにおける保護したいメモリアドレスを VMM に通知し、そのアドレス"
"を EPT を使って保護するといった使い方もできます。 基本的にメモリの保護はカー"
"ネル自身がページテーブルを使って行えますが、カーネル自体が攻撃者に掌握された"
"場合にはカーネルのセキュリティ機構は意味をなさなくなってしまいます。 そこで、"
"起動時に一度だけ VMM に保護対象のアドレスを通知することで、カーネルが陥落して"
"も VMM が指定されたメモリを保護することができます。 といったように、VMCALL は"
"使い方次第でいろいろなことが実現できます。 ぜひ自分なりのアイデアを実装してみ"
"てください。"
msgstr ""
"本チャプターでは VMCALL Service の実装をしました。 実装した機能はログ出力をす"
"るだけのほぼ意味がないものでしたが、この枠組みを利用してゲストとホストの間で"
"さまざまなやり取りをすることができます。 たとえば [BitVisor](https://www."
"bitvisor.org/) では `dbgsh` というプログラムが VMCALL を介して VMM と対話的に"
"やりとりをするシェルを提供しています。 他には、起動時に VMCALL を使って "
"Linux カーネルにおける保護したいメモリアドレスを VMM に通知し、そのアドレス"
"を EPT を使って保護するといった使い方もできます。 基本的にメモリの保護はカー"
"ネル自身がページテーブルを使って行えますが、カーネル自体が攻撃者に掌握された"
"場合にはカーネルのセキュリティ機構は意味をなさなくなってしまいます。 そこで、"
"起動時に一度だけ VMM に保護対象のアドレスを通知することで、カーネルが陥落して"
"も VMM が指定されたメモリを保護することができます。 といったように、VMCALL は"
"使い方次第でいろいろなことが実現できます。 ぜひ自分なりのアイデアを実装してみ"
"てください。"

#: src/vmm/vmcall.md:176
msgid ""
"さて、以上で **Writing Hypervisor in Zig** は終了です。 もしもここまで読んで"
"くださった方がいるのであれば、ありがとうございます。 実装してきた Ymir は、依"
"然としておもちゃの域を超えていません。 [トップページ](../intro.md) に書いたよ"
"うに、いろいろな機能が未実装のままです。 しかしながら、Linux をブートできたと"
"いう事実には変わりありません。 Ymir をベースとして、もしくは全てゼロからフル"
"スクラッチで、さらに自分なりの機能を追加してみてください。 その際の足がかりと"
"して Ymir というおもちゃが役立てば幸いです。"
msgstr ""
"さて、以上で **Writing Hypervisor in Zig** は終了です。 もしもここまで読んで"
"くださった方がいるのであれば、ありがとうございます。 実装してきた Ymir は、依"
"然としておもちゃの域を超えていません。 [トップページ](../intro.md) に書いたよ"
"うに、いろいろな機能が未実装のままです。 しかしながら、Linux をブートできたと"
"いう事実には変わりありません。 Ymir をベースとして、もしくは全てゼロからフル"
"スクラッチで、さらに自分なりの機能を追加してみてください。 その際の足がかりと"
"して Ymir というおもちゃが役立てば幸いです。"

#: src/acknowledgement.md:1
msgid "謝辞"
msgstr "Acknowledgment"

#: src/acknowledgement.md:3
msgid ""
"_Writing Hypervisor in Zig_ は以下の方の協力のもと執筆されました。 この場を借"
"りて感謝の意を表します。"
msgstr ""
"_Writing Hypervisor in Zig_ was written with the help of the following "
"people. We would like to take this opportunity to express my appreciation."

#: src/acknowledgement.md:6
msgid "Authors"
msgstr "Authors"

#: src/acknowledgement.md:8
msgid "[@smallkirby](https://github.com/smallkirby)"
msgstr "[@smallkirby](https://github.com/smallkirby)"

#: src/acknowledgement.md:10
msgid "Contributors"
msgstr "Contributors"

#: src/acknowledgement.md:12
msgid "[@gierens](https://github.com/gierens)"
msgstr "[@gierens](https://github.com/gierens)"

#: src/acknowledgement.md:14
msgid "Special Thanks"
msgstr "Special Thanks"

#: src/acknowledgement.md:16
msgid "乾パン"
msgstr "Kanpan"

#: src/acknowledgement.md:18
msgid "![乾パン](./assets/smallkirby/kanpan.jpg)"
msgstr "![乾パン](./assets/smallkirby/kanpan.jpg)"

#: src/license.md:3
msgid ""
"本サイトのコンテンツは以下に示す例外を除いて全て [CC0 1.0 Universal](https://"
"creativecommons.org/publicdomain/zero/1.0/) のもとで配布し、 全ての著作権と関"
"連する権利を放棄します。"
msgstr ""
"All content on this site is distributed under [CC0 1.0 Universal](https://"
"creativecommons.org/publicdomain/zero/1.0/) with the following exceptions, "
"and all copyright and related rights are disclaimed."

#: src/license.md:8
msgid "以下のコンテンツは例外として CC0 1.0 Universal が適用されません:"
msgstr "CC0 1.0 Universal does not apply to the following content:"

#: src/license.md:10
msgid ""
"`/assets/sdm` 以下で配布される画像: © Intel Corporation. All rights reserved."
msgstr ""
"Images distributed unde `/assets/sdm`: © Intel Corporation. All rights "
"reserved."

#: src/license.md:11
msgid ""
"`/assets/linux` 以下で配布される画像: © Copyright The kernel development "
"community."
msgstr ""
"Images distributed under `/assets/linux`: © Copyright The kernel development "
"community."

#: src/license.md:12
msgid ""
"`/assets/smallkirby` 以下で配布される画像: [smallkirby](https://github.com/"
"smallkirby). All rights reserved."
msgstr ""
"Images distributed under `/assets/smallkirby`: [smallkirby](https://github."
"com/smallkirby). All rights reserved."

#: src/license.md:16
msgid ""
"リファレンス実装である [Ymir](https://github.com/smallkirby/ymir) は [MIT "
"License](https://opensource.org/license/mit) で配布されます。 ただし、本サイ"
"トに掲載しているコードのスニペットは CC0 1.0 Universal のもとで配布します。"
msgstr ""
"The reference implementation, [Ymir](https://github.com/smallkirby/ymir), is "
"distributed under the [MIT License](https://opensource.org/license/mit). "
"However, snippets of code used in this blog are distributed under CC0 1.0 "
"Universal."

#~ msgid ""
#~ "```surtr/defs.zig\n"
#~ "pub const magic: usize = 0xDEADBEEF_CAFEBABE;\n"
#~ "\n"
#~ "pub const BootInfo = extern struct {\n"
#~ "    /// Magic number to check if the boot info is valid.\n"
#~ "    magic: usize = magic,\n"
#~ "    /// UEFI memory map.\n"
#~ "    memory_map: MemoryMap,\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/defs.zig\n"
#~ "pub const magic: usize = 0xDEADBEEF_CAFEBABE;\n"
#~ "\n"
#~ "pub const BootInfo = extern struct {\n"
#~ "    /// Magic number to check if the boot info is valid.\n"
#~ "    magic: usize = magic,\n"
#~ "    /// UEFI memory map.\n"
#~ "    memory_map: MemoryMap,\n"
#~ "};\n"
#~ "```"

#~ msgid "\\[!WARNING\\] Stack Overflow からの Triple Fault"
#~ msgstr "\\[!WARNING\\] Stack Overflow からの Triple Fault"

#~ msgid "\\[!NOTE\\] セクションとセグメントの属性"
#~ msgstr "\\[!NOTE\\] セクションとセグメントの属性"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "extern const __stackguard_lower: [*]const u8;\n"
#~ "\n"
#~ "export fn kernelEntry() callconv(.Naked) noreturn {\n"
#~ "    asm volatile (\n"
#~ "        \\\\movq %[new_stack], %%rsp\n"
#~ "        \\\\call kernelTrampoline\n"
#~ "        :\n"
#~ "        : [new_stack] \"r\" (@intFromPtr(&__stackguard_lower) - 0x10),\n"
#~ "    );\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "extern const __stackguard_lower: [*]const u8;\n"
#~ "\n"
#~ "export fn kernelEntry() callconv(.Naked) noreturn {\n"
#~ "    asm volatile (\n"
#~ "        \\\\movq %[new_stack], %%rsp\n"
#~ "        \\\\call kernelTrampoline\n"
#~ "        :\n"
#~ "        : [new_stack] \"r\" (@intFromPtr(&__stackguard_lower) - 0x10),\n"
#~ "    );\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "export fn kernelTrampoline(boot_info: surtr.BootInfo) callconv(.Win64) "
#~ "noreturn {\n"
#~ "    kernelMain(boot_info) catch |err| {\n"
#~ "        @panic(\"Exiting...\");\n"
#~ "    };\n"
#~ "\n"
#~ "    unreachable;\n"
#~ "}\n"
#~ "\n"
#~ "fn kernelMain(boot_info: surtr.BootInfo) !void {\n"
#~ "    while (true) asm volatile(\"hlt\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "export fn kernelTrampoline(boot_info: surtr.BootInfo) callconv(.Win64) "
#~ "noreturn {\n"
#~ "    kernelMain(boot_info) catch |err| {\n"
#~ "        @panic(\"Exiting...\");\n"
#~ "    };\n"
#~ "\n"
#~ "    unreachable;\n"
#~ "}\n"
#~ "\n"
#~ "fn kernelMain(boot_info: surtr.BootInfo) !void {\n"
#~ "    while (true) asm volatile(\"hlt\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```build.zig\n"
#~ "// Modules\n"
#~ "const surtr_module = b.createModule(.{\n"
#~ "    .root_source_file = b.path(\"surtr/defs.zig\"),\n"
#~ "});\n"
#~ "...\n"
#~ "ymir.root_module.addImport(\"surtr\", surtr_module);\n"
#~ "```"
#~ msgstr ""
#~ "```build.zig\n"
#~ "// Modules\n"
#~ "const surtr_module = b.createModule(.{\n"
#~ "    .root_source_file = b.path(\"surtr/defs.zig\"),\n"
#~ "});\n"
#~ "...\n"
#~ "ymir.root_module.addImport(\"surtr\", surtr_module);\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "// Validate the boot info.\n"
#~ "validateBootInfo(boot_info) catch {\n"
#~ "    // 本当はここでログ出力をしたいけど、それはまた次回\n"
#~ "    return error.InvalidBootInfo;\n"
#~ "};\n"
#~ "\n"
#~ "fn validateBootInfo(boot_info: surtr.BootInfo) !void {\n"
#~ "    if (boot_info.magic != surtr.magic) {\n"
#~ "        return error.InvalidMagic;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "// Validate the boot info.\n"
#~ "validateBootInfo(boot_info) catch {\n"
#~ "    // 本当はここでログ出力をしたいけど、それはまた次回\n"
#~ "    return error.InvalidBootInfo;\n"
#~ "};\n"
#~ "\n"
#~ "fn validateBootInfo(boot_info: surtr.BootInfo) !void {\n"
#~ "    if (boot_info.magic != surtr.magic) {\n"
#~ "        return error.InvalidMagic;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/arch.zig\n"
#~ "// `/arch` 以外から使いたいモジュール\n"
#~ "pub const serial = @import(\"serial.zig\");\n"
#~ "// `/arch` 以外に露出したくないモジュール\n"
#~ "const am = @import(\"asm.zig\");\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/arch.zig\n"
#~ "// `/arch` 以外から使いたいモジュール\n"
#~ "pub const serial = @import(\"serial.zig\");\n"
#~ "// `/arch` 以外に露出したくないモジュール\n"
#~ "const am = @import(\"asm.zig\");\n"
#~ "```"

#~ msgid ""
#~ "```ymir/hoge/fuga.zig\n"
#~ "const neko = @import(\"../piyo/neko.zig\");\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/hoge/fuga.zig\n"
#~ "const neko = @import(\"../piyo/neko.zig\");\n"
#~ "```"

#~ msgid ""
#~ "```zig\n"
#~ "const am = @import(\"arch/x86/asm.zig\"); // 本来はアクセスさせたくない\n"
#~ "```"
#~ msgstr ""
#~ "```zig\n"
#~ "const am = @import(\"arch/x86/asm.zig\"); // 本来はアクセスさせたくない\n"
#~ "```"

#~ msgid ""
#~ "```build.zig\n"
#~ "const ymir_module = b.createModule(.{\n"
#~ "    .root_source_file = b.path(\"ymir/ymir.zig\"),\n"
#~ "});\n"
#~ "ymir_module.addImport(\"ymir\", ymir_module);\n"
#~ "ymir_module.addImport(\"surtr\", surtr_module);\n"
#~ "```"
#~ msgstr ""
#~ "```build.zig\n"
#~ "const ymir_module = b.createModule(.{\n"
#~ "    .root_source_file = b.path(\"ymir/ymir.zig\"),\n"
#~ "});\n"
#~ "ymir_module.addImport(\"ymir\", ymir_module);\n"
#~ "ymir_module.addImport(\"surtr\", surtr_module);\n"
#~ "```"

#~ msgid ""
#~ "```build.zig\n"
#~ "ymir.root_module.addImport(\"ymir\", ymir_module);\n"
#~ "```"
#~ msgstr ""
#~ "```build.zig\n"
#~ "ymir.root_module.addImport(\"ymir\", ymir_module);\n"
#~ "```"

#~ msgid ""
#~ "```ymir/ymir.zig\n"
#~ "pub const arch = @import(\"arch.zig\");\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/ymir.zig\n"
#~ "pub const arch = @import(\"arch.zig\");\n"
#~ "```"

#~ msgid ""
#~ "```zig\n"
#~ "// -- ymir/arch/x86/arch.zig --\n"
#~ "pub fn someFunction() void {}\n"
#~ "\n"
#~ "// -- ymir/main.zig --\n"
#~ "const ymir = @import(\"ymir\");\n"
#~ "const arch = ymir.arch;\n"
#~ "arch.someFunction();\n"
#~ "```"
#~ msgstr ""
#~ "```zig\n"
#~ "// -- ymir/arch/x86/arch.zig --\n"
#~ "pub fn someFunction() void {}\n"
#~ "\n"
#~ "// -- ymir/main.zig --\n"
#~ "const ymir = @import(\"ymir\");\n"
#~ "const arch = ymir.arch;\n"
#~ "arch.someFunction();\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/serial.zig\n"
#~ "const offsets = struct {\n"
#~ "    /// Transmitter Holding Buffer: DLAB=0, W\n"
#~ "    pub const txr = 0;\n"
#~ "    /// Receiver Buffer: DLAB=0, R\n"
#~ "    pub const rxr = 0;\n"
#~ "    /// Divisor Latch Low Byte: DLAB=1, R/W\n"
#~ "    pub const dll = 0;\n"
#~ "    /// Interrupt Enable Register: DLAB=0, R/W\n"
#~ "    pub const ier = 1;\n"
#~ "    /// Divisor Latch High Byte: DLAB=1, R/W\n"
#~ "    pub const dlh = 1;\n"
#~ "    /// Interrupt Identification Register: DLAB=X, R\n"
#~ "    pub const iir = 2;\n"
#~ "    /// FIFO Control Register: DLAB=X, W\n"
#~ "    pub const fcr = 2;\n"
#~ "    /// Line Control Register: DLAB=X, R/W\n"
#~ "    pub const lcr = 3;\n"
#~ "    /// Modem Control Register: DLAB=X, R/W\n"
#~ "    pub const mcr = 4;\n"
#~ "    /// Line Status Register: DLAB=X, R\n"
#~ "    pub const lsr = 5;\n"
#~ "    /// Modem Status Register: DLAB=X, R\n"
#~ "    pub const msr = 6;\n"
#~ "    /// Scratch Register: DLAB=X, R/W\n"
#~ "    pub const sr = 7;\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/serial.zig\n"
#~ "const offsets = struct {\n"
#~ "    /// Transmitter Holding Buffer: DLAB=0, W\n"
#~ "    pub const txr = 0;\n"
#~ "    /// Receiver Buffer: DLAB=0, R\n"
#~ "    pub const rxr = 0;\n"
#~ "    /// Divisor Latch Low Byte: DLAB=1, R/W\n"
#~ "    pub const dll = 0;\n"
#~ "    /// Interrupt Enable Register: DLAB=0, R/W\n"
#~ "    pub const ier = 1;\n"
#~ "    /// Divisor Latch High Byte: DLAB=1, R/W\n"
#~ "    pub const dlh = 1;\n"
#~ "    /// Interrupt Identification Register: DLAB=X, R\n"
#~ "    pub const iir = 2;\n"
#~ "    /// FIFO Control Register: DLAB=X, W\n"
#~ "    pub const fcr = 2;\n"
#~ "    /// Line Control Register: DLAB=X, R/W\n"
#~ "    pub const lcr = 3;\n"
#~ "    /// Modem Control Register: DLAB=X, R/W\n"
#~ "    pub const mcr = 4;\n"
#~ "    /// Line Status Register: DLAB=X, R\n"
#~ "    pub const lsr = 5;\n"
#~ "    /// Modem Status Register: DLAB=X, R\n"
#~ "    pub const msr = 6;\n"
#~ "    /// Scratch Register: DLAB=X, R/W\n"
#~ "    pub const sr = 7;\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "pub inline fn inb(port: u16) u8 {\n"
#~ "    return asm volatile (\n"
#~ "        \\\\inb %[port], %[ret]\n"
#~ "        : [ret] \"={al}\" (-> u8),\n"
#~ "        : [port] \"{dx}\" (port),\n"
#~ "    );\n"
#~ "}\n"
#~ "\n"
#~ "pub inline fn outb(value: u8, port: u16) void {\n"
#~ "    asm volatile (\n"
#~ "        \\\\outb %[value], %[port]\n"
#~ "        :\n"
#~ "        : [value] \"{al}\" (value),\n"
#~ "          [port] \"{dx}\" (port),\n"
#~ "    );\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "pub inline fn inb(port: u16) u8 {\n"
#~ "    return asm volatile (\n"
#~ "        \\\\inb %[port], %[ret]\n"
#~ "        : [ret] \"={al}\" (-> u8),\n"
#~ "        : [port] \"{dx}\" (port),\n"
#~ "    );\n"
#~ "}\n"
#~ "\n"
#~ "pub inline fn outb(value: u8, port: u16) void {\n"
#~ "    asm volatile (\n"
#~ "        \\\\outb %[value], %[port]\n"
#~ "        :\n"
#~ "        : [value] \"{al}\" (value),\n"
#~ "          [port] \"{dx}\" (port),\n"
#~ "    );\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/serial.zig\n"
#~ "const am = @import(\"asm.zig\");\n"
#~ "\n"
#~ "pub fn initSerial(port: Ports, baud: u32) void {\n"
#~ "    const p = @intFromEnum(port);\n"
#~ "    am.outb(0b00_000_0_00, p + offsets.lcr); // 8n1: no parity, 1 stop "
#~ "bit, 8 data bit\n"
#~ "    am.outb(0, p + offsets.ier); // Disable interrupts\n"
#~ "    am.outb(0, p + offsets.fcr); // Disable FIFO\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/serial.zig\n"
#~ "const am = @import(\"asm.zig\");\n"
#~ "\n"
#~ "pub fn initSerial(port: Ports, baud: u32) void {\n"
#~ "    const p = @intFromEnum(port);\n"
#~ "    am.outb(0b00_000_0_00, p + offsets.lcr); // 8n1: no parity, 1 stop "
#~ "bit, 8 data bit\n"
#~ "    am.outb(0, p + offsets.ier); // Disable interrupts\n"
#~ "    am.outb(0, p + offsets.fcr); // Disable FIFO\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/serial.zig\n"
#~ "{\n"
#~ "    ...\n"
#~ "    const divisor = 115200 / baud;\n"
#~ "    const c = am.inb(p + offsets.lcr);\n"
#~ "    am.outb(c | 0b1000_0000, p + offsets.lcr); // Enable DLAB\n"
#~ "    am.outb(@truncate(divisor & 0xFF), p + offsets.dll);\n"
#~ "    am.outb(@truncate((divisor >> 8) & 0xFF), p + offsets.dlh);\n"
#~ "    am.outb(c & 0b0111_1111, p + offsets.lcr); // Disable DLAB\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/serial.zig\n"
#~ "{\n"
#~ "    ...\n"
#~ "    const divisor = 115200 / baud;\n"
#~ "    const c = am.inb(p + offsets.lcr);\n"
#~ "    am.outb(c | 0b1000_0000, p + offsets.lcr); // Enable DLAB\n"
#~ "    am.outb(@truncate(divisor & 0xFF), p + offsets.dll);\n"
#~ "    am.outb(@truncate((divisor >> 8) & 0xFF), p + offsets.dlh);\n"
#~ "    am.outb(c & 0b0111_1111, p + offsets.lcr); // Disable DLAB\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/serial.zig\n"
#~ "const bits = ymir.bits;\n"
#~ "\n"
#~ "pub fn writeByte(byte: u8, port: Ports) void {\n"
#~ "    // Wait until the transmitter holding buffer is empty\n"
#~ "    while ((am.inb(@intFromEnum(port) + offsets.lsr) & 0b0010_0000) == 0) "
#~ "{\n"
#~ "        am.relax();\n"
#~ "    }\n"
#~ "\n"
#~ "    // Put char into the transmitter holding buffer\n"
#~ "    am.outb(byte, @intFromEnum(port));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/serial.zig\n"
#~ "const bits = ymir.bits;\n"
#~ "\n"
#~ "pub fn writeByte(byte: u8, port: Ports) void {\n"
#~ "    // Wait until the transmitter holding buffer is empty\n"
#~ "    while ((am.inb(@intFromEnum(port) + offsets.lsr) & 0b0010_0000) == 0) "
#~ "{\n"
#~ "        am.relax();\n"
#~ "    }\n"
#~ "\n"
#~ "    // Put char into the transmitter holding buffer\n"
#~ "    am.outb(byte, @intFromEnum(port));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```zig\n"
#~ "const ymir = @import(\"ymir\");\n"
#~ "const arch = ymir.arch;\n"
#~ "\n"
#~ "arch.serial.initSerial(.com1, 115200);\n"
#~ "for (\"Hello, Ymir!\\n\") |c|\n"
#~ "    arch.serial.writeByte(c, .com1);\n"
#~ "```"
#~ msgstr ""
#~ "```zig\n"
#~ "const ymir = @import(\"ymir\");\n"
#~ "const arch = ymir.arch;\n"
#~ "\n"
#~ "arch.serial.initSerial(.com1, 115200);\n"
#~ "for (\"Hello, Ymir!\\n\") |c|\n"
#~ "    arch.serial.writeByte(c, .com1);\n"
#~ "```"

#~ msgid ""
#~ "```ymir/serial.zig\n"
#~ "const ymir = @import(\"ymir\");\n"
#~ "const arch = ymir.arch;\n"
#~ "\n"
#~ "pub const Serial = struct {\n"
#~ "    const Self = @This();\n"
#~ "    const WriteFn = *const fn (u8) void;\n"
#~ "    const ReadFn = *const fn () ?u8;\n"
#~ "\n"
#~ "    _write_fn: WriteFn = undefined,\n"
#~ "    _read_fn: ReadFn = undefined,\n"
#~ "    ...\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/serial.zig\n"
#~ "const ymir = @import(\"ymir\");\n"
#~ "const arch = ymir.arch;\n"
#~ "\n"
#~ "pub const Serial = struct {\n"
#~ "    const Self = @This();\n"
#~ "    const WriteFn = *const fn (u8) void;\n"
#~ "    const ReadFn = *const fn () ?u8;\n"
#~ "\n"
#~ "    _write_fn: WriteFn = undefined,\n"
#~ "    _read_fn: ReadFn = undefined,\n"
#~ "    ...\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "const sr = serial.init();\n"
#~ "sr.writeString(\"Hello, Ymir!\\n\");\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "const sr = serial.init();\n"
#~ "sr.writeString(\"Hello, Ymir!\\n\");\n"
#~ "```"

#~ msgid ""
#~ "```ymir/ymir.zig\n"
#~ "pub const bits = @import(\"bits.zig\");\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/ymir.zig\n"
#~ "pub const bits = @import(\"bits.zig\");\n"
#~ "```"

#~ msgid ""
#~ "```zig\n"
#~ "const ymir = @import(\"ymir\");\n"
#~ "const bits = ymir.bits;\n"
#~ "\n"
#~ "bits.foobar();\n"
#~ "```"
#~ msgstr ""
#~ "```zig\n"
#~ "const ymir = @import(\"ymir\");\n"
#~ "const bits = ymir.bits;\n"
#~ "\n"
#~ "bits.foobar();\n"
#~ "```"

#~ msgid ""
#~ "```ymir/bits.zig\n"
#~ "pub fn tobit(T: type, nth: anytype) T {\n"
#~ "    const val = switch (@typeInfo(@TypeOf(nth))) {\n"
#~ "        .Int, .ComptimeInt => nth,\n"
#~ "        .Enum => @intFromEnum(nth),\n"
#~ "        else => @compileError(\"tobit: invalid type\"),\n"
#~ "    };\n"
#~ "    return @as(T, 1) << @intCast(val);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/bits.zig\n"
#~ "pub fn tobit(T: type, nth: anytype) T {\n"
#~ "    const val = switch (@typeInfo(@TypeOf(nth))) {\n"
#~ "        .Int, .ComptimeInt => nth,\n"
#~ "        .Enum => @intFromEnum(nth),\n"
#~ "        else => @compileError(\"tobit: invalid type\"),\n"
#~ "    };\n"
#~ "    return @as(T, 1) << @intCast(val);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```zig\n"
#~ "pub inline fn isset(val: anytype, nth: anytype) bool {\n"
#~ "    const int_nth = switch (@typeInfo(@TypeOf(nth))) {\n"
#~ "        .Int, .ComptimeInt => nth,\n"
#~ "        .Enum => @intFromEnum(nth),\n"
#~ "        else => @compileError(\"isset: invalid type\"),\n"
#~ "    };\n"
#~ "    return ((val >> @intCast(int_nth)) & 1) != 0;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```zig\n"
#~ "pub inline fn isset(val: anytype, nth: anytype) bool {\n"
#~ "    const int_nth = switch (@typeInfo(@TypeOf(nth))) {\n"
#~ "        .Int, .ComptimeInt => nth,\n"
#~ "        .Enum => @intFromEnum(nth),\n"
#~ "        else => @compileError(\"isset: invalid type\"),\n"
#~ "    };\n"
#~ "    return ((val >> @intCast(int_nth)) & 1) != 0;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```zig\n"
#~ "pub inline fn concat(T: type, a: anytype, b: @TypeOf(a)) T {\n"
#~ "    const U = @TypeOf(a);\n"
#~ "    const width_T = @typeInfo(T).Int.bits;\n"
#~ "    const width_U = switch (@typeInfo(U)) {\n"
#~ "        .Int => |t| t.bits,\n"
#~ "        .ComptimeInt => width_T / 2,\n"
#~ "        else => @compileError(\"concat: invalid type\"),\n"
#~ "    };\n"
#~ "    if (width_T != width_U * 2) @compileError(\"concat: invalid type\");\n"
#~ "    return (@as(T, a) << width_U) | @as(T, b);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```zig\n"
#~ "pub inline fn concat(T: type, a: anytype, b: @TypeOf(a)) T {\n"
#~ "    const U = @TypeOf(a);\n"
#~ "    const width_T = @typeInfo(T).Int.bits;\n"
#~ "    const width_U = switch (@typeInfo(U)) {\n"
#~ "        .Int => |t| t.bits,\n"
#~ "        .ComptimeInt => width_T / 2,\n"
#~ "        else => @compileError(\"concat: invalid type\"),\n"
#~ "    };\n"
#~ "    if (width_T != width_U * 2) @compileError(\"concat: invalid type\");\n"
#~ "    return (@as(T, a) << width_U) | @as(T, b);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```zig\n"
#~ "const a: u32 = 0x1234_5678;\n"
#~ "const b: u32 = 0x9ABC_DEF0;\n"
#~ "const c = bits.concat(u64, a, b); // 0x1234_5678_9ABC_DEF0\n"
#~ "```"
#~ msgstr ""
#~ "```zig\n"
#~ "const a: u32 = 0x1234_5678;\n"
#~ "const b: u32 = 0x9ABC_DEF0;\n"
#~ "const c = bits.concat(u64, a, b); // 0x1234_5678_9ABC_DEF0\n"
#~ "```"

#~ msgid ""
#~ "```src/ymir.zig\n"
#~ "pub const is_test = @import(\"builtin\").is_test;\n"
#~ "```"
#~ msgstr ""
#~ "```src/ymir.zig\n"
#~ "pub const is_test = @import(\"builtin\").is_test;\n"
#~ "```"

#~ msgid ""
#~ "```build.zig\n"
#~ "const ymir_tests = b.addTest(.{\n"
#~ "    .name = \"Unit Test\",\n"
#~ "    .root_source_file = b.path(\"ymir/ymir.zig\"),\n"
#~ "    .target = b.standardTargetOptions(.{}),\n"
#~ "    .optimize = optimize,\n"
#~ "    .link_libc = true,\n"
#~ "});\n"
#~ "ymir_tests.root_module.addImport(\"ymir\", &ymir_tests.root_module);\n"
#~ "```"
#~ msgstr ""
#~ "```build.zig\n"
#~ "const ymir_tests = b.addTest(.{\n"
#~ "    .name = \"Unit Test\",\n"
#~ "    .root_source_file = b.path(\"ymir/ymir.zig\"),\n"
#~ "    .target = b.standardTargetOptions(.{}),\n"
#~ "    .optimize = optimize,\n"
#~ "    .link_libc = true,\n"
#~ "});\n"
#~ "ymir_tests.root_module.addImport(\"ymir\", &ymir_tests.root_module);\n"
#~ "```"

#~ msgid ""
#~ "```build.zig\n"
#~ "const run_ymir_tests = b.addRunArtifact(ymir_tests);\n"
#~ "const test_step = b.step(\"test\", \"Run unit tests\");\n"
#~ "test_step.dependOn(&run_ymir_tests.step);\n"
#~ "```"
#~ msgstr ""
#~ "```build.zig\n"
#~ "const run_ymir_tests = b.addRunArtifact(ymir_tests);\n"
#~ "const test_step = b.step(\"test\", \"Run unit tests\");\n"
#~ "test_step.dependOn(&run_ymir_tests.step);\n"
#~ "```"

#~ msgid ""
#~ "```ymir/bits.zig\n"
#~ "const testing = @import(\"std\").testing;\n"
#~ "\n"
#~ "test \"tobit\" {\n"
#~ "    try testing.expectEqual(0b0000_0001, tobit(u8, 0));\n"
#~ "    try testing.expectEqual(0b0001_0000, tobit(u8, 4));\n"
#~ "    try testing.expectEqual(0b1000_0000, tobit(u8, 7));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/bits.zig\n"
#~ "const testing = @import(\"std\").testing;\n"
#~ "\n"
#~ "test \"tobit\" {\n"
#~ "    try testing.expectEqual(0b0000_0001, tobit(u8, 0));\n"
#~ "    try testing.expectEqual(0b0001_0000, tobit(u8, 4));\n"
#~ "    try testing.expectEqual(0b1000_0000, tobit(u8, 7));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/ymir.zig\n"
#~ "const testing = @import(\"std\").testing;\n"
#~ "\n"
#~ "test {\n"
#~ "    testing.refAllDeclsRecursive(@This());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/ymir.zig\n"
#~ "const testing = @import(\"std\").testing;\n"
#~ "\n"
#~ "test {\n"
#~ "    testing.refAllDeclsRecursive(@This());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/log.zig\n"
#~ "const Writer = std.io.Writer(\n"
#~ "    void,\n"
#~ "    LogError,\n"
#~ "    write,\n"
#~ ");\n"
#~ "\n"
#~ "pub const default_log_options = std.Options{\n"
#~ "    .log_level = switch (option.log_level) {\n"
#~ "        .debug => .debug,\n"
#~ "        .info => .info,\n"
#~ "        .warn => .warn,\n"
#~ "        .err => .err,\n"
#~ "    },\n"
#~ "    .logFn = log,\n"
#~ "};\n"
#~ "\n"
#~ "fn log(\n"
#~ "    comptime level: stdlog.Level,\n"
#~ "    comptime scope: @Type(.EnumLiteral),\n"
#~ "    comptime fmt: []const u8,\n"
#~ "    args: anytype,\n"
#~ ") void {\n"
#~ "    const level_str = comptime switch (level) {\n"
#~ "        .debug => \"[DEBUG]\",\n"
#~ "        .info => \"[INFO ]\",\n"
#~ "        .warn => \"[WARN ]\",\n"
#~ "        .err => \"[ERROR]\",\n"
#~ "    };\n"
#~ "\n"
#~ "    const scope_str = if (@tagName(scope).len <= 7) b: {\n"
#~ "        break :b std.fmt.comptimePrint(\"{s: <7} | \", ."
#~ "{@tagName(scope)});\n"
#~ "    } else b: {\n"
#~ "        break :b std.fmt.comptimePrint(\"{s: <7}-| \", .{@tagName(scope)"
#~ "[0..7]});\n"
#~ "    };\n"
#~ "\n"
#~ "    std.fmt.format(\n"
#~ "        Writer{ .context = {} },\n"
#~ "        level_str ++ \" \" ++ scope_str ++ fmt ++ \"\\n\",\n"
#~ "        args,\n"
#~ "    ) catch {};\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/log.zig\n"
#~ "const Writer = std.io.Writer(\n"
#~ "    void,\n"
#~ "    LogError,\n"
#~ "    write,\n"
#~ ");\n"
#~ "\n"
#~ "pub const default_log_options = std.Options{\n"
#~ "    .log_level = switch (option.log_level) {\n"
#~ "        .debug => .debug,\n"
#~ "        .info => .info,\n"
#~ "        .warn => .warn,\n"
#~ "        .err => .err,\n"
#~ "    },\n"
#~ "    .logFn = log,\n"
#~ "};\n"
#~ "\n"
#~ "fn log(\n"
#~ "    comptime level: stdlog.Level,\n"
#~ "    comptime scope: @Type(.EnumLiteral),\n"
#~ "    comptime fmt: []const u8,\n"
#~ "    args: anytype,\n"
#~ ") void {\n"
#~ "    const level_str = comptime switch (level) {\n"
#~ "        .debug => \"[DEBUG]\",\n"
#~ "        .info => \"[INFO ]\",\n"
#~ "        .warn => \"[WARN ]\",\n"
#~ "        .err => \"[ERROR]\",\n"
#~ "    };\n"
#~ "\n"
#~ "    const scope_str = if (@tagName(scope).len <= 7) b: {\n"
#~ "        break :b std.fmt.comptimePrint(\"{s: <7} | \", ."
#~ "{@tagName(scope)});\n"
#~ "    } else b: {\n"
#~ "        break :b std.fmt.comptimePrint(\"{s: <7}-| \", .{@tagName(scope)"
#~ "[0..7]});\n"
#~ "    };\n"
#~ "\n"
#~ "    std.fmt.format(\n"
#~ "        Writer{ .context = {} },\n"
#~ "        level_str ++ \" \" ++ scope_str ++ fmt ++ \"\\n\",\n"
#~ "        args,\n"
#~ "    ) catch {};\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```zig\n"
#~ "ymir_module.addOptions(\"option\", options);\n"
#~ "ymir.root_module.addOptions(\"option\", options);\n"
#~ "```"
#~ msgstr ""
#~ "```zig\n"
#~ "ymir_module.addOptions(\"option\", options);\n"
#~ "ymir.root_module.addOptions(\"option\", options);\n"
#~ "```"

#~ msgid ""
#~ "```ymir/ymir.zig\n"
#~ "pub const klog = @import(\"log.zig\");\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/ymir.zig\n"
#~ "pub const klog = @import(\"log.zig\");\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "const sr = serial.init();\n"
#~ "klog.init(sr);\n"
#~ "log.info(\"Booting Ymir...\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "const sr = serial.init();\n"
#~ "klog.init(sr);\n"
#~ "log.info(\"Booting Ymir...\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "validateBootInfo(boot_info) catch {\n"
#~ "    log.err(\"Invalid boot info\", .{});\n"
#~ "    return error.InvalidBootInfo;\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "validateBootInfo(boot_info) catch {\n"
#~ "    log.err(\"Invalid boot info\", .{});\n"
#~ "    return error.InvalidBootInfo;\n"
#~ "};\n"
#~ "```"

#~ msgid "GDT: Global Descriptor Table"
#~ msgstr "GDT: Global Descriptor Table"

#~ msgid ""
#~ "```ymir/arch/x86/idt.zig\n"
#~ "/// Entry in the Interrupt Descriptor Table.\n"
#~ "pub const GateDescriptor = packed struct(u128) {\n"
#~ "    /// Lower 16 bits of the offset to the ISR.\n"
#~ "    offset_low: u16,\n"
#~ "    /// Segment Selector that must point to a valid code segment in the "
#~ "GDT.\n"
#~ "    seg_selector: u16,\n"
#~ "    /// Interrupt Stack Table. Not used.\n"
#~ "    ist: u3 = 0,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved1: u5 = 0,\n"
#~ "    /// Gate Type.\n"
#~ "    gate_type: GateType,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved2: u1 = 0,\n"
#~ "    /// Descriptor Privilege Level is the required CPL to call the ISR "
#~ "via the INT inst.\n"
#~ "    /// Hardware interrupts ignore this field.\n"
#~ "    dpl: u2,\n"
#~ "    /// Present flag. Must be 1.\n"
#~ "    present: bool = true,\n"
#~ "    /// Middle 16 bits of the offset to the ISR.\n"
#~ "    offset_middle: u16,\n"
#~ "    /// Higher 32 bits of the offset to the ISR.\n"
#~ "    offset_high: u32,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved3: u32 = 0,\n"
#~ "\n"
#~ "    pub fn offset(self: GateDescriptor) u64 {\n"
#~ "        return @as(u64, self.offset_high) << 32 | @as(u64, self."
#~ "offset_middle) << 16 | @as(u64, self.offset_low);\n"
#~ "    }\n"
#~ "};\n"
#~ "\n"
#~ "pub const GateType = enum(u4) {\n"
#~ "    Invalid = 0b0000,\n"
#~ "    Interrupt64 = 0b1110,\n"
#~ "    Trap64 = 0b1111,\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/idt.zig\n"
#~ "/// Entry in the Interrupt Descriptor Table.\n"
#~ "pub const GateDescriptor = packed struct(u128) {\n"
#~ "    /// Lower 16 bits of the offset to the ISR.\n"
#~ "    offset_low: u16,\n"
#~ "    /// Segment Selector that must point to a valid code segment in the "
#~ "GDT.\n"
#~ "    seg_selector: u16,\n"
#~ "    /// Interrupt Stack Table. Not used.\n"
#~ "    ist: u3 = 0,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved1: u5 = 0,\n"
#~ "    /// Gate Type.\n"
#~ "    gate_type: GateType,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved2: u1 = 0,\n"
#~ "    /// Descriptor Privilege Level is the required CPL to call the ISR "
#~ "via the INT inst.\n"
#~ "    /// Hardware interrupts ignore this field.\n"
#~ "    dpl: u2,\n"
#~ "    /// Present flag. Must be 1.\n"
#~ "    present: bool = true,\n"
#~ "    /// Middle 16 bits of the offset to the ISR.\n"
#~ "    offset_middle: u16,\n"
#~ "    /// Higher 32 bits of the offset to the ISR.\n"
#~ "    offset_high: u32,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved3: u32 = 0,\n"
#~ "\n"
#~ "    pub fn offset(self: GateDescriptor) u64 {\n"
#~ "        return @as(u64, self.offset_high) << 32 | @as(u64, self."
#~ "offset_middle) << 16 | @as(u64, self.offset_low);\n"
#~ "    }\n"
#~ "};\n"
#~ "\n"
#~ "pub const GateType = enum(u4) {\n"
#~ "    Invalid = 0b0000,\n"
#~ "    Interrupt64 = 0b1110,\n"
#~ "    Trap64 = 0b1111,\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "arch.idt.init();\n"
#~ "log.info(\"Initialized IDT.\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "arch.idt.init();\n"
#~ "log.info(\"Initialized IDT.\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "const ptr: *u64 = @ptrFromInt(0xDEAD_0000_0000_0000);\n"
#~ "log.info(\"ptr.* = {d}\", .{ptr.*});\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "const ptr: *u64 = @ptrFromInt(0xDEAD_0000_0000_0000);\n"
#~ "log.info(\"ptr.* = {d}\", .{ptr.*});\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/isr.zig\n"
#~ "pub fn generateIsr(comptime vector: usize) idt.Isr {\n"
#~ "    return struct {\n"
#~ "        fn handler() callconv(.Naked) void {\n"
#~ "            // Clear the interrupt flag.\n"
#~ "            asm volatile (\n"
#~ "                \\\\cli\n"
#~ "            );\n"
#~ "            // If the interrupt does not provide an error code, push a "
#~ "dummy one.\n"
#~ "            if (vector != 8 and !(vector >= 10 and vector <= 14) and "
#~ "vector != 17) {\n"
#~ "                asm volatile (\n"
#~ "                    \\\\pushq $0\n"
#~ "                );\n"
#~ "            }\n"
#~ "            // Push the vector.\n"
#~ "            asm volatile (\n"
#~ "                \\\\pushq %[vector]\n"
#~ "                :\n"
#~ "                : [vector] \"n\" (vector),\n"
#~ "            );\n"
#~ "            // Jump to the common ISR.\n"
#~ "            asm volatile (\n"
#~ "                \\\\jmp isrCommon\n"
#~ "            );\n"
#~ "        }\n"
#~ "    }.handler;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/isr.zig\n"
#~ "pub fn generateIsr(comptime vector: usize) idt.Isr {\n"
#~ "    return struct {\n"
#~ "        fn handler() callconv(.Naked) void {\n"
#~ "            // Clear the interrupt flag.\n"
#~ "            asm volatile (\n"
#~ "                \\\\cli\n"
#~ "            );\n"
#~ "            // If the interrupt does not provide an error code, push a "
#~ "dummy one.\n"
#~ "            if (vector != 8 and !(vector >= 10 and vector <= 14) and "
#~ "vector != 17) {\n"
#~ "                asm volatile (\n"
#~ "                    \\\\pushq $0\n"
#~ "                );\n"
#~ "            }\n"
#~ "            // Push the vector.\n"
#~ "            asm volatile (\n"
#~ "                \\\\pushq %[vector]\n"
#~ "                :\n"
#~ "                : [vector] \"n\" (vector),\n"
#~ "            );\n"
#~ "            // Jump to the common ISR.\n"
#~ "            asm volatile (\n"
#~ "                \\\\jmp isrCommon\n"
#~ "            );\n"
#~ "        }\n"
#~ "    }.handler;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/isr.zig\n"
#~ "export fn isrCommon() callconv(.Naked) void {\n"
#~ "    // Save the general-purpose registers.\n"
#~ "    asm volatile (\n"
#~ "        \\\\pushq %%rax\n"
#~ "        \\\\pushq %%rcx\n"
#~ "        \\\\pushq %%rdx\n"
#~ "        \\\\pushq %%rbx\n"
#~ "        \\\\pushq %%rsp\n"
#~ "        \\\\pushq %%rbp\n"
#~ "        \\\\pushq %%rsi\n"
#~ "        \\\\pushq %%rdi\n"
#~ "        \\\\pushq %%r15\n"
#~ "        \\\\pushq %%r14\n"
#~ "        \\\\pushq %%r13\n"
#~ "        \\\\pushq %%r12\n"
#~ "        \\\\pushq %%r11\n"
#~ "        \\\\pushq %%r10\n"
#~ "        \\\\pushq %%r9\n"
#~ "        \\\\pushq %%r8\n"
#~ "    );\n"
#~ "\n"
#~ "    // Push the context and call the handler.\n"
#~ "    asm volatile (\n"
#~ "        \\\\pushq %%rsp\n"
#~ "        \\\\popq %%rdi\n"
#~ "        // Align stack to 16 bytes.\n"
#~ "        \\\\pushq %%rsp\n"
#~ "        \\\\pushq (%%rsp)\n"
#~ "        \\\\andq $-0x10, %%rsp\n"
#~ "        // Call the dispatcher.\n"
#~ "        \\\\call intrZigEntry\n"
#~ "        // Restore the stack.\n"
#~ "        \\\\movq 8(%%rsp), %%rsp\n"
#~ "    );\n"
#~ "\n"
#~ "    // Remove general-purpose registers, error code, and vector from the "
#~ "stack.\n"
#~ "    asm volatile (\n"
#~ "        \\\\popq %%r8\n"
#~ "        \\\\popq %%r9\n"
#~ "        \\\\popq %%r10\n"
#~ "        \\\\popq %%r11\n"
#~ "        \\\\popq %%r12\n"
#~ "        \\\\popq %%r13\n"
#~ "        \\\\popq %%r14\n"
#~ "        \\\\popq %%r15\n"
#~ "        \\\\popq %%rdi\n"
#~ "        \\\\popq %%rsi\n"
#~ "        \\\\popq %%rbp\n"
#~ "        \\\\popq %%rsp\n"
#~ "        \\\\popq %%rbx\n"
#~ "        \\\\popq %%rdx\n"
#~ "        \\\\popq %%rcx\n"
#~ "        \\\\popq %%rax\n"
#~ "        \\\\add   $0x10, %%rsp\n"
#~ "        \\\\iretq\n"
#~ "    );\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/isr.zig\n"
#~ "export fn isrCommon() callconv(.Naked) void {\n"
#~ "    // Save the general-purpose registers.\n"
#~ "    asm volatile (\n"
#~ "        \\\\pushq %%rax\n"
#~ "        \\\\pushq %%rcx\n"
#~ "        \\\\pushq %%rdx\n"
#~ "        \\\\pushq %%rbx\n"
#~ "        \\\\pushq %%rsp\n"
#~ "        \\\\pushq %%rbp\n"
#~ "        \\\\pushq %%rsi\n"
#~ "        \\\\pushq %%rdi\n"
#~ "        \\\\pushq %%r15\n"
#~ "        \\\\pushq %%r14\n"
#~ "        \\\\pushq %%r13\n"
#~ "        \\\\pushq %%r12\n"
#~ "        \\\\pushq %%r11\n"
#~ "        \\\\pushq %%r10\n"
#~ "        \\\\pushq %%r9\n"
#~ "        \\\\pushq %%r8\n"
#~ "    );\n"
#~ "\n"
#~ "    // Push the context and call the handler.\n"
#~ "    asm volatile (\n"
#~ "        \\\\pushq %%rsp\n"
#~ "        \\\\popq %%rdi\n"
#~ "        // Align stack to 16 bytes.\n"
#~ "        \\\\pushq %%rsp\n"
#~ "        \\\\pushq (%%rsp)\n"
#~ "        \\\\andq $-0x10, %%rsp\n"
#~ "        // Call the dispatcher.\n"
#~ "        \\\\call intrZigEntry\n"
#~ "        // Restore the stack.\n"
#~ "        \\\\movq 8(%%rsp), %%rsp\n"
#~ "    );\n"
#~ "\n"
#~ "    // Remove general-purpose registers, error code, and vector from the "
#~ "stack.\n"
#~ "    asm volatile (\n"
#~ "        \\\\popq %%r8\n"
#~ "        \\\\popq %%r9\n"
#~ "        \\\\popq %%r10\n"
#~ "        \\\\popq %%r11\n"
#~ "        \\\\popq %%r12\n"
#~ "        \\\\popq %%r13\n"
#~ "        \\\\popq %%r14\n"
#~ "        \\\\popq %%r15\n"
#~ "        \\\\popq %%rdi\n"
#~ "        \\\\popq %%rsi\n"
#~ "        \\\\popq %%rbp\n"
#~ "        \\\\popq %%rsp\n"
#~ "        \\\\popq %%rbx\n"
#~ "        \\\\popq %%rdx\n"
#~ "        \\\\popq %%rcx\n"
#~ "        \\\\popq %%rax\n"
#~ "        \\\\add   $0x10, %%rsp\n"
#~ "        \\\\iretq\n"
#~ "    );\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/isr.zig\n"
#~ "const intr = @import(\"interrupt.zig\");\n"
#~ "\n"
#~ "pub const Context = packed struct {\n"
#~ "    /// General purpose registers.\n"
#~ "    registers: Registers,\n"
#~ "    /// Interrupt Vector.\n"
#~ "    vector: u64,\n"
#~ "    /// Error Code.\n"
#~ "    error_code: u64,\n"
#~ "\n"
#~ "    // CPU status:\n"
#~ "    rip: u64,\n"
#~ "    cs: u64,\n"
#~ "    rflags: u64,\n"
#~ "};\n"
#~ "const Registers = packed struct {\n"
#~ "    r8: u64,\n"
#~ "    r9: u64,\n"
#~ "    r10: u64,\n"
#~ "    r11: u64,\n"
#~ "    r12: u64,\n"
#~ "    r13: u64,\n"
#~ "    r14: u64,\n"
#~ "    r15: u64,\n"
#~ "    rdi: u64,\n"
#~ "    rsi: u64,\n"
#~ "    rbp: u64,\n"
#~ "    rsp: u64,\n"
#~ "    rbx: u64,\n"
#~ "    rdx: u64,\n"
#~ "    rcx: u64,\n"
#~ "    rax: u64,\n"
#~ "};\n"
#~ "\n"
#~ "export fn intrZigEntry(ctx: *Context) callconv(.C) void {\n"
#~ "    intr.dispatch(ctx);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/isr.zig\n"
#~ "const intr = @import(\"interrupt.zig\");\n"
#~ "\n"
#~ "pub const Context = packed struct {\n"
#~ "    /// General purpose registers.\n"
#~ "    registers: Registers,\n"
#~ "    /// Interrupt Vector.\n"
#~ "    vector: u64,\n"
#~ "    /// Error Code.\n"
#~ "    error_code: u64,\n"
#~ "\n"
#~ "    // CPU status:\n"
#~ "    rip: u64,\n"
#~ "    cs: u64,\n"
#~ "    rflags: u64,\n"
#~ "};\n"
#~ "const Registers = packed struct {\n"
#~ "    r8: u64,\n"
#~ "    r9: u64,\n"
#~ "    r10: u64,\n"
#~ "    r11: u64,\n"
#~ "    r12: u64,\n"
#~ "    r13: u64,\n"
#~ "    r14: u64,\n"
#~ "    r15: u64,\n"
#~ "    rdi: u64,\n"
#~ "    rsi: u64,\n"
#~ "    rbp: u64,\n"
#~ "    rsp: u64,\n"
#~ "    rbx: u64,\n"
#~ "    rdx: u64,\n"
#~ "    rcx: u64,\n"
#~ "    rax: u64,\n"
#~ "};\n"
#~ "\n"
#~ "export fn intrZigEntry(ctx: *Context) callconv(.C) void {\n"
#~ "    intr.dispatch(ctx);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/interrupt.zig\n"
#~ "fn unhandledHandler(context: *Context) void {\n"
#~ "    @setCold(true);\n"
#~ "\n"
#~ "    log.err(\"============ Oops! ===================\", .{});\n"
#~ "    log.err(\"Unhandled interrupt: {s} ({})\", .{\n"
#~ "        exceptionName(context.vector),\n"
#~ "        context.vector,\n"
#~ "    });\n"
#~ "    log.err(\"Error Code: 0x{X}\", .{context.error_code});\n"
#~ "    log.err(\"RIP    : 0x{X:0>16}\", .{context.rip});\n"
#~ "    log.err(\"EFLAGS : 0x{X:0>16}\", .{context.rflags});\n"
#~ "    log.err(\"RAX    : 0x{X:0>16}\", .{context.registers.rax});\n"
#~ "    log.err(\"RBX    : 0x{X:0>16}\", .{context.registers.rbx});\n"
#~ "    log.err(\"RCX    : 0x{X:0>16}\", .{context.registers.rcx});\n"
#~ "    log.err(\"RDX    : 0x{X:0>16}\", .{context.registers.rdx});\n"
#~ "    log.err(\"RSI    : 0x{X:0>16}\", .{context.registers.rsi});\n"
#~ "    log.err(\"RDI    : 0x{X:0>16}\", .{context.registers.rdi});\n"
#~ "    log.err(\"RSP    : 0x{X:0>16}\", .{context.registers.rsp});\n"
#~ "    log.err(\"RBP    : 0x{X:0>16}\", .{context.registers.rbp});\n"
#~ "    log.err(\"R8     : 0x{X:0>16}\", .{context.registers.r8});\n"
#~ "    log.err(\"R9     : 0x{X:0>16}\", .{context.registers.r9});\n"
#~ "    log.err(\"R10    : 0x{X:0>16}\", .{context.registers.r10});\n"
#~ "    log.err(\"R11    : 0x{X:0>16}\", .{context.registers.r11});\n"
#~ "    log.err(\"R12    : 0x{X:0>16}\", .{context.registers.r12});\n"
#~ "    log.err(\"R13    : 0x{X:0>16}\", .{context.registers.r13});\n"
#~ "    log.err(\"R14    : 0x{X:0>16}\", .{context.registers.r14});\n"
#~ "    log.err(\"R15    : 0x{X:0>16}\", .{context.registers.r15});\n"
#~ "    log.err(\"CS     : 0x{X:0>4}\", .{context.cs});\n"
#~ "\n"
#~ "    ymir.endlessHalt();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/interrupt.zig\n"
#~ "fn unhandledHandler(context: *Context) void {\n"
#~ "    @setCold(true);\n"
#~ "\n"
#~ "    log.err(\"============ Oops! ===================\", .{});\n"
#~ "    log.err(\"Unhandled interrupt: {s} ({})\", .{\n"
#~ "        exceptionName(context.vector),\n"
#~ "        context.vector,\n"
#~ "    });\n"
#~ "    log.err(\"Error Code: 0x{X}\", .{context.error_code});\n"
#~ "    log.err(\"RIP    : 0x{X:0>16}\", .{context.rip});\n"
#~ "    log.err(\"EFLAGS : 0x{X:0>16}\", .{context.rflags});\n"
#~ "    log.err(\"RAX    : 0x{X:0>16}\", .{context.registers.rax});\n"
#~ "    log.err(\"RBX    : 0x{X:0>16}\", .{context.registers.rbx});\n"
#~ "    log.err(\"RCX    : 0x{X:0>16}\", .{context.registers.rcx});\n"
#~ "    log.err(\"RDX    : 0x{X:0>16}\", .{context.registers.rdx});\n"
#~ "    log.err(\"RSI    : 0x{X:0>16}\", .{context.registers.rsi});\n"
#~ "    log.err(\"RDI    : 0x{X:0>16}\", .{context.registers.rdi});\n"
#~ "    log.err(\"RSP    : 0x{X:0>16}\", .{context.registers.rsp});\n"
#~ "    log.err(\"RBP    : 0x{X:0>16}\", .{context.registers.rbp});\n"
#~ "    log.err(\"R8     : 0x{X:0>16}\", .{context.registers.r8});\n"
#~ "    log.err(\"R9     : 0x{X:0>16}\", .{context.registers.r9});\n"
#~ "    log.err(\"R10    : 0x{X:0>16}\", .{context.registers.r10});\n"
#~ "    log.err(\"R11    : 0x{X:0>16}\", .{context.registers.r11});\n"
#~ "    log.err(\"R12    : 0x{X:0>16}\", .{context.registers.r12});\n"
#~ "    log.err(\"R13    : 0x{X:0>16}\", .{context.registers.r13});\n"
#~ "    log.err(\"R14    : 0x{X:0>16}\", .{context.registers.r14});\n"
#~ "    log.err(\"R15    : 0x{X:0>16}\", .{context.registers.r15});\n"
#~ "    log.err(\"CS     : 0x{X:0>4}\", .{context.cs});\n"
#~ "\n"
#~ "    ymir.endlessHalt();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/mem/PageAllocator.zig\n"
#~ "const Allocator = std.mem.Allocator;\n"
#~ "const Self = @This();\n"
#~ "const PageAllocator = Self;\n"
#~ "\n"
#~ "pub const vtable = Allocator.VTable{\n"
#~ "    .alloc = allocate,\n"
#~ "    .free = free,\n"
#~ "    .resize = resize,\n"
#~ "};\n"
#~ "\n"
#~ "fn allocate(ctx: *anyopaque, _: usize, _: u8, _: usize) ?[*]u8 "
#~ "{ @panic(\"unimplemented\"); }\n"
#~ "fn free(ctx: *anyopaque, _: []u8, _: u8, _: usize) void { }\n"
#~ "fn resize(ctx: *anyopaque, _: []u8, _: u8, _: usize, _: usize) bool "
#~ "{ @panic(\"unimplemented\"); }\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/mem/PageAllocator.zig\n"
#~ "const Allocator = std.mem.Allocator;\n"
#~ "const Self = @This();\n"
#~ "const PageAllocator = Self;\n"
#~ "\n"
#~ "pub const vtable = Allocator.VTable{\n"
#~ "    .alloc = allocate,\n"
#~ "    .free = free,\n"
#~ "    .resize = resize,\n"
#~ "};\n"
#~ "\n"
#~ "fn allocate(ctx: *anyopaque, _: usize, _: u8, _: usize) ?[*]u8 "
#~ "{ @panic(\"unimplemented\"); }\n"
#~ "fn free(ctx: *anyopaque, _: []u8, _: u8, _: usize) void { }\n"
#~ "fn resize(ctx: *anyopaque, _: []u8, _: u8, _: usize, _: usize) bool "
#~ "{ @panic(\"unimplemented\"); }\n"
#~ "```"

#~ msgid ""
#~ "```zig\n"
#~ "const PageAllocator = @import(\"mem/PageAllocator.zig\");\n"
#~ "// 以下と同じ\n"
#~ "const PageAllocator = @import(\"mem/PageAllocator.zig\")."
#~ "PageAllocator; // <= 冗長\n"
#~ "```"
#~ msgstr ""
#~ "```zig\n"
#~ "const PageAllocator = @import(\"mem/PageAllocator.zig\");\n"
#~ "// 以下と同じ\n"
#~ "const PageAllocator = @import(\"mem/PageAllocator.zig\")."
#~ "PageAllocator; // <= 冗長\n"
#~ "```"

#~ msgid ""
#~ "```ymir/mem/PageAllocator.zig\n"
#~ "/// Maximum physical memory size in bytes that can be managed by this "
#~ "allocator.\n"
#~ "const max_physical_size = 128 * gib;\n"
#~ "/// Maximum page frame count.\n"
#~ "const frame_count = max_physical_size / 4096; // 32Mi frames\n"
#~ "\n"
#~ "/// Single unit of bitmap line.\n"
#~ "const MapLineType = u64;\n"
#~ "/// Bits per map line.\n"
#~ "const bits_per_mapline = @sizeOf(MapLineType) * 8; // 64\n"
#~ "/// Number of map lines.\n"
#~ "const num_maplines = frame_count / bits_per_mapline; // 512Ki lines\n"
#~ "/// Bitmap type.\n"
#~ "const BitMap = [num_maplines]MapLineType;\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/mem/PageAllocator.zig\n"
#~ "/// Maximum physical memory size in bytes that can be managed by this "
#~ "allocator.\n"
#~ "const max_physical_size = 128 * gib;\n"
#~ "/// Maximum page frame count.\n"
#~ "const frame_count = max_physical_size / 4096; // 32Mi frames\n"
#~ "\n"
#~ "/// Single unit of bitmap line.\n"
#~ "const MapLineType = u64;\n"
#~ "/// Bits per map line.\n"
#~ "const bits_per_mapline = @sizeOf(MapLineType) * 8; // 64\n"
#~ "/// Number of map lines.\n"
#~ "const num_maplines = frame_count / bits_per_mapline; // 512Ki lines\n"
#~ "/// Bitmap type.\n"
#~ "const BitMap = [num_maplines]MapLineType;\n"
#~ "```"

#~ msgid ""
#~ "```ymir/mem/PageAllocator.zig\n"
#~ "const Status = enum(u1) {\n"
#~ "    /// Page frame is in use.\n"
#~ "    used = 0,\n"
#~ "    /// Page frame is unused.\n"
#~ "    unused = 1,\n"
#~ "\n"
#~ "    pub inline fn from(boolean: bool) Status {\n"
#~ "        return if (boolean) .used else .unused;\n"
#~ "    }\n"
#~ "};\n"
#~ "\n"
#~ "fn get(self: *Self, frame: FrameId) Status {\n"
#~ "    const line_index = frame / bits_per_mapline;\n"
#~ "    const bit_index: u6 = @truncate(frame % bits_per_mapline);\n"
#~ "    return Status.from(self.bitmap[line_index] & bits.tobit(MapLineType, "
#~ "bit_index) != 0);\n"
#~ "}\n"
#~ "\n"
#~ "fn set(self: *Self, frame: FrameId, status: Status) void {\n"
#~ "    const line_index = frame / bits_per_mapline;\n"
#~ "    const bit_index: u6 = @truncate(frame % bits_per_mapline);\n"
#~ "    switch (status) {\n"
#~ "        .used => self.bitmap[line_index] |= bits.tobit(MapLineType, "
#~ "bit_index),\n"
#~ "        .unused => self.bitmap[line_index] &= ~bits.tobit(MapLineType, "
#~ "bit_index),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/mem/PageAllocator.zig\n"
#~ "const Status = enum(u1) {\n"
#~ "    /// Page frame is in use.\n"
#~ "    used = 0,\n"
#~ "    /// Page frame is unused.\n"
#~ "    unused = 1,\n"
#~ "\n"
#~ "    pub inline fn from(boolean: bool) Status {\n"
#~ "        return if (boolean) .used else .unused;\n"
#~ "    }\n"
#~ "};\n"
#~ "\n"
#~ "fn get(self: *Self, frame: FrameId) Status {\n"
#~ "    const line_index = frame / bits_per_mapline;\n"
#~ "    const bit_index: u6 = @truncate(frame % bits_per_mapline);\n"
#~ "    return Status.from(self.bitmap[line_index] & bits.tobit(MapLineType, "
#~ "bit_index) != 0);\n"
#~ "}\n"
#~ "\n"
#~ "fn set(self: *Self, frame: FrameId, status: Status) void {\n"
#~ "    const line_index = frame / bits_per_mapline;\n"
#~ "    const bit_index: u6 = @truncate(frame % bits_per_mapline);\n"
#~ "    switch (status) {\n"
#~ "        .used => self.bitmap[line_index] |= bits.tobit(MapLineType, "
#~ "bit_index),\n"
#~ "        .unused => self.bitmap[line_index] &= ~bits.tobit(MapLineType, "
#~ "bit_index),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/mem/PageAllocator.zig\n"
#~ "frame_begin: FrameId = 1,\n"
#~ "frame_end: FrameId,\n"
#~ "\n"
#~ "pub fn init(self: *Self, map: MemoryMap) void {\n"
#~ "    ...\n"
#~ "    while (true) {\n"
#~ "        const desc: *uefi.tables.MemoryDescriptor = desc_iter.next() "
#~ "orelse break;\n"
#~ "\n"
#~ "        // Mark holes between regions as allocated (used).\n"
#~ "        if (avail_end < desc.physical_start) {\n"
#~ "            self.markAllocated(phys2frame(avail_end), desc."
#~ "number_of_pages);\n"
#~ "        }\n"
#~ "        // Mark the region described by the descriptor as used or "
#~ "unused.\n"
#~ "        const phys_end = desc.physical_start + desc.number_of_pages * "
#~ "page_size;\n"
#~ "        if (isUsableMemory(desc)) {\n"
#~ "            avail_end = phys_end;\n"
#~ "            self.markNotUsed(phys2frame(desc.physical_start), desc."
#~ "number_of_pages);\n"
#~ "        } else {\n"
#~ "            self.markAllocated(phys2frame(desc.physical_start), desc."
#~ "number_of_pages);\n"
#~ "        }\n"
#~ "\n"
#~ "        self.frame_end = phys2frame(avail_end);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/mem/PageAllocator.zig\n"
#~ "frame_begin: FrameId = 1,\n"
#~ "frame_end: FrameId,\n"
#~ "\n"
#~ "pub fn init(self: *Self, map: MemoryMap) void {\n"
#~ "    ...\n"
#~ "    while (true) {\n"
#~ "        const desc: *uefi.tables.MemoryDescriptor = desc_iter.next() "
#~ "orelse break;\n"
#~ "\n"
#~ "        // Mark holes between regions as allocated (used).\n"
#~ "        if (avail_end < desc.physical_start) {\n"
#~ "            self.markAllocated(phys2frame(avail_end), desc."
#~ "number_of_pages);\n"
#~ "        }\n"
#~ "        // Mark the region described by the descriptor as used or "
#~ "unused.\n"
#~ "        const phys_end = desc.physical_start + desc.number_of_pages * "
#~ "page_size;\n"
#~ "        if (isUsableMemory(desc)) {\n"
#~ "            avail_end = phys_end;\n"
#~ "            self.markNotUsed(phys2frame(desc.physical_start), desc."
#~ "number_of_pages);\n"
#~ "        } else {\n"
#~ "            self.markAllocated(phys2frame(desc.physical_start), desc."
#~ "number_of_pages);\n"
#~ "        }\n"
#~ "\n"
#~ "        self.frame_end = phys2frame(avail_end);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/mem/PageAllocator.zig\n"
#~ "fn resize(_: *anyopaque, _: []u8, _: u8, _: usize, _: usize) bool {\n"
#~ "    @panic(\"PageAllocator does not support resizing\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/mem/PageAllocator.zig\n"
#~ "fn resize(_: *anyopaque, _: []u8, _: u8, _: usize, _: usize) bool {\n"
#~ "    @panic(\"PageAllocator does not support resizing\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/mem.zig\n"
#~ "pub const PageAllocator = @import(\"mem/PageAllocator.zig\");\n"
#~ "pub var page_allocator_instance = PageAllocator.newUninit();\n"
#~ "pub const page_allocator = Allocator{\n"
#~ "    .ptr = &page_allocator_instance,\n"
#~ "    .vtable = &PageAllocator.vtable,\n"
#~ "};\n"
#~ "\n"
#~ "pub fn initPageAllocator(map: MemoryMap) void {\n"
#~ "    page_allocator_instance.init(map);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/mem.zig\n"
#~ "pub const PageAllocator = @import(\"mem/PageAllocator.zig\");\n"
#~ "pub var page_allocator_instance = PageAllocator.newUninit();\n"
#~ "pub const page_allocator = Allocator{\n"
#~ "    .ptr = &page_allocator_instance,\n"
#~ "    .vtable = &PageAllocator.vtable,\n"
#~ "};\n"
#~ "\n"
#~ "pub fn initPageAllocator(map: MemoryMap) void {\n"
#~ "    page_allocator_instance.init(map);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "mem.initPageAllocator(boot_info.memory_map);\n"
#~ "log.info(\"Initialized page allocator\", .{});\n"
#~ "const page_allocator = ymir.mem.page_allocator;\n"
#~ "\n"
#~ "const array = try page_allocator.alloc(u32, 4);\n"
#~ "log.debug(\"Memory allocated @ {X:0>16}\", .{@intFromPtr(array.ptr)});\n"
#~ "page_allocator.free(array);\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "mem.initPageAllocator(boot_info.memory_map);\n"
#~ "log.info(\"Initialized page allocator\", .{});\n"
#~ "const page_allocator = ymir.mem.page_allocator;\n"
#~ "\n"
#~ "const array = try page_allocator.alloc(u32, 4);\n"
#~ "log.debug(\"Memory allocated @ {X:0>16}\", .{@intFromPtr(array.ptr)});\n"
#~ "page_allocator.free(array);\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/page.zig\n"
#~ "pub fn reconstruct(allocator: Allocator) PageError!void {\n"
#~ "    const lv4tbl_ptr: [*]Lv4Entry = @ptrCast(try "
#~ "allocatePage(allocator));\n"
#~ "    const lv4tbl = lv4tbl_ptr[0..num_table_entries]; // 512\n"
#~ "    @memset(lv4tbl, std.mem.zeroes(Lv4Entry));\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/page.zig\n"
#~ "pub fn reconstruct(allocator: Allocator) PageError!void {\n"
#~ "    const lv4tbl_ptr: [*]Lv4Entry = @ptrCast(try "
#~ "allocatePage(allocator));\n"
#~ "    const lv4tbl = lv4tbl_ptr[0..num_table_entries]; // 512\n"
#~ "    @memset(lv4tbl, std.mem.zeroes(Lv4Entry));\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/page.zig\n"
#~ "const direct_map_base = ymir.direct_map_base;\n"
#~ "const direct_map_size = ymir.direct_map_size;\n"
#~ "\n"
#~ "\n"
#~ "pub fn reconstruct(allocator: Allocator) PageError!void {\n"
#~ "    ...\n"
#~ "    const lv4idx_start = (direct_map_base >> lv4_shift) & index_mask;\n"
#~ "    const lv4idx_end = lv4idx_start + (direct_map_size >> lv4_shift);\n"
#~ "\n"
#~ "    // Create the direct mapping using 1GiB pages.\n"
#~ "    for (lv4tbl[lv4idx_start..lv4idx_end], 0..) |*lv4ent, i| {\n"
#~ "        const lv3tbl: [*]Lv3Entry = @ptrCast(try "
#~ "allocatePage(allocator));\n"
#~ "        for (0..num_table_entries) |lv3idx| {\n"
#~ "            lv3tbl[lv3idx] = Lv3Entry.newMapPage(\n"
#~ "                (i << lv4_shift) + (lv3idx << lv3_shift),\n"
#~ "                true,\n"
#~ "            );\n"
#~ "        }\n"
#~ "        lv4ent.* = Lv4Entry.newMapTable(lv3tbl, true);\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/page.zig\n"
#~ "const direct_map_base = ymir.direct_map_base;\n"
#~ "const direct_map_size = ymir.direct_map_size;\n"
#~ "\n"
#~ "\n"
#~ "pub fn reconstruct(allocator: Allocator) PageError!void {\n"
#~ "    ...\n"
#~ "    const lv4idx_start = (direct_map_base >> lv4_shift) & index_mask;\n"
#~ "    const lv4idx_end = lv4idx_start + (direct_map_size >> lv4_shift);\n"
#~ "\n"
#~ "    // Create the direct mapping using 1GiB pages.\n"
#~ "    for (lv4tbl[lv4idx_start..lv4idx_end], 0..) |*lv4ent, i| {\n"
#~ "        const lv3tbl: [*]Lv3Entry = @ptrCast(try "
#~ "allocatePage(allocator));\n"
#~ "        for (0..num_table_entries) |lv3idx| {\n"
#~ "            lv3tbl[lv3idx] = Lv3Entry.newMapPage(\n"
#~ "                (i << lv4_shift) + (lv3idx << lv3_shift),\n"
#~ "                true,\n"
#~ "            );\n"
#~ "        }\n"
#~ "        lv4ent.* = Lv4Entry.newMapTable(lv3tbl, true);\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/page.zig\n"
#~ "pub fn reconstruct(allocator: Allocator) PageError!void {\n"
#~ "    ...\n"
#~ "    // Recursively clone tables for the kernel region.\n"
#~ "    const old_lv4tbl = getLv4Table(am.readCr3());\n"
#~ "    for (lv4idx_end..num_table_entries) |lv4idx| {\n"
#~ "        if (old_lv4tbl[lv4idx].present) {\n"
#~ "            const lv3tbl = getLv3Table(old_lv4tbl[lv4idx].address());\n"
#~ "            const new_lv3tbl = try cloneLevel3Table(lv3tbl, allocator);\n"
#~ "            lv4tbl[lv4idx] = Lv4Entry.newMapTable(new_lv3tbl.ptr, true);\n"
#~ "        }\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/page.zig\n"
#~ "pub fn reconstruct(allocator: Allocator) PageError!void {\n"
#~ "    ...\n"
#~ "    // Recursively clone tables for the kernel region.\n"
#~ "    const old_lv4tbl = getLv4Table(am.readCr3());\n"
#~ "    for (lv4idx_end..num_table_entries) |lv4idx| {\n"
#~ "        if (old_lv4tbl[lv4idx].present) {\n"
#~ "            const lv3tbl = getLv3Table(old_lv4tbl[lv4idx].address());\n"
#~ "            const new_lv3tbl = try cloneLevel3Table(lv3tbl, allocator);\n"
#~ "            lv4tbl[lv4idx] = Lv4Entry.newMapTable(new_lv3tbl.ptr, true);\n"
#~ "        }\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/mem.zig\n"
#~ "pub fn virt2phys(addr: u64) Phys {\n"
#~ "    return if (!mapping_reconstructed) b: {\n"
#~ "        // UEFI's page table.\n"
#~ "        break :b addr;\n"
#~ "    } else if (addr < ymir.kernel_base) b: {\n"
#~ "        // Direct map region.\n"
#~ "        break :b addr - ymir.direct_map_base;\n"
#~ "    } else b: {\n"
#~ "        // Kernel image mapping region.\n"
#~ "        break :b addr - ymir.kernel_base;\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "pub fn phys2virt(addr: u64) Virt {\n"
#~ "    return if (!mapping_reconstructed) b: {\n"
#~ "        // UEFI's page table.\n"
#~ "        break :b addr;\n"
#~ "    } else b: {\n"
#~ "        // Direct map region.\n"
#~ "        break :b addr + ymir.direct_map_base;\n"
#~ "    };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/mem.zig\n"
#~ "pub fn virt2phys(addr: u64) Phys {\n"
#~ "    return if (!mapping_reconstructed) b: {\n"
#~ "        // UEFI's page table.\n"
#~ "        break :b addr;\n"
#~ "    } else if (addr < ymir.kernel_base) b: {\n"
#~ "        // Direct map region.\n"
#~ "        break :b addr - ymir.direct_map_base;\n"
#~ "    } else b: {\n"
#~ "        // Kernel image mapping region.\n"
#~ "        break :b addr - ymir.kernel_base;\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "pub fn phys2virt(addr: u64) Virt {\n"
#~ "    return if (!mapping_reconstructed) b: {\n"
#~ "        // UEFI's page table.\n"
#~ "        break :b addr;\n"
#~ "    } else b: {\n"
#~ "        // Direct map region.\n"
#~ "        break :b addr + ymir.direct_map_base;\n"
#~ "    };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "log.info(\"Reconstructing memory mapping...\", .{});\n"
#~ "try mem.reconstructMapping(mem.page_allocator);\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "log.info(\"Reconstructing memory mapping...\", .{});\n"
#~ "try mem.reconstructMapping(mem.page_allocator);\n"
#~ "```"

#~ msgid ""
#~ "```surtr/arch/x86/asm.zig\n"
#~ "pub inline fn flushTlbSingle(virt: u64) void {\n"
#~ "    asm volatile (\n"
#~ "        \\\\invlpg (%[virt])\n"
#~ "        :\n"
#~ "        : [virt] \"r\" (virt),\n"
#~ "        : \"memory\"\n"
#~ "    );\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/arch/x86/asm.zig\n"
#~ "pub inline fn flushTlbSingle(virt: u64) void {\n"
#~ "    asm volatile (\n"
#~ "        \\\\invlpg (%[virt])\n"
#~ "        :\n"
#~ "        : [virt] \"r\" (virt),\n"
#~ "        : \"memory\"\n"
#~ "    );\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "// セグメントごとにカーネルをロードするところ\n"
#~ "while (true) {\n"
#~ "    const phdr = iter.next() ...;\n"
#~ "    ...\n"
#~ "\n"
#~ "    // Change memory protection.\n"
#~ "    const page_start = phdr.p_vaddr & ~page_mask;\n"
#~ "    const page_end = (phdr.p_vaddr + phdr.p_memsz + (page_size - 1)) & "
#~ "~page_mask;\n"
#~ "    const size = (page_end - page_start) / page_size;\n"
#~ "    const attribute = arch.page.PageAttribute.fromFlags(phdr.p_flags);\n"
#~ "    for (0..size) |i| {\n"
#~ "        arch.page.changeMap4k(\n"
#~ "            page_start + page_size * i,\n"
#~ "            attribute,\n"
#~ "        ) catch |err| {\n"
#~ "            log.err(\"Failed to change memory protection: {?}\", ."
#~ "{err});\n"
#~ "            return .LoadError;\n"
#~ "        };\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "// セグメントごとにカーネルをロードするところ\n"
#~ "while (true) {\n"
#~ "    const phdr = iter.next() ...;\n"
#~ "    ...\n"
#~ "\n"
#~ "    // Change memory protection.\n"
#~ "    const page_start = phdr.p_vaddr & ~page_mask;\n"
#~ "    const page_end = (phdr.p_vaddr + phdr.p_memsz + (page_size - 1)) & "
#~ "~page_mask;\n"
#~ "    const size = (page_end - page_start) / page_size;\n"
#~ "    const attribute = arch.page.PageAttribute.fromFlags(phdr.p_flags);\n"
#~ "    for (0..size) |i| {\n"
#~ "        arch.page.changeMap4k(\n"
#~ "            page_start + page_size * i,\n"
#~ "            attribute,\n"
#~ "        ) catch |err| {\n"
#~ "            log.err(\"Failed to change memory protection: {?}\", ."
#~ "{err});\n"
#~ "            return .LoadError;\n"
#~ "        };\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/panic.zig\n"
#~ "var panicked = false;\n"
#~ "\n"
#~ "fn panic(msg: []const u8, _: ?*builtin.StackTrace, _: ?usize) noreturn {\n"
#~ "    @setCold(true);\n"
#~ "    arch.disableIntr();\n"
#~ "    log.err(\"{s}\", .{msg});\n"
#~ "\n"
#~ "    if (panicked) {\n"
#~ "        log.err(\"Double panic detected. Halting.\", .{});\n"
#~ "        ymir.endlessHalt();\n"
#~ "    }\n"
#~ "    panicked = true;\n"
#~ "\n"
#~ "    ... // スタックトレースの表示\n"
#~ "\n"
#~ "    ymir.endlessHalt();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/panic.zig\n"
#~ "var panicked = false;\n"
#~ "\n"
#~ "fn panic(msg: []const u8, _: ?*builtin.StackTrace, _: ?usize) noreturn {\n"
#~ "    @setCold(true);\n"
#~ "    arch.disableIntr();\n"
#~ "    log.err(\"{s}\", .{msg});\n"
#~ "\n"
#~ "    if (panicked) {\n"
#~ "        log.err(\"Double panic detected. Halting.\", .{});\n"
#~ "        ymir.endlessHalt();\n"
#~ "    }\n"
#~ "    panicked = true;\n"
#~ "\n"
#~ "    ... // スタックトレースの表示\n"
#~ "\n"
#~ "    ymir.endlessHalt();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/panic.zig\n"
#~ "pub const panic_fn = panic;\n"
#~ "\n"
#~ "fn panic(msg: []const u8, _: ?*builtin.StackTrace, _: ?usize) noreturn {\n"
#~ "    ...\n"
#~ "    var it = std.debug.StackIterator.init(@returnAddress(), null);\n"
#~ "    var ix: usize = 0;\n"
#~ "    log.err(\"=== Stack Trace ==============\", .{});\n"
#~ "    while (it.next()) |frame| : (ix += 1) {\n"
#~ "        log.err(\"#{d:0>2}: 0x{X:0>16}\", .{ ix, frame });\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/panic.zig\n"
#~ "pub const panic_fn = panic;\n"
#~ "\n"
#~ "fn panic(msg: []const u8, _: ?*builtin.StackTrace, _: ?usize) noreturn {\n"
#~ "    ...\n"
#~ "    var it = std.debug.StackIterator.init(@returnAddress(), null);\n"
#~ "    var ix: usize = 0;\n"
#~ "    log.err(\"=== Stack Trace ==============\", .{});\n"
#~ "    while (it.next()) |frame| : (ix += 1) {\n"
#~ "        log.err(\"#{d:0>2}: 0x{X:0>16}\", .{ ix, frame });\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.tmp.zig\n"
#~ "@panic(\"fugafuga\");\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.tmp.zig\n"
#~ "@panic(\"fugafuga\");\n"
#~ "```"

#~ msgid ""
#~ "```ymir/mem/BinAllocator.zig\n"
#~ "pub const vtable = Allocator.VTable{\n"
#~ "    .alloc = allocate,\n"
#~ "    .free = free,\n"
#~ "    .resize = resize,\n"
#~ "};\n"
#~ "\n"
#~ "const bin_sizes = [_]usize{\n"
#~ "    0x20, 0x40, 0x80, 0x100, 0x200, 0x400, 0x800,\n"
#~ "};\n"
#~ "\n"
#~ "comptime {\n"
#~ "    if (bin_sizes[bin_sizes.len - 1] > 4096) {\n"
#~ "        @compileError(\"The largest bin size exceeds a 4KiB page "
#~ "size\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/mem/BinAllocator.zig\n"
#~ "pub const vtable = Allocator.VTable{\n"
#~ "    .alloc = allocate,\n"
#~ "    .free = free,\n"
#~ "    .resize = resize,\n"
#~ "};\n"
#~ "\n"
#~ "const bin_sizes = [_]usize{\n"
#~ "    0x20, 0x40, 0x80, 0x100, 0x200, 0x400, 0x800,\n"
#~ "};\n"
#~ "\n"
#~ "comptime {\n"
#~ "    if (bin_sizes[bin_sizes.len - 1] > 4096) {\n"
#~ "        @compileError(\"The largest bin size exceeds a 4KiB page "
#~ "size\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/mem/BinAllocator.zig\n"
#~ "/// Heads of the chunk lists.\n"
#~ "list_heads: [bin_sizes.len]ChunkMetaPointer,\n"
#~ "\n"
#~ "const ChunkMetaNode = packed struct {\n"
#~ "    next: ChunkMetaPointer = null,\n"
#~ "};\n"
#~ "const ChunkMetaPointer = ?*ChunkMetaNode;\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/mem/BinAllocator.zig\n"
#~ "/// Heads of the chunk lists.\n"
#~ "list_heads: [bin_sizes.len]ChunkMetaPointer,\n"
#~ "\n"
#~ "const ChunkMetaNode = packed struct {\n"
#~ "    next: ChunkMetaPointer = null,\n"
#~ "};\n"
#~ "const ChunkMetaPointer = ?*ChunkMetaNode;\n"
#~ "```"

#~ msgid ""
#~ "```ymir/mem/BinAllocator.zig\n"
#~ "fn allocFromBin(self: *Self, bin_index: usize) ?[*]u8 {\n"
#~ "    if (self.list_heads[bin_index] == null) {\n"
#~ "        initBinPage(self, bin_index) orelse return null;\n"
#~ "    }\n"
#~ "    return @ptrCast(pop(&self.list_heads[bin_index]));\n"
#~ "}\n"
#~ "\n"
#~ "fn pop(list_head: *ChunkMetaPointer) *ChunkMetaNode {\n"
#~ "    if (list_head.*) |first| {\n"
#~ "        list_head.* = first.next;\n"
#~ "        return first;\n"
#~ "    } else {\n"
#~ "        @panic(\"BinAllocator: pop from empty list\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/mem/BinAllocator.zig\n"
#~ "fn allocFromBin(self: *Self, bin_index: usize) ?[*]u8 {\n"
#~ "    if (self.list_heads[bin_index] == null) {\n"
#~ "        initBinPage(self, bin_index) orelse return null;\n"
#~ "    }\n"
#~ "    return @ptrCast(pop(&self.list_heads[bin_index]));\n"
#~ "}\n"
#~ "\n"
#~ "fn pop(list_head: *ChunkMetaPointer) *ChunkMetaNode {\n"
#~ "    if (list_head.*) |first| {\n"
#~ "        list_head.* = first.next;\n"
#~ "        return first;\n"
#~ "    } else {\n"
#~ "        @panic(\"BinAllocator: pop from empty list\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/mem/BinAllocator.zig\n"
#~ "fn resize(_: *anyopaque, _: []u8, _: u8, _: usize, _: usize) bool {\n"
#~ "    @panic(\"BinAllocator does not support resizing\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/mem/BinAllocator.zig\n"
#~ "fn resize(_: *anyopaque, _: []u8, _: u8, _: usize, _: usize) bool {\n"
#~ "    @panic(\"BinAllocator does not support resizing\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/mem.zig\n"
#~ "pub const general_allocator = Allocator{\n"
#~ "    .ptr = &bin_allocator_instance,\n"
#~ "    .vtable = &BinAllocator.vtable,\n"
#~ "};\n"
#~ "const BinAllocator = @import(\"mem/BinAllocator.zig\");\n"
#~ "var bin_allocator_instance = BinAllocator.newUninit();\n"
#~ "\n"
#~ "pub fn initGeneralAllocator() void {\n"
#~ "    bin_allocator_instance.init(page_allocator);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/mem.zig\n"
#~ "pub const general_allocator = Allocator{\n"
#~ "    .ptr = &bin_allocator_instance,\n"
#~ "    .vtable = &BinAllocator.vtable,\n"
#~ "};\n"
#~ "const BinAllocator = @import(\"mem/BinAllocator.zig\");\n"
#~ "var bin_allocator_instance = BinAllocator.newUninit();\n"
#~ "\n"
#~ "pub fn initGeneralAllocator() void {\n"
#~ "    bin_allocator_instance.init(page_allocator);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "ymir.mem.initGeneralAllocator();\n"
#~ "log.info(\"Initialized general allocator.\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "ymir.mem.initGeneralAllocator();\n"
#~ "log.info(\"Initialized general allocator.\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "const p = try ymir.mem.general_allocator.alloc(u8, 0x4);\n"
#~ "const q = try ymir.mem.general_allocator.alloc(u8, 0x4);\n"
#~ "log.debug(\"p @ {X:0>16}\", .{@intFromPtr(p.ptr)});\n"
#~ "log.debug(\"q @ {X:0>16}\", .{@intFromPtr(q.ptr)});\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "const p = try ymir.mem.general_allocator.alloc(u8, 0x4);\n"
#~ "const q = try ymir.mem.general_allocator.alloc(u8, 0x4);\n"
#~ "log.debug(\"p @ {X:0>16}\", .{@intFromPtr(p.ptr)});\n"
#~ "log.debug(\"q @ {X:0>16}\", .{@intFromPtr(q.ptr)});\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/pic.zig\n"
#~ "const icw = enum { icw1, icw2, icw3, icw4 };\n"
#~ "const Icw = union(icw) {\n"
#~ "    icw1: Icw1,\n"
#~ "    icw2: Icw2,\n"
#~ "    icw3: Icw3,\n"
#~ "    icw4: Icw4,\n"
#~ "\n"
#~ "    const Icw1 = packed struct(u8) {\n"
#~ "        /// ICW4 is needed.\n"
#~ "        icw4: bool = true,\n"
#~ "        /// Sigle or cascade mode.\n"
#~ "        single: bool = false,\n"
#~ "        /// CALL address interval 4 or 8.\n"
#~ "        interval4: bool = false,\n"
#~ "        /// Level triggered or edge triggered.\n"
#~ "        level: bool = false,\n"
#~ "        /// Initialization command.\n"
#~ "        _icw1: u1 = 1,\n"
#~ "        /// Unused in 8085 mode.\n"
#~ "        _unused: u3 = 0,\n"
#~ "    };\n"
#~ "    const Icw2 = packed struct(u8) {\n"
#~ "        /// Vector offset.\n"
#~ "        offset: u8,\n"
#~ "    };\n"
#~ "    const Icw3 = packed struct(u8) {\n"
#~ "        /// For primary PIC, IRQ that is cascaded.\n"
#~ "        /// For secondary PIC, cascade identity.\n"
#~ "        cascade_id: u8,\n"
#~ "    };\n"
#~ "    const Icw4 = packed struct(u8) {\n"
#~ "        /// 8086/8088 mode or MCS-80/85 mode.\n"
#~ "        mode_8086: bool = true,\n"
#~ "        /// Auto EOI or normal EOI.\n"
#~ "        auto_eoi: bool = false,\n"
#~ "        /// Buffered mode.\n"
#~ "        buf: u2 = 0,\n"
#~ "        /// Special fully nested mode.\n"
#~ "        full_nested: bool = false,\n"
#~ "        /// ReservedZ.\n"
#~ "        _reserved: u3 = 0,\n"
#~ "    };\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/pic.zig\n"
#~ "const icw = enum { icw1, icw2, icw3, icw4 };\n"
#~ "const Icw = union(icw) {\n"
#~ "    icw1: Icw1,\n"
#~ "    icw2: Icw2,\n"
#~ "    icw3: Icw3,\n"
#~ "    icw4: Icw4,\n"
#~ "\n"
#~ "    const Icw1 = packed struct(u8) {\n"
#~ "        /// ICW4 is needed.\n"
#~ "        icw4: bool = true,\n"
#~ "        /// Sigle or cascade mode.\n"
#~ "        single: bool = false,\n"
#~ "        /// CALL address interval 4 or 8.\n"
#~ "        interval4: bool = false,\n"
#~ "        /// Level triggered or edge triggered.\n"
#~ "        level: bool = false,\n"
#~ "        /// Initialization command.\n"
#~ "        _icw1: u1 = 1,\n"
#~ "        /// Unused in 8085 mode.\n"
#~ "        _unused: u3 = 0,\n"
#~ "    };\n"
#~ "    const Icw2 = packed struct(u8) {\n"
#~ "        /// Vector offset.\n"
#~ "        offset: u8,\n"
#~ "    };\n"
#~ "    const Icw3 = packed struct(u8) {\n"
#~ "        /// For primary PIC, IRQ that is cascaded.\n"
#~ "        /// For secondary PIC, cascade identity.\n"
#~ "        cascade_id: u8,\n"
#~ "    };\n"
#~ "    const Icw4 = packed struct(u8) {\n"
#~ "        /// 8086/8088 mode or MCS-80/85 mode.\n"
#~ "        mode_8086: bool = true,\n"
#~ "        /// Auto EOI or normal EOI.\n"
#~ "        auto_eoi: bool = false,\n"
#~ "        /// Buffered mode.\n"
#~ "        buf: u2 = 0,\n"
#~ "        /// Special fully nested mode.\n"
#~ "        full_nested: bool = false,\n"
#~ "        /// ReservedZ.\n"
#~ "        _reserved: u3 = 0,\n"
#~ "    };\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/pic.zig\n"
#~ "const ocw = enum { ocw1, ocw2, ocw3 };\n"
#~ "const Ocw = union(ocw) {\n"
#~ "    ocw1: Ocw1,\n"
#~ "    ocw2: Ocw2,\n"
#~ "    ocw3: Ocw3,\n"
#~ "\n"
#~ "    const Ocw1 = packed struct(u8) {\n"
#~ "        /// Interrupt mask.\n"
#~ "        imr: u8,\n"
#~ "    };\n"
#~ "    const Ocw2 = packed struct(u8) {\n"
#~ "        /// Target IRQ.\n"
#~ "        level: u3 = 0,\n"
#~ "        /// ReservedZ.\n"
#~ "        _reserved: u2 = 0,\n"
#~ "        /// EOI\n"
#~ "        eoi: bool,\n"
#~ "        /// If set, specific EOI.\n"
#~ "        sl: bool,\n"
#~ "        /// Rotate priority.\n"
#~ "        rotate: bool = false,\n"
#~ "    };\n"
#~ "    const Ocw3 = packed struct(u8) {\n"
#~ "        /// Target register to read.\n"
#~ "        ris: Reg,\n"
#~ "        /// Read register command.\n"
#~ "        read: bool,\n"
#~ "        /// Unused in Ymir.\n"
#~ "        _unused1: u1 = 0,\n"
#~ "        /// Reserved 01.\n"
#~ "        _reserved1: u2 = 0b01,\n"
#~ "        /// Unused in Ymir.\n"
#~ "        _unused2: u2 = 0,\n"
#~ "        /// ReservedZ.\n"
#~ "        _reserved2: u1 = 0,\n"
#~ "\n"
#~ "        const Reg = enum(u1) { irr = 0, isr = 1 };\n"
#~ "    };\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/pic.zig\n"
#~ "const ocw = enum { ocw1, ocw2, ocw3 };\n"
#~ "const Ocw = union(ocw) {\n"
#~ "    ocw1: Ocw1,\n"
#~ "    ocw2: Ocw2,\n"
#~ "    ocw3: Ocw3,\n"
#~ "\n"
#~ "    const Ocw1 = packed struct(u8) {\n"
#~ "        /// Interrupt mask.\n"
#~ "        imr: u8,\n"
#~ "    };\n"
#~ "    const Ocw2 = packed struct(u8) {\n"
#~ "        /// Target IRQ.\n"
#~ "        level: u3 = 0,\n"
#~ "        /// ReservedZ.\n"
#~ "        _reserved: u2 = 0,\n"
#~ "        /// EOI\n"
#~ "        eoi: bool,\n"
#~ "        /// If set, specific EOI.\n"
#~ "        sl: bool,\n"
#~ "        /// Rotate priority.\n"
#~ "        rotate: bool = false,\n"
#~ "    };\n"
#~ "    const Ocw3 = packed struct(u8) {\n"
#~ "        /// Target register to read.\n"
#~ "        ris: Reg,\n"
#~ "        /// Read register command.\n"
#~ "        read: bool,\n"
#~ "        /// Unused in Ymir.\n"
#~ "        _unused1: u1 = 0,\n"
#~ "        /// Reserved 01.\n"
#~ "        _reserved1: u2 = 0b01,\n"
#~ "        /// Unused in Ymir.\n"
#~ "        _unused2: u2 = 0,\n"
#~ "        /// ReservedZ.\n"
#~ "        _reserved2: u1 = 0,\n"
#~ "\n"
#~ "        const Reg = enum(u1) { irr = 0, isr = 1 };\n"
#~ "    };\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/pic.zig\n"
#~ "const am = @import(\"asm.zig\");\n"
#~ "\n"
#~ "fn issue(cw: anytype, port: u16) void {\n"
#~ "    const T = @TypeOf(cw);\n"
#~ "    if (T != Icw and T != Ocw) {\n"
#~ "        @compileError(\"Unsupported type for pic.issue()\");\n"
#~ "    }\n"
#~ "    switch (cw) {\n"
#~ "        inline else => |s| am.outb(@bitCast(s), port),\n"
#~ "    }\n"
#~ "    am.relax();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/pic.zig\n"
#~ "const am = @import(\"asm.zig\");\n"
#~ "\n"
#~ "fn issue(cw: anytype, port: u16) void {\n"
#~ "    const T = @TypeOf(cw);\n"
#~ "    if (T != Icw and T != Ocw) {\n"
#~ "        @compileError(\"Unsupported type for pic.issue()\");\n"
#~ "    }\n"
#~ "    switch (cw) {\n"
#~ "        inline else => |s| am.outb(@bitCast(s), port),\n"
#~ "    }\n"
#~ "    am.relax();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/pic.zig\n"
#~ "pub const primary_vector_offset: usize = 32;\n"
#~ "pub const secondary_vector_offset: usize = primary_vector_offset + 8;\n"
#~ "\n"
#~ "pub fn init() void {\n"
#~ "    am.cli();\n"
#~ "    defer am.sti();\n"
#~ "\n"
#~ "    // Start initialization sequence.\n"
#~ "    issue(Icw{ .icw1 = .{} }, primary_command_port);\n"
#~ "    issue(Icw{ .icw1 = .{} }, secondary_command_port);\n"
#~ "\n"
#~ "    // Set the vector offsets.\n"
#~ "    issue(Icw{ .icw2 = .{ .offset = primary_vector_offset } }, "
#~ "primary_data_port);\n"
#~ "    issue(Icw{ .icw2 = .{ .offset = secondary_vector_offset } }, "
#~ "secondary_data_port);\n"
#~ "\n"
#~ "    // Tell primary PIC that there is a slave PIC at IRQ2.\n"
#~ "    issue(Icw{ .icw3 = .{ .cascade_id = 0b100 } }, primary_data_port);\n"
#~ "    // Tell secondary PIC its cascade identity.\n"
#~ "    issue(Icw{ .icw3 = .{ .cascade_id = 2 } }, secondary_data_port);\n"
#~ "\n"
#~ "    // Set the mode.\n"
#~ "    issue(Icw{ .icw4 = .{} }, primary_data_port);\n"
#~ "    issue(Icw{ .icw4 = .{} }, secondary_data_port);\n"
#~ "\n"
#~ "    // Mask all IRQ lines.\n"
#~ "    setImr(0xFF, primary_data_port);\n"
#~ "    setImr(0xFF, secondary_data_port);\n"
#~ "}\n"
#~ "\n"
#~ "fn setImr(imr: u8, port: u16) void {\n"
#~ "    issue(Ocw{ .ocw1 = .{ .imr = imr } }, port);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/pic.zig\n"
#~ "pub const primary_vector_offset: usize = 32;\n"
#~ "pub const secondary_vector_offset: usize = primary_vector_offset + 8;\n"
#~ "\n"
#~ "pub fn init() void {\n"
#~ "    am.cli();\n"
#~ "    defer am.sti();\n"
#~ "\n"
#~ "    // Start initialization sequence.\n"
#~ "    issue(Icw{ .icw1 = .{} }, primary_command_port);\n"
#~ "    issue(Icw{ .icw1 = .{} }, secondary_command_port);\n"
#~ "\n"
#~ "    // Set the vector offsets.\n"
#~ "    issue(Icw{ .icw2 = .{ .offset = primary_vector_offset } }, "
#~ "primary_data_port);\n"
#~ "    issue(Icw{ .icw2 = .{ .offset = secondary_vector_offset } }, "
#~ "secondary_data_port);\n"
#~ "\n"
#~ "    // Tell primary PIC that there is a slave PIC at IRQ2.\n"
#~ "    issue(Icw{ .icw3 = .{ .cascade_id = 0b100 } }, primary_data_port);\n"
#~ "    // Tell secondary PIC its cascade identity.\n"
#~ "    issue(Icw{ .icw3 = .{ .cascade_id = 2 } }, secondary_data_port);\n"
#~ "\n"
#~ "    // Set the mode.\n"
#~ "    issue(Icw{ .icw4 = .{} }, primary_data_port);\n"
#~ "    issue(Icw{ .icw4 = .{} }, secondary_data_port);\n"
#~ "\n"
#~ "    // Mask all IRQ lines.\n"
#~ "    setImr(0xFF, primary_data_port);\n"
#~ "    setImr(0xFF, secondary_data_port);\n"
#~ "}\n"
#~ "\n"
#~ "fn setImr(imr: u8, port: u16) void {\n"
#~ "    issue(Ocw{ .ocw1 = .{ .imr = imr } }, port);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/pic.zig\n"
#~ "pub const IrqLine = enum(u8) {\n"
#~ "    timer = 0,\n"
#~ "    keyboard = 1,\n"
#~ "    secondary = 2,\n"
#~ "    serial2 = 3,\n"
#~ "    serial1 = 4,\n"
#~ "    parallel23 = 5,\n"
#~ "    floppy = 6,\n"
#~ "    parallel1 = 7,\n"
#~ "    rtc = 8,\n"
#~ "    acpi = 9,\n"
#~ "    open1 = 10,\n"
#~ "    open2 = 11,\n"
#~ "    mouse = 12,\n"
#~ "    cop = 13,\n"
#~ "    primary_ata = 14,\n"
#~ "    secondary_ata = 15,\n"
#~ "\n"
#~ "    /// Return true if the IRQ belongs to the primary PIC.\n"
#~ "    pub fn isPrimary(self: IrqLine) bool {\n"
#~ "        return @intFromEnum(self) < 8;\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the command port for this IRQ.\n"
#~ "    pub inline fn commandPort(self: IrqLine) u16 {\n"
#~ "        return if (self.isPrimary()) primary_command_port else "
#~ "secondary_command_port;\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the data port for this IRQ.\n"
#~ "    pub inline fn dataPort(self: IrqLine) u16 {\n"
#~ "        return if (self.isPrimary()) primary_data_port else "
#~ "secondary_data_port;\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the offset of the IRQ within the PIC.\n"
#~ "    pub fn delta(self: IrqLine) u3 {\n"
#~ "        return @intCast(if (self.isPrimary()) @intFromEnum(self) else "
#~ "(@intFromEnum(self) - 8));\n"
#~ "    }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/pic.zig\n"
#~ "pub const IrqLine = enum(u8) {\n"
#~ "    timer = 0,\n"
#~ "    keyboard = 1,\n"
#~ "    secondary = 2,\n"
#~ "    serial2 = 3,\n"
#~ "    serial1 = 4,\n"
#~ "    parallel23 = 5,\n"
#~ "    floppy = 6,\n"
#~ "    parallel1 = 7,\n"
#~ "    rtc = 8,\n"
#~ "    acpi = 9,\n"
#~ "    open1 = 10,\n"
#~ "    open2 = 11,\n"
#~ "    mouse = 12,\n"
#~ "    cop = 13,\n"
#~ "    primary_ata = 14,\n"
#~ "    secondary_ata = 15,\n"
#~ "\n"
#~ "    /// Return true if the IRQ belongs to the primary PIC.\n"
#~ "    pub fn isPrimary(self: IrqLine) bool {\n"
#~ "        return @intFromEnum(self) < 8;\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the command port for this IRQ.\n"
#~ "    pub inline fn commandPort(self: IrqLine) u16 {\n"
#~ "        return if (self.isPrimary()) primary_command_port else "
#~ "secondary_command_port;\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the data port for this IRQ.\n"
#~ "    pub inline fn dataPort(self: IrqLine) u16 {\n"
#~ "        return if (self.isPrimary()) primary_data_port else "
#~ "secondary_data_port;\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the offset of the IRQ within the PIC.\n"
#~ "    pub fn delta(self: IrqLine) u3 {\n"
#~ "        return @intCast(if (self.isPrimary()) @intFromEnum(self) else "
#~ "(@intFromEnum(self) - 8));\n"
#~ "    }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "arch.pic.init();\n"
#~ "log.info(\"Initialized PIC.\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "arch.pic.init();\n"
#~ "log.info(\"Initialized PIC.\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "fn blobIrqHandler(ctx: *arch.intr.Context) void {\n"
#~ "    const vector: u16 = @intCast(ctx.vector - 0x20);\n"
#~ "    log.debug(\"IRQ: {d}\", .{vector});\n"
#~ "    arch.pic.notifyEoi(@enumFromInt(vector));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "fn blobIrqHandler(ctx: *arch.intr.Context) void {\n"
#~ "    const vector: u16 = @intCast(ctx.vector - 0x20);\n"
#~ "    log.debug(\"IRQ: {d}\", .{vector});\n"
#~ "    arch.pic.notifyEoi(@enumFromInt(vector));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/serial.zig\n"
#~ "pub fn enableInterrupt(port: Ports) void {\n"
#~ "    var ie = am.inb(@intFromEnum(port) + offsets.ier);\n"
#~ "    ie |= @as(u8, 0b0000_0001); // Rx-available\n"
#~ "    ie &= ~@as(u8, 0b0000_0010); // ~Tx-available\n"
#~ "    am.outb(ie, @intFromEnum(port) + offsets.ier);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/serial.zig\n"
#~ "pub fn enableInterrupt(port: Ports) void {\n"
#~ "    var ie = am.inb(@intFromEnum(port) + offsets.ier);\n"
#~ "    ie |= @as(u8, 0b0000_0001); // Rx-available\n"
#~ "    ie &= ~@as(u8, 0b0000_0010); // ~Tx-available\n"
#~ "    am.outb(ie, @intFromEnum(port) + offsets.ier);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/interrupts.zig\n"
#~ "const arch = @import(\"ymir\").arch;\n"
#~ "\n"
#~ "pub const user_intr_base = arch.intr.num_system_exceptions;\n"
#~ "\n"
#~ "pub const pic_timer = 0 + user_intr_base;\n"
#~ "...\n"
#~ "pub const pic_serial1 = 4 + user_intr_base;\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/interrupts.zig\n"
#~ "const arch = @import(\"ymir\").arch;\n"
#~ "\n"
#~ "pub const user_intr_base = arch.intr.num_system_exceptions;\n"
#~ "\n"
#~ "pub const pic_timer = 0 + user_intr_base;\n"
#~ "...\n"
#~ "pub const pic_serial1 = 4 + user_intr_base;\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/serial.zig\n"
#~ "    ie |= @as(u8, 0b0000_0011); // Tx-empty, Rx-available\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/serial.zig\n"
#~ "    ie |= @as(u8, 0b0000_0011); // Tx-empty, Rx-available\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "arch.intr.registerHandler(idefs.pic_timer, blobIrqHandler);\n"
#~ "arch.pic.unsetMask(.timer);\n"
#~ "log.info(\"Enabled PIT.\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "arch.intr.registerHandler(idefs.pic_timer, blobIrqHandler);\n"
#~ "arch.pic.unsetMask(.timer);\n"
#~ "log.info(\"Enabled PIT.\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```ymir/vmx.zig\n"
#~ "const VmError = error{\n"
#~ "    /// Memory allocation failed.\n"
#~ "    OutOfMemory,\n"
#~ "    /// The system does not support virtualization.\n"
#~ "    SystemNotSupported,\n"
#~ "    /// Unknown error.\n"
#~ "    UnknownError,\n"
#~ "};\n"
#~ "\n"
#~ "pub const Vm = struct {\n"
#~ "    const Self = @This();\n"
#~ "\n"
#~ "    pub fn new() VmError!Self {\n"
#~ "        // 1. Check CPU vendor.\n"
#~ "        TODO\n"
#~ "        // 2&3. Check if VMX is supported.\n"
#~ "        TODO\n"
#~ "\n"
#~ "        return Self{};\n"
#~ "    }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/vmx.zig\n"
#~ "const VmError = error{\n"
#~ "    /// Memory allocation failed.\n"
#~ "    OutOfMemory,\n"
#~ "    /// The system does not support virtualization.\n"
#~ "    SystemNotSupported,\n"
#~ "    /// Unknown error.\n"
#~ "    UnknownError,\n"
#~ "};\n"
#~ "\n"
#~ "pub const Vm = struct {\n"
#~ "    const Self = @This();\n"
#~ "\n"
#~ "    pub fn new() VmError!Self {\n"
#~ "        // 1. Check CPU vendor.\n"
#~ "        TODO\n"
#~ "        // 2&3. Check if VMX is supported.\n"
#~ "        TODO\n"
#~ "\n"
#~ "        return Self{};\n"
#~ "    }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/cpuid.zig\n"
#~ "pub const Leaf = enum(u32) {\n"
#~ "    maximum_input = 0x0,\n"
#~ "    vers_and_feat_info = 0x1,\n"
#~ "    ext_feature = 0x7,\n"
#~ "    ext_enumeration = 0xD,\n"
#~ "    ext_func = 0x80000000,\n"
#~ "    ext_proc_signature = 0x80000001,\n"
#~ "    _,\n"
#~ "\n"
#~ "    /// Convert u64 to Leaf.\n"
#~ "    pub fn from(rax: u64) Leaf {\n"
#~ "        return @enumFromInt(rax);\n"
#~ "    }\n"
#~ "    /// Issues CPUID instruction to query the leaf and sub-leaf.\n"
#~ "    pub fn query(self: Leaf, subleaf: ?u32) CpuidRegisters {\n"
#~ "        return cpuid(@intFromEnum(self), subleaf orelse 0);\n"
#~ "    }\n"
#~ "};\n"
#~ "\n"
#~ "const CpuidRegisters = struct {\n"
#~ "    eax: u32,\n"
#~ "    ebx: u32,\n"
#~ "    ecx: u32,\n"
#~ "    edx: u32,\n"
#~ "};\n"
#~ "\n"
#~ "pub const FeatureInfoEcx = packed struct(u32) {\n"
#~ "    /// ...\n"
#~ "    _other_fields1: u5,\n"
#~ "    /// Virtual Machine Extensions.\n"
#~ "    vmx: bool = false,\n"
#~ "    /// ...\n"
#~ "    _other_fields2: u26,\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/cpuid.zig\n"
#~ "pub const Leaf = enum(u32) {\n"
#~ "    maximum_input = 0x0,\n"
#~ "    vers_and_feat_info = 0x1,\n"
#~ "    ext_feature = 0x7,\n"
#~ "    ext_enumeration = 0xD,\n"
#~ "    ext_func = 0x80000000,\n"
#~ "    ext_proc_signature = 0x80000001,\n"
#~ "    _,\n"
#~ "\n"
#~ "    /// Convert u64 to Leaf.\n"
#~ "    pub fn from(rax: u64) Leaf {\n"
#~ "        return @enumFromInt(rax);\n"
#~ "    }\n"
#~ "    /// Issues CPUID instruction to query the leaf and sub-leaf.\n"
#~ "    pub fn query(self: Leaf, subleaf: ?u32) CpuidRegisters {\n"
#~ "        return cpuid(@intFromEnum(self), subleaf orelse 0);\n"
#~ "    }\n"
#~ "};\n"
#~ "\n"
#~ "const CpuidRegisters = struct {\n"
#~ "    eax: u32,\n"
#~ "    ebx: u32,\n"
#~ "    ecx: u32,\n"
#~ "    edx: u32,\n"
#~ "};\n"
#~ "\n"
#~ "pub const FeatureInfoEcx = packed struct(u32) {\n"
#~ "    /// ...\n"
#~ "    _other_fields1: u5,\n"
#~ "    /// Virtual Machine Extensions.\n"
#~ "    vmx: bool = false,\n"
#~ "    /// ...\n"
#~ "    _other_fields2: u26,\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```zig\n"
#~ "const result = Leaf.query(.ext_feature, 0x1);\n"
#~ "// OR\n"
#~ "const result = Leaf.ext_feature.query(0x1);\n"
#~ "```"
#~ msgstr ""
#~ "```zig\n"
#~ "const result = Leaf.query(.ext_feature, 0x1);\n"
#~ "// OR\n"
#~ "const result = Leaf.ext_feature.query(0x1);\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/cpuid.zig\n"
#~ "fn cpuid(leaf: u32, subleaf: u32) CpuidRegisters {\n"
#~ "    var eax: u32 = undefined;\n"
#~ "    var ebx: u32 = undefined;\n"
#~ "    var ecx: u32 = undefined;\n"
#~ "    var edx: u32 = undefined;\n"
#~ "\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov %[leaf], %%eax\n"
#~ "        \\\\mov %[subleaf], %%ecx\n"
#~ "        \\\\cpuid\n"
#~ "        \\\\mov %%eax, %[eax]\n"
#~ "        \\\\mov %%ebx, %[ebx]\n"
#~ "        \\\\mov %%ecx, %[ecx]\n"
#~ "        \\\\mov %%edx, %[edx]\n"
#~ "        : [eax] \"=r\" (eax),\n"
#~ "          [ebx] \"=r\" (ebx),\n"
#~ "          [ecx] \"=r\" (ecx),\n"
#~ "          [edx] \"=r\" (edx),\n"
#~ "        : [leaf] \"r\" (leaf),\n"
#~ "          [subleaf] \"r\" (subleaf),\n"
#~ "        : \"rax\", \"rbx\", \"rcx\", \"rdx\"\n"
#~ "    );\n"
#~ "\n"
#~ "    return .{\n"
#~ "        .eax = eax,\n"
#~ "        .ebx = ebx,\n"
#~ "        .ecx = ecx,\n"
#~ "        .edx = edx,\n"
#~ "    };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/cpuid.zig\n"
#~ "fn cpuid(leaf: u32, subleaf: u32) CpuidRegisters {\n"
#~ "    var eax: u32 = undefined;\n"
#~ "    var ebx: u32 = undefined;\n"
#~ "    var ecx: u32 = undefined;\n"
#~ "    var edx: u32 = undefined;\n"
#~ "\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov %[leaf], %%eax\n"
#~ "        \\\\mov %[subleaf], %%ecx\n"
#~ "        \\\\cpuid\n"
#~ "        \\\\mov %%eax, %[eax]\n"
#~ "        \\\\mov %%ebx, %[ebx]\n"
#~ "        \\\\mov %%ecx, %[ecx]\n"
#~ "        \\\\mov %%edx, %[edx]\n"
#~ "        : [eax] \"=r\" (eax),\n"
#~ "          [ebx] \"=r\" (ebx),\n"
#~ "          [ecx] \"=r\" (ecx),\n"
#~ "          [edx] \"=r\" (edx),\n"
#~ "        : [leaf] \"r\" (leaf),\n"
#~ "          [subleaf] \"r\" (subleaf),\n"
#~ "        : \"rax\", \"rbx\", \"rcx\", \"rdx\"\n"
#~ "    );\n"
#~ "\n"
#~ "    return .{\n"
#~ "        .eax = eax,\n"
#~ "        .ebx = ebx,\n"
#~ "        .ecx = ecx,\n"
#~ "        .edx = edx,\n"
#~ "    };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "pub const Msr = enum(u32) {\n"
#~ "    /// IA32_FEATURE_CONTROL MSR.\n"
#~ "    feature_control = 0x003A,\n"
#~ "\n"
#~ "    /// IA32_VMX_BASIC MSR.\n"
#~ "    vmx_basic = 0x0480,\n"
#~ "\n"
#~ "    _,\n"
#~ "};\n"
#~ "\n"
#~ "pub const MsrFeatureControl = packed struct(u64) {\n"
#~ "    /// Lock bit.\n"
#~ "    lock: bool,\n"
#~ "    /// VMX in SMX (Safer Mode Extensions) operation.\n"
#~ "    vmx_in_smx: bool,\n"
#~ "    /// VMX outside SMX operation.\n"
#~ "    vmx_outside_smx: bool,\n"
#~ "    /// ...\n"
#~ "    _other_fields: u61,\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "pub const Msr = enum(u32) {\n"
#~ "    /// IA32_FEATURE_CONTROL MSR.\n"
#~ "    feature_control = 0x003A,\n"
#~ "\n"
#~ "    /// IA32_VMX_BASIC MSR.\n"
#~ "    vmx_basic = 0x0480,\n"
#~ "\n"
#~ "    _,\n"
#~ "};\n"
#~ "\n"
#~ "pub const MsrFeatureControl = packed struct(u64) {\n"
#~ "    /// Lock bit.\n"
#~ "    lock: bool,\n"
#~ "    /// VMX in SMX (Safer Mode Extensions) operation.\n"
#~ "    vmx_in_smx: bool,\n"
#~ "    /// VMX outside SMX operation.\n"
#~ "    vmx_outside_smx: bool,\n"
#~ "    /// ...\n"
#~ "    _other_fields: u61,\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "pub fn readMsr(msr: Msr) u64 {\n"
#~ "    var eax: u32 = undefined;\n"
#~ "    var edx: u32 = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\rdmsr\n"
#~ "        : [eax] \"={eax}\" (eax),\n"
#~ "          [edx] \"={edx}\" (edx),\n"
#~ "        : [msr] \"{ecx}\" (@intFromEnum(msr)),\n"
#~ "    );\n"
#~ "\n"
#~ "    return bits.concat(u64, edx, eax);\n"
#~ "}\n"
#~ "\n"
#~ "pub fn writeMsr(msr: Msr, value: u64) void {\n"
#~ "    asm volatile (\n"
#~ "        \\\\wrmsr\n"
#~ "        :\n"
#~ "        : [msr] \"{ecx}\" (@intFromEnum(msr)),\n"
#~ "          [eax] \"{eax}\" (@as(u32, @truncate(value))),\n"
#~ "          [edx] \"{edx}\" (@as(u32, @truncate(value >> 32))),\n"
#~ "    );\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "pub fn readMsr(msr: Msr) u64 {\n"
#~ "    var eax: u32 = undefined;\n"
#~ "    var edx: u32 = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\rdmsr\n"
#~ "        : [eax] \"={eax}\" (eax),\n"
#~ "          [edx] \"={edx}\" (edx),\n"
#~ "        : [msr] \"{ecx}\" (@intFromEnum(msr)),\n"
#~ "    );\n"
#~ "\n"
#~ "    return bits.concat(u64, edx, eax);\n"
#~ "}\n"
#~ "\n"
#~ "pub fn writeMsr(msr: Msr, value: u64) void {\n"
#~ "    asm volatile (\n"
#~ "        \\\\wrmsr\n"
#~ "        :\n"
#~ "        : [msr] \"{ecx}\" (@intFromEnum(msr)),\n"
#~ "          [eax] \"{eax}\" (@as(u32, @truncate(value))),\n"
#~ "          [edx] \"{edx}\" (@as(u32, @truncate(value >> 32))),\n"
#~ "    );\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/vmx.zig\n"
#~ "const vendor = arch.getCpuVendorId();\n"
#~ "if (!std.mem.eql(u8, vendor[0..], \"GenuineIntel\")) {\n"
#~ "    log.err(\"Unsupported CPU vendor: {s}\", .{vendor});\n"
#~ "    return Error.SystemNotSupported;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/vmx.zig\n"
#~ "const vendor = arch.getCpuVendorId();\n"
#~ "if (!std.mem.eql(u8, vendor[0..], \"GenuineIntel\")) {\n"
#~ "    log.err(\"Unsupported CPU vendor: {s}\", .{vendor});\n"
#~ "    return Error.SystemNotSupported;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/arch.zig\n"
#~ "pub fn isVmxSupported() bool {\n"
#~ "    // Check CPUID if VMX is supported.\n"
#~ "    const regs = cpuid.Leaf.query(.vers_and_feat_info, null);\n"
#~ "    const ecx: cpuid.FeatureInfoEcx = @bitCast(regs.ecx);\n"
#~ "    if (!ecx.vmx) return false;\n"
#~ "\n"
#~ "    // Check VMXON is allowed outside SMX.\n"
#~ "    var msr_fctl: am.MsrFeatureControl = @bitCast(am.readMsr(."
#~ "feature_control));\n"
#~ "    if (!msr_fctl.vmx_outside_smx) {\n"
#~ "        // Enable VMX outside SMX.\n"
#~ "        if (msr_fctl.lock) @panic(\"IA32_FEATURE_CONTROL is locked while "
#~ "VMX outside SMX is disabled\");\n"
#~ "        msr_fctl.vmx_outside_smx = true;\n"
#~ "        msr_fctl.lock = true;\n"
#~ "        am.writeMsr(.feature_control, @bitCast(msr_fctl));\n"
#~ "    }\n"
#~ "    msr_fctl = @bitCast(am.readMsr(.feature_control));\n"
#~ "    if (!msr_fctl.vmx_outside_smx) return false;\n"
#~ "\n"
#~ "    return true;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/arch.zig\n"
#~ "pub fn isVmxSupported() bool {\n"
#~ "    // Check CPUID if VMX is supported.\n"
#~ "    const regs = cpuid.Leaf.query(.vers_and_feat_info, null);\n"
#~ "    const ecx: cpuid.FeatureInfoEcx = @bitCast(regs.ecx);\n"
#~ "    if (!ecx.vmx) return false;\n"
#~ "\n"
#~ "    // Check VMXON is allowed outside SMX.\n"
#~ "    var msr_fctl: am.MsrFeatureControl = @bitCast(am.readMsr(."
#~ "feature_control));\n"
#~ "    if (!msr_fctl.vmx_outside_smx) {\n"
#~ "        // Enable VMX outside SMX.\n"
#~ "        if (msr_fctl.lock) @panic(\"IA32_FEATURE_CONTROL is locked while "
#~ "VMX outside SMX is disabled\");\n"
#~ "        msr_fctl.vmx_outside_smx = true;\n"
#~ "        msr_fctl.lock = true;\n"
#~ "        am.writeMsr(.feature_control, @bitCast(msr_fctl));\n"
#~ "    }\n"
#~ "    msr_fctl = @bitCast(am.readMsr(.feature_control));\n"
#~ "    if (!msr_fctl.vmx_outside_smx) return false;\n"
#~ "\n"
#~ "    return true;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/vmx.zig\n"
#~ "if (!arch.isVmxSupported()) {\n"
#~ "    log.err(\"Virtualization is not supported.\", .{});\n"
#~ "    return Error.SystemNotSupported;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/vmx.zig\n"
#~ "if (!arch.isVmxSupported()) {\n"
#~ "    log.err(\"Virtualization is not supported.\", .{});\n"
#~ "    return Error.SystemNotSupported;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "pub const Vcpu = struct {\n"
#~ "    const Self = @This();\n"
#~ "\n"
#~ "    /// ID of the logical processor.\n"
#~ "    id: usize = 0,\n"
#~ "    /// VPID of the virtual machine.\n"
#~ "    vpid: u16,\n"
#~ "\n"
#~ "    pub fn new(vpid: u16) Self {\n"
#~ "        return Self{ .vpid = vpid };\n"
#~ "    }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "pub const Vcpu = struct {\n"
#~ "    const Self = @This();\n"
#~ "\n"
#~ "    /// ID of the logical processor.\n"
#~ "    id: usize = 0,\n"
#~ "    /// VPID of the virtual machine.\n"
#~ "    vpid: u16,\n"
#~ "\n"
#~ "    pub fn new(vpid: u16) Self {\n"
#~ "        return Self{ .vpid = vpid };\n"
#~ "    }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/vmx.zig\n"
#~ "const impl = switch (builtin.target.cpu.arch) {\n"
#~ "    .x86_64 => @import(\"arch/x86/vmx.zig\"),\n"
#~ "    else => @compileError(\"Unsupported architecture.\"),\n"
#~ "};\n"
#~ "\n"
#~ "pub const Vm = struct {\n"
#~ "    vcpu: impl.Vcpu,\n"
#~ "\n"
#~ "    pub fn new() VmError!Self {\n"
#~ "        ...\n"
#~ "        // Don't use 0, this is reserved for VMX root, outside VMX "
#~ "operation, or for disabled VPID.\n"
#~ "        // While it works here, it will cause issues in future chapters.\n"
#~ "        const vcpu = impl.Vcpu.new(1);\n"
#~ "        return Self{ .vcpu = vcpu };\n"
#~ "    }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/vmx.zig\n"
#~ "const impl = switch (builtin.target.cpu.arch) {\n"
#~ "    .x86_64 => @import(\"arch/x86/vmx.zig\"),\n"
#~ "    else => @compileError(\"Unsupported architecture.\"),\n"
#~ "};\n"
#~ "\n"
#~ "pub const Vm = struct {\n"
#~ "    vcpu: impl.Vcpu,\n"
#~ "\n"
#~ "    pub fn new() VmError!Self {\n"
#~ "        ...\n"
#~ "        // Don't use 0, this is reserved for VMX root, outside VMX "
#~ "operation, or for disabled VPID.\n"
#~ "        // While it works here, it will cause issues in future chapters.\n"
#~ "        const vcpu = impl.Vcpu.new(1);\n"
#~ "        return Self{ .vcpu = vcpu };\n"
#~ "    }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn adjustControlRegisters() void {\n"
#~ "    const vmx_cr0_fixed0: u32 = @truncate(am.readMsr(.vmx_cr0_fixed0));\n"
#~ "    const vmx_cr0_fixed1: u32 = @truncate(am.readMsr(.vmx_cr0_fixed1));\n"
#~ "    const vmx_cr4_fixed0: u32 = @truncate(am.readMsr(.vmx_cr4_fixed0));\n"
#~ "    const vmx_cr4_fixed1: u32 = @truncate(am.readMsr(.vmx_cr4_fixed1));\n"
#~ "\n"
#~ "    var cr0: u64 = @bitCast(am.readCr0());\n"
#~ "    cr0 |= vmx_cr0_fixed0; // Mandatory 1\n"
#~ "    cr0 &= vmx_cr0_fixed1; // Mandatory 0\n"
#~ "    var cr4: u64 = @bitCast(am.readCr4());\n"
#~ "    cr4 |= vmx_cr4_fixed0; // Mandatory 1\n"
#~ "    cr4 &= vmx_cr4_fixed1; // Mandatory 0;\n"
#~ "\n"
#~ "    am.loadCr0(cr0);\n"
#~ "    am.loadCr4(cr4);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn adjustControlRegisters() void {\n"
#~ "    const vmx_cr0_fixed0: u32 = @truncate(am.readMsr(.vmx_cr0_fixed0));\n"
#~ "    const vmx_cr0_fixed1: u32 = @truncate(am.readMsr(.vmx_cr0_fixed1));\n"
#~ "    const vmx_cr4_fixed0: u32 = @truncate(am.readMsr(.vmx_cr4_fixed0));\n"
#~ "    const vmx_cr4_fixed1: u32 = @truncate(am.readMsr(.vmx_cr4_fixed1));\n"
#~ "\n"
#~ "    var cr0: u64 = @bitCast(am.readCr0());\n"
#~ "    cr0 |= vmx_cr0_fixed0; // Mandatory 1\n"
#~ "    cr0 &= vmx_cr0_fixed1; // Mandatory 0\n"
#~ "    var cr4: u64 = @bitCast(am.readCr4());\n"
#~ "    cr4 |= vmx_cr4_fixed0; // Mandatory 1\n"
#~ "    cr4 &= vmx_cr4_fixed1; // Mandatory 0;\n"
#~ "\n"
#~ "    am.loadCr0(cr0);\n"
#~ "    am.loadCr4(cr4);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "pub const Cr4 = packed struct(u64) {\n"
#~ "    /// Other fields, see repository for details.\n"
#~ "    _other_fields1: u13,\n"
#~ "    /// Virtual machine extensions enable. (Used further down.)\n"
#~ "    vmxe: bool,\n"
#~ "    /// More fields, see repository for details.\n"
#~ "    _other_fields2: u40,\n"
#~ "};\n"
#~ "\n"
#~ "pub inline fn readCr4() Cr4 {\n"
#~ "    var cr4: u64 = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov %%cr4, %[cr4]\n"
#~ "        : [cr4] \"=r\" (cr4),\n"
#~ "    );\n"
#~ "    return @bitCast(cr4);\n"
#~ "}\n"
#~ "\n"
#~ "pub inline fn loadCr4(cr4: anytype) void {\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov %[cr4], %%cr4\n"
#~ "        :\n"
#~ "        : [cr4] \"r\" (@as(u64, @bitCast(cr4))),\n"
#~ "    );\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "pub const Cr4 = packed struct(u64) {\n"
#~ "    /// Other fields, see repository for details.\n"
#~ "    _other_fields1: u13,\n"
#~ "    /// Virtual machine extensions enable. (Used further down.)\n"
#~ "    vmxe: bool,\n"
#~ "    /// More fields, see repository for details.\n"
#~ "    _other_fields2: u40,\n"
#~ "};\n"
#~ "\n"
#~ "pub inline fn readCr4() Cr4 {\n"
#~ "    var cr4: u64 = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov %%cr4, %[cr4]\n"
#~ "        : [cr4] \"=r\" (cr4),\n"
#~ "    );\n"
#~ "    return @bitCast(cr4);\n"
#~ "}\n"
#~ "\n"
#~ "pub inline fn loadCr4(cr4: anytype) void {\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov %[cr4], %%cr4\n"
#~ "        :\n"
#~ "        : [cr4] \"r\" (@as(u64, @bitCast(cr4))),\n"
#~ "    );\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "const vmx = @import(\"vmx/common.zig\");\n"
#~ "const vmxerr = vmx.vmxtry;\n"
#~ "\n"
#~ "pub inline fn vmxon(vmxon_region: mem.Phys) VmxError!void {\n"
#~ "    var rflags: u64 = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\vmxon (%[vmxon_phys])\n"
#~ "        \\\\pushf\n"
#~ "        \\\\popq %[rflags]\n"
#~ "        : [rflags] \"=r\" (rflags),\n"
#~ "        : [vmxon_phys] \"r\" (&vmxon_region),\n"
#~ "        : \"cc\", \"memory\"\n"
#~ "    );\n"
#~ "    try vmxerr(rflags);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "const vmx = @import(\"vmx/common.zig\");\n"
#~ "const vmxerr = vmx.vmxtry;\n"
#~ "\n"
#~ "pub inline fn vmxon(vmxon_region: mem.Phys) VmxError!void {\n"
#~ "    var rflags: u64 = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\vmxon (%[vmxon_phys])\n"
#~ "        \\\\pushf\n"
#~ "        \\\\popq %[rflags]\n"
#~ "        : [rflags] \"=r\" (rflags),\n"
#~ "        : [vmxon_phys] \"r\" (&vmxon_region),\n"
#~ "        : \"cc\", \"memory\"\n"
#~ "    );\n"
#~ "    try vmxerr(rflags);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "pub const FlagsRegister = packed struct(u64) {\n"
#~ "    /// Carry flag.\n"
#~ "    cf: bool,\n"
#~ "    /// Reserved. Must be 1.\n"
#~ "    _reversedO: u1 = 1,\n"
#~ "    /// Five other fields, see repository for details.\n"
#~ "    _other_fields1: u4,\n"
#~ "    /// Zero flag.\n"
#~ "    zf: bool,\n"
#~ "    /// More fields, see repository for details.\n"
#~ "    _other_fields2: u57,\n"
#~ "\n"
#~ "    pub fn new() FlagsRegister {\n"
#~ "        var ret = std.mem.zeroes(FlagsRegister);\n"
#~ "        ret._reservedO = 1;\n"
#~ "        return ret;\n"
#~ "    }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "pub const FlagsRegister = packed struct(u64) {\n"
#~ "    /// Carry flag.\n"
#~ "    cf: bool,\n"
#~ "    /// Reserved. Must be 1.\n"
#~ "    _reversedO: u1 = 1,\n"
#~ "    /// Five other fields, see repository for details.\n"
#~ "    _other_fields1: u4,\n"
#~ "    /// Zero flag.\n"
#~ "    zf: bool,\n"
#~ "    /// More fields, see repository for details.\n"
#~ "    _other_fields2: u57,\n"
#~ "\n"
#~ "    pub fn new() FlagsRegister {\n"
#~ "        var ret = std.mem.zeroes(FlagsRegister);\n"
#~ "        ret._reservedO = 1;\n"
#~ "        return ret;\n"
#~ "    }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "vmxon_region: *VmxonRegion = undefined,\n"
#~ "...\n"
#~ "pub fn virtualize(self: *Self, allocator: Allocator) VmxError!void {\n"
#~ "    // Adjust control registers.\n"
#~ "    adjustControlRegisters();\n"
#~ "\n"
#~ "    // Set VMXE bit in CR4.\n"
#~ "    var cr4 = am.readCr4();\n"
#~ "    cr4.vmxe = true;\n"
#~ "    am.loadCr4(cr4);\n"
#~ "\n"
#~ "    // Enter VMX root operation.\n"
#~ "    self.vmxon_region = try vmxon(allocator);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "vmxon_region: *VmxonRegion = undefined,\n"
#~ "...\n"
#~ "pub fn virtualize(self: *Self, allocator: Allocator) VmxError!void {\n"
#~ "    // Adjust control registers.\n"
#~ "    adjustControlRegisters();\n"
#~ "\n"
#~ "    // Set VMXE bit in CR4.\n"
#~ "    var cr4 = am.readCr4();\n"
#~ "    cr4.vmxe = true;\n"
#~ "    am.loadCr4(cr4);\n"
#~ "\n"
#~ "    // Enter VMX root operation.\n"
#~ "    self.vmxon_region = try vmxon(allocator);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/vmx.zig\n"
#~ "pub const Error = VmError || impl.VmxError;\n"
#~ "\n"
#~ "pub fn init(self: *Self, allocator: Allocator) Error!void {\n"
#~ "    try self.vcpu.virtualize(allocator);\n"
#~ "    log.info(\"vCPU #{X} was created.\", .{self.vcpu.id});\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/vmx.zig\n"
#~ "pub const Error = VmError || impl.VmxError;\n"
#~ "\n"
#~ "pub fn init(self: *Self, allocator: Allocator) Error!void {\n"
#~ "    try self.vcpu.virtualize(allocator);\n"
#~ "    log.info(\"vCPU #{X} was created.\", .{self.vcpu.id});\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "asm volatile(\"vmlaunch\");\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "asm volatile(\"vmlaunch\");\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "pub const Vcpu = struct {\n"
#~ "    ...\n"
#~ "    vmcs_region: *VmcsRegion = undefined,\n"
#~ "    ...\n"
#~ "\n"
#~ "    pub fn setupVmcs(self: *Self, allocator: Allocator) VmxError!void {\n"
#~ "        ...\n"
#~ "\n"
#~ "        // Initialize VMCS fields.\n"
#~ "        try setupExecCtrls(self, allocator);\n"
#~ "        try setupExitCtrls(self);\n"
#~ "        try setupEntryCtrls(self);\n"
#~ "        try setupHostState(self);\n"
#~ "        try setupGuestState(self);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn setupExecCtrls(vcpu: *Vcpu, allocator: Allocator) VmxError!void {}\n"
#~ "fn setupExitCtrls(vcpu: *Vcpu) VmxError!void {}\n"
#~ "fn setupEntryCtrls(vcpu: *Vcpu) VmxError!void {}\n"
#~ "fn setupHostState(vcpu: *Vcpu) VmxError!void {}\n"
#~ "fn setupGuestState(vcpu: *Vcpu) VmxError!void {}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "pub const Vcpu = struct {\n"
#~ "    ...\n"
#~ "    vmcs_region: *VmcsRegion = undefined,\n"
#~ "    ...\n"
#~ "\n"
#~ "    pub fn setupVmcs(self: *Self, allocator: Allocator) VmxError!void {\n"
#~ "        ...\n"
#~ "\n"
#~ "        // Initialize VMCS fields.\n"
#~ "        try setupExecCtrls(self, allocator);\n"
#~ "        try setupExitCtrls(self);\n"
#~ "        try setupEntryCtrls(self);\n"
#~ "        try setupHostState(self);\n"
#~ "        try setupGuestState(self);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn setupExecCtrls(vcpu: *Vcpu, allocator: Allocator) VmxError!void {}\n"
#~ "fn setupExitCtrls(vcpu: *Vcpu) VmxError!void {}\n"
#~ "fn setupEntryCtrls(vcpu: *Vcpu) VmxError!void {}\n"
#~ "fn setupHostState(vcpu: *Vcpu) VmxError!void {}\n"
#~ "fn setupGuestState(vcpu: *Vcpu) VmxError!void {}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "pub inline fn vmclear(vmcs_region: mem.Phys) VmxError!void {\n"
#~ "    var rflags: u64 = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\vmclear (%[vmcs_phys])\n"
#~ "        \\\\pushf\n"
#~ "        \\\\popq %[rflags]\n"
#~ "        : [rflags] \"=r\" (rflags),\n"
#~ "        : [vmcs_phys] \"r\" (&vmcs_region),\n"
#~ "        : \"cc\", \"memory\"\n"
#~ "    );\n"
#~ "    try vmxerr(rflags);\n"
#~ "}\n"
#~ "\n"
#~ "pub inline fn vmptrld(vmcs_region: mem.Phys) VmxError!void {\n"
#~ "    var rflags: u64 = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\vmptrld (%[vmcs_phys])\n"
#~ "        \\\\pushf\n"
#~ "        \\\\popq %[rflags]\n"
#~ "        : [rflags] \"=r\" (rflags),\n"
#~ "        : [vmcs_phys] \"r\" (&vmcs_region),\n"
#~ "        : \"cc\", \"memory\"\n"
#~ "    );\n"
#~ "    try vmxerr(rflags);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "pub inline fn vmclear(vmcs_region: mem.Phys) VmxError!void {\n"
#~ "    var rflags: u64 = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\vmclear (%[vmcs_phys])\n"
#~ "        \\\\pushf\n"
#~ "        \\\\popq %[rflags]\n"
#~ "        : [rflags] \"=r\" (rflags),\n"
#~ "        : [vmcs_phys] \"r\" (&vmcs_region),\n"
#~ "        : \"cc\", \"memory\"\n"
#~ "    );\n"
#~ "    try vmxerr(rflags);\n"
#~ "}\n"
#~ "\n"
#~ "pub inline fn vmptrld(vmcs_region: mem.Phys) VmxError!void {\n"
#~ "    var rflags: u64 = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\vmptrld (%[vmcs_phys])\n"
#~ "        \\\\pushf\n"
#~ "        \\\\popq %[rflags]\n"
#~ "        : [rflags] \"=r\" (rflags),\n"
#~ "        : [vmcs_phys] \"r\" (&vmcs_region),\n"
#~ "        : \"cc\", \"memory\"\n"
#~ "    );\n"
#~ "    try vmxerr(rflags);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vmcs.zig\n"
#~ "fn encode(\n"
#~ "    comptime field_type: FieldType,\n"
#~ "    comptime index: u9,\n"
#~ "    comptime access_type: AccessType,\n"
#~ "    comptime width: Width,\n"
#~ ") u32 {\n"
#~ "    return @bitCast(ComponentEncoding{\n"
#~ "        .access_type = access_type,\n"
#~ "        .index = index,\n"
#~ "        .field_type = field_type,\n"
#~ "        .width = width,\n"
#~ "    });\n"
#~ "}\n"
#~ "\n"
#~ "/// Encodes a VMCS field for the guest state area.\n"
#~ "fn eg(\n"
#~ "    comptime index: u9,\n"
#~ "    comptime access_type: AccessType,\n"
#~ "    comptime width: Width,\n"
#~ ") u32 { return encode(.guest_state, index, access_type, width); }\n"
#~ "/// Encodes a VMCS field for the host state area.\n"
#~ "fn eh(\n"
#~ "    comptime index: u9,\n"
#~ "    comptime access_type: AccessType,\n"
#~ "    comptime width: Width,\n"
#~ ") u32 { return encode(.host_state, index, access_type, width); }\n"
#~ "/// Encodes a VMCS field for the control area.\n"
#~ "fn ec(\n"
#~ "    comptime index: u9,\n"
#~ "    comptime access_type: AccessType,\n"
#~ "    comptime width: Width,\n"
#~ ") u32 { return encode(.control, index, access_type, width); }\n"
#~ "/// Encodes a VMCS field for the read-only area.\n"
#~ "fn er(\n"
#~ "    comptime index: u9,\n"
#~ "    comptime access_type: AccessType,\n"
#~ "    comptime width: Width,\n"
#~ ") u32 { return encode(.vmexit, index, access_type, width); }\n"
#~ "\n"
#~ "const AccessType = enum(u1) {\n"
#~ "    full = 0,\n"
#~ "    high = 1,\n"
#~ "};\n"
#~ "const Width = enum(u2) {\n"
#~ "    word = 0,\n"
#~ "    qword = 1,\n"
#~ "    dword = 2,\n"
#~ "    natural = 3,\n"
#~ "};\n"
#~ "const FieldType = enum(u2) {\n"
#~ "    control = 0,\n"
#~ "    vmexit = 1,\n"
#~ "    guest_state = 2,\n"
#~ "    host_state = 3,\n"
#~ "};\n"
#~ "const ComponentEncoding = packed struct(u32) {\n"
#~ "    access_type: AccessType,\n"
#~ "    index: u9,\n"
#~ "    field_type: FieldType,\n"
#~ "    _reserved1: u1 = 0,\n"
#~ "    width: Width,\n"
#~ "    _reserved2: u17 = 0,\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vmcs.zig\n"
#~ "fn encode(\n"
#~ "    comptime field_type: FieldType,\n"
#~ "    comptime index: u9,\n"
#~ "    comptime access_type: AccessType,\n"
#~ "    comptime width: Width,\n"
#~ ") u32 {\n"
#~ "    return @bitCast(ComponentEncoding{\n"
#~ "        .access_type = access_type,\n"
#~ "        .index = index,\n"
#~ "        .field_type = field_type,\n"
#~ "        .width = width,\n"
#~ "    });\n"
#~ "}\n"
#~ "\n"
#~ "/// Encodes a VMCS field for the guest state area.\n"
#~ "fn eg(\n"
#~ "    comptime index: u9,\n"
#~ "    comptime access_type: AccessType,\n"
#~ "    comptime width: Width,\n"
#~ ") u32 { return encode(.guest_state, index, access_type, width); }\n"
#~ "/// Encodes a VMCS field for the host state area.\n"
#~ "fn eh(\n"
#~ "    comptime index: u9,\n"
#~ "    comptime access_type: AccessType,\n"
#~ "    comptime width: Width,\n"
#~ ") u32 { return encode(.host_state, index, access_type, width); }\n"
#~ "/// Encodes a VMCS field for the control area.\n"
#~ "fn ec(\n"
#~ "    comptime index: u9,\n"
#~ "    comptime access_type: AccessType,\n"
#~ "    comptime width: Width,\n"
#~ ") u32 { return encode(.control, index, access_type, width); }\n"
#~ "/// Encodes a VMCS field for the read-only area.\n"
#~ "fn er(\n"
#~ "    comptime index: u9,\n"
#~ "    comptime access_type: AccessType,\n"
#~ "    comptime width: Width,\n"
#~ ") u32 { return encode(.vmexit, index, access_type, width); }\n"
#~ "\n"
#~ "const AccessType = enum(u1) {\n"
#~ "    full = 0,\n"
#~ "    high = 1,\n"
#~ "};\n"
#~ "const Width = enum(u2) {\n"
#~ "    word = 0,\n"
#~ "    qword = 1,\n"
#~ "    dword = 2,\n"
#~ "    natural = 3,\n"
#~ "};\n"
#~ "const FieldType = enum(u2) {\n"
#~ "    control = 0,\n"
#~ "    vmexit = 1,\n"
#~ "    guest_state = 2,\n"
#~ "    host_state = 3,\n"
#~ "};\n"
#~ "const ComponentEncoding = packed struct(u32) {\n"
#~ "    access_type: AccessType,\n"
#~ "    index: u9,\n"
#~ "    field_type: FieldType,\n"
#~ "    _reserved1: u1 = 0,\n"
#~ "    width: Width,\n"
#~ "    _reserved2: u17 = 0,\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vmcs.zig\n"
#~ "pub const guest = enum(u32) {\n"
#~ "    // Natural-width fields.\n"
#~ "    cr0 = eg(0, .full, .natural),\n"
#~ "    cr3 = eg(1, .full, .natural),\n"
#~ "    cr4 = eg(2, .full, .natural),\n"
#~ "    es_base = eg(3, .full, .natural),\n"
#~ "    cs_base = eg(4, .full, .natural),\n"
#~ "    ss_base = eg(5, .full, .natural),\n"
#~ "    ds_base = eg(6, .full, .natural),\n"
#~ "    fs_base = eg(7, .full, .natural),\n"
#~ "    gs_base = eg(8, .full, .natural),\n"
#~ "    ldtr_base = eg(9, .full, .natural),\n"
#~ "    tr_base = eg(10, .full, .natural),\n"
#~ "    gdtr_base = eg(11, .full, .natural),\n"
#~ "    idtr_base = eg(12, .full, .natural),\n"
#~ "    dr7 = eg(13, .full, .natural),\n"
#~ "    rsp = eg(14, .full, .natural),\n"
#~ "    rip = eg(15, .full, .natural),\n"
#~ "    rflags = eg(16, .full, .natural),\n"
#~ "    pending_debug_exceptions = eg(17, .full, .natural),\n"
#~ "    sysenter_esp = eg(18, .full, .natural),\n"
#~ "    sysenter_eip = eg(19, .full, .natural),\n"
#~ "    s_cet = eg(20, .full, .natural),\n"
#~ "    ssp = eg(21, .full, .natural),\n"
#~ "    intr_ssp_table_addr = eg(22, .full, .natural),\n"
#~ "    // 16-bit fields.\n"
#~ "    es_sel = eg(0, .full, .word),\n"
#~ "    cs_sel = eg(1, .full, .word),\n"
#~ "    ss_sel = eg(2, .full, .word),\n"
#~ "    ds_sel = eg(3, .full, .word),\n"
#~ "    fs_sel = eg(4, .full, .word),\n"
#~ "    gs_sel = eg(5, .full, .word),\n"
#~ "    ldtr_sel = eg(6, .full, .word),\n"
#~ "    tr_sel = eg(7, .full, .word),\n"
#~ "    intr_status = eg(8, .full, .word),\n"
#~ "    pml_index = eg(9, .full, .word),\n"
#~ "    uinv = eg(10, .full, .word),\n"
#~ "    // 32-bit fields.\n"
#~ "    es_limit = eg(0, .full, .dword),\n"
#~ "    cs_limit = eg(1, .full, .dword),\n"
#~ "    ss_limit = eg(2, .full, .dword),\n"
#~ "    ds_limit = eg(3, .full, .dword),\n"
#~ "    fs_limit = eg(4, .full, .dword),\n"
#~ "    gs_limit = eg(5, .full, .dword),\n"
#~ "    ldtr_limit = eg(6, .full, .dword),\n"
#~ "    tr_limit = eg(7, .full, .dword),\n"
#~ "    gdtr_limit = eg(8, .full, .dword),\n"
#~ "    idtr_limit = eg(9, .full, .dword),\n"
#~ "    es_rights = eg(10, .full, .dword),\n"
#~ "    cs_rights = eg(11, .full, .dword),\n"
#~ "    ss_rights = eg(12, .full, .dword),\n"
#~ "    ds_rights = eg(13, .full, .dword),\n"
#~ "    fs_rights = eg(14, .full, .dword),\n"
#~ "    gs_rights = eg(15, .full, .dword),\n"
#~ "    ldtr_rights = eg(16, .full, .dword),\n"
#~ "    tr_rights = eg(17, .full, .dword),\n"
#~ "    interruptibility_state = eg(18, .full, .dword),\n"
#~ "    activity_state = eg(19, .full, .dword),\n"
#~ "    smbase = eg(20, .full, .dword),\n"
#~ "    sysenter_cs = eg(21, .full, .dword),\n"
#~ "    preemp_timer = eg(22, .full, .dword),\n"
#~ "    // 64-bit fields.\n"
#~ "    vmcs_link_pointer = eg(0, .full, .qword),\n"
#~ "    dbgctl = eg(1, .full, .qword),\n"
#~ "    pat = eg(2, .full, .qword),\n"
#~ "    efer = eg(3, .full, .qword),\n"
#~ "    perf_global_ctrl = eg(4, .full, .qword),\n"
#~ "    pdpte0 = eg(5, .full, .qword),\n"
#~ "    pdpte1 = eg(6, .full, .qword),\n"
#~ "    pdpte2 = eg(7, .full, .qword),\n"
#~ "    pdpte3 = eg(8, .full, .qword),\n"
#~ "    bndcfgs = eg(9, .full, .qword),\n"
#~ "    rtit_ctl = eg(10, .full, .qword),\n"
#~ "    lbr_ctl = eg(11, .full, .qword),\n"
#~ "    pkrs = eg(12, .full, .qword),\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vmcs.zig\n"
#~ "pub const guest = enum(u32) {\n"
#~ "    // Natural-width fields.\n"
#~ "    cr0 = eg(0, .full, .natural),\n"
#~ "    cr3 = eg(1, .full, .natural),\n"
#~ "    cr4 = eg(2, .full, .natural),\n"
#~ "    es_base = eg(3, .full, .natural),\n"
#~ "    cs_base = eg(4, .full, .natural),\n"
#~ "    ss_base = eg(5, .full, .natural),\n"
#~ "    ds_base = eg(6, .full, .natural),\n"
#~ "    fs_base = eg(7, .full, .natural),\n"
#~ "    gs_base = eg(8, .full, .natural),\n"
#~ "    ldtr_base = eg(9, .full, .natural),\n"
#~ "    tr_base = eg(10, .full, .natural),\n"
#~ "    gdtr_base = eg(11, .full, .natural),\n"
#~ "    idtr_base = eg(12, .full, .natural),\n"
#~ "    dr7 = eg(13, .full, .natural),\n"
#~ "    rsp = eg(14, .full, .natural),\n"
#~ "    rip = eg(15, .full, .natural),\n"
#~ "    rflags = eg(16, .full, .natural),\n"
#~ "    pending_debug_exceptions = eg(17, .full, .natural),\n"
#~ "    sysenter_esp = eg(18, .full, .natural),\n"
#~ "    sysenter_eip = eg(19, .full, .natural),\n"
#~ "    s_cet = eg(20, .full, .natural),\n"
#~ "    ssp = eg(21, .full, .natural),\n"
#~ "    intr_ssp_table_addr = eg(22, .full, .natural),\n"
#~ "    // 16-bit fields.\n"
#~ "    es_sel = eg(0, .full, .word),\n"
#~ "    cs_sel = eg(1, .full, .word),\n"
#~ "    ss_sel = eg(2, .full, .word),\n"
#~ "    ds_sel = eg(3, .full, .word),\n"
#~ "    fs_sel = eg(4, .full, .word),\n"
#~ "    gs_sel = eg(5, .full, .word),\n"
#~ "    ldtr_sel = eg(6, .full, .word),\n"
#~ "    tr_sel = eg(7, .full, .word),\n"
#~ "    intr_status = eg(8, .full, .word),\n"
#~ "    pml_index = eg(9, .full, .word),\n"
#~ "    uinv = eg(10, .full, .word),\n"
#~ "    // 32-bit fields.\n"
#~ "    es_limit = eg(0, .full, .dword),\n"
#~ "    cs_limit = eg(1, .full, .dword),\n"
#~ "    ss_limit = eg(2, .full, .dword),\n"
#~ "    ds_limit = eg(3, .full, .dword),\n"
#~ "    fs_limit = eg(4, .full, .dword),\n"
#~ "    gs_limit = eg(5, .full, .dword),\n"
#~ "    ldtr_limit = eg(6, .full, .dword),\n"
#~ "    tr_limit = eg(7, .full, .dword),\n"
#~ "    gdtr_limit = eg(8, .full, .dword),\n"
#~ "    idtr_limit = eg(9, .full, .dword),\n"
#~ "    es_rights = eg(10, .full, .dword),\n"
#~ "    cs_rights = eg(11, .full, .dword),\n"
#~ "    ss_rights = eg(12, .full, .dword),\n"
#~ "    ds_rights = eg(13, .full, .dword),\n"
#~ "    fs_rights = eg(14, .full, .dword),\n"
#~ "    gs_rights = eg(15, .full, .dword),\n"
#~ "    ldtr_rights = eg(16, .full, .dword),\n"
#~ "    tr_rights = eg(17, .full, .dword),\n"
#~ "    interruptibility_state = eg(18, .full, .dword),\n"
#~ "    activity_state = eg(19, .full, .dword),\n"
#~ "    smbase = eg(20, .full, .dword),\n"
#~ "    sysenter_cs = eg(21, .full, .dword),\n"
#~ "    preemp_timer = eg(22, .full, .dword),\n"
#~ "    // 64-bit fields.\n"
#~ "    vmcs_link_pointer = eg(0, .full, .qword),\n"
#~ "    dbgctl = eg(1, .full, .qword),\n"
#~ "    pat = eg(2, .full, .qword),\n"
#~ "    efer = eg(3, .full, .qword),\n"
#~ "    perf_global_ctrl = eg(4, .full, .qword),\n"
#~ "    pdpte0 = eg(5, .full, .qword),\n"
#~ "    pdpte1 = eg(6, .full, .qword),\n"
#~ "    pdpte2 = eg(7, .full, .qword),\n"
#~ "    pdpte3 = eg(8, .full, .qword),\n"
#~ "    bndcfgs = eg(9, .full, .qword),\n"
#~ "    rtit_ctl = eg(10, .full, .qword),\n"
#~ "    lbr_ctl = eg(11, .full, .qword),\n"
#~ "    pkrs = eg(12, .full, .qword),\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/common.zig\n"
#~ "pub fn vmread(field: anytype) VmxError!u64 {\n"
#~ "    var rflags: u64 = undefined;\n"
#~ "    const ret = asm volatile (\n"
#~ "        \\\\vmread %[field], %[ret]\n"
#~ "        \\\\pushf\n"
#~ "        \\\\popq %[rflags]\n"
#~ "        : [ret] \"={rax}\" (-> u64),\n"
#~ "          [rflags] \"=r\" (rflags),\n"
#~ "        : [field] \"r\" (@as(u64, @intFromEnum(field))),\n"
#~ "    );\n"
#~ "    try vmxtry(rflags);\n"
#~ "    return ret;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/common.zig\n"
#~ "pub fn vmread(field: anytype) VmxError!u64 {\n"
#~ "    var rflags: u64 = undefined;\n"
#~ "    const ret = asm volatile (\n"
#~ "        \\\\vmread %[field], %[ret]\n"
#~ "        \\\\pushf\n"
#~ "        \\\\popq %[rflags]\n"
#~ "        : [ret] \"={rax}\" (-> u64),\n"
#~ "          [rflags] \"=r\" (rflags),\n"
#~ "        : [field] \"r\" (@as(u64, @intFromEnum(field))),\n"
#~ "    );\n"
#~ "    try vmxtry(rflags);\n"
#~ "    return ret;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/common.zig\n"
#~ "pub fn vmwrite(field: anytype, value: anytype) VmxError!void {\n"
#~ "    const value_int = switch (@typeInfo(@TypeOf(value))) {\n"
#~ "        .Int, .ComptimeInt => @as(u64, value),\n"
#~ "        .Struct => switch (@sizeOf(@TypeOf(value))) {\n"
#~ "            1 => @as(u8, @bitCast(value)),\n"
#~ "            2 => @as(u16, @bitCast(value)),\n"
#~ "            4 => @as(u32, @bitCast(value)),\n"
#~ "            8 => @as(u64, @bitCast(value)),\n"
#~ "            else => @compileError(\"Unsupported structure size for "
#~ "vmwrite\"),\n"
#~ "        },\n"
#~ "        .Pointer => @as(u64, @intFromPtr(value)),\n"
#~ "        else => @compileError(\"Unsupported type for vmwrite\"),\n"
#~ "    };\n"
#~ "\n"
#~ "    const rflags = asm volatile (\n"
#~ "        \\\\vmwrite %[value], %[field]\n"
#~ "        \\\\pushf\n"
#~ "        \\\\popq %[rflags]\n"
#~ "        : [rflags] \"=r\" (-> u64),\n"
#~ "        : [field] \"r\" (@as(u64, @intFromEnum(field))),\n"
#~ "          [value] \"r\" (@as(u64, value_int)),\n"
#~ "    );\n"
#~ "    try vmxtry(rflags);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/common.zig\n"
#~ "pub fn vmwrite(field: anytype, value: anytype) VmxError!void {\n"
#~ "    const value_int = switch (@typeInfo(@TypeOf(value))) {\n"
#~ "        .Int, .ComptimeInt => @as(u64, value),\n"
#~ "        .Struct => switch (@sizeOf(@TypeOf(value))) {\n"
#~ "            1 => @as(u8, @bitCast(value)),\n"
#~ "            2 => @as(u16, @bitCast(value)),\n"
#~ "            4 => @as(u32, @bitCast(value)),\n"
#~ "            8 => @as(u64, @bitCast(value)),\n"
#~ "            else => @compileError(\"Unsupported structure size for "
#~ "vmwrite\"),\n"
#~ "        },\n"
#~ "        .Pointer => @as(u64, @intFromPtr(value)),\n"
#~ "        else => @compileError(\"Unsupported type for vmwrite\"),\n"
#~ "    };\n"
#~ "\n"
#~ "    const rflags = asm volatile (\n"
#~ "        \\\\vmwrite %[value], %[field]\n"
#~ "        \\\\pushf\n"
#~ "        \\\\popq %[rflags]\n"
#~ "        : [rflags] \"=r\" (-> u64),\n"
#~ "        : [field] \"r\" (@as(u64, @intFromEnum(field))),\n"
#~ "          [value] \"r\" (@as(u64, value_int)),\n"
#~ "    );\n"
#~ "    try vmxtry(rflags);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.tmp.zig\n"
#~ "...\n"
#~ "pub fn setupVmcs(self: *Self, allocator: Allocator) VmxError!void {\n"
#~ "    ...\n"
#~ "    try resetVmcs(self.vmcs_region);\n"
#~ "    asm volatile(\"vmlaunch\");\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.tmp.zig\n"
#~ "...\n"
#~ "pub fn setupVmcs(self: *Self, allocator: Allocator) VmxError!void {\n"
#~ "    ...\n"
#~ "    try resetVmcs(self.vmcs_region);\n"
#~ "    asm volatile(\"vmlaunch\");\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.tmp.zig\n"
#~ "const rflags = asm volatile (\n"
#~ "    \\\\vmlaunch\n"
#~ "    \\\\pushf\n"
#~ "    \\\\popq %[rflags]\n"
#~ "    : [rflags] \"=r\" (-> u64),\n"
#~ ");\n"
#~ "vmx.vmxtry(rflags) catch |err| {\n"
#~ "    log.err(\"VMLAUNCH: {?}\", .{err});\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.tmp.zig\n"
#~ "const rflags = asm volatile (\n"
#~ "    \\\\vmlaunch\n"
#~ "    \\\\pushf\n"
#~ "    \\\\popq %[rflags]\n"
#~ "    : [rflags] \"=r\" (-> u64),\n"
#~ ");\n"
#~ "vmx.vmxtry(rflags) catch |err| {\n"
#~ "    log.err(\"VMLAUNCH: {?}\", .{err});\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/common.zig\n"
#~ "pub const InstructionError = enum(u32) {\n"
#~ "    error_not_available = 0,\n"
#~ "    vmcall_in_vmxroot = 1,\n"
#~ "    vmclear_invalid_phys = 2,\n"
#~ "    vmclear_vmxonptr = 3,\n"
#~ "    vmlaunch_nonclear_vmcs = 4,\n"
#~ "    vmresume_nonlaunched_vmcs = 5,\n"
#~ "    vmresume_after_vmxoff = 6,\n"
#~ "    vmentry_invalid_ctrl = 7,\n"
#~ "    vmentry_invalid_host_state = 8,\n"
#~ "    vmptrld_invalid_phys = 9,\n"
#~ "    vmptrld_vmxonp = 10,\n"
#~ "    vmptrld_incorrect_rev = 11,\n"
#~ "    vmrw_unsupported_component = 12,\n"
#~ "    vmw_ro_component = 13,\n"
#~ "    vmxon_in_vmxroot = 15,\n"
#~ "    vmentry_invalid_exec_ctrl = 16,\n"
#~ "    vmentry_nonlaunched_exec_ctrl = 17,\n"
#~ "    vmentry_exec_vmcsptr = 18,\n"
#~ "    vmcall_nonclear_vmcs = 19,\n"
#~ "    vmcall_invalid_exitctl = 20,\n"
#~ "    vmcall_incorrect_msgrev = 22,\n"
#~ "    vmxoff_dualmonitor = 23,\n"
#~ "    vmcall_invalid_smm = 24,\n"
#~ "    vmentry_invalid_execctrl = 25,\n"
#~ "    vmentry_events_blocked = 26,\n"
#~ "    invalid_invept = 28,\n"
#~ "\n"
#~ "    /// Get an instruction error number from VMCS.\n"
#~ "    pub fn load() VmxError!InstructionError {\n"
#~ "        return @enumFromInt(@as(u32, @truncate(try vmread(vmcs.ro."
#~ "vminstruction_error))));\n"
#~ "    }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/common.zig\n"
#~ "pub const InstructionError = enum(u32) {\n"
#~ "    error_not_available = 0,\n"
#~ "    vmcall_in_vmxroot = 1,\n"
#~ "    vmclear_invalid_phys = 2,\n"
#~ "    vmclear_vmxonptr = 3,\n"
#~ "    vmlaunch_nonclear_vmcs = 4,\n"
#~ "    vmresume_nonlaunched_vmcs = 5,\n"
#~ "    vmresume_after_vmxoff = 6,\n"
#~ "    vmentry_invalid_ctrl = 7,\n"
#~ "    vmentry_invalid_host_state = 8,\n"
#~ "    vmptrld_invalid_phys = 9,\n"
#~ "    vmptrld_vmxonp = 10,\n"
#~ "    vmptrld_incorrect_rev = 11,\n"
#~ "    vmrw_unsupported_component = 12,\n"
#~ "    vmw_ro_component = 13,\n"
#~ "    vmxon_in_vmxroot = 15,\n"
#~ "    vmentry_invalid_exec_ctrl = 16,\n"
#~ "    vmentry_nonlaunched_exec_ctrl = 17,\n"
#~ "    vmentry_exec_vmcsptr = 18,\n"
#~ "    vmcall_nonclear_vmcs = 19,\n"
#~ "    vmcall_invalid_exitctl = 20,\n"
#~ "    vmcall_incorrect_msgrev = 22,\n"
#~ "    vmxoff_dualmonitor = 23,\n"
#~ "    vmcall_invalid_smm = 24,\n"
#~ "    vmentry_invalid_execctrl = 25,\n"
#~ "    vmentry_events_blocked = 26,\n"
#~ "    invalid_invept = 28,\n"
#~ "\n"
#~ "    /// Get an instruction error number from VMCS.\n"
#~ "    pub fn load() VmxError!InstructionError {\n"
#~ "        return @enumFromInt(@as(u32, @truncate(try vmread(vmcs.ro."
#~ "vminstruction_error))));\n"
#~ "    }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vmcs.zig\n"
#~ "pub const ro = enum(u32) {\n"
#~ "    // Natural-width fields.\n"
#~ "    exit_qual = er(0, .full, .natural),\n"
#~ "    io_rcx = er(1, .full, .natural),\n"
#~ "    io_rsi = er(2, .full, .natural),\n"
#~ "    io_rdi = er(3, .full, .natural),\n"
#~ "    io_rip = er(4, .full, .natural),\n"
#~ "    guest_linear_address = er(5, .full, .natural),\n"
#~ "    // 32-bit fields.\n"
#~ "    vminstruction_error = er(0, .full, .dword),\n"
#~ "    vmexit_reason = er(1, .full, .dword),\n"
#~ "    exit_intr_info = er(2, .full, .dword),\n"
#~ "    exit_intr_ec = er(3, .full, .dword),\n"
#~ "    idt_vectoring_info = er(4, .full, .dword),\n"
#~ "    idt_vectoring_ec = er(5, .full, .dword),\n"
#~ "    exit_inst_len = er(6, .full, .dword),\n"
#~ "    exit_inst_info = er(7, .full, .dword),\n"
#~ "    // 64-bit fields.\n"
#~ "    guest_physical_address = er(0, .full, .qword),\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vmcs.zig\n"
#~ "pub const ro = enum(u32) {\n"
#~ "    // Natural-width fields.\n"
#~ "    exit_qual = er(0, .full, .natural),\n"
#~ "    io_rcx = er(1, .full, .natural),\n"
#~ "    io_rsi = er(2, .full, .natural),\n"
#~ "    io_rdi = er(3, .full, .natural),\n"
#~ "    io_rip = er(4, .full, .natural),\n"
#~ "    guest_linear_address = er(5, .full, .natural),\n"
#~ "    // 32-bit fields.\n"
#~ "    vminstruction_error = er(0, .full, .dword),\n"
#~ "    vmexit_reason = er(1, .full, .dword),\n"
#~ "    exit_intr_info = er(2, .full, .dword),\n"
#~ "    exit_intr_ec = er(3, .full, .dword),\n"
#~ "    idt_vectoring_info = er(4, .full, .dword),\n"
#~ "    idt_vectoring_ec = er(5, .full, .dword),\n"
#~ "    exit_inst_len = er(6, .full, .dword),\n"
#~ "    exit_inst_info = er(7, .full, .dword),\n"
#~ "    // 64-bit fields.\n"
#~ "    guest_physical_address = er(0, .full, .qword),\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.tmp.zig\n"
#~ "vmx.vmxtry(rflags) catch |err| {\n"
#~ "    log.err(\"VMLAUNCH: {?}\", .{err});\n"
#~ "    log.err(\"VM-instruction error number: {s}\", .{@tagName(try vmx."
#~ "InstructionError.load())});\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.tmp.zig\n"
#~ "vmx.vmxtry(rflags) catch |err| {\n"
#~ "    log.err(\"VMLAUNCH: {?}\", .{err});\n"
#~ "    log.err(\"VM-instruction error number: {s}\", .{@tagName(try vmx."
#~ "InstructionError.load())});\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "export fn blobGuest() callconv(.Naked) noreturn {\n"
#~ "    while (true) asm volatile (\"hlt\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "export fn blobGuest() callconv(.Naked) noreturn {\n"
#~ "    while (true) asm volatile (\"hlt\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vmcs.zig\n"
#~ "pub const ctrl = enum(u32) {\n"
#~ "    // Natural-width fields.\n"
#~ "    cr0_mask = ec(0, .full, .natural),\n"
#~ "    cr4_mask = ec(1, .full, .natural),\n"
#~ "    cr0_read_shadow = ec(2, .full, .natural),\n"
#~ "    cr4_read_shadow = ec(3, .full, .natural),\n"
#~ "    cr3_target0 = ec(4, .full, .natural),\n"
#~ "    cr3_target1 = ec(5, .full, .natural),\n"
#~ "    cr3_target2 = ec(6, .full, .natural),\n"
#~ "    cr3_target3 = ec(7, .full, .natural),\n"
#~ "    // 16-bit fields.\n"
#~ "    vpid = ec(0, .full, .word),\n"
#~ "    posted_intr_notif_vector = ec(1, .full, .word),\n"
#~ "    eptp_index = ec(2, .full, .word),\n"
#~ "    hlat_prefix_size = ec(3, .full, .word),\n"
#~ "    pid_pointer_index = ec(4, .full, .word),\n"
#~ "    // 32-bit fields.\n"
#~ "    pin_exec_ctrl = ec(0, .full, .dword),\n"
#~ "    proc_exec_ctrl = ec(1, .full, .dword),\n"
#~ "    exception_bitmap = ec(2, .full, .dword),\n"
#~ "    pf_ec_mask = ec(3, .full, .dword),\n"
#~ "    pf_ec_match = ec(4, .full, .dword),\n"
#~ "    cr3_target_count = ec(5, .full, .dword),\n"
#~ "    primary_exit_ctrl = ec(6, .full, .dword),\n"
#~ "    exit_msr_store_count = ec(7, .full, .dword),\n"
#~ "    vexit_msr_load_count = ec(8, .full, .dword),\n"
#~ "    entry_ctrl = ec(9, .full, .dword),\n"
#~ "    entry_msr_load_count = ec(10, .full, .dword),\n"
#~ "    entry_intr_info = ec(11, .full, .dword),\n"
#~ "    entry_exception_ec = ec(12, .full, .dword),\n"
#~ "    entry_inst_len = ec(13, .full, .dword),\n"
#~ "    tpr_threshold = ec(14, .full, .dword),\n"
#~ "    secondary_proc_exec_ctrl = ec(15, .full, .dword),\n"
#~ "    ple_gap = ec(16, .full, .dword),\n"
#~ "    ple_window = ec(17, .full, .dword),\n"
#~ "    instruction_timeouts = ec(18, .full, .dword),\n"
#~ "    // 64-bit fields.\n"
#~ "    io_bitmap_a = ec(0, .full, .qword),\n"
#~ "    io_bitmap_b = ec(1, .full, .qword),\n"
#~ "    msr_bitmap = ec(2, .full, .qword),\n"
#~ "    exit_msr_store_address = ec(3, .full, .qword),\n"
#~ "    exit_msr_load_address = ec(4, .full, .qword),\n"
#~ "    entry_msr_load_address = ec(5, .full, .qword),\n"
#~ "    executive_vmcs_pointer = ec(6, .full, .qword),\n"
#~ "    pml_address = ec(7, .full, .qword),\n"
#~ "    tsc_offset = ec(8, .full, .qword),\n"
#~ "    virtual_apic_address = ec(9, .full, .qword),\n"
#~ "    apic_access_address = ec(10, .full, .qword),\n"
#~ "    posted_intr_desc_addr = ec(11, .full, .qword),\n"
#~ "    vm_function_controls = ec(12, .full, .qword),\n"
#~ "    eptp = ec(13, .full, .qword),\n"
#~ "    eoi_exit_bitmap0 = ec(14, .full, .qword),\n"
#~ "    eoi_exit_bitmap1 = ec(15, .full, .qword),\n"
#~ "    eoi_exit_bitmap2 = ec(16, .full, .qword),\n"
#~ "    eoi_exit_bitmap3 = ec(17, .full, .qword),\n"
#~ "    eptp_list_address = ec(18, .full, .qword),\n"
#~ "    vmread_bitmap = ec(19, .full, .qword),\n"
#~ "    vmwrite_bitmap = ec(20, .full, .qword),\n"
#~ "    vexception_information_address = ec(21, .full, .qword),\n"
#~ "    xss_exiting_bitmap = ec(22, .full, .qword),\n"
#~ "    encls_exiting_bitmap = ec(23, .full, .qword),\n"
#~ "    sub_page_permission_table_pointer = ec(24, .full, .qword),\n"
#~ "    tsc_multiplier = ec(25, .full, .qword),\n"
#~ "    tertiary_proc_exec_ctrl = ec(26, .full, .qword),\n"
#~ "    enclv_exiting_bitmap = ec(27, .full, .qword),\n"
#~ "    low_pasid_directory = ec(28, .full, .qword),\n"
#~ "    high_pasid_directory = ec(29, .full, .qword),\n"
#~ "    shared_eptp = ec(30, .full, .qword),\n"
#~ "    pconfig_exiting_bitmap = ec(31, .full, .qword),\n"
#~ "    hlatp = ec(32, .full, .qword),\n"
#~ "    pid_pointer_table = ec(33, .full, .qword),\n"
#~ "    secondary_exit_ctrl = ec(34, .full, .qword),\n"
#~ "    spec_ctrl_mask = ec(37, .full, .qword),\n"
#~ "    spec_ctrl_shadow = ec(38, .full, .qword),\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vmcs.zig\n"
#~ "pub const ctrl = enum(u32) {\n"
#~ "    // Natural-width fields.\n"
#~ "    cr0_mask = ec(0, .full, .natural),\n"
#~ "    cr4_mask = ec(1, .full, .natural),\n"
#~ "    cr0_read_shadow = ec(2, .full, .natural),\n"
#~ "    cr4_read_shadow = ec(3, .full, .natural),\n"
#~ "    cr3_target0 = ec(4, .full, .natural),\n"
#~ "    cr3_target1 = ec(5, .full, .natural),\n"
#~ "    cr3_target2 = ec(6, .full, .natural),\n"
#~ "    cr3_target3 = ec(7, .full, .natural),\n"
#~ "    // 16-bit fields.\n"
#~ "    vpid = ec(0, .full, .word),\n"
#~ "    posted_intr_notif_vector = ec(1, .full, .word),\n"
#~ "    eptp_index = ec(2, .full, .word),\n"
#~ "    hlat_prefix_size = ec(3, .full, .word),\n"
#~ "    pid_pointer_index = ec(4, .full, .word),\n"
#~ "    // 32-bit fields.\n"
#~ "    pin_exec_ctrl = ec(0, .full, .dword),\n"
#~ "    proc_exec_ctrl = ec(1, .full, .dword),\n"
#~ "    exception_bitmap = ec(2, .full, .dword),\n"
#~ "    pf_ec_mask = ec(3, .full, .dword),\n"
#~ "    pf_ec_match = ec(4, .full, .dword),\n"
#~ "    cr3_target_count = ec(5, .full, .dword),\n"
#~ "    primary_exit_ctrl = ec(6, .full, .dword),\n"
#~ "    exit_msr_store_count = ec(7, .full, .dword),\n"
#~ "    vexit_msr_load_count = ec(8, .full, .dword),\n"
#~ "    entry_ctrl = ec(9, .full, .dword),\n"
#~ "    entry_msr_load_count = ec(10, .full, .dword),\n"
#~ "    entry_intr_info = ec(11, .full, .dword),\n"
#~ "    entry_exception_ec = ec(12, .full, .dword),\n"
#~ "    entry_inst_len = ec(13, .full, .dword),\n"
#~ "    tpr_threshold = ec(14, .full, .dword),\n"
#~ "    secondary_proc_exec_ctrl = ec(15, .full, .dword),\n"
#~ "    ple_gap = ec(16, .full, .dword),\n"
#~ "    ple_window = ec(17, .full, .dword),\n"
#~ "    instruction_timeouts = ec(18, .full, .dword),\n"
#~ "    // 64-bit fields.\n"
#~ "    io_bitmap_a = ec(0, .full, .qword),\n"
#~ "    io_bitmap_b = ec(1, .full, .qword),\n"
#~ "    msr_bitmap = ec(2, .full, .qword),\n"
#~ "    exit_msr_store_address = ec(3, .full, .qword),\n"
#~ "    exit_msr_load_address = ec(4, .full, .qword),\n"
#~ "    entry_msr_load_address = ec(5, .full, .qword),\n"
#~ "    executive_vmcs_pointer = ec(6, .full, .qword),\n"
#~ "    pml_address = ec(7, .full, .qword),\n"
#~ "    tsc_offset = ec(8, .full, .qword),\n"
#~ "    virtual_apic_address = ec(9, .full, .qword),\n"
#~ "    apic_access_address = ec(10, .full, .qword),\n"
#~ "    posted_intr_desc_addr = ec(11, .full, .qword),\n"
#~ "    vm_function_controls = ec(12, .full, .qword),\n"
#~ "    eptp = ec(13, .full, .qword),\n"
#~ "    eoi_exit_bitmap0 = ec(14, .full, .qword),\n"
#~ "    eoi_exit_bitmap1 = ec(15, .full, .qword),\n"
#~ "    eoi_exit_bitmap2 = ec(16, .full, .qword),\n"
#~ "    eoi_exit_bitmap3 = ec(17, .full, .qword),\n"
#~ "    eptp_list_address = ec(18, .full, .qword),\n"
#~ "    vmread_bitmap = ec(19, .full, .qword),\n"
#~ "    vmwrite_bitmap = ec(20, .full, .qword),\n"
#~ "    vexception_information_address = ec(21, .full, .qword),\n"
#~ "    xss_exiting_bitmap = ec(22, .full, .qword),\n"
#~ "    encls_exiting_bitmap = ec(23, .full, .qword),\n"
#~ "    sub_page_permission_table_pointer = ec(24, .full, .qword),\n"
#~ "    tsc_multiplier = ec(25, .full, .qword),\n"
#~ "    tertiary_proc_exec_ctrl = ec(26, .full, .qword),\n"
#~ "    enclv_exiting_bitmap = ec(27, .full, .qword),\n"
#~ "    low_pasid_directory = ec(28, .full, .qword),\n"
#~ "    high_pasid_directory = ec(29, .full, .qword),\n"
#~ "    shared_eptp = ec(30, .full, .qword),\n"
#~ "    pconfig_exiting_bitmap = ec(31, .full, .qword),\n"
#~ "    hlatp = ec(32, .full, .qword),\n"
#~ "    pid_pointer_table = ec(33, .full, .qword),\n"
#~ "    secondary_exit_ctrl = ec(34, .full, .qword),\n"
#~ "    spec_ctrl_mask = ec(37, .full, .qword),\n"
#~ "    spec_ctrl_shadow = ec(38, .full, .qword),\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn setupExecCtrls(_: *Vcpu, _: Allocator) VmxError!void {\n"
#~ "    const basic_msr = am.readMsrVmxBasic();\n"
#~ "\n"
#~ "    // Pin-based VM-Execution control.\n"
#~ "    const pin_exec_ctrl = try vmcs.PinExecCtrl.store();\n"
#~ "    try adjustRegMandatoryBits(\n"
#~ "        pin_exec_ctrl,\n"
#~ "        if (basic_msr.true_control) am.readMsr(.vmx_true_pinbased_ctls) "
#~ "else am.readMsr(.vmx_pinbased_ctls),\n"
#~ "    ).load();\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn setupExecCtrls(_: *Vcpu, _: Allocator) VmxError!void {\n"
#~ "    const basic_msr = am.readMsrVmxBasic();\n"
#~ "\n"
#~ "    // Pin-based VM-Execution control.\n"
#~ "    const pin_exec_ctrl = try vmcs.PinExecCtrl.store();\n"
#~ "    try adjustRegMandatoryBits(\n"
#~ "        pin_exec_ctrl,\n"
#~ "        if (basic_msr.true_control) am.readMsr(.vmx_true_pinbased_ctls) "
#~ "else am.readMsr(.vmx_pinbased_ctls),\n"
#~ "    ).load();\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn adjustRegMandatoryBits(control: anytype, mask: u64) @TypeOf(control) "
#~ "{\n"
#~ "    var ret: u32 = @bitCast(control);\n"
#~ "    ret |= @as(u32, @truncate(mask)); // Mandatory 1\n"
#~ "    ret &= @as(u32, @truncate(mask >> 32)); // Mandatory 0\n"
#~ "    return @bitCast(ret);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn adjustRegMandatoryBits(control: anytype, mask: u64) @TypeOf(control) "
#~ "{\n"
#~ "    var ret: u32 = @bitCast(control);\n"
#~ "    ret |= @as(u32, @truncate(mask)); // Mandatory 1\n"
#~ "    ret &= @as(u32, @truncate(mask >> 32)); // Mandatory 0\n"
#~ "    return @bitCast(ret);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn setupHostState(_: *Vcpu) VmxError!void {\n"
#~ "    // Control registers.\n"
#~ "    try vmwrite(vmcs.host.cr0, am.readCr0());\n"
#~ "    try vmwrite(vmcs.host.cr3, am.readCr3());\n"
#~ "    try vmwrite(vmcs.host.cr4, am.readCr4());\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn setupHostState(_: *Vcpu) VmxError!void {\n"
#~ "    // Control registers.\n"
#~ "    try vmwrite(vmcs.host.cr0, am.readCr0());\n"
#~ "    try vmwrite(vmcs.host.cr3, am.readCr3());\n"
#~ "    try vmwrite(vmcs.host.cr4, am.readCr4());\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "    // RSP / RIP\n"
#~ "    try vmwrite(vmcs.host.rip, &vmexitBootstrapHandler);\n"
#~ "    try vmwrite(vmcs.host.rsp, @intFromPtr(&temp_stack) + "
#~ "temp_stack_size);\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "    // RSP / RIP\n"
#~ "    try vmwrite(vmcs.host.rip, &vmexitBootstrapHandler);\n"
#~ "    try vmwrite(vmcs.host.rsp, @intFromPtr(&temp_stack) + "
#~ "temp_stack_size);\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "const temp_stack_size: usize = mem.page_size;\n"
#~ "var temp_stack: [temp_stack_size + 0x10]u8 align(0x10) = [_]u8{0} ** "
#~ "(temp_stack_size + 0x10);\n"
#~ "\n"
#~ "fn vmexitBootstrapHandler() callconv(.Naked) noreturn {\n"
#~ "    asm volatile (\n"
#~ "        \\\\call vmexitHandler\n"
#~ "    );\n"
#~ "}\n"
#~ "\n"
#~ "export fn vmexitHandler() noreturn {\n"
#~ "    log.debug(\"[VMEXIT handler]\", .{});\n"
#~ "    const reason = vmx.ExitInfo.load() catch unreachable;\n"
#~ "    log.debug(\"   VMEXIT reason: {?}\", .{reason});\n"
#~ "    while (true) asm volatile (\"hlt\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "const temp_stack_size: usize = mem.page_size;\n"
#~ "var temp_stack: [temp_stack_size + 0x10]u8 align(0x10) = [_]u8{0} ** "
#~ "(temp_stack_size + 0x10);\n"
#~ "\n"
#~ "fn vmexitBootstrapHandler() callconv(.Naked) noreturn {\n"
#~ "    asm volatile (\n"
#~ "        \\\\call vmexitHandler\n"
#~ "    );\n"
#~ "}\n"
#~ "\n"
#~ "export fn vmexitHandler() noreturn {\n"
#~ "    log.debug(\"[VMEXIT handler]\", .{});\n"
#~ "    const reason = vmx.ExitInfo.load() catch unreachable;\n"
#~ "    log.debug(\"   VMEXIT reason: {?}\", .{reason});\n"
#~ "    while (true) asm volatile (\"hlt\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vmcs.zig\n"
#~ "pub const ExitInfo = packed struct(u32) {\n"
#~ "    basic_reason: ExitReason,\n"
#~ "    _zero: u1 = 0,\n"
#~ "    _reserved1: u10 = 0,\n"
#~ "    _one: u1 = 1,\n"
#~ "    pending_mtf: u1 = 0,\n"
#~ "    exit_vmxroot: bool,\n"
#~ "    _reserved2: u1 = 0,\n"
#~ "    entry_failure: bool,\n"
#~ "\n"
#~ "    pub fn load() VmxError!ExitInfo {\n"
#~ "        return @bitCast(@as(u32, @truncate(try vmx.vmread(ro."
#~ "vmexit_reason))));\n"
#~ "    }\n"
#~ "};\n"
#~ "\n"
#~ "pub const ExitReason = enum(u16) {\n"
#~ "    exception_nmi = 0,\n"
#~ "    extintr = 1,\n"
#~ "    triple_fault = 2,\n"
#~ "    init = 3,\n"
#~ "    sipi = 4,\n"
#~ "    io_intr = 5,\n"
#~ "    other_smi = 6,\n"
#~ "    intr_window = 7,\n"
#~ "    nmi_window = 8,\n"
#~ "    task_switch = 9,\n"
#~ "    cpuid = 10,\n"
#~ "    getsec = 11,\n"
#~ "    hlt = 12,\n"
#~ "    invd = 13,\n"
#~ "    invlpg = 14,\n"
#~ "    rdpmc = 15,\n"
#~ "    rdtsc = 16,\n"
#~ "    rsm = 17,\n"
#~ "    vmcall = 18,\n"
#~ "    vmclear = 19,\n"
#~ "    vmlaunch = 20,\n"
#~ "    vmptrld = 21,\n"
#~ "    vmptrst = 22,\n"
#~ "    vmread = 23,\n"
#~ "    vmresume = 24,\n"
#~ "    vmwrite = 25,\n"
#~ "    vmxoff = 26,\n"
#~ "    vmxon = 27,\n"
#~ "    cr = 28,\n"
#~ "    dr = 29,\n"
#~ "    io = 30,\n"
#~ "    rdmsr = 31,\n"
#~ "    wrmsr = 32,\n"
#~ "    entry_fail_guest = 33,\n"
#~ "    entry_fail_msr = 34,\n"
#~ "    mwait = 36,\n"
#~ "    monitor_trap = 37,\n"
#~ "    monitor = 39,\n"
#~ "    pause = 40,\n"
#~ "    entry_fail_mce = 41,\n"
#~ "    tpr_threshold = 43,\n"
#~ "    apic = 44,\n"
#~ "    veoi = 45,\n"
#~ "    gdtr_idtr = 46,\n"
#~ "    ldtr_tr = 47,\n"
#~ "    ept = 48,\n"
#~ "    ept_misconfig = 49,\n"
#~ "    invept = 50,\n"
#~ "    rdtscp = 51,\n"
#~ "    preemption_timer = 52,\n"
#~ "    invvpid = 53,\n"
#~ "    wbinvd_wbnoinvd = 54,\n"
#~ "    xsetbv = 55,\n"
#~ "    apic_write = 56,\n"
#~ "    rdrand = 57,\n"
#~ "    invpcid = 58,\n"
#~ "    vmfunc = 59,\n"
#~ "    encls = 60,\n"
#~ "    rdseed = 61,\n"
#~ "    page_log_full = 62,\n"
#~ "    xsaves = 63,\n"
#~ "    xrstors = 64,\n"
#~ "    pconfig = 65,\n"
#~ "    spp = 66,\n"
#~ "    umwait = 67,\n"
#~ "    tpause = 68,\n"
#~ "    loadiwkey = 69,\n"
#~ "    enclv = 70,\n"
#~ "    enqcmd_pasid_fail = 72,\n"
#~ "    enqcmds_pasid_fail = 73,\n"
#~ "    bus_lock = 74,\n"
#~ "    timeout = 75,\n"
#~ "    seamcall = 76,\n"
#~ "    tdcall = 77,\n"
#~ "};\n"
#~ "\n"
#~ "pub const host = enum(u32) {\n"
#~ "    // Natural-width fields.\n"
#~ "    cr0 = eh(0, .full, .natural),\n"
#~ "    cr3 = eh(1, .full, .natural),\n"
#~ "    cr4 = eh(2, .full, .natural),\n"
#~ "    fs_base = eh(3, .full, .natural),\n"
#~ "    gs_base = eh(4, .full, .natural),\n"
#~ "    tr_base = eh(5, .full, .natural),\n"
#~ "    gdtr_base = eh(6, .full, .natural),\n"
#~ "    idtr_base = eh(7, .full, .natural),\n"
#~ "    sysenter_esp = eh(8, .full, .natural),\n"
#~ "    sysenter_eip = eh(9, .full, .natural),\n"
#~ "    rsp = eh(10, .full, .natural),\n"
#~ "    rip = eh(11, .full, .natural),\n"
#~ "    s_cet = eh(12, .full, .natural),\n"
#~ "    ssp = eh(13, .full, .natural),\n"
#~ "    intr_ssp_table_addr = eh(14, .full, .natural),\n"
#~ "    // 16-bit fields.\n"
#~ "    es_sel = eh(0, .full, .word),\n"
#~ "    cs_sel = eh(1, .full, .word),\n"
#~ "    ss_sel = eh(2, .full, .word),\n"
#~ "    ds_sel = eh(3, .full, .word),\n"
#~ "    fs_sel = eh(4, .full, .word),\n"
#~ "    gs_sel = eh(5, .full, .word),\n"
#~ "    tr_sel = eh(6, .full, .word),\n"
#~ "    // 32-bit fields.\n"
#~ "    sysenter_cs = eh(0, .full, .dword),\n"
#~ "    // 64-bit fields.\n"
#~ "    pat = eh(0, .full, .qword),\n"
#~ "    efer = eh(1, .full, .qword),\n"
#~ "    perf_global_ctrl = eh(2, .full, .qword),\n"
#~ "    pkrs = eh(3, .full, .qword),\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vmcs.zig\n"
#~ "pub const ExitInfo = packed struct(u32) {\n"
#~ "    basic_reason: ExitReason,\n"
#~ "    _zero: u1 = 0,\n"
#~ "    _reserved1: u10 = 0,\n"
#~ "    _one: u1 = 1,\n"
#~ "    pending_mtf: u1 = 0,\n"
#~ "    exit_vmxroot: bool,\n"
#~ "    _reserved2: u1 = 0,\n"
#~ "    entry_failure: bool,\n"
#~ "\n"
#~ "    pub fn load() VmxError!ExitInfo {\n"
#~ "        return @bitCast(@as(u32, @truncate(try vmx.vmread(ro."
#~ "vmexit_reason))));\n"
#~ "    }\n"
#~ "};\n"
#~ "\n"
#~ "pub const ExitReason = enum(u16) {\n"
#~ "    exception_nmi = 0,\n"
#~ "    extintr = 1,\n"
#~ "    triple_fault = 2,\n"
#~ "    init = 3,\n"
#~ "    sipi = 4,\n"
#~ "    io_intr = 5,\n"
#~ "    other_smi = 6,\n"
#~ "    intr_window = 7,\n"
#~ "    nmi_window = 8,\n"
#~ "    task_switch = 9,\n"
#~ "    cpuid = 10,\n"
#~ "    getsec = 11,\n"
#~ "    hlt = 12,\n"
#~ "    invd = 13,\n"
#~ "    invlpg = 14,\n"
#~ "    rdpmc = 15,\n"
#~ "    rdtsc = 16,\n"
#~ "    rsm = 17,\n"
#~ "    vmcall = 18,\n"
#~ "    vmclear = 19,\n"
#~ "    vmlaunch = 20,\n"
#~ "    vmptrld = 21,\n"
#~ "    vmptrst = 22,\n"
#~ "    vmread = 23,\n"
#~ "    vmresume = 24,\n"
#~ "    vmwrite = 25,\n"
#~ "    vmxoff = 26,\n"
#~ "    vmxon = 27,\n"
#~ "    cr = 28,\n"
#~ "    dr = 29,\n"
#~ "    io = 30,\n"
#~ "    rdmsr = 31,\n"
#~ "    wrmsr = 32,\n"
#~ "    entry_fail_guest = 33,\n"
#~ "    entry_fail_msr = 34,\n"
#~ "    mwait = 36,\n"
#~ "    monitor_trap = 37,\n"
#~ "    monitor = 39,\n"
#~ "    pause = 40,\n"
#~ "    entry_fail_mce = 41,\n"
#~ "    tpr_threshold = 43,\n"
#~ "    apic = 44,\n"
#~ "    veoi = 45,\n"
#~ "    gdtr_idtr = 46,\n"
#~ "    ldtr_tr = 47,\n"
#~ "    ept = 48,\n"
#~ "    ept_misconfig = 49,\n"
#~ "    invept = 50,\n"
#~ "    rdtscp = 51,\n"
#~ "    preemption_timer = 52,\n"
#~ "    invvpid = 53,\n"
#~ "    wbinvd_wbnoinvd = 54,\n"
#~ "    xsetbv = 55,\n"
#~ "    apic_write = 56,\n"
#~ "    rdrand = 57,\n"
#~ "    invpcid = 58,\n"
#~ "    vmfunc = 59,\n"
#~ "    encls = 60,\n"
#~ "    rdseed = 61,\n"
#~ "    page_log_full = 62,\n"
#~ "    xsaves = 63,\n"
#~ "    xrstors = 64,\n"
#~ "    pconfig = 65,\n"
#~ "    spp = 66,\n"
#~ "    umwait = 67,\n"
#~ "    tpause = 68,\n"
#~ "    loadiwkey = 69,\n"
#~ "    enclv = 70,\n"
#~ "    enqcmd_pasid_fail = 72,\n"
#~ "    enqcmds_pasid_fail = 73,\n"
#~ "    bus_lock = 74,\n"
#~ "    timeout = 75,\n"
#~ "    seamcall = 76,\n"
#~ "    tdcall = 77,\n"
#~ "};\n"
#~ "\n"
#~ "pub const host = enum(u32) {\n"
#~ "    // Natural-width fields.\n"
#~ "    cr0 = eh(0, .full, .natural),\n"
#~ "    cr3 = eh(1, .full, .natural),\n"
#~ "    cr4 = eh(2, .full, .natural),\n"
#~ "    fs_base = eh(3, .full, .natural),\n"
#~ "    gs_base = eh(4, .full, .natural),\n"
#~ "    tr_base = eh(5, .full, .natural),\n"
#~ "    gdtr_base = eh(6, .full, .natural),\n"
#~ "    idtr_base = eh(7, .full, .natural),\n"
#~ "    sysenter_esp = eh(8, .full, .natural),\n"
#~ "    sysenter_eip = eh(9, .full, .natural),\n"
#~ "    rsp = eh(10, .full, .natural),\n"
#~ "    rip = eh(11, .full, .natural),\n"
#~ "    s_cet = eh(12, .full, .natural),\n"
#~ "    ssp = eh(13, .full, .natural),\n"
#~ "    intr_ssp_table_addr = eh(14, .full, .natural),\n"
#~ "    // 16-bit fields.\n"
#~ "    es_sel = eh(0, .full, .word),\n"
#~ "    cs_sel = eh(1, .full, .word),\n"
#~ "    ss_sel = eh(2, .full, .word),\n"
#~ "    ds_sel = eh(3, .full, .word),\n"
#~ "    fs_sel = eh(4, .full, .word),\n"
#~ "    gs_sel = eh(5, .full, .word),\n"
#~ "    tr_sel = eh(6, .full, .word),\n"
#~ "    // 32-bit fields.\n"
#~ "    sysenter_cs = eh(0, .full, .dword),\n"
#~ "    // 64-bit fields.\n"
#~ "    pat = eh(0, .full, .qword),\n"
#~ "    efer = eh(1, .full, .qword),\n"
#~ "    perf_global_ctrl = eh(2, .full, .qword),\n"
#~ "    pkrs = eh(3, .full, .qword),\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn setupHostState(_: *Vcpu) VmxError!void {\n"
#~ "    ...\n"
#~ "    // Segment registers.\n"
#~ "    try vmwrite(vmcs.host.cs_sel, am.readSegSelector(.cs));\n"
#~ "    try vmwrite(vmcs.host.ss_sel, am.readSegSelector(.ss));\n"
#~ "    try vmwrite(vmcs.host.ds_sel, am.readSegSelector(.ds));\n"
#~ "    try vmwrite(vmcs.host.es_sel, am.readSegSelector(.es));\n"
#~ "    try vmwrite(vmcs.host.fs_sel, am.readSegSelector(.fs));\n"
#~ "    try vmwrite(vmcs.host.gs_sel, am.readSegSelector(.gs));\n"
#~ "    try vmwrite(vmcs.host.tr_sel, am.readSegSelector(.tr));\n"
#~ "\n"
#~ "    try vmwrite(vmcs.host.fs_base, am.readMsr(.fs_base));\n"
#~ "    try vmwrite(vmcs.host.gs_base, am.readMsr(.gs_base));\n"
#~ "    try vmwrite(vmcs.host.tr_base, 0); // Not used in Ymir.\n"
#~ "    try vmwrite(vmcs.host.gdtr_base, am.sgdt().base);\n"
#~ "    try vmwrite(vmcs.host.idtr_base, am.sidt().base);\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn setupHostState(_: *Vcpu) VmxError!void {\n"
#~ "    ...\n"
#~ "    // Segment registers.\n"
#~ "    try vmwrite(vmcs.host.cs_sel, am.readSegSelector(.cs));\n"
#~ "    try vmwrite(vmcs.host.ss_sel, am.readSegSelector(.ss));\n"
#~ "    try vmwrite(vmcs.host.ds_sel, am.readSegSelector(.ds));\n"
#~ "    try vmwrite(vmcs.host.es_sel, am.readSegSelector(.es));\n"
#~ "    try vmwrite(vmcs.host.fs_sel, am.readSegSelector(.fs));\n"
#~ "    try vmwrite(vmcs.host.gs_sel, am.readSegSelector(.gs));\n"
#~ "    try vmwrite(vmcs.host.tr_sel, am.readSegSelector(.tr));\n"
#~ "\n"
#~ "    try vmwrite(vmcs.host.fs_base, am.readMsr(.fs_base));\n"
#~ "    try vmwrite(vmcs.host.gs_base, am.readMsr(.gs_base));\n"
#~ "    try vmwrite(vmcs.host.tr_base, 0); // Not used in Ymir.\n"
#~ "    try vmwrite(vmcs.host.gdtr_base, am.sgdt().base);\n"
#~ "    try vmwrite(vmcs.host.idtr_base, am.sidt().base);\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "const Segment = enum {\n"
#~ "    cs,\n"
#~ "    ss,\n"
#~ "    ds,\n"
#~ "    es,\n"
#~ "    fs,\n"
#~ "    gs,\n"
#~ "    tr,\n"
#~ "    ldtr,\n"
#~ "};\n"
#~ "\n"
#~ "pub fn readSegSelector(segment: Segment) u16 {\n"
#~ "    return switch (segment) {\n"
#~ "        .cs => asm volatile (\"mov %%cs, %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .ss => asm volatile (\"mov %%ss, %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .ds => asm volatile (\"mov %%ds, %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .es => asm volatile (\"mov %%es, %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .fs => asm volatile (\"mov %%fs, %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .gs => asm volatile (\"mov %%gs, %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .tr => asm volatile (\"str %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .ldtr => asm volatile (\"sldt %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "    };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "const Segment = enum {\n"
#~ "    cs,\n"
#~ "    ss,\n"
#~ "    ds,\n"
#~ "    es,\n"
#~ "    fs,\n"
#~ "    gs,\n"
#~ "    tr,\n"
#~ "    ldtr,\n"
#~ "};\n"
#~ "\n"
#~ "pub fn readSegSelector(segment: Segment) u16 {\n"
#~ "    return switch (segment) {\n"
#~ "        .cs => asm volatile (\"mov %%cs, %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .ss => asm volatile (\"mov %%ss, %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .ds => asm volatile (\"mov %%ds, %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .es => asm volatile (\"mov %%es, %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .fs => asm volatile (\"mov %%fs, %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .gs => asm volatile (\"mov %%gs, %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .tr => asm volatile (\"str %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "        .ldtr => asm volatile (\"sldt %[ret]\"\n"
#~ "            : [ret] \"=r\" (-> u16),\n"
#~ "        ),\n"
#~ "    };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "const SgdtRet = packed struct {\n"
#~ "    limit: u16,\n"
#~ "    base: u64,\n"
#~ "};\n"
#~ "\n"
#~ "pub inline fn sgdt() SgdtRet {\n"
#~ "    var gdtr: SgdtRet = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\sgdt %[ret]\n"
#~ "        : [ret] \"=m\" (gdtr),\n"
#~ "    );\n"
#~ "    return gdtr;\n"
#~ "}\n"
#~ "\n"
#~ "const SidtRet = packed struct {\n"
#~ "    limit: u16,\n"
#~ "    base: u64,\n"
#~ "};\n"
#~ "\n"
#~ "pub inline fn sidt() SidtRet {\n"
#~ "    var idtr: SidtRet = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\sidt %[ret]\n"
#~ "        : [ret] \"=m\" (idtr),\n"
#~ "    );\n"
#~ "    return idtr;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "const SgdtRet = packed struct {\n"
#~ "    limit: u16,\n"
#~ "    base: u64,\n"
#~ "};\n"
#~ "\n"
#~ "pub inline fn sgdt() SgdtRet {\n"
#~ "    var gdtr: SgdtRet = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\sgdt %[ret]\n"
#~ "        : [ret] \"=m\" (gdtr),\n"
#~ "    );\n"
#~ "    return gdtr;\n"
#~ "}\n"
#~ "\n"
#~ "const SidtRet = packed struct {\n"
#~ "    limit: u16,\n"
#~ "    base: u64,\n"
#~ "};\n"
#~ "\n"
#~ "pub inline fn sidt() SidtRet {\n"
#~ "    var idtr: SidtRet = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\sidt %[ret]\n"
#~ "        : [ret] \"=m\" (idtr),\n"
#~ "    );\n"
#~ "    return idtr;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn setupHostState(_: *Vcpu) VmxError!void {\n"
#~ "    ...\n"
#~ "    // MSR.\n"
#~ "    try vmwrite(vmcs.host.efer, am.readMsr(.efer));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn setupHostState(_: *Vcpu) VmxError!void {\n"
#~ "    ...\n"
#~ "    // MSR.\n"
#~ "    try vmwrite(vmcs.host.efer, am.readMsr(.efer));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn setupGuestState(_: *Vcpu) VmxError!void {\n"
#~ "    // Control registers.\n"
#~ "    try vmwrite(vmcs.guest.cr0, am.readCr0());\n"
#~ "    try vmwrite(vmcs.guest.cr3, am.readCr3());\n"
#~ "    try vmwrite(vmcs.guest.cr4, am.readCr4());\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn setupGuestState(_: *Vcpu) VmxError!void {\n"
#~ "    // Control registers.\n"
#~ "    try vmwrite(vmcs.guest.cr0, am.readCr0());\n"
#~ "    try vmwrite(vmcs.guest.cr3, am.readCr3());\n"
#~ "    try vmwrite(vmcs.guest.cr4, am.readCr4());\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "    try vmwrite(vmcs.guest.cs_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.ss_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.ds_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.es_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.fs_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.gs_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.tr_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.gdtr_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.idtr_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.ldtr_base, 0xDEAD00); // Marker to indicate "
#~ "the guest.\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "    try vmwrite(vmcs.guest.cs_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.ss_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.ds_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.es_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.fs_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.gs_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.tr_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.gdtr_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.idtr_base, 0);\n"
#~ "    try vmwrite(vmcs.guest.ldtr_base, 0xDEAD00); // Marker to indicate "
#~ "the guest.\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/common.zig\n"
#~ "pub const SegmentRights = packed struct(u32) {\n"
#~ "    const gdt = @import(\"../gdt.zig\");\n"
#~ "\n"
#~ "    accessed: bool = true,\n"
#~ "    rw: bool,\n"
#~ "    dc: bool,\n"
#~ "    executable: bool,\n"
#~ "    desc_type: gdt.DescriptorType,\n"
#~ "    dpl: u2,\n"
#~ "    present: bool = true,\n"
#~ "    _reserved1: u4 = 0,\n"
#~ "    avl: bool = false,\n"
#~ "    long: bool = false,\n"
#~ "    db: u1,\n"
#~ "    granularity: gdt.Granularity,\n"
#~ "    unusable: bool = false,\n"
#~ "    _reserved2: u15 = 0,\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/common.zig\n"
#~ "pub const SegmentRights = packed struct(u32) {\n"
#~ "    const gdt = @import(\"../gdt.zig\");\n"
#~ "\n"
#~ "    accessed: bool = true,\n"
#~ "    rw: bool,\n"
#~ "    dc: bool,\n"
#~ "    executable: bool,\n"
#~ "    desc_type: gdt.DescriptorType,\n"
#~ "    dpl: u2,\n"
#~ "    present: bool = true,\n"
#~ "    _reserved1: u4 = 0,\n"
#~ "    avl: bool = false,\n"
#~ "    long: bool = false,\n"
#~ "    db: u1,\n"
#~ "    granularity: gdt.Granularity,\n"
#~ "    unusable: bool = false,\n"
#~ "    _reserved2: u15 = 0,\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "pub fn loop(_: *Self) VmxError!void {\n"
#~ "    const rflags = asm volatile (\n"
#~ "        \\\\vmlaunch\n"
#~ "        \\\\pushf\n"
#~ "        \\\\popq %[rflags]\n"
#~ "        : [rflags] \"=r\" (-> u64),\n"
#~ "    );\n"
#~ "    vmx.vmxtry(rflags) catch |err| {\n"
#~ "        log.err(\"VMLAUNCH: {?}\", .{err});\n"
#~ "        log.err(\"VM-instruction error number: {s}\", .{@tagName(try vmx."
#~ "InstructionError.load())});\n"
#~ "    };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "pub fn loop(_: *Self) VmxError!void {\n"
#~ "    const rflags = asm volatile (\n"
#~ "        \\\\vmlaunch\n"
#~ "        \\\\pushf\n"
#~ "        \\\\popq %[rflags]\n"
#~ "        : [rflags] \"=r\" (-> u64),\n"
#~ "    );\n"
#~ "    vmx.vmxtry(rflags) catch |err| {\n"
#~ "        log.err(\"VMLAUNCH: {?}\", .{err});\n"
#~ "        log.err(\"VM-instruction error number: {s}\", .{@tagName(try vmx."
#~ "InstructionError.load())});\n"
#~ "    };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "// Launch\n"
#~ "log.info(\"Starting the virtual machine...\", .{});\n"
#~ "try vm.loop();\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "// Launch\n"
#~ "log.info(\"Starting the virtual machine...\", .{});\n"
#~ "try vm.loop();\n"
#~ "```"

#~ msgid "'390,392p'"
#~ msgstr "'390,392p'"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/common.zig\n"
#~ "pub const GuestRegisters = extern struct {\n"
#~ "    rax: u64,\n"
#~ "    rcx: u64,\n"
#~ "    rdx: u64,\n"
#~ "    rbx: u64,\n"
#~ "    rbp: u64,\n"
#~ "    rsi: u64,\n"
#~ "    rdi: u64,\n"
#~ "    r8: u64,\n"
#~ "    r9: u64,\n"
#~ "    r10: u64,\n"
#~ "    r11: u64,\n"
#~ "    r12: u64,\n"
#~ "    r13: u64,\n"
#~ "    r14: u64,\n"
#~ "    r15: u64,\n"
#~ "    // Align to 16 bytes, otherwise movaps would cause #GP.\n"
#~ "    xmm0: u128 align(16),\n"
#~ "    xmm1: u128 align(16),\n"
#~ "    xmm2: u128 align(16),\n"
#~ "    xmm3: u128 align(16),\n"
#~ "    xmm4: u128 align(16),\n"
#~ "    xmm5: u128 align(16),\n"
#~ "    xmm6: u128 align(16),\n"
#~ "    xmm7: u128 align(16),\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/common.zig\n"
#~ "pub const GuestRegisters = extern struct {\n"
#~ "    rax: u64,\n"
#~ "    rcx: u64,\n"
#~ "    rdx: u64,\n"
#~ "    rbx: u64,\n"
#~ "    rbp: u64,\n"
#~ "    rsi: u64,\n"
#~ "    rdi: u64,\n"
#~ "    r8: u64,\n"
#~ "    r9: u64,\n"
#~ "    r10: u64,\n"
#~ "    r11: u64,\n"
#~ "    r12: u64,\n"
#~ "    r13: u64,\n"
#~ "    r14: u64,\n"
#~ "    r15: u64,\n"
#~ "    // Align to 16 bytes, otherwise movaps would cause #GP.\n"
#~ "    xmm0: u128 align(16),\n"
#~ "    xmm1: u128 align(16),\n"
#~ "    xmm2: u128 align(16),\n"
#~ "    xmm3: u128 align(16),\n"
#~ "    xmm4: u128 align(16),\n"
#~ "    xmm5: u128 align(16),\n"
#~ "    xmm6: u128 align(16),\n"
#~ "    xmm7: u128 align(16),\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "pub const Vcpu = struct {\n"
#~ "    ...\n"
#~ "    /// The first VM-entry has been done.\n"
#~ "    launch_done: bool = false,\n"
#~ "    ...\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "pub const Vcpu = struct {\n"
#~ "    ...\n"
#~ "    /// The first VM-entry has been done.\n"
#~ "    launch_done: bool = false,\n"
#~ "    ...\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "pub fn loop(self: *Self) VmxError!void {\n"
#~ "    while (true) {\n"
#~ "        // Enter VMX non-root operation.\n"
#~ "        self.vmentry() catch |err| {\n"
#~ "            log.err(\"VM-entry failed: {?}\", .{err});\n"
#~ "            if (err == VmxError.VmxStatusAvailable) {\n"
#~ "                const inst_err = try vmx.InstructionError.load();\n"
#~ "                log.err(\"VM Instruction error: {?}\", .{inst_err});\n"
#~ "            }\n"
#~ "            self.abort();\n"
#~ "        };\n"
#~ "        ...\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "pub fn loop(self: *Self) VmxError!void {\n"
#~ "    while (true) {\n"
#~ "        // Enter VMX non-root operation.\n"
#~ "        self.vmentry() catch |err| {\n"
#~ "            log.err(\"VM-entry failed: {?}\", .{err});\n"
#~ "            if (err == VmxError.VmxStatusAvailable) {\n"
#~ "                const inst_err = try vmx.InstructionError.load();\n"
#~ "                log.err(\"VM Instruction error: {?}\", .{inst_err});\n"
#~ "            }\n"
#~ "            self.abort();\n"
#~ "        };\n"
#~ "        ...\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "    pub fn abort(self: *Self) noreturn {\n"
#~ "        @setCold(true);\n"
#~ "        self.dump() catch log.err(\"Failed to dump VM information.\", ."
#~ "{});\n"
#~ "        ymir.endlessHalt();\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn dump(self: *Self) VmxError!void {\n"
#~ "        try self.printGuestState();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn printGuestState(self: *Self) VmxError!void {\n"
#~ "        log.err(\"=== vCPU Information ===\", .{});\n"
#~ "        log.err(\"[Guest State]\", .{});\n"
#~ "        log.err(\"RIP: 0x{X:0>16}\", .{try vmread(vmcs.guest.rip)});\n"
#~ "        log.err(\"RSP: 0x{X:0>16}\", .{try vmread(vmcs.guest.rsp)});\n"
#~ "        log.err(\"RAX: 0x{X:0>16}\", .{self.guest_regs.rax});\n"
#~ "        log.err(\"RBX: 0x{X:0>16}\", .{self.guest_regs.rbx});\n"
#~ "        log.err(\"RCX: 0x{X:0>16}\", .{self.guest_regs.rcx});\n"
#~ "        log.err(\"RDX: 0x{X:0>16}\", .{self.guest_regs.rdx});\n"
#~ "        log.err(\"RSI: 0x{X:0>16}\", .{self.guest_regs.rsi});\n"
#~ "        log.err(\"RDI: 0x{X:0>16}\", .{self.guest_regs.rdi});\n"
#~ "        log.err(\"RBP: 0x{X:0>16}\", .{self.guest_regs.rbp});\n"
#~ "        log.err(\"R8 : 0x{X:0>16}\", .{self.guest_regs.r8});\n"
#~ "        log.err(\"R9 : 0x{X:0>16}\", .{self.guest_regs.r9});\n"
#~ "        log.err(\"R10: 0x{X:0>16}\", .{self.guest_regs.r10});\n"
#~ "        log.err(\"R11: 0x{X:0>16}\", .{self.guest_regs.r11});\n"
#~ "        log.err(\"R12: 0x{X:0>16}\", .{self.guest_regs.r12});\n"
#~ "        log.err(\"R13: 0x{X:0>16}\", .{self.guest_regs.r13});\n"
#~ "        log.err(\"R14: 0x{X:0>16}\", .{self.guest_regs.r14});\n"
#~ "        log.err(\"R15: 0x{X:0>16}\", .{self.guest_regs.r15});\n"
#~ "        log.err(\"CR0: 0x{X:0>16}\", .{try vmread(vmcs.guest.cr0)});\n"
#~ "        log.err(\"CR3: 0x{X:0>16}\", .{try vmread(vmcs.guest.cr3)});\n"
#~ "        log.err(\"CR4: 0x{X:0>16}\", .{try vmread(vmcs.guest.cr4)});\n"
#~ "        log.err(\"EFER:0x{X:0>16}\", .{try vmread(vmcs.guest.efer)});\n"
#~ "        log.err(\n"
#~ "            \"CS : 0x{X:0>4} 0x{X:0>16} 0x{X:0>8}\",\n"
#~ "            .{\n"
#~ "                try vmread(vmcs.guest.cs_sel),\n"
#~ "                try vmread(vmcs.guest.cs_base),\n"
#~ "                try vmread(vmcs.guest.cs_limit),\n"
#~ "            },\n"
#~ "        );\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "    pub fn abort(self: *Self) noreturn {\n"
#~ "        @setCold(true);\n"
#~ "        self.dump() catch log.err(\"Failed to dump VM information.\", ."
#~ "{});\n"
#~ "        ymir.endlessHalt();\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn dump(self: *Self) VmxError!void {\n"
#~ "        try self.printGuestState();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn printGuestState(self: *Self) VmxError!void {\n"
#~ "        log.err(\"=== vCPU Information ===\", .{});\n"
#~ "        log.err(\"[Guest State]\", .{});\n"
#~ "        log.err(\"RIP: 0x{X:0>16}\", .{try vmread(vmcs.guest.rip)});\n"
#~ "        log.err(\"RSP: 0x{X:0>16}\", .{try vmread(vmcs.guest.rsp)});\n"
#~ "        log.err(\"RAX: 0x{X:0>16}\", .{self.guest_regs.rax});\n"
#~ "        log.err(\"RBX: 0x{X:0>16}\", .{self.guest_regs.rbx});\n"
#~ "        log.err(\"RCX: 0x{X:0>16}\", .{self.guest_regs.rcx});\n"
#~ "        log.err(\"RDX: 0x{X:0>16}\", .{self.guest_regs.rdx});\n"
#~ "        log.err(\"RSI: 0x{X:0>16}\", .{self.guest_regs.rsi});\n"
#~ "        log.err(\"RDI: 0x{X:0>16}\", .{self.guest_regs.rdi});\n"
#~ "        log.err(\"RBP: 0x{X:0>16}\", .{self.guest_regs.rbp});\n"
#~ "        log.err(\"R8 : 0x{X:0>16}\", .{self.guest_regs.r8});\n"
#~ "        log.err(\"R9 : 0x{X:0>16}\", .{self.guest_regs.r9});\n"
#~ "        log.err(\"R10: 0x{X:0>16}\", .{self.guest_regs.r10});\n"
#~ "        log.err(\"R11: 0x{X:0>16}\", .{self.guest_regs.r11});\n"
#~ "        log.err(\"R12: 0x{X:0>16}\", .{self.guest_regs.r12});\n"
#~ "        log.err(\"R13: 0x{X:0>16}\", .{self.guest_regs.r13});\n"
#~ "        log.err(\"R14: 0x{X:0>16}\", .{self.guest_regs.r14});\n"
#~ "        log.err(\"R15: 0x{X:0>16}\", .{self.guest_regs.r15});\n"
#~ "        log.err(\"CR0: 0x{X:0>16}\", .{try vmread(vmcs.guest.cr0)});\n"
#~ "        log.err(\"CR3: 0x{X:0>16}\", .{try vmread(vmcs.guest.cr3)});\n"
#~ "        log.err(\"CR4: 0x{X:0>16}\", .{try vmread(vmcs.guest.cr4)});\n"
#~ "        log.err(\"EFER:0x{X:0>16}\", .{try vmread(vmcs.guest.efer)});\n"
#~ "        log.err(\n"
#~ "            \"CS : 0x{X:0>4} 0x{X:0>16} 0x{X:0>8}\",\n"
#~ "            .{\n"
#~ "                try vmread(vmcs.guest.cs_sel),\n"
#~ "                try vmread(vmcs.guest.cs_base),\n"
#~ "                try vmread(vmcs.guest.cs_limit),\n"
#~ "            },\n"
#~ "        );\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn vmentry(self: *Self) VmxError!void {\n"
#~ "    const success = asm volatile (\n"
#~ "        \\\\mov %[self], %%rdi\n"
#~ "        \\\\call asmVmEntry\n"
#~ "        : [ret] \"={ax}\" (-> u8),\n"
#~ "        : [self] \"r\" (self),\n"
#~ "        : \"rax\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"r8\", \"r9\", "
#~ "\"r10\", \"r11\"\n"
#~ "    ) == 0;\n"
#~ "\n"
#~ "    if (!self.launch_done and success) {\n"
#~ "        self.launch_done = true;\n"
#~ "    }\n"
#~ "\n"
#~ "    if (!success) {\n"
#~ "        const inst_err = try vmread(vmcs.ro.vminstruction_error);\n"
#~ "        return if (inst_err != 0) VmxError.VmxStatusAvailable else "
#~ "VmxError.VmxStatusUnavailable;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn vmentry(self: *Self) VmxError!void {\n"
#~ "    const success = asm volatile (\n"
#~ "        \\\\mov %[self], %%rdi\n"
#~ "        \\\\call asmVmEntry\n"
#~ "        : [ret] \"={ax}\" (-> u8),\n"
#~ "        : [self] \"r\" (self),\n"
#~ "        : \"rax\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"r8\", \"r9\", "
#~ "\"r10\", \"r11\"\n"
#~ "    ) == 0;\n"
#~ "\n"
#~ "    if (!self.launch_done and success) {\n"
#~ "        self.launch_done = true;\n"
#~ "    }\n"
#~ "\n"
#~ "    if (!success) {\n"
#~ "        const inst_err = try vmread(vmcs.ro.vminstruction_error);\n"
#~ "        return if (inst_err != 0) VmxError.VmxStatusAvailable else "
#~ "VmxError.VmxStatusUnavailable;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "export fn asmVmEntry() callconv(.Naked) u8 {\n"
#~ "    // Save callee saved registers.\n"
#~ "    asm volatile (\n"
#~ "        \\\\push %%rbp\n"
#~ "        \\\\push %%r15\n"
#~ "        \\\\push %%r14\n"
#~ "        \\\\push %%r13\n"
#~ "        \\\\push %%r12\n"
#~ "        \\\\push %%rbx\n"
#~ "    );\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "export fn asmVmEntry() callconv(.Naked) u8 {\n"
#~ "    // Save callee saved registers.\n"
#~ "    asm volatile (\n"
#~ "        \\\\push %%rbp\n"
#~ "        \\\\push %%r15\n"
#~ "        \\\\push %%r14\n"
#~ "        \\\\push %%r13\n"
#~ "        \\\\push %%r12\n"
#~ "        \\\\push %%rbx\n"
#~ "    );\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Save a pointer to guest registers\n"
#~ "    asm volatile (std.fmt.comptimePrint(\n"
#~ "            \\\\lea {d}(%%rdi), %%rbx\n"
#~ "            \\\\push %%rbx\n"
#~ "        ,\n"
#~ "            .{@offsetOf(Vcpu, \"guest_regs\")},\n"
#~ "        ));\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Save a pointer to guest registers\n"
#~ "    asm volatile (std.fmt.comptimePrint(\n"
#~ "            \\\\lea {d}(%%rdi), %%rbx\n"
#~ "            \\\\push %%rbx\n"
#~ "        ,\n"
#~ "            .{@offsetOf(Vcpu, \"guest_regs\")},\n"
#~ "        ));\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Set host stack\n"
#~ "    asm volatile (\n"
#~ "        \\\\push %%rdi\n"
#~ "        \\\\lea 8(%%rsp), %%rdi\n"
#~ "        \\\\call setHostStack\n"
#~ "        \\\\pop %%rdi\n"
#~ "    );\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Set host stack\n"
#~ "    asm volatile (\n"
#~ "        \\\\push %%rdi\n"
#~ "        \\\\lea 8(%%rsp), %%rdi\n"
#~ "        \\\\call setHostStack\n"
#~ "        \\\\pop %%rdi\n"
#~ "    );\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Determine VMLAUNCH or VMRESUME.\n"
#~ "    asm volatile (std.fmt.comptimePrint(\n"
#~ "            \\\\testb $1, {d}(%%rdi)\n"
#~ "        ,\n"
#~ "            .{@offsetOf(Vcpu, \"launch_done\")},\n"
#~ "        ));\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Determine VMLAUNCH or VMRESUME.\n"
#~ "    asm volatile (std.fmt.comptimePrint(\n"
#~ "            \\\\testb $1, {d}(%%rdi)\n"
#~ "        ,\n"
#~ "            .{@offsetOf(Vcpu, \"launch_done\")},\n"
#~ "        ));\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Restore guest registers.\n"
#~ "    asm volatile (std.fmt.comptimePrint(\n"
#~ "            \\\\mov %%rdi, %%rax\n"
#~ "            \\\\mov {[rcx]}(%%rax), %%rcx\n"
#~ "            \\\\mov {[rdx]}(%%rax), %%rdx\n"
#~ "            \\\\mov {[rbx]}(%%rax), %%rbx\n"
#~ "            \\\\mov {[rsi]}(%%rax), %%rsi\n"
#~ "            \\\\mov {[rdi]}(%%rax), %%rdi\n"
#~ "            \\\\mov {[rbp]}(%%rax), %%rbp\n"
#~ "            \\\\mov {[r8]}(%%rax), %%r8\n"
#~ "            \\\\mov {[r9]}(%%rax), %%r9\n"
#~ "            \\\\mov {[r10]}(%%rax), %%r10\n"
#~ "            \\\\mov {[r11]}(%%rax), %%r11\n"
#~ "            \\\\mov {[r12]}(%%rax), %%r12\n"
#~ "            \\\\mov {[r13]}(%%rax), %%r13\n"
#~ "            \\\\mov {[r14]}(%%rax), %%r14\n"
#~ "            \\\\mov {[r15]}(%%rax), %%r15\n"
#~ "            \\\\movaps {[xmm0]}(%%rax), %%xmm0\n"
#~ "            \\\\movaps {[xmm1]}(%%rax), %%xmm1\n"
#~ "            \\\\movaps {[xmm2]}(%%rax), %%xmm2\n"
#~ "            \\\\movaps {[xmm3]}(%%rax), %%xmm3\n"
#~ "            \\\\movaps {[xmm4]}(%%rax), %%xmm4\n"
#~ "            \\\\movaps {[xmm5]}(%%rax), %%xmm5\n"
#~ "            \\\\movaps {[xmm6]}(%%rax), %%xmm6\n"
#~ "            \\\\movaps {[xmm7]}(%%rax), %%xmm7\n"
#~ "            \\\\mov {[rax]}(%%rax), %%rax\n"
#~ "        , .{\n"
#~ "            .rax = @offsetOf(vmx.GuestRegisters, \"rax\"),\n"
#~ "            .rcx = @offsetOf(vmx.GuestRegisters, \"rcx\"),\n"
#~ "            .rdx = @offsetOf(vmx.GuestRegisters, \"rdx\"),\n"
#~ "            .rbx = @offsetOf(vmx.GuestRegisters, \"rbx\"),\n"
#~ "            .rsi = @offsetOf(vmx.GuestRegisters, \"rsi\"),\n"
#~ "            .rdi = @offsetOf(vmx.GuestRegisters, \"rdi\"),\n"
#~ "            .rbp = @offsetOf(vmx.GuestRegisters, \"rbp\"),\n"
#~ "            .r8 = @offsetOf(vmx.GuestRegisters, \"r8\"),\n"
#~ "            .r9 = @offsetOf(vmx.GuestRegisters, \"r9\"),\n"
#~ "            .r10 = @offsetOf(vmx.GuestRegisters, \"r10\"),\n"
#~ "            .r11 = @offsetOf(vmx.GuestRegisters, \"r11\"),\n"
#~ "            .r12 = @offsetOf(vmx.GuestRegisters, \"r12\"),\n"
#~ "            .r13 = @offsetOf(vmx.GuestRegisters, \"r13\"),\n"
#~ "            .r14 = @offsetOf(vmx.GuestRegisters, \"r14\"),\n"
#~ "            .r15 = @offsetOf(vmx.GuestRegisters, \"r15\"),\n"
#~ "            .xmm0 = @offsetOf(vmx.GuestRegisters, \"xmm0\"),\n"
#~ "            .xmm1 = @offsetOf(vmx.GuestRegisters, \"xmm1\"),\n"
#~ "            .xmm2 = @offsetOf(vmx.GuestRegisters, \"xmm2\"),\n"
#~ "            .xmm3 = @offsetOf(vmx.GuestRegisters, \"xmm3\"),\n"
#~ "            .xmm4 = @offsetOf(vmx.GuestRegisters, \"xmm4\"),\n"
#~ "            .xmm5 = @offsetOf(vmx.GuestRegisters, \"xmm5\"),\n"
#~ "            .xmm6 = @offsetOf(vmx.GuestRegisters, \"xmm6\"),\n"
#~ "            .xmm7 = @offsetOf(vmx.GuestRegisters, \"xmm7\"),\n"
#~ "        }));\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Restore guest registers.\n"
#~ "    asm volatile (std.fmt.comptimePrint(\n"
#~ "            \\\\mov %%rdi, %%rax\n"
#~ "            \\\\mov {[rcx]}(%%rax), %%rcx\n"
#~ "            \\\\mov {[rdx]}(%%rax), %%rdx\n"
#~ "            \\\\mov {[rbx]}(%%rax), %%rbx\n"
#~ "            \\\\mov {[rsi]}(%%rax), %%rsi\n"
#~ "            \\\\mov {[rdi]}(%%rax), %%rdi\n"
#~ "            \\\\mov {[rbp]}(%%rax), %%rbp\n"
#~ "            \\\\mov {[r8]}(%%rax), %%r8\n"
#~ "            \\\\mov {[r9]}(%%rax), %%r9\n"
#~ "            \\\\mov {[r10]}(%%rax), %%r10\n"
#~ "            \\\\mov {[r11]}(%%rax), %%r11\n"
#~ "            \\\\mov {[r12]}(%%rax), %%r12\n"
#~ "            \\\\mov {[r13]}(%%rax), %%r13\n"
#~ "            \\\\mov {[r14]}(%%rax), %%r14\n"
#~ "            \\\\mov {[r15]}(%%rax), %%r15\n"
#~ "            \\\\movaps {[xmm0]}(%%rax), %%xmm0\n"
#~ "            \\\\movaps {[xmm1]}(%%rax), %%xmm1\n"
#~ "            \\\\movaps {[xmm2]}(%%rax), %%xmm2\n"
#~ "            \\\\movaps {[xmm3]}(%%rax), %%xmm3\n"
#~ "            \\\\movaps {[xmm4]}(%%rax), %%xmm4\n"
#~ "            \\\\movaps {[xmm5]}(%%rax), %%xmm5\n"
#~ "            \\\\movaps {[xmm6]}(%%rax), %%xmm6\n"
#~ "            \\\\movaps {[xmm7]}(%%rax), %%xmm7\n"
#~ "            \\\\mov {[rax]}(%%rax), %%rax\n"
#~ "        , .{\n"
#~ "            .rax = @offsetOf(vmx.GuestRegisters, \"rax\"),\n"
#~ "            .rcx = @offsetOf(vmx.GuestRegisters, \"rcx\"),\n"
#~ "            .rdx = @offsetOf(vmx.GuestRegisters, \"rdx\"),\n"
#~ "            .rbx = @offsetOf(vmx.GuestRegisters, \"rbx\"),\n"
#~ "            .rsi = @offsetOf(vmx.GuestRegisters, \"rsi\"),\n"
#~ "            .rdi = @offsetOf(vmx.GuestRegisters, \"rdi\"),\n"
#~ "            .rbp = @offsetOf(vmx.GuestRegisters, \"rbp\"),\n"
#~ "            .r8 = @offsetOf(vmx.GuestRegisters, \"r8\"),\n"
#~ "            .r9 = @offsetOf(vmx.GuestRegisters, \"r9\"),\n"
#~ "            .r10 = @offsetOf(vmx.GuestRegisters, \"r10\"),\n"
#~ "            .r11 = @offsetOf(vmx.GuestRegisters, \"r11\"),\n"
#~ "            .r12 = @offsetOf(vmx.GuestRegisters, \"r12\"),\n"
#~ "            .r13 = @offsetOf(vmx.GuestRegisters, \"r13\"),\n"
#~ "            .r14 = @offsetOf(vmx.GuestRegisters, \"r14\"),\n"
#~ "            .r15 = @offsetOf(vmx.GuestRegisters, \"r15\"),\n"
#~ "            .xmm0 = @offsetOf(vmx.GuestRegisters, \"xmm0\"),\n"
#~ "            .xmm1 = @offsetOf(vmx.GuestRegisters, \"xmm1\"),\n"
#~ "            .xmm2 = @offsetOf(vmx.GuestRegisters, \"xmm2\"),\n"
#~ "            .xmm3 = @offsetOf(vmx.GuestRegisters, \"xmm3\"),\n"
#~ "            .xmm4 = @offsetOf(vmx.GuestRegisters, \"xmm4\"),\n"
#~ "            .xmm5 = @offsetOf(vmx.GuestRegisters, \"xmm5\"),\n"
#~ "            .xmm6 = @offsetOf(vmx.GuestRegisters, \"xmm6\"),\n"
#~ "            .xmm7 = @offsetOf(vmx.GuestRegisters, \"xmm7\"),\n"
#~ "        }));\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // VMLAUNCH or VMRESUME.\n"
#~ "    asm volatile (\n"
#~ "        \\\\jz .L_vmlaunch\n"
#~ "        \\\\vmresume\n"
#~ "        \\\\.L_vmlaunch:\n"
#~ "        \\\\vmlaunch\n"
#~ "    );\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // VMLAUNCH or VMRESUME.\n"
#~ "    asm volatile (\n"
#~ "        \\\\jz .L_vmlaunch\n"
#~ "        \\\\vmresume\n"
#~ "        \\\\.L_vmlaunch:\n"
#~ "        \\\\vmlaunch\n"
#~ "    );\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Set return value to 1.\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov $1, %%al\n"
#~ "    );\n"
#~ "    // Restore callee saved registers.\n"
#~ "    asm volatile (\n"
#~ "        \\\\add $0x8, %%rsp\n"
#~ "        \\\\pop %%rbx\n"
#~ "        \\\\pop %%r12\n"
#~ "        \\\\pop %%r13\n"
#~ "        \\\\pop %%r14\n"
#~ "        \\\\pop %%r15\n"
#~ "        \\\\pop %%rbp\n"
#~ "    );\n"
#~ "    // Return to caller of asmVmEntry()\n"
#~ "    asm volatile (\n"
#~ "        \\\\ret\n"
#~ "    );\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Set return value to 1.\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov $1, %%al\n"
#~ "    );\n"
#~ "    // Restore callee saved registers.\n"
#~ "    asm volatile (\n"
#~ "        \\\\add $0x8, %%rsp\n"
#~ "        \\\\pop %%rbx\n"
#~ "        \\\\pop %%r12\n"
#~ "        \\\\pop %%r13\n"
#~ "        \\\\pop %%r14\n"
#~ "        \\\\pop %%r15\n"
#~ "        \\\\pop %%rbp\n"
#~ "    );\n"
#~ "    // Return to caller of asmVmEntry()\n"
#~ "    asm volatile (\n"
#~ "        \\\\ret\n"
#~ "    );\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "pub fn asmVmExit() callconv(.Naked) void {\n"
#~ "    // Disable IRQ.\n"
#~ "    asm volatile (\n"
#~ "        \\\\cli\n"
#~ "    );\n"
#~ "    // Save guest RAX, get &guest_regs\n"
#~ "    asm volatile (\n"
#~ "        \\\\push %%rax\n"
#~ "        \\\\movq 8(%%rsp), %%rax\n"
#~ "    );\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "pub fn asmVmExit() callconv(.Naked) void {\n"
#~ "    // Disable IRQ.\n"
#~ "    asm volatile (\n"
#~ "        \\\\cli\n"
#~ "    );\n"
#~ "    // Save guest RAX, get &guest_regs\n"
#~ "    asm volatile (\n"
#~ "        \\\\push %%rax\n"
#~ "        \\\\movq 8(%%rsp), %%rax\n"
#~ "    );\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Save guest registers.\n"
#~ "    asm volatile (std.fmt.comptimePrint(\n"
#~ "            \\\\\n"
#~ "            // Save pushed RAX.\n"
#~ "            \\\\pop {[rax]}(%%rax)\n"
#~ "            // Discard pushed &guest_regs.\n"
#~ "            \\\\add $0x8, %%rsp\n"
#~ "            // Save guest registers.\n"
#~ "            \\\\mov %%rcx, {[rcx]}(%%rax)\n"
#~ "            \\\\mov %%rdx, {[rdx]}(%%rax)\n"
#~ "            \\\\mov %%rbx, {[rbx]}(%%rax)\n"
#~ "            \\\\mov %%rsi, {[rsi]}(%%rax)\n"
#~ "            \\\\mov %%rdi, {[rdi]}(%%rax)\n"
#~ "            \\\\mov %%rbp, {[rbp]}(%%rax)\n"
#~ "            \\\\mov %%r8, {[r8]}(%%rax)\n"
#~ "            \\\\mov %%r9, {[r9]}(%%rax)\n"
#~ "            \\\\mov %%r10, {[r10]}(%%rax)\n"
#~ "            \\\\mov %%r11, {[r11]}(%%rax)\n"
#~ "            \\\\mov %%r12, {[r12]}(%%rax)\n"
#~ "            \\\\mov %%r13, {[r13]}(%%rax)\n"
#~ "            \\\\mov %%r14, {[r14]}(%%rax)\n"
#~ "            \\\\mov %%r15, {[r15]}(%%rax)\n"
#~ "            \\\\movaps %%xmm0, {[xmm0]}(%%rax)\n"
#~ "            \\\\movaps %%xmm1, {[xmm1]}(%%rax)\n"
#~ "            \\\\movaps %%xmm2, {[xmm2]}(%%rax)\n"
#~ "            \\\\movaps %%xmm3, {[xmm3]}(%%rax)\n"
#~ "            \\\\movaps %%xmm4, {[xmm4]}(%%rax)\n"
#~ "            \\\\movaps %%xmm5, {[xmm5]}(%%rax)\n"
#~ "            \\\\movaps %%xmm6, {[xmm6]}(%%rax)\n"
#~ "            \\\\movaps %%xmm7, {[xmm7]}(%%rax)\n"
#~ "        ,\n"
#~ "            .{\n"
#~ "                .rax = @offsetOf(vmx.GuestRegisters, \"rax\"),\n"
#~ "                .rcx = @offsetOf(vmx.GuestRegisters, \"rcx\"),\n"
#~ "                .rdx = @offsetOf(vmx.GuestRegisters, \"rdx\"),\n"
#~ "                .rbx = @offsetOf(vmx.GuestRegisters, \"rbx\"),\n"
#~ "                .rsi = @offsetOf(vmx.GuestRegisters, \"rsi\"),\n"
#~ "                .rdi = @offsetOf(vmx.GuestRegisters, \"rdi\"),\n"
#~ "                .rbp = @offsetOf(vmx.GuestRegisters, \"rbp\"),\n"
#~ "                .r8 = @offsetOf(vmx.GuestRegisters, \"r8\"),\n"
#~ "                .r9 = @offsetOf(vmx.GuestRegisters, \"r9\"),\n"
#~ "                .r10 = @offsetOf(vmx.GuestRegisters, \"r10\"),\n"
#~ "                .r11 = @offsetOf(vmx.GuestRegisters, \"r11\"),\n"
#~ "                .r12 = @offsetOf(vmx.GuestRegisters, \"r12\"),\n"
#~ "                .r13 = @offsetOf(vmx.GuestRegisters, \"r13\"),\n"
#~ "                .r14 = @offsetOf(vmx.GuestRegisters, \"r14\"),\n"
#~ "                .r15 = @offsetOf(vmx.GuestRegisters, \"r15\"),\n"
#~ "                .xmm0 = @offsetOf(vmx.GuestRegisters, \"xmm0\"),\n"
#~ "                .xmm1 = @offsetOf(vmx.GuestRegisters, \"xmm1\"),\n"
#~ "                .xmm2 = @offsetOf(vmx.GuestRegisters, \"xmm2\"),\n"
#~ "                .xmm3 = @offsetOf(vmx.GuestRegisters, \"xmm3\"),\n"
#~ "                .xmm4 = @offsetOf(vmx.GuestRegisters, \"xmm4\"),\n"
#~ "                .xmm5 = @offsetOf(vmx.GuestRegisters, \"xmm5\"),\n"
#~ "                .xmm6 = @offsetOf(vmx.GuestRegisters, \"xmm6\"),\n"
#~ "                .xmm7 = @offsetOf(vmx.GuestRegisters, \"xmm7\"),\n"
#~ "            },\n"
#~ "        ));\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Save guest registers.\n"
#~ "    asm volatile (std.fmt.comptimePrint(\n"
#~ "            \\\\\n"
#~ "            // Save pushed RAX.\n"
#~ "            \\\\pop {[rax]}(%%rax)\n"
#~ "            // Discard pushed &guest_regs.\n"
#~ "            \\\\add $0x8, %%rsp\n"
#~ "            // Save guest registers.\n"
#~ "            \\\\mov %%rcx, {[rcx]}(%%rax)\n"
#~ "            \\\\mov %%rdx, {[rdx]}(%%rax)\n"
#~ "            \\\\mov %%rbx, {[rbx]}(%%rax)\n"
#~ "            \\\\mov %%rsi, {[rsi]}(%%rax)\n"
#~ "            \\\\mov %%rdi, {[rdi]}(%%rax)\n"
#~ "            \\\\mov %%rbp, {[rbp]}(%%rax)\n"
#~ "            \\\\mov %%r8, {[r8]}(%%rax)\n"
#~ "            \\\\mov %%r9, {[r9]}(%%rax)\n"
#~ "            \\\\mov %%r10, {[r10]}(%%rax)\n"
#~ "            \\\\mov %%r11, {[r11]}(%%rax)\n"
#~ "            \\\\mov %%r12, {[r12]}(%%rax)\n"
#~ "            \\\\mov %%r13, {[r13]}(%%rax)\n"
#~ "            \\\\mov %%r14, {[r14]}(%%rax)\n"
#~ "            \\\\mov %%r15, {[r15]}(%%rax)\n"
#~ "            \\\\movaps %%xmm0, {[xmm0]}(%%rax)\n"
#~ "            \\\\movaps %%xmm1, {[xmm1]}(%%rax)\n"
#~ "            \\\\movaps %%xmm2, {[xmm2]}(%%rax)\n"
#~ "            \\\\movaps %%xmm3, {[xmm3]}(%%rax)\n"
#~ "            \\\\movaps %%xmm4, {[xmm4]}(%%rax)\n"
#~ "            \\\\movaps %%xmm5, {[xmm5]}(%%rax)\n"
#~ "            \\\\movaps %%xmm6, {[xmm6]}(%%rax)\n"
#~ "            \\\\movaps %%xmm7, {[xmm7]}(%%rax)\n"
#~ "        ,\n"
#~ "            .{\n"
#~ "                .rax = @offsetOf(vmx.GuestRegisters, \"rax\"),\n"
#~ "                .rcx = @offsetOf(vmx.GuestRegisters, \"rcx\"),\n"
#~ "                .rdx = @offsetOf(vmx.GuestRegisters, \"rdx\"),\n"
#~ "                .rbx = @offsetOf(vmx.GuestRegisters, \"rbx\"),\n"
#~ "                .rsi = @offsetOf(vmx.GuestRegisters, \"rsi\"),\n"
#~ "                .rdi = @offsetOf(vmx.GuestRegisters, \"rdi\"),\n"
#~ "                .rbp = @offsetOf(vmx.GuestRegisters, \"rbp\"),\n"
#~ "                .r8 = @offsetOf(vmx.GuestRegisters, \"r8\"),\n"
#~ "                .r9 = @offsetOf(vmx.GuestRegisters, \"r9\"),\n"
#~ "                .r10 = @offsetOf(vmx.GuestRegisters, \"r10\"),\n"
#~ "                .r11 = @offsetOf(vmx.GuestRegisters, \"r11\"),\n"
#~ "                .r12 = @offsetOf(vmx.GuestRegisters, \"r12\"),\n"
#~ "                .r13 = @offsetOf(vmx.GuestRegisters, \"r13\"),\n"
#~ "                .r14 = @offsetOf(vmx.GuestRegisters, \"r14\"),\n"
#~ "                .r15 = @offsetOf(vmx.GuestRegisters, \"r15\"),\n"
#~ "                .xmm0 = @offsetOf(vmx.GuestRegisters, \"xmm0\"),\n"
#~ "                .xmm1 = @offsetOf(vmx.GuestRegisters, \"xmm1\"),\n"
#~ "                .xmm2 = @offsetOf(vmx.GuestRegisters, \"xmm2\"),\n"
#~ "                .xmm3 = @offsetOf(vmx.GuestRegisters, \"xmm3\"),\n"
#~ "                .xmm4 = @offsetOf(vmx.GuestRegisters, \"xmm4\"),\n"
#~ "                .xmm5 = @offsetOf(vmx.GuestRegisters, \"xmm5\"),\n"
#~ "                .xmm6 = @offsetOf(vmx.GuestRegisters, \"xmm6\"),\n"
#~ "                .xmm7 = @offsetOf(vmx.GuestRegisters, \"xmm7\"),\n"
#~ "            },\n"
#~ "        ));\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Restore callee saved registers.\n"
#~ "    asm volatile (\n"
#~ "        \\\\pop %%rbx\n"
#~ "        \\\\pop %%r12\n"
#~ "        \\\\pop %%r13\n"
#~ "        \\\\pop %%r14\n"
#~ "        \\\\pop %%r15\n"
#~ "        \\\\pop %%rbp\n"
#~ "    );\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Restore callee saved registers.\n"
#~ "    asm volatile (\n"
#~ "        \\\\pop %%rbx\n"
#~ "        \\\\pop %%r12\n"
#~ "        \\\\pop %%r13\n"
#~ "        \\\\pop %%r14\n"
#~ "        \\\\pop %%r15\n"
#~ "        \\\\pop %%rbp\n"
#~ "    );\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Return to caller of asmVmEntry()\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov $0, %%rax\n"
#~ "        \\\\ret\n"
#~ "    );\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/asm.zig\n"
#~ "    // Return to caller of asmVmEntry()\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov $0, %%rax\n"
#~ "        \\\\ret\n"
#~ "    );\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn handleExit(self: *Self, exit_info: vmx.ExitInfo) VmxError!void {\n"
#~ "    switch (exit_info.basic_reason) {\n"
#~ "        .hlt => {\n"
#~ "            try self.stepNextInst();\n"
#~ "            log.debug(\"HLT\", .{});\n"
#~ "        },\n"
#~ "        else => {\n"
#~ "            log.err(\"Unhandled VM-exit: reason={?}\", .{exit_info."
#~ "basic_reason});\n"
#~ "            self.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn stepNextInst(_: *Self) VmxError!void {\n"
#~ "    const rip = try vmread(vmcs.guest.rip);\n"
#~ "    try vmwrite(vmcs.guest.rip, rip + try vmread(vmcs.ro."
#~ "exit_inst_len));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn handleExit(self: *Self, exit_info: vmx.ExitInfo) VmxError!void {\n"
#~ "    switch (exit_info.basic_reason) {\n"
#~ "        .hlt => {\n"
#~ "            try self.stepNextInst();\n"
#~ "            log.debug(\"HLT\", .{});\n"
#~ "        },\n"
#~ "        else => {\n"
#~ "            log.err(\"Unhandled VM-exit: reason={?}\", .{exit_info."
#~ "basic_reason});\n"
#~ "            self.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn stepNextInst(_: *Self) VmxError!void {\n"
#~ "    const rip = try vmread(vmcs.guest.rip);\n"
#~ "    try vmwrite(vmcs.guest.rip, rip + try vmread(vmcs.ro."
#~ "exit_inst_len));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "let vmam = @import(\"asm.zig\");\n"
#~ "\n"
#~ "fn setupHostState(_: *Vcpu) VmxError!void {\n"
#~ "    ...\n"
#~ "    try vmwrite(vmcs.host.rip, &vmam.asmVmExit);\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "let vmam = @import(\"asm.zig\");\n"
#~ "\n"
#~ "fn setupHostState(_: *Vcpu) VmxError!void {\n"
#~ "    ...\n"
#~ "    try vmwrite(vmcs.host.rip, &vmam.asmVmExit);\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/ept.zig\n"
#~ "fn EntryBase(table_level: TableLevel) type {\n"
#~ "    return packed struct(u64) {\n"
#~ "        const Self = @This();\n"
#~ "        const level = table_level;\n"
#~ "        const LowerType = switch (level) {\n"
#~ "            .lv4 => Lv3Entry,\n"
#~ "            .lv3 => Lv2Entry,\n"
#~ "            .lv2 => Lv1Entry,\n"
#~ "            .lv1 => struct {},\n"
#~ "        };\n"
#~ "\n"
#~ "        /// Whether reads are allowed.\n"
#~ "        read: bool = true,\n"
#~ "        /// Whether writes are allowed.\n"
#~ "        write: bool = true,\n"
#~ "        /// If \"mode-based execute control for EPT\" is 0, execute "
#~ "access.\n"
#~ "        /// If that field is 1, execute access for supervisor-mode linear "
#~ "address.\n"
#~ "        exec_super: bool = true,\n"
#~ "        /// EPT memory type.\n"
#~ "        /// ReservedZ when the entry maps a page.\n"
#~ "        type: MemoryType = .uncacheable,\n"
#~ "        /// Ignore PAT memory type.\n"
#~ "        ignore_pat: bool = false,\n"
#~ "        /// If true, this entry maps memory. Otherwise, this references a "
#~ "page table.\n"
#~ "        map_memory: bool,\n"
#~ "        /// If EPTP[6] is 1, accessed flag. Otherwise, ignored.\n"
#~ "        accessed: bool = false,\n"
#~ "        // If EPTP[6] is 1, dirty flag. Otherwise, ignored.\n"
#~ "        dirty: bool = false,\n"
#~ "        /// Execute access for user-mode linear address.\n"
#~ "        exec_user: bool = true,\n"
#~ "        /// Ignored\n"
#~ "        _ignored2: u1 = 0,\n"
#~ "        /// 4KB aligned physical address of the mapped page or page "
#~ "table.\n"
#~ "        phys: u52,\n"
#~ "\n"
#~ "        /// Return true if the entry is present.\n"
#~ "        pub fn present(self: Self) bool {\n"
#~ "            return self.read or self.write or self.exec_super;\n"
#~ "        }\n"
#~ "\n"
#~ "        /// Get the physical address of the page or page table that this "
#~ "entry references or maps.\n"
#~ "        pub inline fn address(self: Self) Phys {\n"
#~ "            return @as(u64, @intCast(self.phys)) << page_shift_4k;\n"
#~ "        }\n"
#~ "\n"
#~ "        /// Get a new page table entry that references a page table.\n"
#~ "        pub fn newMapTable(table: []LowerType) Self {\n"
#~ "            if (level == .lv1) @compileError(\"Lv1 EPT entry cannot "
#~ "reference a page table\");\n"
#~ "            return Self{\n"
#~ "                .map_memory = false,\n"
#~ "                .type = .uncacheable,\n"
#~ "                .phys = @truncate(virt2phys(table.ptr) >> "
#~ "page_shift_4k),\n"
#~ "            };\n"
#~ "        }\n"
#~ "\n"
#~ "        /// Get a new page table entry that maps a page.\n"
#~ "        pub fn newMapPage(phys: Phys) Self {\n"
#~ "            if (level == .lv4) @compileError(\"Lv4 EPT entry cannot map a "
#~ "page\");\n"
#~ "            return Self{\n"
#~ "                .read = true,\n"
#~ "                .write = true,\n"
#~ "                .exec_super = true,\n"
#~ "                .exec_user = true,\n"
#~ "                .map_memory = true,\n"
#~ "                .type = @enumFromInt(0),\n"
#~ "                .phys = @truncate(virt2phys(phys) >> page_shift_4k),\n"
#~ "            };\n"
#~ "        }\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "const Lv4Entry = EntryBase(.lv4);\n"
#~ "const Lv3Entry = EntryBase(.lv3);\n"
#~ "const Lv2Entry = EntryBase(.lv2);\n"
#~ "const Lv1Entry = EntryBase(.lv1);\n"
#~ "\n"
#~ "const MemoryType = enum(u3) {\n"
#~ "    uncacheable = 0,\n"
#~ "    write_back = 6,\n"
#~ "};\n"
#~ "\n"
#~ "const TableLevel = enum {\n"
#~ "    lv4,\n"
#~ "    lv3,\n"
#~ "    lv2,\n"
#~ "    lv1,\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/ept.zig\n"
#~ "fn EntryBase(table_level: TableLevel) type {\n"
#~ "    return packed struct(u64) {\n"
#~ "        const Self = @This();\n"
#~ "        const level = table_level;\n"
#~ "        const LowerType = switch (level) {\n"
#~ "            .lv4 => Lv3Entry,\n"
#~ "            .lv3 => Lv2Entry,\n"
#~ "            .lv2 => Lv1Entry,\n"
#~ "            .lv1 => struct {},\n"
#~ "        };\n"
#~ "\n"
#~ "        /// Whether reads are allowed.\n"
#~ "        read: bool = true,\n"
#~ "        /// Whether writes are allowed.\n"
#~ "        write: bool = true,\n"
#~ "        /// If \"mode-based execute control for EPT\" is 0, execute "
#~ "access.\n"
#~ "        /// If that field is 1, execute access for supervisor-mode linear "
#~ "address.\n"
#~ "        exec_super: bool = true,\n"
#~ "        /// EPT memory type.\n"
#~ "        /// ReservedZ when the entry maps a page.\n"
#~ "        type: MemoryType = .uncacheable,\n"
#~ "        /// Ignore PAT memory type.\n"
#~ "        ignore_pat: bool = false,\n"
#~ "        /// If true, this entry maps memory. Otherwise, this references a "
#~ "page table.\n"
#~ "        map_memory: bool,\n"
#~ "        /// If EPTP[6] is 1, accessed flag. Otherwise, ignored.\n"
#~ "        accessed: bool = false,\n"
#~ "        // If EPTP[6] is 1, dirty flag. Otherwise, ignored.\n"
#~ "        dirty: bool = false,\n"
#~ "        /// Execute access for user-mode linear address.\n"
#~ "        exec_user: bool = true,\n"
#~ "        /// Ignored\n"
#~ "        _ignored2: u1 = 0,\n"
#~ "        /// 4KB aligned physical address of the mapped page or page "
#~ "table.\n"
#~ "        phys: u52,\n"
#~ "\n"
#~ "        /// Return true if the entry is present.\n"
#~ "        pub fn present(self: Self) bool {\n"
#~ "            return self.read or self.write or self.exec_super;\n"
#~ "        }\n"
#~ "\n"
#~ "        /// Get the physical address of the page or page table that this "
#~ "entry references or maps.\n"
#~ "        pub inline fn address(self: Self) Phys {\n"
#~ "            return @as(u64, @intCast(self.phys)) << page_shift_4k;\n"
#~ "        }\n"
#~ "\n"
#~ "        /// Get a new page table entry that references a page table.\n"
#~ "        pub fn newMapTable(table: []LowerType) Self {\n"
#~ "            if (level == .lv1) @compileError(\"Lv1 EPT entry cannot "
#~ "reference a page table\");\n"
#~ "            return Self{\n"
#~ "                .map_memory = false,\n"
#~ "                .type = .uncacheable,\n"
#~ "                .phys = @truncate(virt2phys(table.ptr) >> "
#~ "page_shift_4k),\n"
#~ "            };\n"
#~ "        }\n"
#~ "\n"
#~ "        /// Get a new page table entry that maps a page.\n"
#~ "        pub fn newMapPage(phys: Phys) Self {\n"
#~ "            if (level == .lv4) @compileError(\"Lv4 EPT entry cannot map a "
#~ "page\");\n"
#~ "            return Self{\n"
#~ "                .read = true,\n"
#~ "                .write = true,\n"
#~ "                .exec_super = true,\n"
#~ "                .exec_user = true,\n"
#~ "                .map_memory = true,\n"
#~ "                .type = @enumFromInt(0),\n"
#~ "                .phys = @truncate(virt2phys(phys) >> page_shift_4k),\n"
#~ "            };\n"
#~ "        }\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "const Lv4Entry = EntryBase(.lv4);\n"
#~ "const Lv3Entry = EntryBase(.lv3);\n"
#~ "const Lv2Entry = EntryBase(.lv2);\n"
#~ "const Lv1Entry = EntryBase(.lv1);\n"
#~ "\n"
#~ "const MemoryType = enum(u3) {\n"
#~ "    uncacheable = 0,\n"
#~ "    write_back = 6,\n"
#~ "};\n"
#~ "\n"
#~ "const TableLevel = enum {\n"
#~ "    lv4,\n"
#~ "    lv3,\n"
#~ "    lv2,\n"
#~ "    lv1,\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/ept.zig\n"
#~ "pub const Eptp = packed struct(u64) {\n"
#~ "    /// Memory type.\n"
#~ "    type: MemoryType = .write_back,\n"
#~ "    /// EPT page-walk length.\n"
#~ "    level: PageLevel = .four,\n"
#~ "    /// Enable dirty and accessed flags for EPT.\n"
#~ "    enable_ad: bool = true,\n"
#~ "    /// Enable enforcement of access rights for supervisor shadow-stack "
#~ "pages.\n"
#~ "    enable_ar: bool = false,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved1: u4 = 0,\n"
#~ "    /// 4KB aligned address of the Level-4 EPT table.\n"
#~ "    phys: u52,\n"
#~ "\n"
#~ "    pub fn new(lv4tbl: []Lv4Entry) Eptp {\n"
#~ "        return Eptp{\n"
#~ "            .phys = @truncate(virt2phys(lv4tbl.ptr) >> page_shift_4k),\n"
#~ "        };\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the host virtual address of the Level-4 EPT table.\n"
#~ "    pub fn getLv4(self: *Eptp) []Lv4Entry {\n"
#~ "        const virt: [*]Lv4Entry = @ptrFromInt(phys2virt(@as(u64, "
#~ "@intCast(self.phys)) << page_shift_4k));\n"
#~ "        return virt[0..num_table_entries];\n"
#~ "    }\n"
#~ "\n"
#~ "    const PageLevel = enum(u3) {\n"
#~ "        four = 3,\n"
#~ "        five = 4,\n"
#~ "    };\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/ept.zig\n"
#~ "pub const Eptp = packed struct(u64) {\n"
#~ "    /// Memory type.\n"
#~ "    type: MemoryType = .write_back,\n"
#~ "    /// EPT page-walk length.\n"
#~ "    level: PageLevel = .four,\n"
#~ "    /// Enable dirty and accessed flags for EPT.\n"
#~ "    enable_ad: bool = true,\n"
#~ "    /// Enable enforcement of access rights for supervisor shadow-stack "
#~ "pages.\n"
#~ "    enable_ar: bool = false,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved1: u4 = 0,\n"
#~ "    /// 4KB aligned address of the Level-4 EPT table.\n"
#~ "    phys: u52,\n"
#~ "\n"
#~ "    pub fn new(lv4tbl: []Lv4Entry) Eptp {\n"
#~ "        return Eptp{\n"
#~ "            .phys = @truncate(virt2phys(lv4tbl.ptr) >> page_shift_4k),\n"
#~ "        };\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the host virtual address of the Level-4 EPT table.\n"
#~ "    pub fn getLv4(self: *Eptp) []Lv4Entry {\n"
#~ "        const virt: [*]Lv4Entry = @ptrFromInt(phys2virt(@as(u64, "
#~ "@intCast(self.phys)) << page_shift_4k));\n"
#~ "        return virt[0..num_table_entries];\n"
#~ "    }\n"
#~ "\n"
#~ "    const PageLevel = enum(u3) {\n"
#~ "        four = 3,\n"
#~ "        five = 4,\n"
#~ "    };\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/vmx.zig\n"
#~ "const guest_memory_size = 100 * mem.mib;\n"
#~ "\n"
#~ "pub const Vm = struct {\n"
#~ "    guest_mem: []u8 = undefined,\n"
#~ "    ...\n"
#~ "    pub fn setupGuestMemory(\n"
#~ "        self: *Self,\n"
#~ "        allocator: Allocator,\n"
#~ "        page_allocator: *PageAllocator,\n"
#~ "    ) Error!void {\n"
#~ "        // Allocate guest memory.\n"
#~ "        self.guest_mem = page_allocator.allocPages(\n"
#~ "            guest_memory_size / mem.page_size_4k,\n"
#~ "            mem.page_size_2mb, // This alignment is required because EPT "
#~ "uses only 2MiB pages.\n"
#~ "        ) orelse return Error.OutOfMemory;\n"
#~ "\n"
#~ "        // Create simple EPT mapping.\n"
#~ "        const eptp = try impl.mapGuest(self.guest_mem, allocator);\n"
#~ "        try self.vcpu.setEptp(eptp, self.guest_mem.ptr);\n"
#~ "        log.info(\"Guest memory is mapped: HVA=0x{X:0>16} "
#~ "(size=0x{X})\", .{ @intFromPtr(self.guest_mem.ptr), self.guest_mem."
#~ "len });\n"
#~ "    }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/vmx.zig\n"
#~ "const guest_memory_size = 100 * mem.mib;\n"
#~ "\n"
#~ "pub const Vm = struct {\n"
#~ "    guest_mem: []u8 = undefined,\n"
#~ "    ...\n"
#~ "    pub fn setupGuestMemory(\n"
#~ "        self: *Self,\n"
#~ "        allocator: Allocator,\n"
#~ "        page_allocator: *PageAllocator,\n"
#~ "    ) Error!void {\n"
#~ "        // Allocate guest memory.\n"
#~ "        self.guest_mem = page_allocator.allocPages(\n"
#~ "            guest_memory_size / mem.page_size_4k,\n"
#~ "            mem.page_size_2mb, // This alignment is required because EPT "
#~ "uses only 2MiB pages.\n"
#~ "        ) orelse return Error.OutOfMemory;\n"
#~ "\n"
#~ "        // Create simple EPT mapping.\n"
#~ "        const eptp = try impl.mapGuest(self.guest_mem, allocator);\n"
#~ "        try self.vcpu.setEptp(eptp, self.guest_mem.ptr);\n"
#~ "        log.info(\"Guest memory is mapped: HVA=0x{X:0>16} "
#~ "(size=0x{X})\", .{ @intFromPtr(self.guest_mem.ptr), self.guest_mem."
#~ "len });\n"
#~ "    }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/ept.zig\n"
#~ "pub fn initEpt(\n"
#~ "    /// Guest physical address to map.\n"
#~ "    guest_start: Phys,\n"
#~ "    /// Host physical address to map.\n"
#~ "    host_start: Phys,\n"
#~ "    /// Size in bytes of the memory region to map.\n"
#~ "    size: usize,\n"
#~ "    /// Page allocator.\n"
#~ "    allocator: Allocator,\n"
#~ ") Error!Eptp {\n"
#~ "    const lv4tbl = try initTable(Lv4Entry, allocator);\n"
#~ "    log.debug(\"EPT Level4 Table @ {X:0>16}\", .{@intFromPtr(lv4tbl."
#~ "ptr)});\n"
#~ "\n"
#~ "    for (0..size / page_size_2mb) |i| {\n"
#~ "        try map2m(\n"
#~ "            guest_start + page_size_2mb * i,\n"
#~ "            host_start + page_size_2mb * i,\n"
#~ "            lv4tbl,\n"
#~ "            allocator,\n"
#~ "        );\n"
#~ "    }\n"
#~ "\n"
#~ "    return Eptp.new(lv4tbl);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/ept.zig\n"
#~ "pub fn initEpt(\n"
#~ "    /// Guest physical address to map.\n"
#~ "    guest_start: Phys,\n"
#~ "    /// Host physical address to map.\n"
#~ "    host_start: Phys,\n"
#~ "    /// Size in bytes of the memory region to map.\n"
#~ "    size: usize,\n"
#~ "    /// Page allocator.\n"
#~ "    allocator: Allocator,\n"
#~ ") Error!Eptp {\n"
#~ "    const lv4tbl = try initTable(Lv4Entry, allocator);\n"
#~ "    log.debug(\"EPT Level4 Table @ {X:0>16}\", .{@intFromPtr(lv4tbl."
#~ "ptr)});\n"
#~ "\n"
#~ "    for (0..size / page_size_2mb) |i| {\n"
#~ "        try map2m(\n"
#~ "            guest_start + page_size_2mb * i,\n"
#~ "            host_start + page_size_2mb * i,\n"
#~ "            lv4tbl,\n"
#~ "            allocator,\n"
#~ "        );\n"
#~ "    }\n"
#~ "\n"
#~ "    return Eptp.new(lv4tbl);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "fn kernelMain(boot_info: surtr.BootInfo) !void {\n"
#~ "    ...\n"
#~ "    try vm.setupGuestMemory(general_allocator, &mem."
#~ "page_allocator_instance);\n"
#~ "    log.info(\"Setup guest memory.\", .{});\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "fn kernelMain(boot_info: surtr.BootInfo) !void {\n"
#~ "    ...\n"
#~ "    try vm.setupGuestMemory(general_allocator, &mem."
#~ "page_allocator_instance);\n"
#~ "    log.info(\"Setup guest memory.\", .{});\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn setupGuestState(_: *Vcpu) VmxError!void {\n"
#~ "    ...\n"
#~ "    var cr0 = std.mem.zeroes(am.Cr0);\n"
#~ "    cr0.pe = true;  // Protected-mode\n"
#~ "    cr0.ne = true;  // Numeric error\n"
#~ "    cr0.pg = false; // Paging\n"
#~ "    try vmwrite(vmcs.guest.cr0, cr0);\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn setupGuestState(_: *Vcpu) VmxError!void {\n"
#~ "    ...\n"
#~ "    var cr0 = std.mem.zeroes(am.Cr0);\n"
#~ "    cr0.pe = true;  // Protected-mode\n"
#~ "    cr0.ne = true;  // Numeric error\n"
#~ "    cr0.pg = false; // Paging\n"
#~ "    try vmwrite(vmcs.guest.cr0, cr0);\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "/// CR0 register.\n"
#~ "pub const Cr0 = packed struct(u64) {\n"
#~ "    /// Protected mode enable.\n"
#~ "    pe: bool,\n"
#~ "    /// Monitor co-processor.\n"
#~ "    mp: bool,\n"
#~ "    /// Emulation.\n"
#~ "    em: bool,\n"
#~ "    /// Task switched.\n"
#~ "    ts: bool,\n"
#~ "    /// Extension type.\n"
#~ "    et: bool,\n"
#~ "    /// Numeric error.\n"
#~ "    ne: bool,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved1: u10 = 0,\n"
#~ "    /// Write protect.\n"
#~ "    wp: bool,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved2: u1 = 0,\n"
#~ "    /// Alignment mask.\n"
#~ "    am: bool,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved3: u10 = 0,\n"
#~ "    /// Not-Write Through.\n"
#~ "    nw: bool,\n"
#~ "    /// Cache disable.\n"
#~ "    cd: bool,\n"
#~ "    /// Paging.\n"
#~ "    pg: bool,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved4: u32 = 0,\n"
#~ "};\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "/// CR0 register.\n"
#~ "pub const Cr0 = packed struct(u64) {\n"
#~ "    /// Protected mode enable.\n"
#~ "    pe: bool,\n"
#~ "    /// Monitor co-processor.\n"
#~ "    mp: bool,\n"
#~ "    /// Emulation.\n"
#~ "    em: bool,\n"
#~ "    /// Task switched.\n"
#~ "    ts: bool,\n"
#~ "    /// Extension type.\n"
#~ "    et: bool,\n"
#~ "    /// Numeric error.\n"
#~ "    ne: bool,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved1: u10 = 0,\n"
#~ "    /// Write protect.\n"
#~ "    wp: bool,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved2: u1 = 0,\n"
#~ "    /// Alignment mask.\n"
#~ "    am: bool,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved3: u10 = 0,\n"
#~ "    /// Not-Write Through.\n"
#~ "    nw: bool,\n"
#~ "    /// Cache disable.\n"
#~ "    cd: bool,\n"
#~ "    /// Paging.\n"
#~ "    pg: bool,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved4: u32 = 0,\n"
#~ "};\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "const guest = openFile(root_dir, \"bzImage\") catch return .Aborted;\n"
#~ "\n"
#~ "const guest_info_buffer_size: usize = @sizeOf(uefi.FileInfo) + 0x100;\n"
#~ "var guest_info_actual_size = guest_info_buffer_size;\n"
#~ "var guest_info_buffer: [guest_info_buffer_size]u8 align(@alignOf(uefi."
#~ "FileInfo)) = undefined;\n"
#~ "\n"
#~ "status = guest.getInfo(&uefi.FileInfo.guid, &guest_info_actual_size, "
#~ "&guest_info_buffer);\n"
#~ "if (status != .Success) return status;\n"
#~ "const guest_info: *const uefi.FileInfo = "
#~ "@alignCast(@ptrCast(&guest_info_buffer));\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "const guest = openFile(root_dir, \"bzImage\") catch return .Aborted;\n"
#~ "\n"
#~ "const guest_info_buffer_size: usize = @sizeOf(uefi.FileInfo) + 0x100;\n"
#~ "var guest_info_actual_size = guest_info_buffer_size;\n"
#~ "var guest_info_buffer: [guest_info_buffer_size]u8 align(@alignOf(uefi."
#~ "FileInfo)) = undefined;\n"
#~ "\n"
#~ "status = guest.getInfo(&uefi.FileInfo.guid, &guest_info_actual_size, "
#~ "&guest_info_buffer);\n"
#~ "if (status != .Success) return status;\n"
#~ "const guest_info: *const uefi.FileInfo = "
#~ "@alignCast(@ptrCast(&guest_info_buffer));\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "status = guest.read(&guest_size, @ptrFromInt(guest_start));\n"
#~ "if (status != .Success) return status;\n"
#~ "log.info(\"Loaded guest kernel image @ 0x{X:0>16} ~ 0x{X:0>16}\", ."
#~ "{ guest_start, guest_start + guest_size });\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "status = guest.read(&guest_size, @ptrFromInt(guest_start));\n"
#~ "if (status != .Success) return status;\n"
#~ "log.info(\"Loaded guest kernel image @ 0x{X:0>16} ~ 0x{X:0>16}\", ."
#~ "{ guest_start, guest_start + guest_size });\n"
#~ "```"

#~ msgid ""
#~ "```surtr/defs.zig\n"
#~ "pub const BootInfo = extern struct {\n"
#~ "    ...\n"
#~ "    guest_info: GuestInfo,\n"
#~ "};\n"
#~ "\n"
#~ "pub const GuestInfo = extern struct {\n"
#~ "    /// Physical address the guest image is loaded.\n"
#~ "    guest_image: [*]u8,\n"
#~ "    /// Size in bytes of the guest image.\n"
#~ "    guest_size: usize,\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/defs.zig\n"
#~ "pub const BootInfo = extern struct {\n"
#~ "    ...\n"
#~ "    guest_info: GuestInfo,\n"
#~ "};\n"
#~ "\n"
#~ "pub const GuestInfo = extern struct {\n"
#~ "    /// Physical address the guest image is loaded.\n"
#~ "    guest_image: [*]u8,\n"
#~ "    /// Size in bytes of the guest image.\n"
#~ "    guest_size: usize,\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/linux.zig\n"
#~ "pub const BootParams = extern struct {\n"
#~ "    /// Maximum number of entries in the E820 map.\n"
#~ "    const e820max = 128;\n"
#~ "\n"
#~ "    _screen_info: [0x40]u8 align(1),\n"
#~ "    _apm_bios_info: [0x14]u8 align(1),\n"
#~ "    _pad2: [4]u8 align(1),\n"
#~ "    tboot_addr: u64 align(1),\n"
#~ "    ist_info: [0x10]u8 align(1),\n"
#~ "    _pad3: [0x10]u8 align(1),\n"
#~ "    hd0_info: [0x10]u8 align(1),\n"
#~ "    hd1_info: [0x10]u8 align(1),\n"
#~ "    _sys_desc_table: [0x10]u8 align(1),\n"
#~ "    _olpc_ofw_header: [0x10]u8 align(1),\n"
#~ "    _pad4: [0x80]u8 align(1),\n"
#~ "    _edid_info: [0x80]u8 align(1),\n"
#~ "    _efi_info: [0x20]u8 align(1),\n"
#~ "    alt_mem_k: u32 align(1),\n"
#~ "    scratch: u32 align(1),\n"
#~ "    /// Number of entries in the E820 map.\n"
#~ "    e820_entries: u8 align(1),\n"
#~ "    eddbuf_entries: u8 align(1),\n"
#~ "    edd_mbr_sig_buf_entries: u8 align(1),\n"
#~ "    kbd_status: u8 align(1),\n"
#~ "    _pad6: [5]u8 align(1),\n"
#~ "    /// Setup header.\n"
#~ "    hdr: SetupHeader,\n"
#~ "    _pad7: [0x290 - SetupHeader.header_offset - @sizeOf(SetupHeader)]u8 "
#~ "align(1),\n"
#~ "    _edd_mbr_sig_buffer: [0x10]u32 align(1),\n"
#~ "    /// System memory map that can be retrieved by INT 15, E820h.\n"
#~ "    e820_map: [e820max]E820Entry align(1),\n"
#~ "    _unimplemented: [0x330]u8 align(1),\n"
#~ "\n"
#~ "    /// Instantiate boot params from bzImage.\n"
#~ "    pub fn from(bytes: []u8) @This() {\n"
#~ "        return std.mem.bytesToValue(\n"
#~ "            @This(),\n"
#~ "            bytes[0..@sizeOf(@This())],\n"
#~ "        );\n"
#~ "    }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/linux.zig\n"
#~ "pub const BootParams = extern struct {\n"
#~ "    /// Maximum number of entries in the E820 map.\n"
#~ "    const e820max = 128;\n"
#~ "\n"
#~ "    _screen_info: [0x40]u8 align(1),\n"
#~ "    _apm_bios_info: [0x14]u8 align(1),\n"
#~ "    _pad2: [4]u8 align(1),\n"
#~ "    tboot_addr: u64 align(1),\n"
#~ "    ist_info: [0x10]u8 align(1),\n"
#~ "    _pad3: [0x10]u8 align(1),\n"
#~ "    hd0_info: [0x10]u8 align(1),\n"
#~ "    hd1_info: [0x10]u8 align(1),\n"
#~ "    _sys_desc_table: [0x10]u8 align(1),\n"
#~ "    _olpc_ofw_header: [0x10]u8 align(1),\n"
#~ "    _pad4: [0x80]u8 align(1),\n"
#~ "    _edid_info: [0x80]u8 align(1),\n"
#~ "    _efi_info: [0x20]u8 align(1),\n"
#~ "    alt_mem_k: u32 align(1),\n"
#~ "    scratch: u32 align(1),\n"
#~ "    /// Number of entries in the E820 map.\n"
#~ "    e820_entries: u8 align(1),\n"
#~ "    eddbuf_entries: u8 align(1),\n"
#~ "    edd_mbr_sig_buf_entries: u8 align(1),\n"
#~ "    kbd_status: u8 align(1),\n"
#~ "    _pad6: [5]u8 align(1),\n"
#~ "    /// Setup header.\n"
#~ "    hdr: SetupHeader,\n"
#~ "    _pad7: [0x290 - SetupHeader.header_offset - @sizeOf(SetupHeader)]u8 "
#~ "align(1),\n"
#~ "    _edd_mbr_sig_buffer: [0x10]u32 align(1),\n"
#~ "    /// System memory map that can be retrieved by INT 15, E820h.\n"
#~ "    e820_map: [e820max]E820Entry align(1),\n"
#~ "    _unimplemented: [0x330]u8 align(1),\n"
#~ "\n"
#~ "    /// Instantiate boot params from bzImage.\n"
#~ "    pub fn from(bytes: []u8) @This() {\n"
#~ "        return std.mem.bytesToValue(\n"
#~ "            @This(),\n"
#~ "            bytes[0..@sizeOf(@This())],\n"
#~ "        );\n"
#~ "    }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/linux.zig\n"
#~ "pub const SetupHeader = extern struct {\n"
#~ "    /// RO. The number of setup sectors.\n"
#~ "    setup_sects: u8 align(1),\n"
#~ "    root_flags: u16 align(1),\n"
#~ "    syssize: u32 align(1),\n"
#~ "    ram_size: u16 align(1),\n"
#~ "    vid_mode: u16 align(1),\n"
#~ "    root_dev: u16 align(1),\n"
#~ "    boot_flag: u16 align(1),\n"
#~ "    jump: u16 align(1),\n"
#~ "    header: u32 align(1),\n"
#~ "    /// RO. Boot protocol version supported.\n"
#~ "    version: u16 align(1),\n"
#~ "    realmode_switch: u32 align(1),\n"
#~ "    start_sys_seg: u16 align(1),\n"
#~ "    kernel_version: u16 align(1),\n"
#~ "    /// M. The type of loader. Specify 0xFF if no ID is assigned.\n"
#~ "    type_of_loader: u8 align(1),\n"
#~ "    /// M. Bitmask.\n"
#~ "    loadflags: LoadflagBitfield align(1),\n"
#~ "    setup_move_size: u16 align(1),\n"
#~ "    code32_start: u32 align(1),\n"
#~ "    /// M. The 32-bit linear address of initial ramdisk or ramfs.\n"
#~ "    /// Specify 0 if there is no ramdisk or ramfs.\n"
#~ "    ramdisk_image: u32 align(1),\n"
#~ "    /// M. The size of the initial ramdisk or ramfs.\n"
#~ "    ramdisk_size: u32 align(1),\n"
#~ "    bootsect_kludge: u32 align(1),\n"
#~ "    /// W. Offset of the end of the setup/heap minus 0x200.\n"
#~ "    heap_end_ptr: u16 align(1),\n"
#~ "    /// W(opt). Extension of the loader ID.\n"
#~ "    ext_loader_ver: u8 align(1),\n"
#~ "    ext_loader_type: u8 align(1),\n"
#~ "    /// W. The 32-bit linear address of the kernel command line.\n"
#~ "    cmd_line_ptr: u32 align(1),\n"
#~ "    /// R. Highest address that can be used for initrd.\n"
#~ "    initrd_addr_max: u32 align(1),\n"
#~ "    kernel_alignment: u32 align(1),\n"
#~ "    relocatable_kernel: u8 align(1),\n"
#~ "    min_alignment: u8 align(1),\n"
#~ "    xloadflags: u16 align(1),\n"
#~ "    /// R. Maximum size of the cmdline.\n"
#~ "    cmdline_size: u32 align(1),\n"
#~ "    hardware_subarch: u32 align(1),\n"
#~ "    hardware_subarch_data: u64 align(1),\n"
#~ "    payload_offset: u32 align(1),\n"
#~ "    payload_length: u32 align(1),\n"
#~ "    setup_data: u64 align(1),\n"
#~ "    pref_address: u64 align(1),\n"
#~ "    init_size: u32 align(1),\n"
#~ "    handover_offset: u32 align(1),\n"
#~ "    kernel_info_offset: u32 align(1),\n"
#~ "\n"
#~ "    /// Bitfield for loadflags.\n"
#~ "    const LoadflagBitfield = packed struct(u8) {\n"
#~ "        /// If true, the protected-mode code is loaded at 0x100000.\n"
#~ "        loaded_high: bool = false,\n"
#~ "        /// If true, KASLR enabled.\n"
#~ "        kaslr_flag: bool = false,\n"
#~ "        /// Unused.\n"
#~ "        _unused: u3 = 0,\n"
#~ "        /// If false, print early messages.\n"
#~ "        quiet_flag: bool = false,\n"
#~ "        /// If false, reload the segment registers in the 32 bit entry "
#~ "point.\n"
#~ "        keep_segments: bool = false,\n"
#~ "        /// Set true to indicate that the value entered in the "
#~ "`heap_end_ptr` is valid.\n"
#~ "        can_use_heap: bool = false,\n"
#~ "\n"
#~ "        /// Convert to u8.\n"
#~ "        pub fn to_u8(self: @This()) u8 {\n"
#~ "            return @bitCast(self);\n"
#~ "        }\n"
#~ "    };\n"
#~ "\n"
#~ "    /// The offset where the header starts in the bzImage.\n"
#~ "    pub const header_offset = 0x1F1;\n"
#~ "\n"
#~ "    /// Instantiate a header from bzImage.\n"
#~ "    pub fn from(bytes: []u8) @This() {\n"
#~ "        var hdr = std.mem.bytesToValue(\n"
#~ "            @This(),\n"
#~ "            bytes[header_offset .. header_offset + @sizeOf(@This())],\n"
#~ "        );\n"
#~ "        if (hdr.setup_sects == 0) {\n"
#~ "            hdr.setup_sects = 4;\n"
#~ "        }\n"
#~ "\n"
#~ "        return hdr;\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the offset of the protected-mode kernel code.\n"
#~ "    /// Real-mode code consists of the boot sector (1 sector == 512 "
#~ "bytes)\n"
#~ "    /// plus the setup code (`setup_sects` sectors).\n"
#~ "    pub fn getProtectedCodeOffset(self: @This()) usize {\n"
#~ "        return (@as(usize, self.setup_sects) + 1) * 512;\n"
#~ "    }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/linux.zig\n"
#~ "pub const SetupHeader = extern struct {\n"
#~ "    /// RO. The number of setup sectors.\n"
#~ "    setup_sects: u8 align(1),\n"
#~ "    root_flags: u16 align(1),\n"
#~ "    syssize: u32 align(1),\n"
#~ "    ram_size: u16 align(1),\n"
#~ "    vid_mode: u16 align(1),\n"
#~ "    root_dev: u16 align(1),\n"
#~ "    boot_flag: u16 align(1),\n"
#~ "    jump: u16 align(1),\n"
#~ "    header: u32 align(1),\n"
#~ "    /// RO. Boot protocol version supported.\n"
#~ "    version: u16 align(1),\n"
#~ "    realmode_switch: u32 align(1),\n"
#~ "    start_sys_seg: u16 align(1),\n"
#~ "    kernel_version: u16 align(1),\n"
#~ "    /// M. The type of loader. Specify 0xFF if no ID is assigned.\n"
#~ "    type_of_loader: u8 align(1),\n"
#~ "    /// M. Bitmask.\n"
#~ "    loadflags: LoadflagBitfield align(1),\n"
#~ "    setup_move_size: u16 align(1),\n"
#~ "    code32_start: u32 align(1),\n"
#~ "    /// M. The 32-bit linear address of initial ramdisk or ramfs.\n"
#~ "    /// Specify 0 if there is no ramdisk or ramfs.\n"
#~ "    ramdisk_image: u32 align(1),\n"
#~ "    /// M. The size of the initial ramdisk or ramfs.\n"
#~ "    ramdisk_size: u32 align(1),\n"
#~ "    bootsect_kludge: u32 align(1),\n"
#~ "    /// W. Offset of the end of the setup/heap minus 0x200.\n"
#~ "    heap_end_ptr: u16 align(1),\n"
#~ "    /// W(opt). Extension of the loader ID.\n"
#~ "    ext_loader_ver: u8 align(1),\n"
#~ "    ext_loader_type: u8 align(1),\n"
#~ "    /// W. The 32-bit linear address of the kernel command line.\n"
#~ "    cmd_line_ptr: u32 align(1),\n"
#~ "    /// R. Highest address that can be used for initrd.\n"
#~ "    initrd_addr_max: u32 align(1),\n"
#~ "    kernel_alignment: u32 align(1),\n"
#~ "    relocatable_kernel: u8 align(1),\n"
#~ "    min_alignment: u8 align(1),\n"
#~ "    xloadflags: u16 align(1),\n"
#~ "    /// R. Maximum size of the cmdline.\n"
#~ "    cmdline_size: u32 align(1),\n"
#~ "    hardware_subarch: u32 align(1),\n"
#~ "    hardware_subarch_data: u64 align(1),\n"
#~ "    payload_offset: u32 align(1),\n"
#~ "    payload_length: u32 align(1),\n"
#~ "    setup_data: u64 align(1),\n"
#~ "    pref_address: u64 align(1),\n"
#~ "    init_size: u32 align(1),\n"
#~ "    handover_offset: u32 align(1),\n"
#~ "    kernel_info_offset: u32 align(1),\n"
#~ "\n"
#~ "    /// Bitfield for loadflags.\n"
#~ "    const LoadflagBitfield = packed struct(u8) {\n"
#~ "        /// If true, the protected-mode code is loaded at 0x100000.\n"
#~ "        loaded_high: bool = false,\n"
#~ "        /// If true, KASLR enabled.\n"
#~ "        kaslr_flag: bool = false,\n"
#~ "        /// Unused.\n"
#~ "        _unused: u3 = 0,\n"
#~ "        /// If false, print early messages.\n"
#~ "        quiet_flag: bool = false,\n"
#~ "        /// If false, reload the segment registers in the 32 bit entry "
#~ "point.\n"
#~ "        keep_segments: bool = false,\n"
#~ "        /// Set true to indicate that the value entered in the "
#~ "`heap_end_ptr` is valid.\n"
#~ "        can_use_heap: bool = false,\n"
#~ "\n"
#~ "        /// Convert to u8.\n"
#~ "        pub fn to_u8(self: @This()) u8 {\n"
#~ "            return @bitCast(self);\n"
#~ "        }\n"
#~ "    };\n"
#~ "\n"
#~ "    /// The offset where the header starts in the bzImage.\n"
#~ "    pub const header_offset = 0x1F1;\n"
#~ "\n"
#~ "    /// Instantiate a header from bzImage.\n"
#~ "    pub fn from(bytes: []u8) @This() {\n"
#~ "        var hdr = std.mem.bytesToValue(\n"
#~ "            @This(),\n"
#~ "            bytes[header_offset .. header_offset + @sizeOf(@This())],\n"
#~ "        );\n"
#~ "        if (hdr.setup_sects == 0) {\n"
#~ "            hdr.setup_sects = 4;\n"
#~ "        }\n"
#~ "\n"
#~ "        return hdr;\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the offset of the protected-mode kernel code.\n"
#~ "    /// Real-mode code consists of the boot sector (1 sector == 512 "
#~ "bytes)\n"
#~ "    /// plus the setup code (`setup_sects` sectors).\n"
#~ "    pub fn getProtectedCodeOffset(self: @This()) usize {\n"
#~ "        return (@as(usize, self.setup_sects) + 1) * 512;\n"
#~ "    }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/linux.zig\n"
#~ "pub const E820Entry = extern struct {\n"
#~ "    addr: u64 align(1),\n"
#~ "    size: u64 align(1),\n"
#~ "    type: Type align(1),\n"
#~ "\n"
#~ "    pub const Type = enum(u32) {\n"
#~ "        /// RAM.\n"
#~ "        ram = 1,\n"
#~ "        /// Reserved.\n"
#~ "        reserved = 2,\n"
#~ "        /// ACPI reclaimable memory.\n"
#~ "        acpi = 3,\n"
#~ "        /// ACPI NVS memory.\n"
#~ "        nvs = 4,\n"
#~ "        /// Unusable memory region.\n"
#~ "        unusable = 5,\n"
#~ "    };\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/linux.zig\n"
#~ "pub const E820Entry = extern struct {\n"
#~ "    addr: u64 align(1),\n"
#~ "    size: u64 align(1),\n"
#~ "    type: Type align(1),\n"
#~ "\n"
#~ "    pub const Type = enum(u32) {\n"
#~ "        /// RAM.\n"
#~ "        ram = 1,\n"
#~ "        /// Reserved.\n"
#~ "        reserved = 2,\n"
#~ "        /// ACPI reclaimable memory.\n"
#~ "        acpi = 3,\n"
#~ "        /// ACPI NVS memory.\n"
#~ "        nvs = 4,\n"
#~ "        /// Unusable memory region.\n"
#~ "        unusable = 5,\n"
#~ "    };\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/linux.zig\n"
#~ "pub const layout = struct {\n"
#~ "    /// Where the kernel boot parameters are loaded, known as \"zero "
#~ "page\".\n"
#~ "    /// Must be initialized with zeros.\n"
#~ "    pub const bootparam = 0x0001_0000;\n"
#~ "    /// Where the kernel cmdline is located.\n"
#~ "    pub const cmdline = 0x0002_0000;\n"
#~ "    /// Where the protected-mode kernel code is loaded\n"
#~ "    pub const kernel_base = 0x0010_0000;\n"
#~ "    /// Where the initrd is loaded.\n"
#~ "    pub const initrd = 0x0600_0000;\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/linux.zig\n"
#~ "pub const layout = struct {\n"
#~ "    /// Where the kernel boot parameters are loaded, known as \"zero "
#~ "page\".\n"
#~ "    /// Must be initialized with zeros.\n"
#~ "    pub const bootparam = 0x0001_0000;\n"
#~ "    /// Where the kernel cmdline is located.\n"
#~ "    pub const cmdline = 0x0002_0000;\n"
#~ "    /// Where the protected-mode kernel code is loaded\n"
#~ "    pub const kernel_base = 0x0010_0000;\n"
#~ "    /// Where the initrd is loaded.\n"
#~ "    pub const initrd = 0x0600_0000;\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/vmx.zig\n"
#~ "fn loadKernel(self: *Self, kernel: []u8) Error!void {\n"
#~ "    const guest_mem = self.guest_mem;\n"
#~ "\n"
#~ "    var bp = BootParams.from(kernel);\n"
#~ "    bp.e820_entries = 0;\n"
#~ "\n"
#~ "    // Setup necessary fields\n"
#~ "    bp.hdr.type_of_loader = 0xFF;\n"
#~ "    bp.hdr.ext_loader_ver = 0;\n"
#~ "    bp.hdr.loadflags.loaded_high = true; // load kernel at 0x10_0000\n"
#~ "    bp.hdr.loadflags.can_use_heap = true; // use memory 0..BOOTPARAM as "
#~ "heap\n"
#~ "    bp.hdr.heap_end_ptr = linux.layout.bootparam - 0x200;\n"
#~ "    bp.hdr.loadflags.keep_segments = true; // we set CS/DS/SS/ES to flag "
#~ "segments with a base of 0.\n"
#~ "    bp.hdr.cmd_line_ptr = linux.layout.cmdline;\n"
#~ "    bp.hdr.vid_mode = 0xFFFF; // VGA (normal)\n"
#~ "\n"
#~ "    // Setup E820 map\n"
#~ "    bp.addE820entry(0, linux.layout.kernel_base, .ram);\n"
#~ "    bp.addE820entry(\n"
#~ "        linux.layout.kernel_base,\n"
#~ "        guest_mem.len - linux.layout.kernel_base,\n"
#~ "        .ram,\n"
#~ "    );\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/vmx.zig\n"
#~ "fn loadKernel(self: *Self, kernel: []u8) Error!void {\n"
#~ "    const guest_mem = self.guest_mem;\n"
#~ "\n"
#~ "    var bp = BootParams.from(kernel);\n"
#~ "    bp.e820_entries = 0;\n"
#~ "\n"
#~ "    // Setup necessary fields\n"
#~ "    bp.hdr.type_of_loader = 0xFF;\n"
#~ "    bp.hdr.ext_loader_ver = 0;\n"
#~ "    bp.hdr.loadflags.loaded_high = true; // load kernel at 0x10_0000\n"
#~ "    bp.hdr.loadflags.can_use_heap = true; // use memory 0..BOOTPARAM as "
#~ "heap\n"
#~ "    bp.hdr.heap_end_ptr = linux.layout.bootparam - 0x200;\n"
#~ "    bp.hdr.loadflags.keep_segments = true; // we set CS/DS/SS/ES to flag "
#~ "segments with a base of 0.\n"
#~ "    bp.hdr.cmd_line_ptr = linux.layout.cmdline;\n"
#~ "    bp.hdr.vid_mode = 0xFFFF; // VGA (normal)\n"
#~ "\n"
#~ "    // Setup E820 map\n"
#~ "    bp.addE820entry(0, linux.layout.kernel_base, .ram);\n"
#~ "    bp.addE820entry(\n"
#~ "        linux.layout.kernel_base,\n"
#~ "        guest_mem.len - linux.layout.kernel_base,\n"
#~ "        .ram,\n"
#~ "    );\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/vmx.zig\n"
#~ "    const cmdline_max_size = if (bp.hdr.cmdline_size < 256) bp.hdr."
#~ "cmdline_size else 256;\n"
#~ "    const cmdline = guest_mem[linux.layout.cmdline .. linux.layout."
#~ "cmdline + cmdline_max_size];\n"
#~ "    const cmdline_val = \"console=ttyS0 earlyprintk=serial nokaslr\";\n"
#~ "    @memset(cmdline, 0);\n"
#~ "    @memcpy(cmdline[0..cmdline_val.len], cmdline_val);\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/vmx.zig\n"
#~ "    const cmdline_max_size = if (bp.hdr.cmdline_size < 256) bp.hdr."
#~ "cmdline_size else 256;\n"
#~ "    const cmdline = guest_mem[linux.layout.cmdline .. linux.layout."
#~ "cmdline + cmdline_max_size];\n"
#~ "    const cmdline_val = \"console=ttyS0 earlyprintk=serial nokaslr\";\n"
#~ "    @memset(cmdline, 0);\n"
#~ "    @memcpy(cmdline[0..cmdline_val.len], cmdline_val);\n"
#~ "```"

#~ msgid ""
#~ "```ymir/vmx.zig.diff\n"
#~ "         ) orelse return Error.OutOfMemory;\n"
#~ "\n"
#~ "+        // Load kernel\n"
#~ "+        try self.loadKernel(guest_image);\n"
#~ "+\n"
#~ "         // Create simple EPT mapping.\n"
#~ "         const eptp = try impl.mapGuest(self.guest_mem, allocator);\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/vmx.zig.diff\n"
#~ "         ) orelse return Error.OutOfMemory;\n"
#~ "\n"
#~ "+        // Load kernel\n"
#~ "+        try self.loadKernel(guest_image);\n"
#~ "+\n"
#~ "         // Create simple EPT mapping.\n"
#~ "         const eptp = try impl.mapGuest(self.guest_mem, allocator);\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "// Copy boot_info into Ymir's stack since it becomes inaccessible after "
#~ "memory mapping is reconstructed.\n"
#~ "const guest_info = boot_info.guest_info;\n"
#~ "\n"
#~ "...\n"
#~ "\n"
#~ "// (After entering VMX Operation)\n"
#~ "const guest_kernel = b: {\n"
#~ "    const ptr: [*]u8 = @ptrFromInt(ymir.mem.phys2virt(guest_info."
#~ "guest_image));\n"
#~ "    break :b ptr[0..guest_info.guest_size];\n"
#~ "};\n"
#~ "try vm.setupGuestMemory(\n"
#~ "    guest_kernel,\n"
#~ "    mem.general_allocator,\n"
#~ "    &mem.page_allocator_instance,\n"
#~ ");\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "// Copy boot_info into Ymir's stack since it becomes inaccessible after "
#~ "memory mapping is reconstructed.\n"
#~ "const guest_info = boot_info.guest_info;\n"
#~ "\n"
#~ "...\n"
#~ "\n"
#~ "// (After entering VMX Operation)\n"
#~ "const guest_kernel = b: {\n"
#~ "    const ptr: [*]u8 = @ptrFromInt(ymir.mem.phys2virt(guest_info."
#~ "guest_image));\n"
#~ "    break :b ptr[0..guest_info.guest_size];\n"
#~ "};\n"
#~ "try vm.setupGuestMemory(\n"
#~ "    guest_kernel,\n"
#~ "    mem.general_allocator,\n"
#~ "    &mem.page_allocator_instance,\n"
#~ ");\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "const cpuid = @import(\"cpuid.zig\");\n"
#~ "\n"
#~ "fn handleExit(self: *Self, exit_info: vmx.ExitInfo) VmxError!void {\n"
#~ "    switch (exit_info.basic_reason) {\n"
#~ "        .cpuid => {\n"
#~ "            try cpuid.handleCpuidExit(self);\n"
#~ "            try self.stepNextInst();\n"
#~ "        },\n"
#~ "        ...\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "const cpuid = @import(\"cpuid.zig\");\n"
#~ "\n"
#~ "fn handleExit(self: *Self, exit_info: vmx.ExitInfo) VmxError!void {\n"
#~ "    switch (exit_info.basic_reason) {\n"
#~ "        .cpuid => {\n"
#~ "            try cpuid.handleCpuidExit(self);\n"
#~ "            try self.stepNextInst();\n"
#~ "        },\n"
#~ "        ...\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "switch (Leaf.from(regs.rax)) {\n"
#~ "    _ => {\n"
#~ "        log.warn(\"Unhandled CPUID: Leaf=0x{X:0>8}, Sub=0x{X:0>8}\", ."
#~ "{ regs.rax, regs.rcx });\n"
#~ "        invalid(vcpu);\n"
#~ "    },\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "switch (Leaf.from(regs.rax)) {\n"
#~ "    _ => {\n"
#~ "        log.warn(\"Unhandled CPUID: Leaf=0x{X:0>8}, Sub=0x{X:0>8}\", ."
#~ "{ regs.rax, regs.rcx });\n"
#~ "        invalid(vcpu);\n"
#~ "    },\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "    .maximum_input => {\n"
#~ "        setValue(&regs.rax, 0x20); // Maximum input value for basic "
#~ "CPUID.\n"
#~ "        setValue(&regs.rbx, 0x72_69_6D_59); // Ymir\n"
#~ "        setValue(&regs.rcx, 0x72_69_6D_59); // Ymir\n"
#~ "        setValue(&regs.rdx, 0x72_69_6D_59); // Ymir\n"
#~ "    },\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "    .maximum_input => {\n"
#~ "        setValue(&regs.rax, 0x20); // Maximum input value for basic "
#~ "CPUID.\n"
#~ "        setValue(&regs.rbx, 0x72_69_6D_59); // Ymir\n"
#~ "        setValue(&regs.rcx, 0x72_69_6D_59); // Ymir\n"
#~ "        setValue(&regs.rdx, 0x72_69_6D_59); // Ymir\n"
#~ "    },\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "    .version_info => {\n"
#~ "        const orig = Leaf.query(.version_info, null);\n"
#~ "        setValue(&regs.rax, orig.eax); // Version information.\n"
#~ "        setValue(&regs.rbx, orig.ebx); // Brand index / CLFLUSH line "
#~ "size / Addressable IDs / Initial APIC ID\n"
#~ "        setValue(&regs.rcx, @as(u32, @bitCast(feature_info_ecx)));\n"
#~ "        setValue(&regs.rdx, @as(u32, @bitCast(feature_info_edx)));\n"
#~ "    },\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "    .version_info => {\n"
#~ "        const orig = Leaf.query(.version_info, null);\n"
#~ "        setValue(&regs.rax, orig.eax); // Version information.\n"
#~ "        setValue(&regs.rbx, orig.ebx); // Brand index / CLFLUSH line "
#~ "size / Addressable IDs / Initial APIC ID\n"
#~ "        setValue(&regs.rcx, @as(u32, @bitCast(feature_info_ecx)));\n"
#~ "        setValue(&regs.rdx, @as(u32, @bitCast(feature_info_edx)));\n"
#~ "    },\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/cpuid.zig\n"
#~ "pub const FeatureInfoEcx = packed struct(u32) {\n"
#~ "    /// Streaming SIMD Extensions 3 (SSE3).\n"
#~ "    sse3: bool = false,\n"
#~ "    /// PCLMULQDQ.\n"
#~ "    pclmulqdq: bool = false,\n"
#~ "    /// 64-bit DS Area.\n"
#~ "    dtes64: bool = false,\n"
#~ "    /// MONITOR/MWAIT.\n"
#~ "    monitor: bool = false,\n"
#~ "    // CPL Qualified Debug Store.\n"
#~ "    ds_cpl: bool = false,\n"
#~ "    /// Virtual Machine Extensions.\n"
#~ "    vmx: bool = false,\n"
#~ "    /// Safer Mode Extensions.\n"
#~ "    smx: bool = false,\n"
#~ "    /// Enhanced Intel SpeedStep Technology.\n"
#~ "    eist: bool = false,\n"
#~ "    /// Thermal Monitor 2.\n"
#~ "    tm2: bool = false,\n"
#~ "    /// SSSE3 extensions.\n"
#~ "    ssse3: bool = false,\n"
#~ "    /// L1 context ID.\n"
#~ "    cnxt_id: bool = false,\n"
#~ "    /// IA32_DEBUG_INTERFACE.\n"
#~ "    sdbg: bool = false,\n"
#~ "    /// FMA extesions using YMM state.\n"
#~ "    fma: bool = false,\n"
#~ "    /// CMPXCHG16B available.\n"
#~ "    cmpxchg16b: bool = false,\n"
#~ "    /// xTPR update control.\n"
#~ "    xtpr: bool = false,\n"
#~ "    /// Perfmon and Debug Capability.\n"
#~ "    pdcm: bool = false,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved_0: bool = false,\n"
#~ "    /// Process-context identifiers.\n"
#~ "    pcid: bool = false,\n"
#~ "    /// Ability to prevent data from memory mapped devices.\n"
#~ "    dca: bool = false,\n"
#~ "    /// SSE4.1 extensions.\n"
#~ "    sse4_1: bool = false,\n"
#~ "    /// SSE4.2 extensions.\n"
#~ "    sse4_2: bool = false,\n"
#~ "    /// x2APIC support.\n"
#~ "    x2apic: bool = false,\n"
#~ "    /// MOVBE instruction.\n"
#~ "    movbe: bool = false,\n"
#~ "    /// POPCNT instruction.\n"
#~ "    popcnt: bool = false,\n"
#~ "    /// Local APIC timer supports one-shot operation using TSC deadline.\n"
#~ "    tsc_deadline: bool = false,\n"
#~ "    /// AES instruction.\n"
#~ "    aesni: bool = false,\n"
#~ "    /// XSAVE/XRSTOR states.\n"
#~ "    xsave: bool = false,\n"
#~ "    /// OS has enabled XSETBV/XGETBV instructions to access XCR0.\n"
#~ "    osxsave: bool = false,\n"
#~ "    /// AVX.\n"
#~ "    avx: bool = false,\n"
#~ "    /// 16-bit floating-point conversion instructions.\n"
#~ "    f16c: bool = false,\n"
#~ "    /// RDRAND instruction.\n"
#~ "    rdrand: bool = false,\n"
#~ "    /// Not used.\n"
#~ "    hypervisor: bool = false,\n"
#~ "};\n"
#~ "\n"
#~ "pub const FeatureInfoEdx = packed struct(u32) {\n"
#~ "    /// x87 FPU.\n"
#~ "    fpu: bool = false,\n"
#~ "    /// Virtual 8086 mode enhancements.\n"
#~ "    vme: bool = false,\n"
#~ "    /// Debugging extensions.\n"
#~ "    de: bool = false,\n"
#~ "    /// Page Size Extension.\n"
#~ "    pse: bool = false,\n"
#~ "    /// Time Stamp Counter.\n"
#~ "    tsc: bool = false,\n"
#~ "    /// RDMSR and WRMSR instructions.\n"
#~ "    msr: bool = false,\n"
#~ "    /// Physical Address Extension.\n"
#~ "    pae: bool = false,\n"
#~ "    /// Machine Check Exception.\n"
#~ "    mce: bool = false,\n"
#~ "    /// CMPXCHG8B instruction.\n"
#~ "    cx8: bool = false,\n"
#~ "    /// APIC on-chip.\n"
#~ "    apic: bool = false,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved_0: bool = false,\n"
#~ "    /// SYSENTER/SYSEXIT instructions.\n"
#~ "    sep: bool = false,\n"
#~ "    /// Memory Type Range Registers.\n"
#~ "    mtrr: bool = false,\n"
#~ "    /// Page Global Bit.\n"
#~ "    pge: bool = false,\n"
#~ "    /// Machine check architecture.\n"
#~ "    mca: bool = false,\n"
#~ "    /// Conditional move instructions.\n"
#~ "    cmov: bool = false,\n"
#~ "    /// Page attribute table.\n"
#~ "    pat: bool = false,\n"
#~ "    /// 36-bit Page Size Extension.\n"
#~ "    pse36: bool = false,\n"
#~ "    /// Processor serial number.\n"
#~ "    psn: bool = false,\n"
#~ "    /// CLFLUSH instruction.\n"
#~ "    clfsh: bool = false,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved_1: bool = false,\n"
#~ "    /// Debug store.\n"
#~ "    ds: bool = false,\n"
#~ "    /// Thermal monitor and software controlled clock facilities.\n"
#~ "    acpi: bool = false,\n"
#~ "    /// Intel MMX Technology.\n"
#~ "    mmx: bool = false,\n"
#~ "    /// FXSAVE and FXRSTOR instructions.\n"
#~ "    fxsr: bool = false,\n"
#~ "    /// SSE extensions.\n"
#~ "    sse: bool = false,\n"
#~ "    /// SSE2 extensions.\n"
#~ "    sse2: bool = false,\n"
#~ "    /// Self snoop.\n"
#~ "    ss: bool = false,\n"
#~ "    /// Max APIC IDs reserved field.\n"
#~ "    htt: bool = false,\n"
#~ "    /// Thermal monitor.\n"
#~ "    tm: bool = false,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved_2: bool = false,\n"
#~ "    /// Pending Break Enable.\n"
#~ "    pbe: bool = false,\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/cpuid.zig\n"
#~ "pub const FeatureInfoEcx = packed struct(u32) {\n"
#~ "    /// Streaming SIMD Extensions 3 (SSE3).\n"
#~ "    sse3: bool = false,\n"
#~ "    /// PCLMULQDQ.\n"
#~ "    pclmulqdq: bool = false,\n"
#~ "    /// 64-bit DS Area.\n"
#~ "    dtes64: bool = false,\n"
#~ "    /// MONITOR/MWAIT.\n"
#~ "    monitor: bool = false,\n"
#~ "    // CPL Qualified Debug Store.\n"
#~ "    ds_cpl: bool = false,\n"
#~ "    /// Virtual Machine Extensions.\n"
#~ "    vmx: bool = false,\n"
#~ "    /// Safer Mode Extensions.\n"
#~ "    smx: bool = false,\n"
#~ "    /// Enhanced Intel SpeedStep Technology.\n"
#~ "    eist: bool = false,\n"
#~ "    /// Thermal Monitor 2.\n"
#~ "    tm2: bool = false,\n"
#~ "    /// SSSE3 extensions.\n"
#~ "    ssse3: bool = false,\n"
#~ "    /// L1 context ID.\n"
#~ "    cnxt_id: bool = false,\n"
#~ "    /// IA32_DEBUG_INTERFACE.\n"
#~ "    sdbg: bool = false,\n"
#~ "    /// FMA extesions using YMM state.\n"
#~ "    fma: bool = false,\n"
#~ "    /// CMPXCHG16B available.\n"
#~ "    cmpxchg16b: bool = false,\n"
#~ "    /// xTPR update control.\n"
#~ "    xtpr: bool = false,\n"
#~ "    /// Perfmon and Debug Capability.\n"
#~ "    pdcm: bool = false,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved_0: bool = false,\n"
#~ "    /// Process-context identifiers.\n"
#~ "    pcid: bool = false,\n"
#~ "    /// Ability to prevent data from memory mapped devices.\n"
#~ "    dca: bool = false,\n"
#~ "    /// SSE4.1 extensions.\n"
#~ "    sse4_1: bool = false,\n"
#~ "    /// SSE4.2 extensions.\n"
#~ "    sse4_2: bool = false,\n"
#~ "    /// x2APIC support.\n"
#~ "    x2apic: bool = false,\n"
#~ "    /// MOVBE instruction.\n"
#~ "    movbe: bool = false,\n"
#~ "    /// POPCNT instruction.\n"
#~ "    popcnt: bool = false,\n"
#~ "    /// Local APIC timer supports one-shot operation using TSC deadline.\n"
#~ "    tsc_deadline: bool = false,\n"
#~ "    /// AES instruction.\n"
#~ "    aesni: bool = false,\n"
#~ "    /// XSAVE/XRSTOR states.\n"
#~ "    xsave: bool = false,\n"
#~ "    /// OS has enabled XSETBV/XGETBV instructions to access XCR0.\n"
#~ "    osxsave: bool = false,\n"
#~ "    /// AVX.\n"
#~ "    avx: bool = false,\n"
#~ "    /// 16-bit floating-point conversion instructions.\n"
#~ "    f16c: bool = false,\n"
#~ "    /// RDRAND instruction.\n"
#~ "    rdrand: bool = false,\n"
#~ "    /// Not used.\n"
#~ "    hypervisor: bool = false,\n"
#~ "};\n"
#~ "\n"
#~ "pub const FeatureInfoEdx = packed struct(u32) {\n"
#~ "    /// x87 FPU.\n"
#~ "    fpu: bool = false,\n"
#~ "    /// Virtual 8086 mode enhancements.\n"
#~ "    vme: bool = false,\n"
#~ "    /// Debugging extensions.\n"
#~ "    de: bool = false,\n"
#~ "    /// Page Size Extension.\n"
#~ "    pse: bool = false,\n"
#~ "    /// Time Stamp Counter.\n"
#~ "    tsc: bool = false,\n"
#~ "    /// RDMSR and WRMSR instructions.\n"
#~ "    msr: bool = false,\n"
#~ "    /// Physical Address Extension.\n"
#~ "    pae: bool = false,\n"
#~ "    /// Machine Check Exception.\n"
#~ "    mce: bool = false,\n"
#~ "    /// CMPXCHG8B instruction.\n"
#~ "    cx8: bool = false,\n"
#~ "    /// APIC on-chip.\n"
#~ "    apic: bool = false,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved_0: bool = false,\n"
#~ "    /// SYSENTER/SYSEXIT instructions.\n"
#~ "    sep: bool = false,\n"
#~ "    /// Memory Type Range Registers.\n"
#~ "    mtrr: bool = false,\n"
#~ "    /// Page Global Bit.\n"
#~ "    pge: bool = false,\n"
#~ "    /// Machine check architecture.\n"
#~ "    mca: bool = false,\n"
#~ "    /// Conditional move instructions.\n"
#~ "    cmov: bool = false,\n"
#~ "    /// Page attribute table.\n"
#~ "    pat: bool = false,\n"
#~ "    /// 36-bit Page Size Extension.\n"
#~ "    pse36: bool = false,\n"
#~ "    /// Processor serial number.\n"
#~ "    psn: bool = false,\n"
#~ "    /// CLFLUSH instruction.\n"
#~ "    clfsh: bool = false,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved_1: bool = false,\n"
#~ "    /// Debug store.\n"
#~ "    ds: bool = false,\n"
#~ "    /// Thermal monitor and software controlled clock facilities.\n"
#~ "    acpi: bool = false,\n"
#~ "    /// Intel MMX Technology.\n"
#~ "    mmx: bool = false,\n"
#~ "    /// FXSAVE and FXRSTOR instructions.\n"
#~ "    fxsr: bool = false,\n"
#~ "    /// SSE extensions.\n"
#~ "    sse: bool = false,\n"
#~ "    /// SSE2 extensions.\n"
#~ "    sse2: bool = false,\n"
#~ "    /// Self snoop.\n"
#~ "    ss: bool = false,\n"
#~ "    /// Max APIC IDs reserved field.\n"
#~ "    htt: bool = false,\n"
#~ "    /// Thermal monitor.\n"
#~ "    tm: bool = false,\n"
#~ "    /// Reserved.\n"
#~ "    _reserved_2: bool = false,\n"
#~ "    /// Pending Break Enable.\n"
#~ "    pbe: bool = false,\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "    .ext_feature => {\n"
#~ "        switch (regs.rcx) {\n"
#~ "            0 => {\n"
#~ "                setValue(&regs.rax, 1); // Maximum input value for "
#~ "supported leaf 7 sub-leaves.\n"
#~ "                setValue(&regs.rbx, @as(u32, "
#~ "@bitCast(ext_feature0_ebx)));\n"
#~ "                setValue(&regs.rcx, 0); // Unimplemented.\n"
#~ "                setValue(&regs.rdx, 0); // Unimplemented.\n"
#~ "            },\n"
#~ "            1, 2 => invalid(vcpu),\n"
#~ "            else => {\n"
#~ "                log.err(\"Unhandled CPUID: Leaf=0x{X:0>8}, "
#~ "Sub=0x{X:0>8}\", .{ regs.rax, regs.rcx });\n"
#~ "                vcpu.abort();\n"
#~ "            },\n"
#~ "        }\n"
#~ "    },\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "    .ext_feature => {\n"
#~ "        switch (regs.rcx) {\n"
#~ "            0 => {\n"
#~ "                setValue(&regs.rax, 1); // Maximum input value for "
#~ "supported leaf 7 sub-leaves.\n"
#~ "                setValue(&regs.rbx, @as(u32, "
#~ "@bitCast(ext_feature0_ebx)));\n"
#~ "                setValue(&regs.rcx, 0); // Unimplemented.\n"
#~ "                setValue(&regs.rdx, 0); // Unimplemented.\n"
#~ "            },\n"
#~ "            1, 2 => invalid(vcpu),\n"
#~ "            else => {\n"
#~ "                log.err(\"Unhandled CPUID: Leaf=0x{X:0>8}, "
#~ "Sub=0x{X:0>8}\", .{ regs.rax, regs.rcx });\n"
#~ "                vcpu.abort();\n"
#~ "            },\n"
#~ "        }\n"
#~ "    },\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "    .ext_enumeration => {\n"
#~ "        switch (regs.rcx) {\n"
#~ "            1 => invalid(vcpu),\n"
#~ "            else => {\n"
#~ "                log.err(\"Unhandled CPUID: Leaf=0x{X:0>8}, "
#~ "Sub=0x{X:0>8}\", .{ regs.rax, regs.rcx });\n"
#~ "                vcpu.abort();\n"
#~ "            },\n"
#~ "        }\n"
#~ "    },\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "    .ext_enumeration => {\n"
#~ "        switch (regs.rcx) {\n"
#~ "            1 => invalid(vcpu),\n"
#~ "            else => {\n"
#~ "                log.err(\"Unhandled CPUID: Leaf=0x{X:0>8}, "
#~ "Sub=0x{X:0>8}\", .{ regs.rax, regs.rcx });\n"
#~ "                vcpu.abort();\n"
#~ "            },\n"
#~ "        }\n"
#~ "    },\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "    .ext_func => {\n"
#~ "        setValue(&regs.rax, 0x8000_0000 + 1); // Maximum input value for "
#~ "extended function CPUID.\n"
#~ "        setValue(&regs.rbx, 0); // Reserved.\n"
#~ "        setValue(&regs.rcx, 0); // Reserved.\n"
#~ "        setValue(&regs.rdx, 0); // Reserved.\n"
#~ "    },\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "    .ext_func => {\n"
#~ "        setValue(&regs.rax, 0x8000_0000 + 1); // Maximum input value for "
#~ "extended function CPUID.\n"
#~ "        setValue(&regs.rbx, 0); // Reserved.\n"
#~ "        setValue(&regs.rcx, 0); // Reserved.\n"
#~ "        setValue(&regs.rdx, 0); // Reserved.\n"
#~ "    },\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "    .ext_proc_signature => {\n"
#~ "        const orig = Leaf.ext_proc_signature.query(null);\n"
#~ "        setValue(&regs.rax, 0); // Extended processor signature and "
#~ "feature bits.\n"
#~ "        setValue(&regs.rbx, 0); // Reserved.\n"
#~ "        setValue(&regs.rcx, orig.ecx); // LAHF in 64-bit mode / LZCNT / "
#~ "PREFETCHW\n"
#~ "        setValue(&regs.rdx, orig.edx); // SYSCALL / XD / 1GB large page / "
#~ "RDTSCP and IA32_TSC_AUX / Intel64\n"
#~ "    },\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/cpuid.zig\n"
#~ "    .ext_proc_signature => {\n"
#~ "        const orig = Leaf.ext_proc_signature.query(null);\n"
#~ "        setValue(&regs.rax, 0); // Extended processor signature and "
#~ "feature bits.\n"
#~ "        setValue(&regs.rbx, 0); // Reserved.\n"
#~ "        setValue(&regs.rcx, orig.ecx); // LAHF in 64-bit mode / LZCNT / "
#~ "PREFETCHW\n"
#~ "        setValue(&regs.rdx, orig.edx); // SYSCALL / XD / 1GB large page / "
#~ "RDTSCP and IA32_TSC_AUX / Intel64\n"
#~ "    },\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/msr.zig\n"
#~ "pub const ShadowMsr = struct {\n"
#~ "    /// Maximum number of MSR entries in a page.\n"
#~ "    const max_num_ents = 512;\n"
#~ "\n"
#~ "    /// MSR entries.\n"
#~ "    ents: []SavedMsr,\n"
#~ "    /// Number of registered MSR entries.\n"
#~ "    num_ents: usize = 0,\n"
#~ "    /// MSR Entry.\n"
#~ "    pub const SavedMsr = packed struct(u128) {\n"
#~ "        index: u32,\n"
#~ "        reserved: u32 = 0,\n"
#~ "        data: u64,\n"
#~ "    };\n"
#~ "\n"
#~ "    /// Initialize saved MSR page.\n"
#~ "    pub fn init(allocator: Allocator) !ShadowMsr {\n"
#~ "        const ents = try allocator.alloc(SavedMsr, max_num_ents);\n"
#~ "        @memset(ents, std.mem.zeroes(SavedMsr));\n"
#~ "\n"
#~ "        return ShadowMsr{\n"
#~ "            .ents = ents,\n"
#~ "        };\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Register or update MSR entry.\n"
#~ "    pub fn set(self: *ShadowMsr, index: am.Msr, data: u64) void {\n"
#~ "        return self.setByIndex(@intFromEnum(index), data);\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Register or update MSR entry indexed by `index`.\n"
#~ "    pub fn setByIndex(self: *ShadowMsr, index: u32, data: u64) void {\n"
#~ "        for (0..self.num_ents) |i| {\n"
#~ "            if (self.ents[i].index == index) {\n"
#~ "                self.ents[i].data = data;\n"
#~ "                return;\n"
#~ "            }\n"
#~ "        }\n"
#~ "        self.ents[self.num_ents] = SavedMsr{ .index = index, .data = "
#~ "data };\n"
#~ "        self.num_ents += 1;\n"
#~ "        if (self.num_ents > max_num_ents) {\n"
#~ "            @panic(\"Too many MSR entries registered.\");\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the saved MSRs.\n"
#~ "    pub fn savedEnts(self: *ShadowMsr) []SavedMsr {\n"
#~ "        return self.ents[0..self.num_ents];\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Find the saved MSR entry.\n"
#~ "    pub fn find(self: *ShadowMsr, index: am.Msr) ?*SavedMsr {\n"
#~ "        const index_num = @intFromEnum(index);\n"
#~ "        for (0..self.num_ents) |i| {\n"
#~ "            if (self.ents[i].index == index_num) {\n"
#~ "                return &self.ents[i];\n"
#~ "            }\n"
#~ "        }\n"
#~ "        return null;\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the host physical address of the MSR page.\n"
#~ "    pub fn phys(self: *ShadowMsr) u64 {\n"
#~ "        return mem.virt2phys(self.ents.ptr);\n"
#~ "    }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/msr.zig\n"
#~ "pub const ShadowMsr = struct {\n"
#~ "    /// Maximum number of MSR entries in a page.\n"
#~ "    const max_num_ents = 512;\n"
#~ "\n"
#~ "    /// MSR entries.\n"
#~ "    ents: []SavedMsr,\n"
#~ "    /// Number of registered MSR entries.\n"
#~ "    num_ents: usize = 0,\n"
#~ "    /// MSR Entry.\n"
#~ "    pub const SavedMsr = packed struct(u128) {\n"
#~ "        index: u32,\n"
#~ "        reserved: u32 = 0,\n"
#~ "        data: u64,\n"
#~ "    };\n"
#~ "\n"
#~ "    /// Initialize saved MSR page.\n"
#~ "    pub fn init(allocator: Allocator) !ShadowMsr {\n"
#~ "        const ents = try allocator.alloc(SavedMsr, max_num_ents);\n"
#~ "        @memset(ents, std.mem.zeroes(SavedMsr));\n"
#~ "\n"
#~ "        return ShadowMsr{\n"
#~ "            .ents = ents,\n"
#~ "        };\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Register or update MSR entry.\n"
#~ "    pub fn set(self: *ShadowMsr, index: am.Msr, data: u64) void {\n"
#~ "        return self.setByIndex(@intFromEnum(index), data);\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Register or update MSR entry indexed by `index`.\n"
#~ "    pub fn setByIndex(self: *ShadowMsr, index: u32, data: u64) void {\n"
#~ "        for (0..self.num_ents) |i| {\n"
#~ "            if (self.ents[i].index == index) {\n"
#~ "                self.ents[i].data = data;\n"
#~ "                return;\n"
#~ "            }\n"
#~ "        }\n"
#~ "        self.ents[self.num_ents] = SavedMsr{ .index = index, .data = "
#~ "data };\n"
#~ "        self.num_ents += 1;\n"
#~ "        if (self.num_ents > max_num_ents) {\n"
#~ "            @panic(\"Too many MSR entries registered.\");\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the saved MSRs.\n"
#~ "    pub fn savedEnts(self: *ShadowMsr) []SavedMsr {\n"
#~ "        return self.ents[0..self.num_ents];\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Find the saved MSR entry.\n"
#~ "    pub fn find(self: *ShadowMsr, index: am.Msr) ?*SavedMsr {\n"
#~ "        const index_num = @intFromEnum(index);\n"
#~ "        for (0..self.num_ents) |i| {\n"
#~ "            if (self.ents[i].index == index_num) {\n"
#~ "                return &self.ents[i];\n"
#~ "            }\n"
#~ "        }\n"
#~ "        return null;\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Get the host physical address of the MSR page.\n"
#~ "    pub fn phys(self: *ShadowMsr) u64 {\n"
#~ "        return mem.virt2phys(self.ents.ptr);\n"
#~ "    }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn registerMsrs(vcpu: *Vcpu, allocator: Allocator) !void {\n"
#~ "    vcpu.host_msr = try msr.ShadowMsr.init(allocator);\n"
#~ "    vcpu.guest_msr = try msr.ShadowMsr.init(allocator);\n"
#~ "\n"
#~ "    const hm = &vcpu.host_msr;\n"
#~ "    const gm = &vcpu.guest_msr;\n"
#~ "\n"
#~ "    // Host MSRs.\n"
#~ "    hm.set(.tsc_aux, am.readMsr(.tsc_aux));\n"
#~ "    hm.set(.star, am.readMsr(.star));\n"
#~ "    hm.set(.lstar, am.readMsr(.lstar));\n"
#~ "    hm.set(.cstar, am.readMsr(.cstar));\n"
#~ "    hm.set(.fmask, am.readMsr(.fmask));\n"
#~ "    hm.set(.kernel_gs_base, am.readMsr(.kernel_gs_base));\n"
#~ "\n"
#~ "    // Guest MSRs.\n"
#~ "    gm.set(.tsc_aux, 0);\n"
#~ "    gm.set(.star, 0);\n"
#~ "    gm.set(.lstar, 0);\n"
#~ "    gm.set(.cstar, 0);\n"
#~ "    gm.set(.fmask, 0);\n"
#~ "    gm.set(.kernel_gs_base, 0);\n"
#~ "\n"
#~ "    // Init MSR data in VMCS.\n"
#~ "    try vmwrite(vmcs.ctrl.exit_msr_load_address, hm.phys());\n"
#~ "    try vmwrite(vmcs.ctrl.exit_msr_store_address, gm.phys());\n"
#~ "    try vmwrite(vmcs.ctrl.entry_msr_load_address, gm.phys());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn registerMsrs(vcpu: *Vcpu, allocator: Allocator) !void {\n"
#~ "    vcpu.host_msr = try msr.ShadowMsr.init(allocator);\n"
#~ "    vcpu.guest_msr = try msr.ShadowMsr.init(allocator);\n"
#~ "\n"
#~ "    const hm = &vcpu.host_msr;\n"
#~ "    const gm = &vcpu.guest_msr;\n"
#~ "\n"
#~ "    // Host MSRs.\n"
#~ "    hm.set(.tsc_aux, am.readMsr(.tsc_aux));\n"
#~ "    hm.set(.star, am.readMsr(.star));\n"
#~ "    hm.set(.lstar, am.readMsr(.lstar));\n"
#~ "    hm.set(.cstar, am.readMsr(.cstar));\n"
#~ "    hm.set(.fmask, am.readMsr(.fmask));\n"
#~ "    hm.set(.kernel_gs_base, am.readMsr(.kernel_gs_base));\n"
#~ "\n"
#~ "    // Guest MSRs.\n"
#~ "    gm.set(.tsc_aux, 0);\n"
#~ "    gm.set(.star, 0);\n"
#~ "    gm.set(.lstar, 0);\n"
#~ "    gm.set(.cstar, 0);\n"
#~ "    gm.set(.fmask, 0);\n"
#~ "    gm.set(.kernel_gs_base, 0);\n"
#~ "\n"
#~ "    // Init MSR data in VMCS.\n"
#~ "    try vmwrite(vmcs.ctrl.exit_msr_load_address, hm.phys());\n"
#~ "    try vmwrite(vmcs.ctrl.exit_msr_store_address, gm.phys());\n"
#~ "    try vmwrite(vmcs.ctrl.entry_msr_load_address, gm.phys());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn updateMsrs(vcpu: *Vcpu) VmxError!void {\n"
#~ "    // Save host MSRs.\n"
#~ "    for (vcpu.host_msr.savedEnts()) |ent| {\n"
#~ "        vcpu.host_msr.setByIndex(ent.index, am.readMsr(@enumFromInt(ent."
#~ "index)));\n"
#~ "    }\n"
#~ "    // Update MSR counts.\n"
#~ "    try vmwrite(vmcs.ctrl.vexit_msr_load_count, vcpu.host_msr.num_ents);\n"
#~ "    try vmwrite(vmcs.ctrl.exit_msr_store_count, vcpu.guest_msr."
#~ "num_ents);\n"
#~ "    try vmwrite(vmcs.ctrl.entry_msr_load_count, vcpu.guest_msr."
#~ "num_ents);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn updateMsrs(vcpu: *Vcpu) VmxError!void {\n"
#~ "    // Save host MSRs.\n"
#~ "    for (vcpu.host_msr.savedEnts()) |ent| {\n"
#~ "        vcpu.host_msr.setByIndex(ent.index, am.readMsr(@enumFromInt(ent."
#~ "index)));\n"
#~ "    }\n"
#~ "    // Update MSR counts.\n"
#~ "    try vmwrite(vmcs.ctrl.vexit_msr_load_count, vcpu.host_msr.num_ents);\n"
#~ "    try vmwrite(vmcs.ctrl.exit_msr_store_count, vcpu.guest_msr."
#~ "num_ents);\n"
#~ "    try vmwrite(vmcs.ctrl.entry_msr_load_count, vcpu.guest_msr."
#~ "num_ents);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/msr.zig\n"
#~ "/// Concatnate two 32-bit values into a 64-bit value.\n"
#~ "fn concat(r1: u64, r2: u64) u64 {\n"
#~ "    return ((r1 & 0xFFFF_FFFF) << 32) | (r2 & 0xFFFF_FFFF);\n"
#~ "}\n"
#~ "\n"
#~ "/// Set the 64-bit return value to the guest registers.\n"
#~ "fn setRetVal(vcpu: *Vcpu, val: u64) void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    @as(*u32, @ptrCast(&regs.rdx)).* = @as(u32, @truncate(val >> 32));\n"
#~ "    @as(*u32, @ptrCast(&regs.rax)).* = @as(u32, @truncate(val));\n"
#~ "}\n"
#~ "\n"
#~ "/// Read from the MSR Area.\n"
#~ "fn shadowRead(vcpu: *Vcpu, msr_kind: am.Msr) void {\n"
#~ "    if (vcpu.guest_msr.find(msr_kind)) |msr| {\n"
#~ "        setRetVal(vcpu, msr.data);\n"
#~ "    } else {\n"
#~ "        log.err(\"RDMSR: MSR is not registered: {s}\", ."
#~ "{@tagName(msr_kind)});\n"
#~ "        vcpu.abort();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/msr.zig\n"
#~ "/// Concatnate two 32-bit values into a 64-bit value.\n"
#~ "fn concat(r1: u64, r2: u64) u64 {\n"
#~ "    return ((r1 & 0xFFFF_FFFF) << 32) | (r2 & 0xFFFF_FFFF);\n"
#~ "}\n"
#~ "\n"
#~ "/// Set the 64-bit return value to the guest registers.\n"
#~ "fn setRetVal(vcpu: *Vcpu, val: u64) void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    @as(*u32, @ptrCast(&regs.rdx)).* = @as(u32, @truncate(val >> 32));\n"
#~ "    @as(*u32, @ptrCast(&regs.rax)).* = @as(u32, @truncate(val));\n"
#~ "}\n"
#~ "\n"
#~ "/// Read from the MSR Area.\n"
#~ "fn shadowRead(vcpu: *Vcpu, msr_kind: am.Msr) void {\n"
#~ "    if (vcpu.guest_msr.find(msr_kind)) |msr| {\n"
#~ "        setRetVal(vcpu, msr.data);\n"
#~ "    } else {\n"
#~ "        log.err(\"RDMSR: MSR is not registered: {s}\", ."
#~ "{@tagName(msr_kind)});\n"
#~ "        vcpu.abort();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/msr.zig\n"
#~ "pub fn handleRdmsrExit(vcpu: *Vcpu) VmxError!void {\n"
#~ "    const guest_regs = &vcpu.guest_regs;\n"
#~ "    const msr_kind: am.Msr = @enumFromInt(guest_regs.rcx);\n"
#~ "\n"
#~ "    switch (msr_kind) {\n"
#~ "        .apic_base => setRetVal(vcpu, std.math.maxInt(u64)), // 無効\n"
#~ "        .efer => setRetVal(vcpu, try vmx.vmread(vmcs.guest.efer)),\n"
#~ "        .fs_base => setRetVal(vcpu, try vmx.vmread(vmcs.guest.fs_base)),\n"
#~ "        .gs_base => setRetVal(vcpu, try vmx.vmread(vmcs.guest.gs_base)),\n"
#~ "        .kernel_gs_base => shadowRead(vcpu, msr_kind),\n"
#~ "        else => {\n"
#~ "            log.err(\"Unhandled RDMSR: {?}\", .{msr_kind});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/msr.zig\n"
#~ "pub fn handleRdmsrExit(vcpu: *Vcpu) VmxError!void {\n"
#~ "    const guest_regs = &vcpu.guest_regs;\n"
#~ "    const msr_kind: am.Msr = @enumFromInt(guest_regs.rcx);\n"
#~ "\n"
#~ "    switch (msr_kind) {\n"
#~ "        .apic_base => setRetVal(vcpu, std.math.maxInt(u64)), // 無効\n"
#~ "        .efer => setRetVal(vcpu, try vmx.vmread(vmcs.guest.efer)),\n"
#~ "        .fs_base => setRetVal(vcpu, try vmx.vmread(vmcs.guest.fs_base)),\n"
#~ "        .gs_base => setRetVal(vcpu, try vmx.vmread(vmcs.guest.gs_base)),\n"
#~ "        .kernel_gs_base => shadowRead(vcpu, msr_kind),\n"
#~ "        else => {\n"
#~ "            log.err(\"Unhandled RDMSR: {?}\", .{msr_kind});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/msr.zig\n"
#~ "fn shadowWrite(vcpu: *Vcpu, msr_kind: am.Msr) void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    if (vcpu.guest_msr.find(msr_kind)) |_| {\n"
#~ "        vcpu.guest_msr.set(msr_kind, concat(regs.rdx, regs.rax));\n"
#~ "    } else {\n"
#~ "        log.err(\"WRMSR: MSR is not registered: {s}\", ."
#~ "{@tagName(msr_kind)});\n"
#~ "        vcpu.abort();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/msr.zig\n"
#~ "fn shadowWrite(vcpu: *Vcpu, msr_kind: am.Msr) void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    if (vcpu.guest_msr.find(msr_kind)) |_| {\n"
#~ "        vcpu.guest_msr.set(msr_kind, concat(regs.rdx, regs.rax));\n"
#~ "    } else {\n"
#~ "        log.err(\"WRMSR: MSR is not registered: {s}\", ."
#~ "{@tagName(msr_kind)});\n"
#~ "        vcpu.abort();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/msr.zig\n"
#~ "pub fn handleWrmsrExit(vcpu: *Vcpu) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    const value = concat(regs.rdx, regs.rax);\n"
#~ "    const msr_kind: am.Msr = @enumFromInt(regs.rcx);\n"
#~ "\n"
#~ "    switch (msr_kind) {\n"
#~ "        .star,\n"
#~ "        .lstar,\n"
#~ "        .cstar,\n"
#~ "        .tsc_aux,\n"
#~ "        .fmask,\n"
#~ "        .kernel_gs_base,\n"
#~ "        => shadowWrite(vcpu, msr_kind),\n"
#~ "        .sysenter_cs => try vmx.vmwrite(vmcs.guest.sysenter_cs, value),\n"
#~ "        .sysenter_eip => try vmx.vmwrite(vmcs.guest.sysenter_eip, "
#~ "value),\n"
#~ "        .sysenter_esp => try vmx.vmwrite(vmcs.guest.sysenter_esp, "
#~ "value),\n"
#~ "        .efer => try vmx.vmwrite(vmcs.guest.efer, value),\n"
#~ "        .gs_base => try vmx.vmwrite(vmcs.guest.gs_base, value),\n"
#~ "        .fs_base => try vmx.vmwrite(vmcs.guest.fs_base, value),\n"
#~ "        else => {\n"
#~ "            log.err(\"Unhandled WRMSR: {?}\", .{msr_kind});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/msr.zig\n"
#~ "pub fn handleWrmsrExit(vcpu: *Vcpu) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    const value = concat(regs.rdx, regs.rax);\n"
#~ "    const msr_kind: am.Msr = @enumFromInt(regs.rcx);\n"
#~ "\n"
#~ "    switch (msr_kind) {\n"
#~ "        .star,\n"
#~ "        .lstar,\n"
#~ "        .cstar,\n"
#~ "        .tsc_aux,\n"
#~ "        .fmask,\n"
#~ "        .kernel_gs_base,\n"
#~ "        => shadowWrite(vcpu, msr_kind),\n"
#~ "        .sysenter_cs => try vmx.vmwrite(vmcs.guest.sysenter_cs, value),\n"
#~ "        .sysenter_eip => try vmx.vmwrite(vmcs.guest.sysenter_eip, "
#~ "value),\n"
#~ "        .sysenter_esp => try vmx.vmwrite(vmcs.guest.sysenter_esp, "
#~ "value),\n"
#~ "        .efer => try vmx.vmwrite(vmcs.guest.efer, value),\n"
#~ "        .gs_base => try vmx.vmwrite(vmcs.guest.gs_base, value),\n"
#~ "        .fs_base => try vmx.vmwrite(vmcs.guest.fs_base, value),\n"
#~ "        else => {\n"
#~ "            log.err(\"Unhandled WRMSR: {?}\", .{msr_kind});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/cr.zig\n"
#~ "pub fn handleAccessCr(vcpu: *Vcpu, qual: QualCr) VmxError!void {\n"
#~ "    switch (qual.access_type) {\n"
#~ "        .mov_to => ...\n"
#~ "        .mov_from => ...\n"
#~ "        else => {\n"
#~ "            log.err(\"Unimplemented CR access: {?}\", .{qual});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/cr.zig\n"
#~ "pub fn handleAccessCr(vcpu: *Vcpu, qual: QualCr) VmxError!void {\n"
#~ "    switch (qual.access_type) {\n"
#~ "        .mov_to => ...\n"
#~ "        .mov_from => ...\n"
#~ "        else => {\n"
#~ "            log.err(\"Unimplemented CR access: {?}\", .{qual});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "const InvvpidType = enum(u64) {\n"
#~ "    individual_address = 0,\n"
#~ "    single_context = 1,\n"
#~ "    all_context = 2,\n"
#~ "    single_global = 3,\n"
#~ "};\n"
#~ "\n"
#~ "pub inline fn invvpid(comptime inv_type: InvvpidType, vpid: u16) void {\n"
#~ "    const descriptor: packed struct(u128) {\n"
#~ "        vpid: u16,\n"
#~ "        _reserved: u48 = 0,\n"
#~ "        linear_addr: u64 = 0,\n"
#~ "    } align(128) = .{ .vpid = vpid };\n"
#~ "    asm volatile (\n"
#~ "        \\\\invvpid (%[descriptor]), %[inv_type]\n"
#~ "        :\n"
#~ "        : [inv_type] \"r\" (@intFromEnum(inv_type)),\n"
#~ "          [descriptor] \"r\" (&descriptor),\n"
#~ "        : \"memory\"\n"
#~ "    );\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/asm.zig\n"
#~ "const InvvpidType = enum(u64) {\n"
#~ "    individual_address = 0,\n"
#~ "    single_context = 1,\n"
#~ "    all_context = 2,\n"
#~ "    single_global = 3,\n"
#~ "};\n"
#~ "\n"
#~ "pub inline fn invvpid(comptime inv_type: InvvpidType, vpid: u16) void {\n"
#~ "    const descriptor: packed struct(u128) {\n"
#~ "        vpid: u16,\n"
#~ "        _reserved: u48 = 0,\n"
#~ "        linear_addr: u64 = 0,\n"
#~ "    } align(128) = .{ .vpid = vpid };\n"
#~ "    asm volatile (\n"
#~ "        \\\\invvpid (%[descriptor]), %[inv_type]\n"
#~ "        :\n"
#~ "        : [inv_type] \"r\" (@intFromEnum(inv_type)),\n"
#~ "          [descriptor] \"r\" (&descriptor),\n"
#~ "        : \"memory\"\n"
#~ "    );\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/common.zig\n"
#~ "pub const qual = struct {\n"
#~ "    pub const QualIo = packed struct(u64) {\n"
#~ "        /// Size of access.\n"
#~ "        size: Size,\n"
#~ "        /// Direction of the attempted access.\n"
#~ "        direction: Direction,\n"
#~ "        /// String instruction.\n"
#~ "        string: bool,\n"
#~ "        /// Rep prefix.\n"
#~ "        rep: bool,\n"
#~ "        /// Operand encoding.\n"
#~ "        operand_encoding: OperandEncoding,\n"
#~ "        /// Not used.\n"
#~ "        _reserved2: u9,\n"
#~ "        /// Port number.\n"
#~ "        port: u16,\n"
#~ "        /// Not used.\n"
#~ "        _reserved3: u32,\n"
#~ "\n"
#~ "        const Size = enum(u3) {\n"
#~ "            /// Byte.\n"
#~ "            byte = 0,\n"
#~ "            /// Word.\n"
#~ "            word = 1,\n"
#~ "            /// Dword.\n"
#~ "            dword = 3,\n"
#~ "        };\n"
#~ "\n"
#~ "        const Direction = enum(u1) {\n"
#~ "            out = 0,\n"
#~ "            in = 1,\n"
#~ "        };\n"
#~ "\n"
#~ "        const OperandEncoding = enum(u1) {\n"
#~ "            /// I/O instruction uses DX register as port number.\n"
#~ "            dx = 0,\n"
#~ "            /// I/O instruction uses immediate value as port number.\n"
#~ "            imm = 1,\n"
#~ "        };\n"
#~ "    };\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/common.zig\n"
#~ "pub const qual = struct {\n"
#~ "    pub const QualIo = packed struct(u64) {\n"
#~ "        /// Size of access.\n"
#~ "        size: Size,\n"
#~ "        /// Direction of the attempted access.\n"
#~ "        direction: Direction,\n"
#~ "        /// String instruction.\n"
#~ "        string: bool,\n"
#~ "        /// Rep prefix.\n"
#~ "        rep: bool,\n"
#~ "        /// Operand encoding.\n"
#~ "        operand_encoding: OperandEncoding,\n"
#~ "        /// Not used.\n"
#~ "        _reserved2: u9,\n"
#~ "        /// Port number.\n"
#~ "        port: u16,\n"
#~ "        /// Not used.\n"
#~ "        _reserved3: u32,\n"
#~ "\n"
#~ "        const Size = enum(u3) {\n"
#~ "            /// Byte.\n"
#~ "            byte = 0,\n"
#~ "            /// Word.\n"
#~ "            word = 1,\n"
#~ "            /// Dword.\n"
#~ "            dword = 3,\n"
#~ "        };\n"
#~ "\n"
#~ "        const Direction = enum(u1) {\n"
#~ "            out = 0,\n"
#~ "            in = 1,\n"
#~ "        };\n"
#~ "\n"
#~ "        const OperandEncoding = enum(u1) {\n"
#~ "            /// I/O instruction uses DX register as port number.\n"
#~ "            dx = 0,\n"
#~ "            /// I/O instruction uses immediate value as port number.\n"
#~ "            imm = 1,\n"
#~ "        };\n"
#~ "    };\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "pub fn handleIo(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    return switch (qual.direction) {\n"
#~ "        .in => try handleIoIn(vcpu, qual),\n"
#~ "        .out => try handleIoOut(vcpu, qual),\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "fn handleIoIn(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    switch (qual.port) {\n"
#~ "        else => {\n"
#~ "            log.err(\"Unhandled I/O-in port: 0x{X}\", .{qual.port});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn handleIoOut(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    switch (qual.port) {\n"
#~ "        else => {\n"
#~ "            log.err(\"Unhandled I/O-out port: 0x{X}\", .{qual.port});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "pub fn handleIo(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    return switch (qual.direction) {\n"
#~ "        .in => try handleIoIn(vcpu, qual),\n"
#~ "        .out => try handleIoOut(vcpu, qual),\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "fn handleIoIn(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    switch (qual.port) {\n"
#~ "        else => {\n"
#~ "            log.err(\"Unhandled I/O-in port: 0x{X}\", .{qual.port});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn handleIoOut(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    switch (qual.port) {\n"
#~ "        else => {\n"
#~ "            log.err(\"Unhandled I/O-out port: 0x{X}\", .{qual.port});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "fn handleIoIn(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    switch (qual.port) {\n"
#~ "        0x0CF8...0x0CFF => regs.rax = 0, // PCI. Unimplemented.\n"
#~ "        0xC000...0xCFFF => {}, // Old PCI. Ignore.\n"
#~ "        ...\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn handleIoOut(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    switch (qual.port) {\n"
#~ "        0x0CF8...0x0CFF => {}, // PCI. Unimplemented.\n"
#~ "        0xC000...0xCFFF => {}, // Old PCI. Ignore.\n"
#~ "        ...\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "fn handleIoIn(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    switch (qual.port) {\n"
#~ "        0x0CF8...0x0CFF => regs.rax = 0, // PCI. Unimplemented.\n"
#~ "        0xC000...0xCFFF => {}, // Old PCI. Ignore.\n"
#~ "        ...\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn handleIoOut(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    switch (qual.port) {\n"
#~ "        0x0CF8...0x0CFF => {}, // PCI. Unimplemented.\n"
#~ "        0xC000...0xCFFF => {}, // Old PCI. Ignore.\n"
#~ "        ...\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "pub const Serial = struct {\n"
#~ "    /// Interrupt Enable Register.\n"
#~ "    ier: u8 = 0,\n"
#~ "    /// Modem Control Register.\n"
#~ "    mcr: u8 = 0,\n"
#~ "\n"
#~ "    pub fn new() Serial {\n"
#~ "        return Serial{};\n"
#~ "    }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "pub const Serial = struct {\n"
#~ "    /// Interrupt Enable Register.\n"
#~ "    ier: u8 = 0,\n"
#~ "    /// Modem Control Register.\n"
#~ "    mcr: u8 = 0,\n"
#~ "\n"
#~ "    pub fn new() Serial {\n"
#~ "        return Serial{};\n"
#~ "    }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "fn handleSerialIn(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    switch (qual.port) {\n"
#~ "        // Receive buffer.\n"
#~ "        0x3F8 => regs.rax = am.inb(qual.port), // pass-through\n"
#~ "        // Interrupt Enable Register (DLAB=1) / Divisor Latch High "
#~ "Register (DLAB=0).\n"
#~ "        0x3F9 => regs.rax = vcpu.serial.ier,\n"
#~ "        // Interrupt Identification Register.\n"
#~ "        0x3FA => regs.rax = am.inb(qual.port), // pass-through\n"
#~ "        // Line Control Register (MSB is DLAB).\n"
#~ "        0x3FB => regs.rax = 0x00,\n"
#~ "        // Modem Control Register.\n"
#~ "        0x3FC => regs.rax = vcpu.serial.mcr,\n"
#~ "        // Line Status Register.\n"
#~ "        0x3FD => regs.rax = am.inb(qual.port), // pass-through\n"
#~ "        // Modem Status Register.\n"
#~ "        0x3FE => regs.rax = am.inb(qual.port), // pass-through\n"
#~ "        // Scratch Register.\n"
#~ "        0x3FF => regs.rax = 0, // 8250\n"
#~ "        else => {\n"
#~ "            log.err(\"Unsupported I/O-in to the first serial port: "
#~ "0x{X}\", .{qual.port});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "fn handleSerialIn(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    switch (qual.port) {\n"
#~ "        // Receive buffer.\n"
#~ "        0x3F8 => regs.rax = am.inb(qual.port), // pass-through\n"
#~ "        // Interrupt Enable Register (DLAB=1) / Divisor Latch High "
#~ "Register (DLAB=0).\n"
#~ "        0x3F9 => regs.rax = vcpu.serial.ier,\n"
#~ "        // Interrupt Identification Register.\n"
#~ "        0x3FA => regs.rax = am.inb(qual.port), // pass-through\n"
#~ "        // Line Control Register (MSB is DLAB).\n"
#~ "        0x3FB => regs.rax = 0x00,\n"
#~ "        // Modem Control Register.\n"
#~ "        0x3FC => regs.rax = vcpu.serial.mcr,\n"
#~ "        // Line Status Register.\n"
#~ "        0x3FD => regs.rax = am.inb(qual.port), // pass-through\n"
#~ "        // Modem Status Register.\n"
#~ "        0x3FE => regs.rax = am.inb(qual.port), // pass-through\n"
#~ "        // Scratch Register.\n"
#~ "        0x3FF => regs.rax = 0, // 8250\n"
#~ "        else => {\n"
#~ "            log.err(\"Unsupported I/O-in to the first serial port: "
#~ "0x{X}\", .{qual.port});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "const sr = arch.serial;\n"
#~ "\n"
#~ "fn handleSerialOut(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    switch (qual.port) {\n"
#~ "        // Transmit buffer.\n"
#~ "        0x3F8 => sr.writeByte(@truncate(regs.rax), .com1),\n"
#~ "        // Interrupt Enable Register.\n"
#~ "        0x3F9 => vcpu.serial.ier = @truncate(regs.rax),\n"
#~ "        // FIFO control registers.\n"
#~ "        0x3FA => {}, // ignore\n"
#~ "        // Line Control Register (MSB is DLAB).\n"
#~ "        0x3FB => {}, // ignore\n"
#~ "        // Modem Control Register.\n"
#~ "        0x3FC => vcpu.serial.mcr = @truncate(regs.rax),\n"
#~ "        // Scratch Register.\n"
#~ "        0x3FF => {}, // ignore\n"
#~ "        else => {\n"
#~ "            log.err(\"Unsupported I/O-out to the first serial port: "
#~ "0x{X}\", .{qual.port});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "const sr = arch.serial;\n"
#~ "\n"
#~ "fn handleSerialOut(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    switch (qual.port) {\n"
#~ "        // Transmit buffer.\n"
#~ "        0x3F8 => sr.writeByte(@truncate(regs.rax), .com1),\n"
#~ "        // Interrupt Enable Register.\n"
#~ "        0x3F9 => vcpu.serial.ier = @truncate(regs.rax),\n"
#~ "        // FIFO control registers.\n"
#~ "        0x3FA => {}, // ignore\n"
#~ "        // Line Control Register (MSB is DLAB).\n"
#~ "        0x3FB => {}, // ignore\n"
#~ "        // Modem Control Register.\n"
#~ "        0x3FC => vcpu.serial.mcr = @truncate(regs.rax),\n"
#~ "        // Scratch Register.\n"
#~ "        0x3FF => {}, // ignore\n"
#~ "        else => {\n"
#~ "            log.err(\"Unsupported I/O-out to the first serial port: "
#~ "0x{X}\", .{qual.port});\n"
#~ "            vcpu.abort();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "fn handleIoIn(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    switch (qual.port) {\n"
#~ "        0x02E8...0x02EF => {}, // Fourth serial port. Ignore.\n"
#~ "        0x02F8...0x02FF => {}, // Second serial port. Ignore.\n"
#~ "        0x03E8...0x03EF => {}, // Third serial port. Ignore.\n"
#~ "        0x03F8...0x03FF => try handleSerialIn(vcpu, qual),\n"
#~ "        ...\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn handleIoOut(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    switch (qual.port) {\n"
#~ "        0x02E8...0x02EF => {}, // Fourth serial port. Ignore.\n"
#~ "        0x02F8...0x02FF => {}, // Second serial port. Ignore.\n"
#~ "        0x03E8...0x03EF => {}, // Third serial port. Ignore.\n"
#~ "        0x03F8...0x03FF => try handleSerialOut(vcpu, qual),\n"
#~ "        ...\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "fn handleIoIn(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    switch (qual.port) {\n"
#~ "        0x02E8...0x02EF => {}, // Fourth serial port. Ignore.\n"
#~ "        0x02F8...0x02FF => {}, // Second serial port. Ignore.\n"
#~ "        0x03E8...0x03EF => {}, // Third serial port. Ignore.\n"
#~ "        0x03F8...0x03FF => try handleSerialIn(vcpu, qual),\n"
#~ "        ...\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn handleIoOut(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    switch (qual.port) {\n"
#~ "        0x02E8...0x02EF => {}, // Fourth serial port. Ignore.\n"
#~ "        0x02F8...0x02FF => {}, // Second serial port. Ignore.\n"
#~ "        0x03E8...0x03EF => {}, // Third serial port. Ignore.\n"
#~ "        0x03F8...0x03FF => try handleSerialOut(vcpu, qual),\n"
#~ "        ...\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "pub const Pic = struct {\n"
#~ "    /// Mask of the primary PIC.\n"
#~ "    primary_mask: u8,\n"
#~ "    /// Mask of the secondary PIC.\n"
#~ "    secondary_mask: u8,\n"
#~ "    /// Initialization phase of the primary PIC.\n"
#~ "    primary_phase: InitPhase = .uninitialized,\n"
#~ "    /// Initialization phase of the secondary PIC.\n"
#~ "    secondary_phase: InitPhase = .uninitialized,\n"
#~ "    /// Vector offset of the primary PIC.\n"
#~ "    primary_base: u8 = 0,\n"
#~ "    /// Vector offset of the secondary PIC.\n"
#~ "    secondary_base: u8 = 0,\n"
#~ "\n"
#~ "    const InitPhase = enum {\n"
#~ "        uninitialized,  // ICW1 が送信される前\n"
#~ "        phase1,         // ICW1 が送信された後\n"
#~ "        phase2,         // ICW2 が送信された後\n"
#~ "        phase3,         // ICW3 が送信された後\n"
#~ "        inited,         // ICW4 が送信され初期化終了\n"
#~ "    };\n"
#~ "\n"
#~ "    pub fn new() Pic {\n"
#~ "        return Pic{\n"
#~ "            .primary_mask = 0xFF,\n"
#~ "            .secondary_mask = 0xFF,\n"
#~ "        };\n"
#~ "    }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "pub const Pic = struct {\n"
#~ "    /// Mask of the primary PIC.\n"
#~ "    primary_mask: u8,\n"
#~ "    /// Mask of the secondary PIC.\n"
#~ "    secondary_mask: u8,\n"
#~ "    /// Initialization phase of the primary PIC.\n"
#~ "    primary_phase: InitPhase = .uninitialized,\n"
#~ "    /// Initialization phase of the secondary PIC.\n"
#~ "    secondary_phase: InitPhase = .uninitialized,\n"
#~ "    /// Vector offset of the primary PIC.\n"
#~ "    primary_base: u8 = 0,\n"
#~ "    /// Vector offset of the secondary PIC.\n"
#~ "    secondary_base: u8 = 0,\n"
#~ "\n"
#~ "    const InitPhase = enum {\n"
#~ "        uninitialized,  // ICW1 が送信される前\n"
#~ "        phase1,         // ICW1 が送信された後\n"
#~ "        phase2,         // ICW2 が送信された後\n"
#~ "        phase3,         // ICW3 が送信された後\n"
#~ "        inited,         // ICW4 が送信され初期化終了\n"
#~ "    };\n"
#~ "\n"
#~ "    pub fn new() Pic {\n"
#~ "        return Pic{\n"
#~ "            .primary_mask = 0xFF,\n"
#~ "            .secondary_mask = 0xFF,\n"
#~ "        };\n"
#~ "    }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "fn handlePicIn(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    const pic = &vcpu.pic;\n"
#~ "\n"
#~ "    switch (qual.port) {\n"
#~ "        // Primary PIC data.\n"
#~ "        0x21 => switch (pic.primary_phase) {\n"
#~ "            .uninitialized, .inited => regs.rax = pic.primary_mask,\n"
#~ "            else => vcpu.abort(),\n"
#~ "        },\n"
#~ "        // Secondary PIC data.\n"
#~ "        0xA1 => switch (pic.secondary_phase) {\n"
#~ "            .uninitialized, .inited => regs.rax = pic.secondary_mask,\n"
#~ "            else => vcpu.abort(),\n"
#~ "        },\n"
#~ "        else => vcpu.abort(),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "fn handlePicIn(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    const pic = &vcpu.pic;\n"
#~ "\n"
#~ "    switch (qual.port) {\n"
#~ "        // Primary PIC data.\n"
#~ "        0x21 => switch (pic.primary_phase) {\n"
#~ "            .uninitialized, .inited => regs.rax = pic.primary_mask,\n"
#~ "            else => vcpu.abort(),\n"
#~ "        },\n"
#~ "        // Secondary PIC data.\n"
#~ "        0xA1 => switch (pic.secondary_phase) {\n"
#~ "            .uninitialized, .inited => regs.rax = pic.secondary_mask,\n"
#~ "            else => vcpu.abort(),\n"
#~ "        },\n"
#~ "        else => vcpu.abort(),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "fn handlePicOut(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    const pic = &vcpu.pic;\n"
#~ "    const dx: u8 = @truncate(regs.rax);\n"
#~ "\n"
#~ "    switch (qual.port) {\n"
#~ "        // Primary PIC command.\n"
#~ "        0x20 => switch (dx) {\n"
#~ "            0x11 => pic.primary_phase = .phase1,\n"
#~ "            // Specific-EOI.\n"
#~ "            // It's Ymir's responsibility to send EOI, so guests are not "
#~ "allowed to send EOI.\n"
#~ "            0x60...0x67 => {},\n"
#~ "            else => vcpu.abort(),\n"
#~ "        },\n"
#~ "        // Primary PIC data.\n"
#~ "        0x21 => switch (pic.primary_phase) {\n"
#~ "            .uninitialized, .inited => pic.primary_mask = dx,\n"
#~ "            .phase1 => {\n"
#~ "                log.info(\"Primary PIC vector offset: 0x{X}\", .{dx});\n"
#~ "                pic.primary_base = dx;\n"
#~ "                pic.primary_phase = .phase2;\n"
#~ "            },\n"
#~ "            .phase2 =>\n"
#~ "                if (dx != (1 << 2)) vcpu.abort(),\n"
#~ "                else pic.primary_phase = .phase3,\n"
#~ "            .phase3 => pic.primary_phase = .inited,\n"
#~ "        },\n"
#~ "\n"
#~ "        // Secondary PIC command.\n"
#~ "        0xA0 => switch (dx) {\n"
#~ "            0x11 => pic.secondary_phase = .phase1,\n"
#~ "            // Specific-EOI.\n"
#~ "            // It's Ymir's responsibility to send EOI, so guests are not "
#~ "allowed to send EOI.\n"
#~ "            0x60...0x67 => {},\n"
#~ "            else => vcpu.abort(),\n"
#~ "        },\n"
#~ "        // Secondary PIC data.\n"
#~ "        0xA1 => switch (pic.secondary_phase) {\n"
#~ "            .uninitialized, .inited => pic.secondary_mask = dx,\n"
#~ "            .phase1 => {\n"
#~ "                log.info(\"Secondary PIC vector offset: 0x{X}\", .{dx});\n"
#~ "                pic.secondary_base = dx;\n"
#~ "                pic.secondary_phase = .phase2;\n"
#~ "            },\n"
#~ "            .phase2 =>\n"
#~ "                if (dx != 2) vcpu.abort(),\n"
#~ "                else pic.secondary_phase = .phase3,\n"
#~ "            .phase3 => pic.secondary_phase = .inited,\n"
#~ "        },\n"
#~ "        else => vcpu.abort(),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "fn handlePicOut(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    const pic = &vcpu.pic;\n"
#~ "    const dx: u8 = @truncate(regs.rax);\n"
#~ "\n"
#~ "    switch (qual.port) {\n"
#~ "        // Primary PIC command.\n"
#~ "        0x20 => switch (dx) {\n"
#~ "            0x11 => pic.primary_phase = .phase1,\n"
#~ "            // Specific-EOI.\n"
#~ "            // It's Ymir's responsibility to send EOI, so guests are not "
#~ "allowed to send EOI.\n"
#~ "            0x60...0x67 => {},\n"
#~ "            else => vcpu.abort(),\n"
#~ "        },\n"
#~ "        // Primary PIC data.\n"
#~ "        0x21 => switch (pic.primary_phase) {\n"
#~ "            .uninitialized, .inited => pic.primary_mask = dx,\n"
#~ "            .phase1 => {\n"
#~ "                log.info(\"Primary PIC vector offset: 0x{X}\", .{dx});\n"
#~ "                pic.primary_base = dx;\n"
#~ "                pic.primary_phase = .phase2;\n"
#~ "            },\n"
#~ "            .phase2 =>\n"
#~ "                if (dx != (1 << 2)) vcpu.abort(),\n"
#~ "                else pic.primary_phase = .phase3,\n"
#~ "            .phase3 => pic.primary_phase = .inited,\n"
#~ "        },\n"
#~ "\n"
#~ "        // Secondary PIC command.\n"
#~ "        0xA0 => switch (dx) {\n"
#~ "            0x11 => pic.secondary_phase = .phase1,\n"
#~ "            // Specific-EOI.\n"
#~ "            // It's Ymir's responsibility to send EOI, so guests are not "
#~ "allowed to send EOI.\n"
#~ "            0x60...0x67 => {},\n"
#~ "            else => vcpu.abort(),\n"
#~ "        },\n"
#~ "        // Secondary PIC data.\n"
#~ "        0xA1 => switch (pic.secondary_phase) {\n"
#~ "            .uninitialized, .inited => pic.secondary_mask = dx,\n"
#~ "            .phase1 => {\n"
#~ "                log.info(\"Secondary PIC vector offset: 0x{X}\", .{dx});\n"
#~ "                pic.secondary_base = dx;\n"
#~ "                pic.secondary_phase = .phase2;\n"
#~ "            },\n"
#~ "            .phase2 =>\n"
#~ "                if (dx != 2) vcpu.abort(),\n"
#~ "                else pic.secondary_phase = .phase3,\n"
#~ "            .phase3 => pic.secondary_phase = .inited,\n"
#~ "        },\n"
#~ "        else => vcpu.abort(),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "fn handleIoIn(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    switch (qual.port) {\n"
#~ "        0x0020...0x0021 => try handlePicIn(vcpu, qual),\n"
#~ "        0x0040...0x0047 => try handlePitIn(vcpu, qual),\n"
#~ "        0x0060...0x0064 => regs.rax = 0,                // PS/2. "
#~ "Unimplemented.\n"
#~ "        0x0070...0x0071 => regs.rax = 0,                // RTC. "
#~ "Unimplemented.\n"
#~ "        0x0080...0x008F => {},                          // DMA. "
#~ "Unimplemented.\n"
#~ "        0x00A0...0x00A1 => try handlePicIn(vcpu, qual),\n"
#~ "        0x02E8...0x02EF => {},                          // Fourth serial "
#~ "port. Ignore.\n"
#~ "        0x02F8...0x02FF => {},                          // Second serial "
#~ "port. Ignore.\n"
#~ "        0x03B0...0x03DF => regs.rax = 0,                // VGA. "
#~ "Uniimplemented.\n"
#~ "        0x03E8...0x03EF => {},                          // Third serial "
#~ "port. Ignore.\n"
#~ "        0x03F8...0x03FF => try handleSerialIn(vcpu, qual),\n"
#~ "        0x0CF8...0x0CFF => regs.rax = 0,                // PCI. "
#~ "Unimplemented.\n"
#~ "        0xC000...0xCFFF => {},                          // Old PCI. "
#~ "Ignore.\n"
#~ "        else => vcpu.abort(),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn handleIoOut(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    switch (qual.port) {\n"
#~ "        0x0020...0x0021 => try handlePicOut(vcpu, qual),\n"
#~ "        0x0040...0x0047 => try handlePitOut(vcpu, qual),\n"
#~ "        0x0060...0x0064 => {},                          // PS/2. "
#~ "Unimplemented.\n"
#~ "        0x0070...0x0071 => {},                          // RTC. "
#~ "Unimplemented.\n"
#~ "        0x0080...0x008F => {},                          // DMA. "
#~ "Unimplemented.\n"
#~ "        0x00A0...0x00A1 => try handlePicOut(vcpu, qual),\n"
#~ "        0x02E8...0x02EF => {},                          // Fourth serial "
#~ "port. Ignore.\n"
#~ "        0x02F8...0x02FF => {},                          // Second serial "
#~ "port. Ignore.\n"
#~ "        0x03B0...0x03DF => {},                          // VGA. "
#~ "Uniimplemented.\n"
#~ "        0x03F8...0x03FF => try handleSerialOut(vcpu, qual),\n"
#~ "        0x03E8...0x03EF => {},                          // Third serial "
#~ "port. Ignore.\n"
#~ "        0x0CF8...0x0CFF => {},                          // PCI. "
#~ "Unimplemented.\n"
#~ "        0xC000...0xCFFF => {},                          // Old PCI. "
#~ "Ignore.\n"
#~ "        else => vcpu.abort(),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/io.zig\n"
#~ "fn handleIoIn(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    switch (qual.port) {\n"
#~ "        0x0020...0x0021 => try handlePicIn(vcpu, qual),\n"
#~ "        0x0040...0x0047 => try handlePitIn(vcpu, qual),\n"
#~ "        0x0060...0x0064 => regs.rax = 0,                // PS/2. "
#~ "Unimplemented.\n"
#~ "        0x0070...0x0071 => regs.rax = 0,                // RTC. "
#~ "Unimplemented.\n"
#~ "        0x0080...0x008F => {},                          // DMA. "
#~ "Unimplemented.\n"
#~ "        0x00A0...0x00A1 => try handlePicIn(vcpu, qual),\n"
#~ "        0x02E8...0x02EF => {},                          // Fourth serial "
#~ "port. Ignore.\n"
#~ "        0x02F8...0x02FF => {},                          // Second serial "
#~ "port. Ignore.\n"
#~ "        0x03B0...0x03DF => regs.rax = 0,                // VGA. "
#~ "Uniimplemented.\n"
#~ "        0x03E8...0x03EF => {},                          // Third serial "
#~ "port. Ignore.\n"
#~ "        0x03F8...0x03FF => try handleSerialIn(vcpu, qual),\n"
#~ "        0x0CF8...0x0CFF => regs.rax = 0,                // PCI. "
#~ "Unimplemented.\n"
#~ "        0xC000...0xCFFF => {},                          // Old PCI. "
#~ "Ignore.\n"
#~ "        else => vcpu.abort(),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn handleIoOut(vcpu: *Vcpu, qual: QualIo) VmxError!void {\n"
#~ "    const regs = &vcpu.guest_regs;\n"
#~ "    switch (qual.port) {\n"
#~ "        0x0020...0x0021 => try handlePicOut(vcpu, qual),\n"
#~ "        0x0040...0x0047 => try handlePitOut(vcpu, qual),\n"
#~ "        0x0060...0x0064 => {},                          // PS/2. "
#~ "Unimplemented.\n"
#~ "        0x0070...0x0071 => {},                          // RTC. "
#~ "Unimplemented.\n"
#~ "        0x0080...0x008F => {},                          // DMA. "
#~ "Unimplemented.\n"
#~ "        0x00A0...0x00A1 => try handlePicOut(vcpu, qual),\n"
#~ "        0x02E8...0x02EF => {},                          // Fourth serial "
#~ "port. Ignore.\n"
#~ "        0x02F8...0x02FF => {},                          // Second serial "
#~ "port. Ignore.\n"
#~ "        0x03B0...0x03DF => {},                          // VGA. "
#~ "Uniimplemented.\n"
#~ "        0x03F8...0x03FF => try handleSerialOut(vcpu, qual),\n"
#~ "        0x03E8...0x03EF => {},                          // Third serial "
#~ "port. Ignore.\n"
#~ "        0x0CF8...0x0CFF => {},                          // PCI. "
#~ "Unimplemented.\n"
#~ "        0xC000...0xCFFF => {},                          // Old PCI. "
#~ "Ignore.\n"
#~ "        else => vcpu.abort(),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```init/calibrate.c\n"
#~ "/* wait for \"start of\" clock tick */\n"
#~ "ticks = jiffies;\n"
#~ "while (ticks == jiffies)\n"
#~ "    ; /* nothing */\n"
#~ "/* Go .. */\n"
#~ "ticks = jiffies;\n"
#~ "```"
#~ msgstr ""
#~ "```init/calibrate.c\n"
#~ "/* wait for \"start of\" clock tick */\n"
#~ "ticks = jiffies;\n"
#~ "while (ticks == jiffies)\n"
#~ "    ; /* nothing */\n"
#~ "/* Go .. */\n"
#~ "ticks = jiffies;\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/interrupt.zig\n"
#~ "pub const Subscriber = struct {\n"
#~ "    /// Context of the subscriber.\n"
#~ "    self: *anyopaque,\n"
#~ "    /// Context of the interrupt.\n"
#~ "    callback: Callback,\n"
#~ "\n"
#~ "    pub const Callback = *const fn (*anyopaque, *Context) void;\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/interrupt.zig\n"
#~ "pub const Subscriber = struct {\n"
#~ "    /// Context of the subscriber.\n"
#~ "    self: *anyopaque,\n"
#~ "    /// Context of the interrupt.\n"
#~ "    callback: Callback,\n"
#~ "\n"
#~ "    pub const Callback = *const fn (*anyopaque, *Context) void;\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/interrupt.zig\n"
#~ "pub fn dispatch(context: *Context) void {\n"
#~ "    const vector = context.vector;\n"
#~ "    // Notify subscribers.\n"
#~ "    for (subscribers) |subscriber| {\n"
#~ "        if (subscriber) |s| s.callback(s.self, context);\n"
#~ "    }\n"
#~ "    // Call the handler.\n"
#~ "    handlers[vector](context);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/interrupt.zig\n"
#~ "pub fn dispatch(context: *Context) void {\n"
#~ "    const vector = context.vector;\n"
#~ "    // Notify subscribers.\n"
#~ "    for (subscribers) |subscriber| {\n"
#~ "        if (subscriber) |s| s.callback(s.self, context);\n"
#~ "    }\n"
#~ "    // Call the handler.\n"
#~ "    handlers[vector](context);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.tmp.zig\n"
#~ "const A = struct { value: u64 };\n"
#~ "var something: A = .{ .value = 0xDEAD };\n"
#~ "try arch.intr.subscribe(&something, blobSubscriber);\n"
#~ "\n"
#~ "fn blobSubscriber(p: *anyopaque, _: *arch.intr.Context) void {\n"
#~ "    const self: *A = @alignCast(@ptrCast(p));\n"
#~ "    log.debug(\"self: value = {X}\", .{self.value});\n"
#~ "    @panic(\"Subscriber is HERE!!!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.tmp.zig\n"
#~ "const A = struct { value: u64 };\n"
#~ "var something: A = .{ .value = 0xDEAD };\n"
#~ "try arch.intr.subscribe(&something, blobSubscriber);\n"
#~ "\n"
#~ "fn blobSubscriber(p: *anyopaque, _: *arch.intr.Context) void {\n"
#~ "    const self: *A = @alignCast(@ptrCast(p));\n"
#~ "    log.debug(\"self: value = {X}\", .{self.value});\n"
#~ "    @panic(\"Subscriber is HERE!!!\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn injectExtIntr(self: *Self) VmxError!bool {\n"
#~ "    const pending = self.pending_irq;\n"
#~ "\n"
#~ "    // 1. No interrupts to inject.\n"
#~ "    if (pending == 0) return false;\n"
#~ "    // 2. PIC is not initialized.\n"
#~ "    if (self.pic.primary_phase != .inited) return false;\n"
#~ "\n"
#~ "    // 3. Guest is blocking interrupts.\n"
#~ "    const eflags: am.FlagsRegister = @bitCast(try vmread(vmcs.guest."
#~ "rflags));\n"
#~ "    if (!eflags.ief) return false;\n"
#~ "\n"
#~ "    ...\n"
#~ "\n"
#~ "    return false;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn injectExtIntr(self: *Self) VmxError!bool {\n"
#~ "    const pending = self.pending_irq;\n"
#~ "\n"
#~ "    // 1. No interrupts to inject.\n"
#~ "    if (pending == 0) return false;\n"
#~ "    // 2. PIC is not initialized.\n"
#~ "    if (self.pic.primary_phase != .inited) return false;\n"
#~ "\n"
#~ "    // 3. Guest is blocking interrupts.\n"
#~ "    const eflags: am.FlagsRegister = @bitCast(try vmread(vmcs.guest."
#~ "rflags));\n"
#~ "    if (!eflags.ief) return false;\n"
#~ "\n"
#~ "    ...\n"
#~ "\n"
#~ "    return false;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn injectExtIntr(self: *Self) VmxError!bool {\n"
#~ "    ...\n"
#~ "    const is_secondary_masked = bits.isset(self.pic.primary_mask, IrqLine."
#~ "secondary);\n"
#~ "    for (0..15) |i| {\n"
#~ "        if (is_secondary_masked and i >= 8) break;\n"
#~ "\n"
#~ "        const irq: IrqLine = @enumFromInt(i);\n"
#~ "        const irq_bit = bits.tobit(u16, irq);\n"
#~ "        // The IRQ is not pending.\n"
#~ "        if (pending & irq_bit == 0) continue;\n"
#~ "\n"
#~ "        // Check if the IRQ is masked.\n"
#~ "        const is_masked = if (irq.isPrimary()) b: {\n"
#~ "            break :b bits.isset(self.pic.primary_mask, irq.delta());\n"
#~ "        } else b: {\n"
#~ "            const is_irq_masked = bits.isset(self.pic.secondary_mask, irq."
#~ "delta());\n"
#~ "            break :b is_secondary_masked or is_irq_masked;\n"
#~ "        };\n"
#~ "        if (is_masked) continue;\n"
#~ "        ...\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn injectExtIntr(self: *Self) VmxError!bool {\n"
#~ "    ...\n"
#~ "    const is_secondary_masked = bits.isset(self.pic.primary_mask, IrqLine."
#~ "secondary);\n"
#~ "    for (0..15) |i| {\n"
#~ "        if (is_secondary_masked and i >= 8) break;\n"
#~ "\n"
#~ "        const irq: IrqLine = @enumFromInt(i);\n"
#~ "        const irq_bit = bits.tobit(u16, irq);\n"
#~ "        // The IRQ is not pending.\n"
#~ "        if (pending & irq_bit == 0) continue;\n"
#~ "\n"
#~ "        // Check if the IRQ is masked.\n"
#~ "        const is_masked = if (irq.isPrimary()) b: {\n"
#~ "            break :b bits.isset(self.pic.primary_mask, irq.delta());\n"
#~ "        } else b: {\n"
#~ "            const is_irq_masked = bits.isset(self.pic.secondary_mask, irq."
#~ "delta());\n"
#~ "            break :b is_secondary_masked or is_irq_masked;\n"
#~ "        };\n"
#~ "        if (is_masked) continue;\n"
#~ "        ...\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn injectExtIntr(self: *Self) VmxError!bool {\n"
#~ "    ...\n"
#~ "    for (0..15) |i| {\n"
#~ "        const intr_info = vmx.EntryIntrInfo{\n"
#~ "            .vector = irq.delta() + if (irq.isPrimary()) self.pic."
#~ "primary_base else self.pic.secondary_base,\n"
#~ "            .type = .external,\n"
#~ "            .ec_available = false,\n"
#~ "            .valid = true,\n"
#~ "        };\n"
#~ "        try vmwrite(vmcs.ctrl.entry_intr_info, intr_info);\n"
#~ "\n"
#~ "        // Clear the pending IRQ.\n"
#~ "        self.pending_irq &= ~irq_bit;\n"
#~ "        return true;\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "fn injectExtIntr(self: *Self) VmxError!bool {\n"
#~ "    ...\n"
#~ "    for (0..15) |i| {\n"
#~ "        const intr_info = vmx.EntryIntrInfo{\n"
#~ "            .vector = irq.delta() + if (irq.isPrimary()) self.pic."
#~ "primary_base else self.pic.secondary_base,\n"
#~ "            .type = .external,\n"
#~ "            .ec_available = false,\n"
#~ "            .valid = true,\n"
#~ "        };\n"
#~ "        try vmwrite(vmcs.ctrl.entry_intr_info, intr_info);\n"
#~ "\n"
#~ "        // Clear the pending IRQ.\n"
#~ "        self.pending_irq &= ~irq_bit;\n"
#~ "        return true;\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ ".extintr => {\n"
#~ "    // Consume the interrupt by Ymir.\n"
#~ "    // At the same time, interrupt subscriber sets the pending IRQ.\n"
#~ "    asm volatile (\n"
#~ "        \\\\sti\n"
#~ "        \\\\nop\n"
#~ "        \\\\cli\n"
#~ "    );\n"
#~ "    // Give the external interrupt to guest.\n"
#~ "    _ = try self.injectExtIntr();\n"
#~ "},\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ ".extintr => {\n"
#~ "    // Consume the interrupt by Ymir.\n"
#~ "    // At the same time, interrupt subscriber sets the pending IRQ.\n"
#~ "    asm volatile (\n"
#~ "        \\\\sti\n"
#~ "        \\\\nop\n"
#~ "        \\\\cli\n"
#~ "    );\n"
#~ "    // Give the external interrupt to guest.\n"
#~ "    _ = try self.injectExtIntr();\n"
#~ "},\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "    .hlt => {\n"
#~ "        // Wait until the external interrupt is generated.\n"
#~ "        while (!try self.injectExtIntr()) {\n"
#~ "            asm volatile (\n"
#~ "                \\\\sti\n"
#~ "                \\\\hlt\n"
#~ "                \\\\cli\n"
#~ "            );\n"
#~ "        }\n"
#~ "\n"
#~ "        try vmwrite(vmcs.guest.activity_state, 0);\n"
#~ "        try vmwrite(vmcs.guest.interruptibility_state, 0);\n"
#~ "        try self.stepNextInst();\n"
#~ "    },\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vcpu.zig\n"
#~ "    .hlt => {\n"
#~ "        // Wait until the external interrupt is generated.\n"
#~ "        while (!try self.injectExtIntr()) {\n"
#~ "            asm volatile (\n"
#~ "                \\\\sti\n"
#~ "                \\\\hlt\n"
#~ "                \\\\cli\n"
#~ "            );\n"
#~ "        }\n"
#~ "\n"
#~ "        try vmwrite(vmcs.guest.activity_state, 0);\n"
#~ "        try vmwrite(vmcs.guest.interruptibility_state, 0);\n"
#~ "        try self.stepNextInst();\n"
#~ "    },\n"
#~ "```"

#~ msgid "# 展開\n"
#~ msgstr "# 展開\n"

#~ msgid "# 圧縮\n"
#~ msgstr "# 圧縮\n"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "const initrd = openFile(root_dir, \"rootfs.cpio.gz\") catch return ."
#~ "Aborted;\n"
#~ "const initrd_info_buffer_size: usize = @sizeOf(uefi.FileInfo) + 0x100;\n"
#~ "var initrd_info_actual_size = initrd_info_buffer_size;\n"
#~ "var initrd_info_buffer: [initrd_info_buffer_size]u8 align(@alignOf(uefi."
#~ "FileInfo)) = undefined;\n"
#~ "status = initrd.getInfo(&uefi.FileInfo.guid, &initrd_info_actual_size, "
#~ "&initrd_info_buffer);\n"
#~ "if (status != .Success) return status;\n"
#~ "\n"
#~ "const initrd_info: *const uefi.FileInfo = "
#~ "@alignCast(@ptrCast(&initrd_info_buffer));\n"
#~ "var initrd_size = initrd_info.file_size;\n"
#~ "var initrd_start: u64 = undefined;\n"
#~ "const initrd_size_pages = (initrd_size + (page_size - 1)) / page_size;\n"
#~ "status = boot_service.allocatePages(.AllocateAnyPages, .LoaderData, "
#~ "initrd_size_pages, @ptrCast(&initrd_start));\n"
#~ "if (status != .Success) return status;\n"
#~ "\n"
#~ "status = initrd.read(&initrd_size, @ptrFromInt(initrd_start));\n"
#~ "if (status != .Success) return status;\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "const initrd = openFile(root_dir, \"rootfs.cpio.gz\") catch return ."
#~ "Aborted;\n"
#~ "const initrd_info_buffer_size: usize = @sizeOf(uefi.FileInfo) + 0x100;\n"
#~ "var initrd_info_actual_size = initrd_info_buffer_size;\n"
#~ "var initrd_info_buffer: [initrd_info_buffer_size]u8 align(@alignOf(uefi."
#~ "FileInfo)) = undefined;\n"
#~ "status = initrd.getInfo(&uefi.FileInfo.guid, &initrd_info_actual_size, "
#~ "&initrd_info_buffer);\n"
#~ "if (status != .Success) return status;\n"
#~ "\n"
#~ "const initrd_info: *const uefi.FileInfo = "
#~ "@alignCast(@ptrCast(&initrd_info_buffer));\n"
#~ "var initrd_size = initrd_info.file_size;\n"
#~ "var initrd_start: u64 = undefined;\n"
#~ "const initrd_size_pages = (initrd_size + (page_size - 1)) / page_size;\n"
#~ "status = boot_service.allocatePages(.AllocateAnyPages, .LoaderData, "
#~ "initrd_size_pages, @ptrCast(&initrd_start));\n"
#~ "if (status != .Success) return status;\n"
#~ "\n"
#~ "status = initrd.read(&initrd_size, @ptrFromInt(initrd_start));\n"
#~ "if (status != .Success) return status;\n"
#~ "```"

#~ msgid ""
#~ "```surtr/defs.zig\n"
#~ "pub const GuestInfo = extern struct {\n"
#~ "    ...\n"
#~ "    /// Physical address the initrd is loaded.\n"
#~ "    initrd_addr: [*]u8,\n"
#~ "    /// Size in bytes of the initrd.\n"
#~ "    initrd_size: usize,\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/defs.zig\n"
#~ "pub const GuestInfo = extern struct {\n"
#~ "    ...\n"
#~ "    /// Physical address the initrd is loaded.\n"
#~ "    initrd_addr: [*]u8,\n"
#~ "    /// Size in bytes of the initrd.\n"
#~ "    initrd_size: usize,\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "const initrd = b: {\n"
#~ "    const ptr: [*]u8 = @ptrFromInt(ymir.mem.phys2virt(guest_info."
#~ "initrd_addr));\n"
#~ "    break :b ptr[0..guest_info.initrd_size];\n"
#~ "};\n"
#~ "log.info(\"initrd: 0x{X:0>16} (size=0x{X})\", .{ @intFromPtr(initrd.ptr), "
#~ "initrd.len });\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "const initrd = b: {\n"
#~ "    const ptr: [*]u8 = @ptrFromInt(ymir.mem.phys2virt(guest_info."
#~ "initrd_addr));\n"
#~ "    break :b ptr[0..guest_info.initrd_size];\n"
#~ "};\n"
#~ "log.info(\"initrd: 0x{X:0>16} (size=0x{X})\", .{ @intFromPtr(initrd.ptr), "
#~ "initrd.len });\n"
#~ "```"

#~ msgid ""
#~ "```ymir/vmx.zig\n"
#~ "fn loadKernel(self: *Self, kernel: []u8, initrd: []u8) Error!void {\n"
#~ "    ...\n"
#~ "    // Load initrd\n"
#~ "    bp.hdr.ramdisk_image = linux.layout.initrd;\n"
#~ "    bp.hdr.ramdisk_size = @truncate(initrd.len);\n"
#~ "    try loadImage(guest_mem, initrd, linux.layout.initrd);\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/vmx.zig\n"
#~ "fn loadKernel(self: *Self, kernel: []u8, initrd: []u8) Error!void {\n"
#~ "    ...\n"
#~ "    // Load initrd\n"
#~ "    bp.hdr.ramdisk_image = linux.layout.initrd;\n"
#~ "    bp.hdr.ramdisk_size = @truncate(initrd.len);\n"
#~ "    try loadImage(guest_mem, initrd, linux.layout.initrd);\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vmc.zig\n"
#~ "const VmcallNr = enum(u64) {\n"
#~ "    hello = 0,\n"
#~ "\n"
#~ "    _,\n"
#~ "};\n"
#~ "\n"
#~ "pub fn handleVmcall(vcpu: *Vcpu) VmxError!void {\n"
#~ "    const rax = vcpu.guest_regs.rax;\n"
#~ "    const nr: VmcallNr = @enumFromInt(rax);\n"
#~ "\n"
#~ "    switch (nr) {\n"
#~ "        .hello => try vmcHello(vcpu),\n"
#~ "        _ => log.err(\"Unhandled VMCALL: nr={d}\", .{rax}),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vmc.zig\n"
#~ "const VmcallNr = enum(u64) {\n"
#~ "    hello = 0,\n"
#~ "\n"
#~ "    _,\n"
#~ "};\n"
#~ "\n"
#~ "pub fn handleVmcall(vcpu: *Vcpu) VmxError!void {\n"
#~ "    const rax = vcpu.guest_regs.rax;\n"
#~ "    const nr: VmcallNr = @enumFromInt(rax);\n"
#~ "\n"
#~ "    switch (nr) {\n"
#~ "        .hello => try vmcHello(vcpu),\n"
#~ "        _ => log.err(\"Unhandled VMCALL: nr={d}\", .{rax}),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymir/arch/x86/vmx/vmc.zig\n"
#~ "const logo =\n"
#~ "    \\\\   ____     __ ,---.    ,---..-./`) .-------.\n"
#~ "    \\\\   \\   \\   /  /|    \\  /    |\\ .-.')|  _ _   \\\n"
#~ "    \\\\    \\  _. /  ' |  ,  \\/  ,  |/ `-' \\| ( ' )  |\n"
#~ "    \\\\     _( )_ .'  |  |\\_   /|  | `-'`\"`|(_ o _) /\n"
#~ "    \\\\ ___(_ o _)'   |  _( )_/ |  | .---. | (_,_).' __\n"
#~ "    \\\\|   |(_,_)'    | (_ o _) |  | |   | |  |\\ \\  |  |\n"
#~ "    \\\\|   `-'  /     |  (_,_)  |  | |   | |  | \\ `'   /\n"
#~ "    \\\\ \\      /      |  |      |  | |   | |  |  \\    /\n"
#~ "    \\\\  `-..-'       '--'      '--' '---' ''-'   `'-'\n"
#~ ";\n"
#~ "\n"
#~ "fn vmcHello(_: *Vcpu) VmxError!void {\n"
#~ "    log.info(\"GREETINGS FROM VMX-ROOT...\\n{s}\\n\", .{logo});\n"
#~ "    log.info(\"This OS is hypervisored by Ymir.\\n\", .{});\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/arch/x86/vmx/vmc.zig\n"
#~ "const logo =\n"
#~ "    \\\\   ____     __ ,---.    ,---..-./`) .-------.\n"
#~ "    \\\\   \\   \\   /  /|    \\  /    |\\ .-.')|  _ _   \\\n"
#~ "    \\\\    \\  _. /  ' |  ,  \\/  ,  |/ `-' \\| ( ' )  |\n"
#~ "    \\\\     _( )_ .'  |  |\\_   /|  | `-'`\"`|(_ o _) /\n"
#~ "    \\\\ ___(_ o _)'   |  _( )_/ |  | .---. | (_,_).' __\n"
#~ "    \\\\|   |(_,_)'    | (_ o _) |  | |   | |  |\\ \\  |  |\n"
#~ "    \\\\|   `-'  /     |  (_,_)  |  | |   | |  | \\ `'   /\n"
#~ "    \\\\ \\      /      |  |      |  | |   | |  |  \\    /\n"
#~ "    \\\\  `-..-'       '--'      '--' '---' ''-'   `'-'\n"
#~ ";\n"
#~ "\n"
#~ "fn vmcHello(_: *Vcpu) VmxError!void {\n"
#~ "    log.info(\"GREETINGS FROM VMX-ROOT...\\n{s}\\n\", .{logo});\n"
#~ "    log.info(\"This OS is hypervisored by Ymir.\\n\", .{});\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ymirsh/main.zig\n"
#~ "fn asmVmcall(nr: u64) void {\n"
#~ "    asm volatile (\n"
#~ "        \\\\movq %[nr], %%rax\n"
#~ "        \\\\vmcall\n"
#~ "        :\n"
#~ "        : [nr] \"rax\" (nr),\n"
#~ "        : \"memory\"\n"
#~ "    );\n"
#~ "}\n"
#~ "\n"
#~ "pub fn main() !void {\n"
#~ "    asmVmcall(0);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymirsh/main.zig\n"
#~ "fn asmVmcall(nr: u64) void {\n"
#~ "    asm volatile (\n"
#~ "        \\\\movq %[nr], %%rax\n"
#~ "        \\\\vmcall\n"
#~ "        :\n"
#~ "        : [nr] \"rax\" (nr),\n"
#~ "        : \"memory\"\n"
#~ "    );\n"
#~ "}\n"
#~ "\n"
#~ "pub fn main() !void {\n"
#~ "    asmVmcall(0);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```build.zig\n"
#~ "const ymirsh = b.addExecutable(.{\n"
#~ "    .name = \"ymirsh\",\n"
#~ "    .root_source_file = b.path(\"ymirsh/main.zig\"),\n"
#~ "    .target = b.resolveTargetQuery(.{\n"
#~ "        .cpu_arch = .x86_64,\n"
#~ "        .os_tag = .linux,\n"
#~ "        .cpu_model = .baseline,\n"
#~ "    }),\n"
#~ "    .optimize = optimize,\n"
#~ "    .linkage = .static,\n"
#~ "});\n"
#~ "ymirsh.root_module.addOptions(\"option\", options);\n"
#~ "b.installArtifact(ymirsh);\n"
#~ "```"
#~ msgstr ""
#~ "```build.zig\n"
#~ "const ymirsh = b.addExecutable(.{\n"
#~ "    .name = \"ymirsh\",\n"
#~ "    .root_source_file = b.path(\"ymirsh/main.zig\"),\n"
#~ "    .target = b.resolveTargetQuery(.{\n"
#~ "        .cpu_arch = .x86_64,\n"
#~ "        .os_tag = .linux,\n"
#~ "        .cpu_model = .baseline,\n"
#~ "    }),\n"
#~ "    .optimize = optimize,\n"
#~ "    .linkage = .static,\n"
#~ "});\n"
#~ "ymirsh.root_module.addOptions(\"option\", options);\n"
#~ "b.installArtifact(ymirsh);\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "status = boot_service.freePool(header_buffer);\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to free memory for kernel ELF header.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "status = boot_service.freePool(header_buffer);\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to free memory for kernel ELF header.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "status = kernel.close();\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to close kernel file.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "status = kernel.close();\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to close kernel file.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "status = root_dir.close();\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to close filesystem volume.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "status = root_dir.close();\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to close filesystem volume.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/defs.zig\n"
#~ "pub const MemoryMap = extern struct {\n"
#~ "    /// Total buffer size prepared to store the memory map.\n"
#~ "    buffer_size: usize,\n"
#~ "    /// Memory descriptors.\n"
#~ "    descriptors: [*]uefi.tables.MemoryDescriptor,\n"
#~ "    /// Total memory map size.\n"
#~ "    map_size: usize,\n"
#~ "    /// Map key used to check if the memory map has been changed.\n"
#~ "    map_key: usize,\n"
#~ "    /// Size in bytes of each memory descriptor.\n"
#~ "    descriptor_size: usize,\n"
#~ "    /// UEFI memory descriptor version.\n"
#~ "    descriptor_version: u32,\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/defs.zig\n"
#~ "pub const MemoryMap = extern struct {\n"
#~ "    /// Total buffer size prepared to store the memory map.\n"
#~ "    buffer_size: usize,\n"
#~ "    /// Memory descriptors.\n"
#~ "    descriptors: [*]uefi.tables.MemoryDescriptor,\n"
#~ "    /// Total memory map size.\n"
#~ "    map_size: usize,\n"
#~ "    /// Map key used to check if the memory map has been changed.\n"
#~ "    map_key: usize,\n"
#~ "    /// Size in bytes of each memory descriptor.\n"
#~ "    descriptor_size: usize,\n"
#~ "    /// UEFI memory descriptor version.\n"
#~ "    descriptor_version: u32,\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "var map_iter = defs.MemoryDescriptorIterator.new(map);\n"
#~ "while (true) {\n"
#~ "    if (map_iter.next()) |md| {\n"
#~ "        log.debug(\"  0x{X:0>16} - 0x{X:0>16} : {s}\", .{\n"
#~ "            md.physical_start,\n"
#~ "            md.physical_start + md.number_of_pages * page_size,\n"
#~ "            @tagName(md.type),\n"
#~ "        });\n"
#~ "    } else break;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "var map_iter = defs.MemoryDescriptorIterator.new(map);\n"
#~ "while (true) {\n"
#~ "    if (map_iter.next()) |md| {\n"
#~ "        log.debug(\"  0x{X:0>16} - 0x{X:0>16} : {s}\", .{\n"
#~ "            md.physical_start,\n"
#~ "            md.physical_start + md.number_of_pages * page_size,\n"
#~ "            @tagName(md.type),\n"
#~ "        });\n"
#~ "    } else break;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "log.info(\"Exiting boot services.\", .{});\n"
#~ "status = boot_service.exitBootServices(uefi.handle, map.map_key);\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "log.info(\"Exiting boot services.\", .{});\n"
#~ "status = boot_service.exitBootServices(uefi.handle, map.map_key);\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "if (status != .Success) {\n"
#~ "    map.buffer_size = map_buffer.len;\n"
#~ "    map.map_size = map_buffer.len;\n"
#~ "    status = getMemoryMap(&map, boot_service);\n"
#~ "    if (status != .Success) {\n"
#~ "        log.err(\"Failed to get memory map after failed to exit boot "
#~ "services.\", .{});\n"
#~ "        return status;\n"
#~ "    }\n"
#~ "    status = boot_service.exitBootServices(uefi.handle, map.map_key);\n"
#~ "    if (status != .Success) {\n"
#~ "        log.err(\"Failed to exit boot services.\", .{});\n"
#~ "        return status;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "if (status != .Success) {\n"
#~ "    map.buffer_size = map_buffer.len;\n"
#~ "    map.map_size = map_buffer.len;\n"
#~ "    status = getMemoryMap(&map, boot_service);\n"
#~ "    if (status != .Success) {\n"
#~ "        log.err(\"Failed to get memory map after failed to exit boot "
#~ "services.\", .{});\n"
#~ "        return status;\n"
#~ "    }\n"
#~ "    status = boot_service.exitBootServices(uefi.handle, map.map_key);\n"
#~ "    if (status != .Success) {\n"
#~ "        log.err(\"Failed to exit boot services.\", .{});\n"
#~ "        return status;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-surtr-load_kernel`]"
#~ "(https://github.com/smallkirby/ymir/tree/whiz-surtr-load_kernel) ブランチ"
#~ "にあります。"
#~ msgstr ""
#~ "\\[!IMPORTANT\\] 本チャプターの最終コードは [`whiz-surtr-load_kernel`]"
#~ "(https://github.com/smallkirby/ymir/tree/whiz-surtr-load_kernel) ブランチ"
#~ "にあります。"

#~ msgid "\\[!NOTE\\] 詳しくは..."
#~ msgstr "\\[!NOTE\\] 詳しくは..."

#~ msgid ""
#~ "```build.zig\n"
#~ "ymir.linker_script = b.path(\"ymir/linker.ld\");\n"
#~ "```"
#~ msgstr ""
#~ "```build.zig\n"
#~ "ymir.linker_script = b.path(\"ymir/linker.ld\");\n"
#~ "```"

#~ msgid "\\[!WARNING\\] 本当に良いレイアウトは？"
#~ msgstr "\\[!WARNING\\] 本当に良いレイアウトは？"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "while (true) {\n"
#~ "    const phdr = iter.next() catch |err| {\n"
#~ "        log.err(\"Failed to get program header: {?}\\n\", .{err});\n"
#~ "        return .LoadError;\n"
#~ "    } orelse break;\n"
#~ "    if (phdr.p_type != elf.PT_LOAD) continue;\n"
#~ "    if (phdr.p_paddr < kernel_start_phys) kernel_start_phys = phdr."
#~ "p_paddr;\n"
#~ "    if (phdr.p_vaddr < kernel_start_virt) kernel_start_virt = phdr."
#~ "p_vaddr;\n"
#~ "    if (phdr.p_paddr + phdr.p_memsz > kernel_end_phys) kernel_end_phys = "
#~ "phdr.p_paddr + phdr.p_memsz;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "while (true) {\n"
#~ "    const phdr = iter.next() catch |err| {\n"
#~ "        log.err(\"Failed to get program header: {?}\\n\", .{err});\n"
#~ "        return .LoadError;\n"
#~ "    } orelse break;\n"
#~ "    if (phdr.p_type != elf.PT_LOAD) continue;\n"
#~ "    if (phdr.p_paddr < kernel_start_phys) kernel_start_phys = phdr."
#~ "p_paddr;\n"
#~ "    if (phdr.p_vaddr < kernel_start_virt) kernel_start_virt = phdr."
#~ "p_vaddr;\n"
#~ "    if (phdr.p_paddr + phdr.p_memsz > kernel_end_phys) kernel_end_phys = "
#~ "phdr.p_paddr + phdr.p_memsz;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "const pages_4kib = (kernel_end_phys - kernel_start_phys + (page_size - "
#~ "1)) / page_size;\n"
#~ "log.info(\"Kernel image: 0x{X:0>16} - 0x{X:0>16} (0x{X} pages)\", ."
#~ "{ kernel_start_phys, kernel_end_phys, pages_4kib });\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "const pages_4kib = (kernel_end_phys - kernel_start_phys + (page_size - "
#~ "1)) / page_size;\n"
#~ "log.info(\"Kernel image: 0x{X:0>16} - 0x{X:0>16} (0x{X} pages)\", ."
#~ "{ kernel_start_phys, kernel_end_phys, pages_4kib });\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "status = boot_service.allocatePages(.AllocateAddress, .LoaderData, "
#~ "pages_4kib, @ptrCast(&kernel_start_phys));\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to allocate memory for kernel image: {?}\", ."
#~ "{status});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "log.info(\"Allocated memory for kernel image @ 0x{X:0>16} ~ "
#~ "0x{X:0>16}\", .{ kernel_start_phys, kernel_start_phys + pages_4kib * "
#~ "page_size });\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "status = boot_service.allocatePages(.AllocateAddress, .LoaderData, "
#~ "pages_4kib, @ptrCast(&kernel_start_phys));\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to allocate memory for kernel image: {?}\", ."
#~ "{status});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "log.info(\"Allocated memory for kernel image @ 0x{X:0>16} ~ "
#~ "0x{X:0>16}\", .{ kernel_start_phys, kernel_start_phys + pages_4kib * "
#~ "page_size });\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "for (0..pages_4kib) |i| {\n"
#~ "    arch.page.map4kTo(\n"
#~ "        kernel_start_virt + page_size * i,\n"
#~ "        kernel_start_phys + page_size * i,\n"
#~ "        .read_write,\n"
#~ "        boot_service,\n"
#~ "    ) catch |err| {\n"
#~ "        log.err(\"Failed to map memory for kernel image: {?}\", .{err});\n"
#~ "        return .LoadError;\n"
#~ "    };\n"
#~ "}\n"
#~ "log.info(\"Mapped memory for kernel image.\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "for (0..pages_4kib) |i| {\n"
#~ "    arch.page.map4kTo(\n"
#~ "        kernel_start_virt + page_size * i,\n"
#~ "        kernel_start_phys + page_size * i,\n"
#~ "        .read_write,\n"
#~ "        boot_service,\n"
#~ "    ) catch |err| {\n"
#~ "        log.err(\"Failed to map memory for kernel image: {?}\", .{err});\n"
#~ "        return .LoadError;\n"
#~ "    };\n"
#~ "}\n"
#~ "log.info(\"Mapped memory for kernel image.\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "log.info(\"Loading kernel image...\", .{});\n"
#~ "iter = elf_header.program_header_iterator(kernel);\n"
#~ "while (true) {\n"
#~ "    const phdr = iter.next() catch |err| {\n"
#~ "        log.err(\"Failed to get program header: {?}\\n\", .{err});\n"
#~ "        return .LoadError;\n"
#~ "    } orelse break;\n"
#~ "    if (phdr.p_type != elf.PT_LOAD) continue;\n"
#~ "\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "log.info(\"Loading kernel image...\", .{});\n"
#~ "iter = elf_header.program_header_iterator(kernel);\n"
#~ "while (true) {\n"
#~ "    const phdr = iter.next() catch |err| {\n"
#~ "        log.err(\"Failed to get program header: {?}\\n\", .{err});\n"
#~ "        return .LoadError;\n"
#~ "    } orelse break;\n"
#~ "    if (phdr.p_type != elf.PT_LOAD) continue;\n"
#~ "\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "status = kernel.setPosition(phdr.p_offset);\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to set position for kernel image.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "const segment: [*]u8 = @ptrFromInt(phdr.p_vaddr);\n"
#~ "var mem_size = phdr.p_memsz;\n"
#~ "status = kernel.read(&mem_size, segment);\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to read kernel image.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "log.info(\n"
#~ "    \"  Seg @ 0x{X:0>16} - 0x{X:0>16}\",\n"
#~ "    .{ phdr.p_vaddr, phdr.p_vaddr + phdr.p_memsz },\n"
#~ ");\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "status = kernel.setPosition(phdr.p_offset);\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to set position for kernel image.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "const segment: [*]u8 = @ptrFromInt(phdr.p_vaddr);\n"
#~ "var mem_size = phdr.p_memsz;\n"
#~ "status = kernel.read(&mem_size, segment);\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to read kernel image.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "log.info(\n"
#~ "    \"  Seg @ 0x{X:0>16} - 0x{X:0>16}\",\n"
#~ "    .{ phdr.p_vaddr, phdr.p_vaddr + phdr.p_memsz },\n"
#~ ");\n"
#~ "```"

#~ msgid "\\[!NOTE\\] 仮想アドレスと物理アドレス"
#~ msgstr "\\[!NOTE\\] 仮想アドレスと物理アドレス"

#~ msgid ""
#~ "```surtr/arch.zig\n"
#~ "const builtin = @import(\"builtin\");\n"
#~ "pub usingnamespace switch (builtin.target.cpu.arch) {\n"
#~ "    .x86_64 => @import(\"arch/x86/arch.zig\"),\n"
#~ "    else => @compileError(\"Unsupported architecture.\"),\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/arch.zig\n"
#~ "const builtin = @import(\"builtin\");\n"
#~ "pub usingnamespace switch (builtin.target.cpu.arch) {\n"
#~ "    .x86_64 => @import(\"arch/x86/arch.zig\"),\n"
#~ "    else => @compileError(\"Unsupported architecture.\"),\n"
#~ "};\n"
#~ "```"

#~ msgid "\\[!INFO\\] usingnamespace"
#~ msgstr "\\[!INFO\\] usingnamespace"

#~ msgid ""
#~ "```surtr/arch/x86/arch.zig\n"
#~ "pub const page = @import(\"page.zig\");\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/arch/x86/arch.zig\n"
#~ "pub const page = @import(\"page.zig\");\n"
#~ "```"

#~ msgid ""
#~ "```surtr/arch/x86/page.zig\n"
#~ "const TableLevel = enum { lv4, lv3, lv2, lv1 };\n"
#~ "\n"
#~ "fn EntryBase(table_level: TableLevel) type {\n"
#~ "    return packed struct(u64) {\n"
#~ "        const Self = @This();\n"
#~ "        const level = table_level;\n"
#~ "\n"
#~ "        /// Present.\n"
#~ "        present: bool = true,\n"
#~ "        /// Read/Write.\n"
#~ "        /// If set to false, write access is not allowed to the region.\n"
#~ "        rw: bool,\n"
#~ "        /// User/Supervisor.\n"
#~ "        /// If set to false, user-mode access is not allowed to the "
#~ "region.\n"
#~ "        us: bool,\n"
#~ "        /// Page-level write-through.\n"
#~ "        /// Indirectly determines the memory type used to access the page "
#~ "or page table.\n"
#~ "        pwt: bool = false,\n"
#~ "        /// Page-level cache disable.\n"
#~ "        /// Indirectly determines the memory type used to access the page "
#~ "or page table.\n"
#~ "        pcd: bool = false,\n"
#~ "        /// Accessed.\n"
#~ "        /// Indicates whether this entry has been used for translation.\n"
#~ "        accessed: bool = false,\n"
#~ "        /// Dirty bit.\n"
#~ "        /// Indicates whether software has written to the 2MiB page.\n"
#~ "        /// Ignored when this entry references a page table.\n"
#~ "        dirty: bool = false,\n"
#~ "        /// Page Size.\n"
#~ "        /// If set to true, the entry maps a page.\n"
#~ "        /// If set to false, the entry references a page table.\n"
#~ "        ps: bool,\n"
#~ "        /// Ignored when CR4.PGE != 1.\n"
#~ "        /// Ignored when this entry references a page table.\n"
#~ "        /// Ignored for level-4 entries.\n"
#~ "        global: bool = true,\n"
#~ "        /// Ignored\n"
#~ "        _ignored1: u2 = 0,\n"
#~ "        /// Ignored except for HLAT paging.\n"
#~ "        restart: bool = false,\n"
#~ "        /// When the entry maps a page, physical address of the page.\n"
#~ "        /// When the entry references a page table, 4KB aligned address "
#~ "of the page table.\n"
#~ "        phys: u51,\n"
#~ "        /// Execute Disable.\n"
#~ "        xd: bool = false,\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "const Lv4Entry = EntryBase(.lv4);\n"
#~ "const Lv3Entry = EntryBase(.lv3);\n"
#~ "const Lv2Entry = EntryBase(.lv2);\n"
#~ "const Lv1Entry = EntryBase(.lv1);\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/arch/x86/page.zig\n"
#~ "const TableLevel = enum { lv4, lv3, lv2, lv1 };\n"
#~ "\n"
#~ "fn EntryBase(table_level: TableLevel) type {\n"
#~ "    return packed struct(u64) {\n"
#~ "        const Self = @This();\n"
#~ "        const level = table_level;\n"
#~ "\n"
#~ "        /// Present.\n"
#~ "        present: bool = true,\n"
#~ "        /// Read/Write.\n"
#~ "        /// If set to false, write access is not allowed to the region.\n"
#~ "        rw: bool,\n"
#~ "        /// User/Supervisor.\n"
#~ "        /// If set to false, user-mode access is not allowed to the "
#~ "region.\n"
#~ "        us: bool,\n"
#~ "        /// Page-level write-through.\n"
#~ "        /// Indirectly determines the memory type used to access the page "
#~ "or page table.\n"
#~ "        pwt: bool = false,\n"
#~ "        /// Page-level cache disable.\n"
#~ "        /// Indirectly determines the memory type used to access the page "
#~ "or page table.\n"
#~ "        pcd: bool = false,\n"
#~ "        /// Accessed.\n"
#~ "        /// Indicates whether this entry has been used for translation.\n"
#~ "        accessed: bool = false,\n"
#~ "        /// Dirty bit.\n"
#~ "        /// Indicates whether software has written to the 2MiB page.\n"
#~ "        /// Ignored when this entry references a page table.\n"
#~ "        dirty: bool = false,\n"
#~ "        /// Page Size.\n"
#~ "        /// If set to true, the entry maps a page.\n"
#~ "        /// If set to false, the entry references a page table.\n"
#~ "        ps: bool,\n"
#~ "        /// Ignored when CR4.PGE != 1.\n"
#~ "        /// Ignored when this entry references a page table.\n"
#~ "        /// Ignored for level-4 entries.\n"
#~ "        global: bool = true,\n"
#~ "        /// Ignored\n"
#~ "        _ignored1: u2 = 0,\n"
#~ "        /// Ignored except for HLAT paging.\n"
#~ "        restart: bool = false,\n"
#~ "        /// When the entry maps a page, physical address of the page.\n"
#~ "        /// When the entry references a page table, 4KB aligned address "
#~ "of the page table.\n"
#~ "        phys: u51,\n"
#~ "        /// Execute Disable.\n"
#~ "        xd: bool = false,\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "const Lv4Entry = EntryBase(.lv4);\n"
#~ "const Lv3Entry = EntryBase(.lv3);\n"
#~ "const Lv2Entry = EntryBase(.lv2);\n"
#~ "const Lv1Entry = EntryBase(.lv1);\n"
#~ "```"

#~ msgid ""
#~ "```surtr/arch/x86/page.zig\n"
#~ "pub fn newMapPage(phys: Phys, present: bool) Self {\n"
#~ "    if (level == .lv4) @compileError(\"Lv4 entry cannot map a page\");\n"
#~ "    return Self{\n"
#~ "        .present = present,\n"
#~ "        .rw = true,\n"
#~ "        .us = false,\n"
#~ "        .ps = true,\n"
#~ "        .phys = @truncate(phys >> 12),\n"
#~ "    };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/arch/x86/page.zig\n"
#~ "pub fn newMapPage(phys: Phys, present: bool) Self {\n"
#~ "    if (level == .lv4) @compileError(\"Lv4 entry cannot map a page\");\n"
#~ "    return Self{\n"
#~ "        .present = present,\n"
#~ "        .rw = true,\n"
#~ "        .us = false,\n"
#~ "        .ps = true,\n"
#~ "        .phys = @truncate(phys >> 12),\n"
#~ "    };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/arch/x86/page.zig\n"
#~ "pub fn newMapTable(table: [*]LowerType, present: bool) Self {\n"
#~ "    if (level == .lv1) @compileError(\"Lv1 entry cannot reference a page "
#~ "table\");\n"
#~ "    return Self{\n"
#~ "        .present = present,\n"
#~ "        .rw = true,\n"
#~ "        .us = false,\n"
#~ "        .ps = false,\n"
#~ "        .phys = @truncate(@intFromPtr(table) >> 12),\n"
#~ "    };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/arch/x86/page.zig\n"
#~ "pub fn newMapTable(table: [*]LowerType, present: bool) Self {\n"
#~ "    if (level == .lv1) @compileError(\"Lv1 entry cannot reference a page "
#~ "table\");\n"
#~ "    return Self{\n"
#~ "        .present = present,\n"
#~ "        .rw = true,\n"
#~ "        .us = false,\n"
#~ "        .ps = false,\n"
#~ "        .phys = @truncate(@intFromPtr(table) >> 12),\n"
#~ "    };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/arch/x86/page.zig\n"
#~ "fn getEntry(T: type, vaddr: Virt, paddr: Phys) *T {\n"
#~ "    const table = getTable(T, paddr);\n"
#~ "    const shift = switch (T) {\n"
#~ "        Lv4Entry => 39,\n"
#~ "        Lv3Entry => 30,\n"
#~ "        Lv2Entry => 21,\n"
#~ "        Lv1Entry => 12,\n"
#~ "        else => @compileError(\"Unsupported type\"),\n"
#~ "    };\n"
#~ "    return &table[(vaddr >> shift) & 0x1FF];\n"
#~ "}\n"
#~ "\n"
#~ "fn getLv4Entry(addr: Virt, cr3: Phys) *Lv4Entry {\n"
#~ "    return getEntry(Lv4Entry, addr, cr3);\n"
#~ "}\n"
#~ "fn getLv3Entry(addr: Virt, lv3tbl_paddr: Phys) *Lv3Entry {\n"
#~ "    return getEntry(Lv3Entry, addr, lv3tbl_paddr);\n"
#~ "}\n"
#~ "fn getLv2Entry(addr: Virt, lv2tbl_paddr: Phys) *Lv2Entry {\n"
#~ "    return getEntry(Lv2Entry, addr, lv2tbl_paddr);\n"
#~ "}\n"
#~ "fn getLv1Entry(addr: Virt, lv1tbl_paddr: Phys) *Lv1Entry {\n"
#~ "    return getEntry(Lv1Entry, addr, lv1tbl_paddr);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/arch/x86/page.zig\n"
#~ "fn getEntry(T: type, vaddr: Virt, paddr: Phys) *T {\n"
#~ "    const table = getTable(T, paddr);\n"
#~ "    const shift = switch (T) {\n"
#~ "        Lv4Entry => 39,\n"
#~ "        Lv3Entry => 30,\n"
#~ "        Lv2Entry => 21,\n"
#~ "        Lv1Entry => 12,\n"
#~ "        else => @compileError(\"Unsupported type\"),\n"
#~ "    };\n"
#~ "    return &table[(vaddr >> shift) & 0x1FF];\n"
#~ "}\n"
#~ "\n"
#~ "fn getLv4Entry(addr: Virt, cr3: Phys) *Lv4Entry {\n"
#~ "    return getEntry(Lv4Entry, addr, cr3);\n"
#~ "}\n"
#~ "fn getLv3Entry(addr: Virt, lv3tbl_paddr: Phys) *Lv3Entry {\n"
#~ "    return getEntry(Lv3Entry, addr, lv3tbl_paddr);\n"
#~ "}\n"
#~ "fn getLv2Entry(addr: Virt, lv2tbl_paddr: Phys) *Lv2Entry {\n"
#~ "    return getEntry(Lv2Entry, addr, lv2tbl_paddr);\n"
#~ "}\n"
#~ "fn getLv1Entry(addr: Virt, lv1tbl_paddr: Phys) *Lv1Entry {\n"
#~ "    return getEntry(Lv1Entry, addr, lv1tbl_paddr);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/arch/x86/asm.zig\n"
#~ "pub inline fn readCr3() u64 {\n"
#~ "    var cr3: u64 = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov %%cr3, %[cr3]\n"
#~ "        : [cr3] \"=r\" (cr3),\n"
#~ "    );\n"
#~ "    return cr3;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/arch/x86/asm.zig\n"
#~ "pub inline fn readCr3() u64 {\n"
#~ "    var cr3: u64 = undefined;\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov %%cr3, %[cr3]\n"
#~ "        : [cr3] \"=r\" (cr3),\n"
#~ "    );\n"
#~ "    return cr3;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/arch/x86/page.zig\n"
#~ "const am = @import(\"asm.zig\");\n"
#~ "\n"
#~ "pub const PageAttribute = enum {\n"
#~ "    /// RO\n"
#~ "    read_only,\n"
#~ "    /// RW\n"
#~ "    read_write,\n"
#~ "    /// RX\n"
#~ "    executable,\n"
#~ "};\n"
#~ "\n"
#~ "pub const PageError = error{ NoMemory, NotPresent, NotCanonical, "
#~ "InvalidAddress, AlreadyMapped };\n"
#~ "\n"
#~ "pub fn map4kTo(virt: Virt, phys: Phys, attr: PageAttribute, bs: "
#~ "*BootServices) PageError!void {\n"
#~ "    const rw = switch (attr) {\n"
#~ "        .read_only, .executable => false,\n"
#~ "        .read_write => true,\n"
#~ "    };\n"
#~ "\n"
#~ "    const lv4ent = getLv4Entry(virt, am.readCr3());\n"
#~ "    if (!lv4ent.present) try allocateNewTable(Lv4Entry, lv4ent, bs);\n"
#~ "\n"
#~ "    const lv3ent = getLv3Entry(virt, lv4ent.address());\n"
#~ "    if (!lv3ent.present) try allocateNewTable(Lv3Entry, lv3ent, bs);\n"
#~ "\n"
#~ "    const lv2ent = getLv2Entry(virt, lv3ent.address());\n"
#~ "    if (!lv2ent.present) try allocateNewTable(Lv2Entry, lv2ent, bs);\n"
#~ "\n"
#~ "    const lv1ent = getLv1Entry(virt, lv2ent.address());\n"
#~ "    if (lv1ent.present) return PageError.AlreadyMapped;\n"
#~ "    var new_lv1ent = Lv1Entry.newMapPage(phys, true);\n"
#~ "\n"
#~ "    new_lv1ent.rw = rw;\n"
#~ "    lv1ent.* = new_lv1ent;\n"
#~ "    // No need to flush TLB because the page was not present before.\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/arch/x86/page.zig\n"
#~ "const am = @import(\"asm.zig\");\n"
#~ "\n"
#~ "pub const PageAttribute = enum {\n"
#~ "    /// RO\n"
#~ "    read_only,\n"
#~ "    /// RW\n"
#~ "    read_write,\n"
#~ "    /// RX\n"
#~ "    executable,\n"
#~ "};\n"
#~ "\n"
#~ "pub const PageError = error{ NoMemory, NotPresent, NotCanonical, "
#~ "InvalidAddress, AlreadyMapped };\n"
#~ "\n"
#~ "pub fn map4kTo(virt: Virt, phys: Phys, attr: PageAttribute, bs: "
#~ "*BootServices) PageError!void {\n"
#~ "    const rw = switch (attr) {\n"
#~ "        .read_only, .executable => false,\n"
#~ "        .read_write => true,\n"
#~ "    };\n"
#~ "\n"
#~ "    const lv4ent = getLv4Entry(virt, am.readCr3());\n"
#~ "    if (!lv4ent.present) try allocateNewTable(Lv4Entry, lv4ent, bs);\n"
#~ "\n"
#~ "    const lv3ent = getLv3Entry(virt, lv4ent.address());\n"
#~ "    if (!lv3ent.present) try allocateNewTable(Lv3Entry, lv3ent, bs);\n"
#~ "\n"
#~ "    const lv2ent = getLv2Entry(virt, lv3ent.address());\n"
#~ "    if (!lv2ent.present) try allocateNewTable(Lv2Entry, lv2ent, bs);\n"
#~ "\n"
#~ "    const lv1ent = getLv1Entry(virt, lv2ent.address());\n"
#~ "    if (lv1ent.present) return PageError.AlreadyMapped;\n"
#~ "    var new_lv1ent = Lv1Entry.newMapPage(phys, true);\n"
#~ "\n"
#~ "    new_lv1ent.rw = rw;\n"
#~ "    lv1ent.* = new_lv1ent;\n"
#~ "    // No need to flush TLB because the page was not present before.\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "const arch = @import(\"arch.zig\");\n"
#~ "\n"
#~ "arch.page.map4kTo(\n"
#~ "    0xFFFF_FFFF_DEAD_0000,\n"
#~ "    0x10_0000,\n"
#~ "    .read_write,\n"
#~ "    boot_service,\n"
#~ ") catch |err| {\n"
#~ "    log.err(\"Failed to map 4KiB page: {?}\", .{err});\n"
#~ "    return .Aborted;\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "const arch = @import(\"arch.zig\");\n"
#~ "\n"
#~ "arch.page.map4kTo(\n"
#~ "    0xFFFF_FFFF_DEAD_0000,\n"
#~ "    0x10_0000,\n"
#~ "    .read_write,\n"
#~ "    boot_service,\n"
#~ ") catch |err| {\n"
#~ "    log.err(\"Failed to map 4KiB page: {?}\", .{err});\n"
#~ "    return .Aborted;\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```surtr/arch/x86/asm.zig\n"
#~ "pub inline fn loadCr3(cr3: u64) void {\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov %[cr3], %%cr3\n"
#~ "        :\n"
#~ "        : [cr3] \"r\" (cr3),\n"
#~ "    );\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/arch/x86/asm.zig\n"
#~ "pub inline fn loadCr3(cr3: u64) void {\n"
#~ "    asm volatile (\n"
#~ "        \\\\mov %[cr3], %%cr3\n"
#~ "        :\n"
#~ "        : [cr3] \"r\" (cr3),\n"
#~ "    );\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "arch.page.setLv4Writable(boot_service) catch |err| {\n"
#~ "    log.err(\"Failed to set page table writable: {?}\", .{err});\n"
#~ "    return .LoadError;\n"
#~ "};\n"
#~ "log.debug(\"Set page table writable.\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "arch.page.setLv4Writable(boot_service) catch |err| {\n"
#~ "    log.err(\"Failed to set page table writable: {?}\", .{err});\n"
#~ "    return .LoadError;\n"
#~ "};\n"
#~ "log.debug(\"Set page table writable.\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```ymir/main.zig\n"
#~ "export fn kernelEntry() callconv(.Naked) noreturn {\n"
#~ "    while (true)\n"
#~ "        asm volatile (\"hlt\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ymir/main.zig\n"
#~ "export fn kernelEntry() callconv(.Naked) noreturn {\n"
#~ "    while (true)\n"
#~ "        asm volatile (\"hlt\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```build.zig\n"
#~ "const ymir_target = b.resolveTargetQuery(.{\n"
#~ "    .cpu_arch = .x86_64,\n"
#~ "    .os_tag = .freestanding,\n"
#~ "    .ofmt = .elf,\n"
#~ "});\n"
#~ "const ymir = b.addExecutable(.{\n"
#~ "    .name = \"ymir.elf\",\n"
#~ "    .root_source_file = b.path(\"ymir/main.zig\"),\n"
#~ "    .target = ymir_target, // Freestanding x64 ELF executable\n"
#~ "    .optimize = optimize, // You can choose the optimization level.\n"
#~ "    .linkage = .static,\n"
#~ "    .code_model = .kernel,\n"
#~ "});\n"
#~ "ymir.entry = .{ .symbol_name = \"kernelEntry\" };\n"
#~ "b.installArtifact(ymir);\n"
#~ "```"
#~ msgstr ""
#~ "```build.zig\n"
#~ "const ymir_target = b.resolveTargetQuery(.{\n"
#~ "    .cpu_arch = .x86_64,\n"
#~ "    .os_tag = .freestanding,\n"
#~ "    .ofmt = .elf,\n"
#~ "});\n"
#~ "const ymir = b.addExecutable(.{\n"
#~ "    .name = \"ymir.elf\",\n"
#~ "    .root_source_file = b.path(\"ymir/main.zig\"),\n"
#~ "    .target = ymir_target, // Freestanding x64 ELF executable\n"
#~ "    .optimize = optimize, // You can choose the optimization level.\n"
#~ "    .linkage = .static,\n"
#~ "    .code_model = .kernel,\n"
#~ "});\n"
#~ "ymir.entry = .{ .symbol_name = \"kernelEntry\" };\n"
#~ "b.installArtifact(ymir);\n"
#~ "```"

#~ msgid ""
#~ "'s complement, little endian\n"
#~ "  Version:                           1 (current)\n"
#~ "  OS/ABI:                            UNIX - System V\n"
#~ "  ABI Version:                       0\n"
#~ "  Type:                              EXEC (Executable file)\n"
#~ "  Machine:                           Advanced Micro Devices X86-64\n"
#~ "  Version:                           0x1\n"
#~ "  Entry point address:               0x1001120\n"
#~ "  Start of program headers:          64 (bytes into file)\n"
#~ "  Start of section headers:          5216 (bytes into file)\n"
#~ "  Flags:                             0x0\n"
#~ "  Size of this header:               64 (bytes)\n"
#~ "  Size of program headers:           56 (bytes)\n"
#~ "  Number of program headers:         4\n"
#~ "  Size of section headers:           64 (bytes)\n"
#~ "  Number of section headers:         13\n"
#~ "  Section header string table index: 11\n"
#~ msgstr ""
#~ "'s complement, little endian\n"
#~ "  Version:                           1 (current)\n"
#~ "  OS/ABI:                            UNIX - System V\n"
#~ "  ABI Version:                       0\n"
#~ "  Type:                              EXEC (Executable file)\n"
#~ "  Machine:                           Advanced Micro Devices X86-64\n"
#~ "  Version:                           0x1\n"
#~ "  Entry point address:               0x1001120\n"
#~ "  Start of program headers:          64 (bytes into file)\n"
#~ "  Start of section headers:          5216 (bytes into file)\n"
#~ "  Flags:                             0x0\n"
#~ "  Size of this header:               64 (bytes)\n"
#~ "  Size of program headers:           56 (bytes)\n"
#~ "  Number of program headers:         4\n"
#~ "  Size of section headers:           64 (bytes)\n"
#~ "  Number of section headers:         13\n"
#~ "  Section header string table index: 11\n"

#~ msgid ""
#~ "```build.zig\n"
#~ "const install_ymir = b.addInstallFile(\n"
#~ "    ymir.getEmittedBin(),\n"
#~ "    b.fmt(\"{s}/{s}\", .{ out_dir_name, ymir.name }),\n"
#~ ");\n"
#~ "install_ymir.step.dependOn(&ymir.step);\n"
#~ "b.getInstallStep().dependOn(&install_ymir.step);\n"
#~ "```"
#~ msgstr ""
#~ "```build.zig\n"
#~ "const install_ymir = b.addInstallFile(\n"
#~ "    ymir.getEmittedBin(),\n"
#~ "    b.fmt(\"{s}/{s}\", .{ out_dir_name, ymir.name }),\n"
#~ ");\n"
#~ "install_ymir.step.dependOn(&ymir.step);\n"
#~ "b.getInstallStep().dependOn(&install_ymir.step);\n"
#~ "```"

#~ msgid ""
#~ "```src/boot.zig\n"
#~ "const boot_service: *uefi.tables.BootServices = uefi.system_table."
#~ "boot_services orelse {\n"
#~ "    log.err(\"Failed to get boot services.\", .{});\n"
#~ "    return .Aborted;\n"
#~ "};\n"
#~ "log.info(\"Got boot services.\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```src/boot.zig\n"
#~ "const boot_service: *uefi.tables.BootServices = uefi.system_table."
#~ "boot_services orelse {\n"
#~ "    log.err(\"Failed to get boot services.\", .{});\n"
#~ "    return .Aborted;\n"
#~ "};\n"
#~ "log.info(\"Got boot services.\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```src/boot.zig\n"
#~ "var fs: *uefi.protocol.SimpleFileSystem = undefined;\n"
#~ "status = boot_service.locateProtocol(&uefi.protocol.SimpleFileSystem."
#~ "guid, null, @ptrCast(&fs));\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to locate simple file system protocol.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "log.info(\"Located simple file system protocol.\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```src/boot.zig\n"
#~ "var fs: *uefi.protocol.SimpleFileSystem = undefined;\n"
#~ "status = boot_service.locateProtocol(&uefi.protocol.SimpleFileSystem."
#~ "guid, null, @ptrCast(&fs));\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to locate simple file system protocol.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "log.info(\"Located simple file system protocol.\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```src/boot.zig\n"
#~ "var root_dir: *uefi.protocol.File = undefined;\n"
#~ "status = fs.openVolume(&root_dir);\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to open volume.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "log.info(\"Opened filesystem volume.\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```src/boot.zig\n"
#~ "var root_dir: *uefi.protocol.File = undefined;\n"
#~ "status = fs.openVolume(&root_dir);\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to open volume.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "log.info(\"Opened filesystem volume.\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```src/boot.zig\n"
#~ "fn openFile(\n"
#~ "    root: *uefi.protocol.File,\n"
#~ "    comptime name: [:0]const u8,\n"
#~ ") !*uefi.protocol.File {\n"
#~ "    var file: *uefi.protocol.File = undefined;\n"
#~ "    const status = root.open(\n"
#~ "        &file,\n"
#~ "        &toUcs2(name),\n"
#~ "        uefi.protocol.File.efi_file_mode_read,\n"
#~ "        0,\n"
#~ "    );\n"
#~ "\n"
#~ "    if (status != .Success) {\n"
#~ "        log.err(\"Failed to open file: {s}\", .{name});\n"
#~ "        return error.Aborted;\n"
#~ "    }\n"
#~ "    return file;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```src/boot.zig\n"
#~ "fn openFile(\n"
#~ "    root: *uefi.protocol.File,\n"
#~ "    comptime name: [:0]const u8,\n"
#~ ") !*uefi.protocol.File {\n"
#~ "    var file: *uefi.protocol.File = undefined;\n"
#~ "    const status = root.open(\n"
#~ "        &file,\n"
#~ "        &toUcs2(name),\n"
#~ "        uefi.protocol.File.efi_file_mode_read,\n"
#~ "        0,\n"
#~ "    );\n"
#~ "\n"
#~ "    if (status != .Success) {\n"
#~ "        log.err(\"Failed to open file: {s}\", .{name});\n"
#~ "        return error.Aborted;\n"
#~ "    }\n"
#~ "    return file;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```src/boot.zig\n"
#~ "const kernel = openFile(root_dir, \"ymir.elf\") catch return .Aborted;\n"
#~ "log.info(\"Opened kernel file.\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```src/boot.zig\n"
#~ "const kernel = openFile(root_dir, \"ymir.elf\") catch return .Aborted;\n"
#~ "log.info(\"Opened kernel file.\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```src/boot.zig\n"
#~ "var header_size: usize = @sizeOf(elf.Elf64_Ehdr);\n"
#~ "var header_buffer: [*]align(8) u8 = undefined;\n"
#~ "status = boot_service.allocatePool(.LoaderData, header_size, "
#~ "&header_buffer);\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to allocate memory for kernel ELF header.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```src/boot.zig\n"
#~ "var header_size: usize = @sizeOf(elf.Elf64_Ehdr);\n"
#~ "var header_buffer: [*]align(8) u8 = undefined;\n"
#~ "status = boot_service.allocatePool(.LoaderData, header_size, "
#~ "&header_buffer);\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to allocate memory for kernel ELF header.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```src/boot.zig\n"
#~ "status = kernel.read(&header_size, header_buffer);\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to read kernel ELF header.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```src/boot.zig\n"
#~ "status = kernel.read(&header_size, header_buffer);\n"
#~ "if (status != .Success) {\n"
#~ "    log.err(\"Failed to read kernel ELF header.\", .{});\n"
#~ "    return status;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```src/boot.zig\n"
#~ "const elf_header = elf.Header.parse(header_buffer[0..@sizeOf(elf."
#~ "Elf64_Ehdr)]) catch |err| {\n"
#~ "    log.err(\"Failed to parse kernel ELF header: {?}\", .{err});\n"
#~ "    return .Aborted;\n"
#~ "};\n"
#~ "log.info(\"Parsed kernel ELF header.\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```src/boot.zig\n"
#~ "const elf_header = elf.Header.parse(header_buffer[0..@sizeOf(elf."
#~ "Elf64_Ehdr)]) catch |err| {\n"
#~ "    log.err(\"Failed to parse kernel ELF header: {?}\", .{err});\n"
#~ "    return .Aborted;\n"
#~ "};\n"
#~ "log.info(\"Parsed kernel ELF header.\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```zig\n"
#~ "for (\"Hello, world!\\n\") |b| {\n"
#~ "    con_out.outputString(&[_:0]u16{ b }).err() catch unreachable;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```zig\n"
#~ "for (\"Hello, world!\\n\") |b| {\n"
#~ "    con_out.outputString(&[_:0]u16{ b }).err() catch unreachable;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/log.zig\n"
#~ "fn log(\n"
#~ "    comptime level: stdlog.Level,\n"
#~ "    scope: @Type(.EnumLiteral),\n"
#~ "    comptime fmt: []const u8,\n"
#~ "    args: anytype,\n"
#~ ") void {\n"
#~ "    _ = level;\n"
#~ "    _ = scope;\n"
#~ "\n"
#~ "    std.fmt.format(\n"
#~ "        Writer{ .context = {} },\n"
#~ "        fmt ++ \"\\r\\n\",\n"
#~ "        args,\n"
#~ "    ) catch unreachable;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/log.zig\n"
#~ "fn log(\n"
#~ "    comptime level: stdlog.Level,\n"
#~ "    scope: @Type(.EnumLiteral),\n"
#~ "    comptime fmt: []const u8,\n"
#~ "    args: anytype,\n"
#~ ") void {\n"
#~ "    _ = level;\n"
#~ "    _ = scope;\n"
#~ "\n"
#~ "    std.fmt.format(\n"
#~ "        Writer{ .context = {} },\n"
#~ "        fmt ++ \"\\r\\n\",\n"
#~ "        args,\n"
#~ "    ) catch unreachable;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "const blog = @import(\"log.zig\");\n"
#~ "pub const std_options = blog.default_log_options;\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "const blog = @import(\"log.zig\");\n"
#~ "pub const std_options = blog.default_log_options;\n"
#~ "```"

#~ msgid ""
#~ "```surtr/log.zig\n"
#~ "const Sto = uefi.protocol.SimpleTextOutput;\n"
#~ "\n"
#~ "var con_out: *Sto = undefined;\n"
#~ "\n"
#~ "/// Initialize bootloader log.\n"
#~ "pub fn init(out: *Sto) void {\n"
#~ "    con_out = out;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/log.zig\n"
#~ "const Sto = uefi.protocol.SimpleTextOutput;\n"
#~ "\n"
#~ "var con_out: *Sto = undefined;\n"
#~ "\n"
#~ "/// Initialize bootloader log.\n"
#~ "pub fn init(out: *Sto) void {\n"
#~ "    con_out = out;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "const log = std.log;\n"
#~ "\n"
#~ "blog.init(con_out);\n"
#~ "log.info(\"Initialized bootloader log.\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "const log = std.log;\n"
#~ "\n"
#~ "blog.init(con_out);\n"
#~ "log.info(\"Initialized bootloader log.\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```zig\n"
#~ "const log = std.log.scoped(.hoge);\n"
#~ "log.info(\"Hello, from hoge scope\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```zig\n"
#~ "const log = std.log.scoped(.hoge);\n"
#~ "log.info(\"Hello, from hoge scope\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```surtr/log.zig\n"
#~ "fn log(\n"
#~ "    comptime level: stdlog.Level,\n"
#~ "    scope: @Type(.EnumLiteral),\n"
#~ "    comptime fmt: []const u8,\n"
#~ "    args: anytype,\n"
#~ ") void {\n"
#~ "    _ = level;\n"
#~ "    const scope_str = if (scope == .default) \": \" else \"(\" ++ "
#~ "@tagName(scope) ++ \"): \";\n"
#~ "\n"
#~ "    std.fmt.format(\n"
#~ "        Writer{ .context = {} },\n"
#~ "        scope_str ++ fmt ++ \"\\r\\n\",\n"
#~ "        args,\n"
#~ "    ) catch unreachable;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/log.zig\n"
#~ "fn log(\n"
#~ "    comptime level: stdlog.Level,\n"
#~ "    scope: @Type(.EnumLiteral),\n"
#~ "    comptime fmt: []const u8,\n"
#~ "    args: anytype,\n"
#~ ") void {\n"
#~ "    _ = level;\n"
#~ "    const scope_str = if (scope == .default) \": \" else \"(\" ++ "
#~ "@tagName(scope) ++ \"): \";\n"
#~ "\n"
#~ "    std.fmt.format(\n"
#~ "        Writer{ .context = {} },\n"
#~ "        scope_str ++ fmt ++ \"\\r\\n\",\n"
#~ "        args,\n"
#~ "    ) catch unreachable;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "const log = std.log.scoped(.surtr);\n"
#~ "log.info(\"Hello, world!\", .{});\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "const log = std.log.scoped(.surtr);\n"
#~ "log.info(\"Hello, world!\", .{});\n"
#~ "```"

#~ msgid ""
#~ "```surtr/log.zig\n"
#~ "fn log(\n"
#~ "    comptime level: stdlog.Level,\n"
#~ "    scope: @Type(.EnumLiteral),\n"
#~ "    comptime fmt: []const u8,\n"
#~ "    args: anytype,\n"
#~ ") void {\n"
#~ "    const level_str = comptime switch (level) {\n"
#~ "        .debug => \"[DEBUG]\",\n"
#~ "        .info => \"[INFO ]\",\n"
#~ "        .warn => \"[WARN ]\",\n"
#~ "        .err => \"[ERROR]\",\n"
#~ "    };\n"
#~ "    const scope_str = if (scope == .default) \": \" else \"(\" ++ "
#~ "@tagName(scope) ++ \"): \";\n"
#~ "\n"
#~ "    std.fmt.format(\n"
#~ "        Writer{ .context = {} },\n"
#~ "        level_str ++ \" \" ++ scope_str ++ fmt ++ \"\\r\\n\",\n"
#~ "        args,\n"
#~ "    ) catch unreachable;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/log.zig\n"
#~ "fn log(\n"
#~ "    comptime level: stdlog.Level,\n"
#~ "    scope: @Type(.EnumLiteral),\n"
#~ "    comptime fmt: []const u8,\n"
#~ "    args: anytype,\n"
#~ ") void {\n"
#~ "    const level_str = comptime switch (level) {\n"
#~ "        .debug => \"[DEBUG]\",\n"
#~ "        .info => \"[INFO ]\",\n"
#~ "        .warn => \"[WARN ]\",\n"
#~ "        .err => \"[ERROR]\",\n"
#~ "    };\n"
#~ "    const scope_str = if (scope == .default) \": \" else \"(\" ++ "
#~ "@tagName(scope) ++ \"): \";\n"
#~ "\n"
#~ "    std.fmt.format(\n"
#~ "        Writer{ .context = {} },\n"
#~ "        level_str ++ \" \" ++ scope_str ++ fmt ++ \"\\r\\n\",\n"
#~ "        args,\n"
#~ "    ) catch unreachable;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```build.zig\n"
#~ "// Options\n"
#~ "const s_log_level = b.option(\n"
#~ "    []const u8,\n"
#~ "    \"log_level\",\n"
#~ "    \"log_level\",\n"
#~ ") orelse \"info\";\n"
#~ "const log_level: std.log.Level = b: {\n"
#~ "    const eql = std.mem.eql;\n"
#~ "    break :b if (eql(u8, s_log_level, \"debug\"))\n"
#~ "        .debug\n"
#~ "    else if (eql(u8, s_log_level, \"info\"))\n"
#~ "        .info\n"
#~ "    else if (eql(u8, s_log_level, \"warn\"))\n"
#~ "        .warn\n"
#~ "    else if (eql(u8, s_log_level, \"error\"))\n"
#~ "        .err\n"
#~ "    else\n"
#~ "        @panic(\"Invalid log level\");\n"
#~ "};\n"
#~ "\n"
#~ "// 新たなオプションの作成\n"
#~ "const options = b.addOptions();\n"
#~ "options.addOption(std.log.Level, \"log_level\", log_level);\n"
#~ "\n"
#~ "// Surtr にオプションの追加\n"
#~ "surtr.root_module.addOptions(\"option\", options);\n"
#~ "```"
#~ msgstr ""
#~ "```build.zig\n"
#~ "// Options\n"
#~ "const s_log_level = b.option(\n"
#~ "    []const u8,\n"
#~ "    \"log_level\",\n"
#~ "    \"log_level\",\n"
#~ ") orelse \"info\";\n"
#~ "const log_level: std.log.Level = b: {\n"
#~ "    const eql = std.mem.eql;\n"
#~ "    break :b if (eql(u8, s_log_level, \"debug\"))\n"
#~ "        .debug\n"
#~ "    else if (eql(u8, s_log_level, \"info\"))\n"
#~ "        .info\n"
#~ "    else if (eql(u8, s_log_level, \"warn\"))\n"
#~ "        .warn\n"
#~ "    else if (eql(u8, s_log_level, \"error\"))\n"
#~ "        .err\n"
#~ "    else\n"
#~ "        @panic(\"Invalid log level\");\n"
#~ "};\n"
#~ "\n"
#~ "// 新たなオプションの作成\n"
#~ "const options = b.addOptions();\n"
#~ "options.addOption(std.log.Level, \"log_level\", log_level);\n"
#~ "\n"
#~ "// Surtr にオプションの追加\n"
#~ "surtr.root_module.addOptions(\"option\", options);\n"
#~ "```"

#~ msgid ""
#~ "```surtr/log.zig\n"
#~ "const option = @import(\"option\"); // build.zig で指定したオプション名\n"
#~ "const log_level = option.log_level;\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/log.zig\n"
#~ "const option = @import(\"option\"); // build.zig で指定したオプション名\n"
#~ "const log_level = option.log_level;\n"
#~ "```"

#~ msgid ""
#~ "```surtr/boot.zig\n"
#~ "const std = @import(\"std\");\n"
#~ "const uefi = std.os.uefi;\n"
#~ "\n"
#~ "pub fn main() uefi.Status {\n"
#~ "    while (true)\n"
#~ "        asm volatile (\"hlt\");\n"
#~ "\n"
#~ "    return .success;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```surtr/boot.zig\n"
#~ "const std = @import(\"std\");\n"
#~ "const uefi = std.os.uefi;\n"
#~ "\n"
#~ "pub fn main() uefi.Status {\n"
#~ "    while (true)\n"
#~ "        asm volatile (\"hlt\");\n"
#~ "\n"
#~ "    return .success;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```build.zig\n"
#~ "// EFI directory\n"
#~ "const out_dir_name = \"img\";\n"
#~ "const install_surtr = b.addInstallFile(\n"
#~ "    surtr.getEmittedBin(),\n"
#~ "    b.fmt(\"{s}/efi/boot/{s}\", .{ out_dir_name, surtr.name }),\n"
#~ ");\n"
#~ "install_surtr.step.dependOn(&surtr.step);\n"
#~ "b.getInstallStep().dependOn(&install_surtr.step);\n"
#~ "```"
#~ msgstr ""
#~ "```build.zig\n"
#~ "// EFI directory\n"
#~ "const out_dir_name = \"img\";\n"
#~ "const install_surtr = b.addInstallFile(\n"
#~ "    surtr.getEmittedBin(),\n"
#~ "    b.fmt(\"{s}/efi/boot/{s}\", .{ out_dir_name, surtr.name }),\n"
#~ ");\n"
#~ "install_surtr.step.dependOn(&surtr.step);\n"
#~ "b.getInstallStep().dependOn(&install_surtr.step);\n"
#~ "```"

#~ msgid ""
#~ "```build.zig\n"
#~ "const qemu_args = [_][]const u8{\n"
#~ "    \"qemu-system-x86_64\",\n"
#~ "    \"-m\",\n"
#~ "    \"512M\",\n"
#~ "    \"-bios\",\n"
#~ "    \"/usr/share/ovmf/OVMF.fd\",\n"
#~ "    \"-drive\",\n"
#~ "    b.fmt(\"file=fat:rw:{s}/{s},format=raw\", .{ b.install_path, "
#~ "out_dir_name }),\n"
#~ "    \"-nographic\",\n"
#~ "    \"-serial\",\n"
#~ "    \"mon:stdio\",\n"
#~ "    \"-no-reboot\",\n"
#~ "    \"-enable-kvm\",\n"
#~ "    \"-cpu\",\n"
#~ "    \"host\",\n"
#~ "    \"-s\",\n"
#~ "};\n"
#~ "const qemu_cmd = b.addSystemCommand(&qemu_args);\n"
#~ "qemu_cmd.step.dependOn(b.getInstallStep());\n"
#~ "\n"
#~ "const run_qemu_cmd = b.step(\"run\", \"Run QEMU\");\n"
#~ "run_qemu_cmd.dependOn(&qemu_cmd.step);\n"
#~ "```"
#~ msgstr ""
#~ "```build.zig\n"
#~ "const qemu_args = [_][]const u8{\n"
#~ "    \"qemu-system-x86_64\",\n"
#~ "    \"-m\",\n"
#~ "    \"512M\",\n"
#~ "    \"-bios\",\n"
#~ "    \"/usr/share/ovmf/OVMF.fd\",\n"
#~ "    \"-drive\",\n"
#~ "    b.fmt(\"file=fat:rw:{s}/{s},format=raw\", .{ b.install_path, "
#~ "out_dir_name }),\n"
#~ "    \"-nographic\",\n"
#~ "    \"-serial\",\n"
#~ "    \"mon:stdio\",\n"
#~ "    \"-no-reboot\",\n"
#~ "    \"-enable-kvm\",\n"
#~ "    \"-cpu\",\n"
#~ "    \"host\",\n"
#~ "    \"-s\",\n"
#~ "};\n"
#~ "const qemu_cmd = b.addSystemCommand(&qemu_args);\n"
#~ "qemu_cmd.step.dependOn(b.getInstallStep());\n"
#~ "\n"
#~ "const run_qemu_cmd = b.step(\"run\", \"Run QEMU\");\n"
#~ "run_qemu_cmd.dependOn(&qemu_cmd.step);\n"
#~ "```"

#~ msgid "# 0x2000\n"
#~ msgstr "# 0x2000\n"

#~ msgid "# 0x2008\n"
#~ msgstr "# 0x2008\n"

#~ msgid ""
#~ "```build.zig\n"
#~ "const std = @import(\"std\");\n"
#~ "\n"
#~ "pub fn build(b: *std.Build) void {\n"
#~ "    const optimize = b.standardOptimizeOption(.{});\n"
#~ "\n"
#~ "    // Surtr Executable\n"
#~ "    const surtr = b.addExecutable(.{\n"
#~ "        .name = \"BOOTX64.EFI\",\n"
#~ "        .root_source_file = b.path(\"surtr/boot.zig\"),\n"
#~ "        .target = b.resolveTargetQuery(.{\n"
#~ "            .cpu_arch = .x86_64,\n"
#~ "            .os_tag = .uefi,\n"
#~ "        }),\n"
#~ "        .optimize = optimize,\n"
#~ "        .linkage = .static,\n"
#~ "    });\n"
#~ "    b.installArtifact(surtr);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```build.zig\n"
#~ "const std = @import(\"std\");\n"
#~ "\n"
#~ "pub fn build(b: *std.Build) void {\n"
#~ "    const optimize = b.standardOptimizeOption(.{});\n"
#~ "\n"
#~ "    // Surtr Executable\n"
#~ "    const surtr = b.addExecutable(.{\n"
#~ "        .name = \"BOOTX64.EFI\",\n"
#~ "        .root_source_file = b.path(\"surtr/boot.zig\"),\n"
#~ "        .target = b.resolveTargetQuery(.{\n"
#~ "            .cpu_arch = .x86_64,\n"
#~ "            .os_tag = .uefi,\n"
#~ "        }),\n"
#~ "        .optimize = optimize,\n"
#~ "        .linkage = .static,\n"
#~ "    });\n"
#~ "    b.installArtifact(surtr);\n"
#~ "}\n"
#~ "```"

#~ msgid "\\[!WARNING\\] ZLS と Zig のバージョン"
#~ msgstr "\\[!WARNING\\] Version Consistency between ZLS and Zig"
